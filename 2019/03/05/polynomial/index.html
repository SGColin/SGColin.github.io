<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Templates of Polynomial | SGColin's Space</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Templates of Polynomial</h1><a id="logo" href="/.">SGColin's Space</a><p class="description">God helps those who help themselves.</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/diary/"><i class="fa fa-calendar"> Diary</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Templates of Polynomial</h1><div class="post-meta">Mar 5, 2019<span> | </span><span class="category"><a href="/categories/Notes/">Notes</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">Contents</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#写在前面"><span class="toc-number">1.</span> <span class="toc-text">写在前面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-number">2.</span> <span class="toc-text">参考资料</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多项式乘法"><span class="toc-number">3.</span> <span class="toc-text">多项式乘法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#问题描述"><span class="toc-number">3.1.</span> <span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解决方法"><span class="toc-number">3.2.</span> <span class="toc-text">解决方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码实现"><span class="toc-number">3.3.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多项式求逆"><span class="toc-number">4.</span> <span class="toc-text">多项式求逆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#问题描述-1"><span class="toc-number">4.1.</span> <span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解决方法-1"><span class="toc-number">4.2.</span> <span class="toc-text">解决方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码实现-1"><span class="toc-number">4.3.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多项式开根"><span class="toc-number">5.</span> <span class="toc-text">多项式开根</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#问题描述-2"><span class="toc-number">5.1.</span> <span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解决方法-2"><span class="toc-number">5.2.</span> <span class="toc-text">解决方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码实现-2"><span class="toc-number">5.3.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多项式除法和取模"><span class="toc-number">6.</span> <span class="toc-text">多项式除法和取模</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#问题描述-3"><span class="toc-number">6.1.</span> <span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解决方法-3"><span class="toc-number">6.2.</span> <span class="toc-text">解决方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码实现-3"><span class="toc-number">6.3.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分治-FFT"><span class="toc-number">7.</span> <span class="toc-text">分治 FFT</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#问题描述-4"><span class="toc-number">7.1.</span> <span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解决方法-4"><span class="toc-number">7.2.</span> <span class="toc-text">解决方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#分治求解"><span class="toc-number">7.2.1.</span> <span class="toc-text">分治求解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多项式求逆-1"><span class="toc-number">7.2.2.</span> <span class="toc-text">多项式求逆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码实现-4"><span class="toc-number">7.3.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多项式求导和积分"><span class="toc-number">8.</span> <span class="toc-text">多项式求导和积分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#问题描述-5"><span class="toc-number">8.1.</span> <span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解决方法-5"><span class="toc-number">8.2.</span> <span class="toc-text">解决方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码实现-5"><span class="toc-number">8.3.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多项式-ln"><span class="toc-number">9.</span> <span class="toc-text">多项式 ln</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#问题描述-6"><span class="toc-number">9.1.</span> <span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解决方法-6"><span class="toc-number">9.2.</span> <span class="toc-text">解决方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码实现-6"><span class="toc-number">9.3.</span> <span class="toc-text">代码实现</span></a></li></ol></li></ol></div></div><div class="post-content"><p>最近在写一些多项式的模板题，代码总是显得十分混乱。</p>
<p>深感代码通用的重要性，因此开一篇小结用以记录比较通用的模板。</p>
<p>如果模板出了问题请联系我，万分感谢。</p>
<a id="more"></a>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>为了体现简洁，在每一部分只会放关键代码。</p>
<p>关于完整代码，在每一部分的代码标题处都放了链接。</p>
<p>可以保证代码之间函数的调用是合法的，会给出参数说明。</p>
<p>因为放代码可能会比较长，可以点右边的小火箭回到目录。</p>
<p>如果 MathJax 加载不出来或加载有误，请您多刷新几次。</p>
<p>模板出了问题请联系我，万分感谢。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Picks 的博客  <a href="http://picks.logdown.com/" target="_blank" rel="noopener">Picks’s Blog</a></p>
<p>Miskcoo 的博客  <a href="http://blog.miskcoo.com/" target="_blank" rel="noopener">Miskcoo’s Space</a></p>
<h2 id="多项式乘法"><a href="#多项式乘法" class="headerlink" title="多项式乘法"></a>多项式乘法</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定两个多项式 $A(x) $ 和 $B(x)$ ：</p>
<script type="math/tex; mode=display">
A(x)=\sum_{i=0}^{n}a_ix^i\ ,\ B(x)=\sum_{i=0}^{n} b_i x^i</script><p>求卷积 $C(x) =A(x) * B(x)$ ，满足</p>
<script type="math/tex; mode=display">
C(x)=\sum_{i=0}^{n} c_i x^i\ ,\  c_i=\sum_{k=0}^{i} a_k\times b_{i-k}</script><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>这部分上面提到的神仙们讲解的都十分详细。</p>
<p>我的小结限于篇幅，只挂一下 pdf 版本的连接了：<a href="https://blog.gyx.me/papers/fft.pdf">快速傅里叶变换初步</a></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>使用 <a href="http://uoj.ac/problem/34" target="_blank" rel="noopener">[ UOJ 34 ] 多项式乘法</a> 作为测试题。</p>
<ul>
<li><p><a href="https://blog.gyx.me/code/template/polynomial/fft.cpp">Fast Fourier Transform</a>，使用的是 3 次变换的最基本写法，用时 362 ms</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Complex *f, <span class="keyword">int</span> len, <span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">      <span class="keyword">if</span> (rev[i] &gt; i) swap(f[i], f[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">      Complex wn = Complex(<span class="built_in">cos</span>(PI / i) , o * <span class="built_in">sin</span>(PI / i));</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j += (i &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Complex w = Complex(<span class="number">1</span>, <span class="number">0</span>), x, y;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; ++k, w = w * wn) &#123;</span><br><span class="line">          x = f[j + k]; y = w * f[i + j + k];</span><br><span class="line">          f[i + j + k] = x - y; f[j + k] = x + y;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="number">-1</span>) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) f[i].x /= len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://blog.gyx.me/code/template/polynomial/ntt.cpp">Fast Number-Theoretic Transform</a>，模数为 998244353，用时 403 ms</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> *f, <span class="keyword">int</span> len, <span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i)</span><br><span class="line">    <span class="keyword">if</span> (i &gt; rev[i]) swap(f[i], f[rev[i]]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> wn = qpow(<span class="number">3</span>, (mod - <span class="number">1</span>) / (i &lt;&lt; <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="number">-1</span>) wn = qpow(wn, mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j += (i &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">      <span class="keyword">int</span> w = <span class="number">1</span>, x, y;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; ++k, w = <span class="number">1l</span>l * w * wn % mod) &#123;</span><br><span class="line">        x = f[j + k]; y = <span class="number">1l</span>l * w * f[i + j + k] % mod;</span><br><span class="line">        f[j + k] = mo(x + y); f[i + j + k] = mo(x - y + mod);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (o == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> invl = qpow(len, mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) f[i] = <span class="number">1l</span>l * f[i] * invl % mod;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="多项式求逆"><a href="#多项式求逆" class="headerlink" title="多项式求逆"></a>多项式求逆</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个 $n$ 次多项式 $A(x)$ ，求出一个多项式 $B(x)$， 满足</p>
<script type="math/tex; mode=display">
A(x) * B(x) \equiv 1  \pmod{ x^{n+1}}</script><p>系数对 998244353 取模。</p>
<h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><p>采用倍增的思想。</p>
<p>考虑只有常数项的时候，$A(x)\equiv c\pmod{x}$ ，那么 $A^{-1}(x)$ 即为 $c^{-1}$。</p>
<p>对于 $n&gt;1$ 的时候，设 $B(x)=A^{-1}(x)$ ，有</p>
<script type="math/tex; mode=display">
A(x)B(x)\equiv 1\pmod{x^n}</script><p>因为此时模 $x^n$ 相当于只保留多项式前 $n$ 项，所以该同余式在模 $x^k,0\le k\le n$ 时都成立</p>
<script type="math/tex; mode=display">
A(x)B(x)\equiv 1\pmod{x^{\lceil\frac{n}{2}\rceil}}</script><p>假设在 $\pmod {x^{\lceil \frac n2\rceil}}$ 意义下 $A(x)$ 的逆元是 $B′(x)$ 并且我们已经求出，那么</p>
<script type="math/tex; mode=display">
A(x)B'(x) \equiv 1 \pmod {x^{\lceil \frac{n}{2} \rceil}}</script><p>两式相减，得</p>
<script type="math/tex; mode=display">
B(x)-B'(x) \equiv 0 \pmod {x^{\lceil \frac{n}{2} \rceil}}</script><p>两边平方，得</p>
<script type="math/tex; mode=display">
B^2(x)-2B(x)B'(x)+B'^2(x)\equiv 0\pmod{x^n}</script><p>模数平方的合法性在于，大于 $n$ 的系数卷积中每组乘法必然有一项下标小于 $n$ ，因此乘起来必然为 $0$ 。</p>
<p>两侧同称 $A(x)$ ，整理得</p>
<script type="math/tex; mode=display">
B(x)\equiv2B'(x)-A(x)B'^2(x)\pmod{x^n}</script><p>因此只需将 $B’(x)$ 和 $A(x)$ 在模 $x^n$ 意义下的插值求出，有</p>
<script type="math/tex; mode=display">
B_i=2B'_i-A_iB'^2_i=B'_i(2-A_iB')</script><p>因此一遍 NTT 就可以由 $B’(x)$ 求出 $B(x)$ 了。</p>
<p>总的时间复杂度为</p>
<script type="math/tex; mode=display">
T(n) = T(\frac{n}{2}) + \mathcal O(n \log n) = \mathcal O(n \log n)</script><p>由此过程也可以得到一个结论：<strong>一个多项式有没有逆元完全取决于其常数项是否有逆元。</strong></p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>使用 <a href="https://www.luogu.org/problemnew/show/P4238" target="_blank" rel="noopener">[ Luogu P4238 ] 多项式求逆</a> 作为测试题。</p>
<ul>
<li><p><a href="https://blog.gyx.me/code/template/polynomial/inv1.cpp">递归版本</a>，使用 O2 优化，用时 562 ms</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inv</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;b[<span class="number">0</span>] = qpow(a[<span class="number">0</span>], mod - <span class="number">2</span>); <span class="keyword">return</span>;&#125;</span><br><span class="line">  Inv(a, b, (n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">int</span> len = Rev(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) tmp[i] = a[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; len; ++i) b[i] = tmp[i] = <span class="number">0</span>;</span><br><span class="line">  NTT(b, len, <span class="number">1</span>); NTT(tmp, len, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    b[i] = (<span class="number">2l</span>l - <span class="number">1l</span>l * tmp[i] * b[i] % mod + mod) * b[i] % mod;</span><br><span class="line">  NTT(b, len, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) tmp[i] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; len; ++i) b[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://blog.gyx.me/code/template/polynomial/inv2.cpp">迭代版本</a>，使用 O2 优化，用时 570 ms</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inv</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  b[<span class="number">0</span>] = qpow(a[<span class="number">0</span>], mod - <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">int</span> len;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt; (n &lt;&lt; <span class="number">1</span>); l &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    len = Rev(l &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; ++i) tmp[i] = a[i];</span><br><span class="line">    NTT(b, len, <span class="number">1</span>); NTT(tmp, len, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">      b[i] = (<span class="number">2l</span>l - <span class="number">1l</span>l * tmp[i] * b[i] % mod + mod) * b[i] % mod;</span><br><span class="line">    NTT(b, len, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; len; ++i) b[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="多项式开根"><a href="#多项式开根" class="headerlink" title="多项式开根"></a>多项式开根</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个 $n$ 次多项式 $A(x)$，求一个在 $\bmod{x^{n+1}}$ 意义下的多项式 $B(x)$，使得 </p>
<script type="math/tex; mode=display">
B^2(x) \equiv A(x) \pmod{x^{n+1}}</script><p>多项式的系数在模 998244353 意义下进行运算，保证常数项 $a_0=1$。</p>
<h3 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h3><p>同样采用倍增的思想。</p>
<p>考虑只有常数项的时候，$A(x)\equiv c\pmod x$ ，那么 $\sqrt {A(x)}$ 即为 $\sqrt c \equiv 1\pmod{x}$ （二次剩余）。</p>
<p>对于 $n&gt;1$ 的时候，同样根据上一题的结论，我们可以把问题范围缩小到 $\bmod {x^{\lceil \frac{n}2\rceil}}$ ，有</p>
<script type="math/tex; mode=display">
B^2(x)\equiv A(x)\pmod{x^n}\ \Rightarrow\ B^2(x)\equiv A(x)\pmod{x^{\lceil \frac{n}2\rceil}}</script><p>不妨设我们已经求出来了 $\bmod{x^{\lceil \frac{n}2\rceil}} $ 意义下的根 $D(x)$，即</p>
<script type="math/tex; mode=display">
D^2(x)\equiv A(x)\pmod{x^{\lceil \frac{n}2\rceil}}</script><p>因此 $B(x)$ 与 $D(x)$ 在模 $x^{\lceil \frac{n}2\rceil}$ 意义下同余，移项得</p>
<script type="math/tex; mode=display">
B(x)-D(x)\equiv 0\pmod{x^{\lceil \frac{n}2\rceil}}</script><p>两侧平方，得</p>
<script type="math/tex; mode=display">
B^2(x)+D^2(x)-2B(x)D(x)\equiv 0\pmod{x^n}</script><p>模数能平方的原因与上一题相同。</p>
<p>我们知道$\bmod{x^n}$  时 $B^2(x)$ 即为 $A(x)$ ，因此</p>
<script type="math/tex; mode=display">
A(x)+D^2(x)-2B(x)D(x)\equiv 0\pmod{x^n}</script><p>移项，得</p>
<script type="math/tex; mode=display">
B(x)\equiv \frac{D^2(x) + A(x)}{2D(x)}\equiv \bigg(D(x) +\frac{A(x)}{D(x)}\bigg)\times 2^{-1}\pmod{x^n}</script><p>因此倍增时进行多项式求逆即可，总的时间复杂度为</p>
<script type="math/tex; mode=display">
T(n) = T(\frac{n}{2}) + \mathcal O(n \log n) = \mathcal O(n \log n)</script><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><p>使用 <a href="https://www.luogu.org/problemnew/show/P5205" target="_blank" rel="noopener">[ Luogu P5205 ] 多项式开根</a> 作为测试题，多项式求逆部分均采用递归版本。</p>
<ul>
<li><p><a href="https://blog.gyx.me/code/template/polynomial/sqrt1.cpp">递归版本</a>，使用 O2 优化，用时 3081 ms</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Sqrt</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;b[<span class="number">0</span>] = <span class="number">1</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">  Sqrt(a, b, (n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  Inv(b, b0, n);</span><br><span class="line">  <span class="keyword">int</span> len = Rev(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) a0[i] = a[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; len; ++i) a0[i] = <span class="number">0</span>;</span><br><span class="line">  NTT(a0, len, <span class="number">1</span>); NTT(b0, len, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) a0[i] = <span class="number">1l</span>l * a0[i] * b0[i] % mod;</span><br><span class="line">  NTT(a0, len, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) b[i] = <span class="number">1l</span>l * (b[i] + a0[i]) % mod * inv2 % mod;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; len; ++i) b[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://blog.gyx.me/code/template/polynomial/sqrt2.cpp">迭代版本</a>，使用 O2 优化，用时 3104 ms</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Sqrt</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  b[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> len;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt; (n &lt;&lt; <span class="number">1</span>); l &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    Inv(b, b0, l);</span><br><span class="line">    len = Rev(l &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; ++i) a0[i] = a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; len; ++i) a0[i] = <span class="number">0</span>;</span><br><span class="line">    NTT(a0, len, <span class="number">1</span>); NTT(b0, len, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) a0[i] = <span class="number">1l</span>l * a0[i] * b0[i] % mod;</span><br><span class="line">    NTT(a0, len, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; ++i) b[i] = <span class="number">1l</span>l * (b[i] + a0[i]) % mod * inv2 % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; len; ++i) b[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="多项式除法和取模"><a href="#多项式除法和取模" class="headerlink" title="多项式除法和取模"></a>多项式除法和取模</h2><h3 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个 $n$ 次多项式 $A(x)$ 和一个 $m$ 次多项式 $B(x)$，求出多项式 $D(x)$, $R(x)$，满足</p>
<script type="math/tex; mode=display">
A(x) = D(x)B(x) + R(x)</script><p>$D(x)$ 次数为 $n-m$，$R(x)$ 次数小于 $m$ ，所有的运算在模 998244353 意义下进行。</p>
<h3 id="解决方法-3"><a href="#解决方法-3" class="headerlink" title="解决方法"></a>解决方法</h3><p>注意到带着 $R(x)$ 在这里很麻烦，前人们想到了一个神奇的解决办法。</p>
<p>设 $A^R(x)=x^nA(\frac{1}{x})$ ，我们将右侧展开：</p>
<script type="math/tex; mode=display">
A^R(x)=x^nA(\frac{1}{x})=x^n\sum_{i=0}^na_i\frac{1}{x^i}=\sum_{i=0}^na_ix^{n-i}</script><p>所以 $A^R(x)$ 就是将 $A(x)$ 的<strong>系数反转</strong> 。</p>
<p>我们将所求的等式中 $x$ 全部换成 $\frac{1}{x}$ ，然后两侧同乘 $x^n$ ：</p>
<script type="math/tex; mode=display">
x^n A(\frac{1}{x}) = x^{n - m}D(\frac{1}{x}) x^mB(\frac{1}{x}) + x^{n - m + 1}x^{m - 1}R(\frac{1}{x})</script><script type="math/tex; mode=display">
A^R(x) = D^R(x)B^R(x) + x^{n - m + 1}R^R(x)</script><p>注意到 $D^R(x)$ 最高次反转后不变，依然为 $n-m$。</p>
<p>而右侧的 $R^R(x)$ 因为前面有 $x^{n-m+1}$ 所以最低次为 $n-m+1$ 。</p>
<p>所以我们可以把多项式运算在 $\bmod{x^{n-m+1}}$ 意义下进行，这样 $R(x)$ 就消失了：</p>
<script type="math/tex; mode=display">
A^R(x) \equiv D^R(x)B^R(x) \pmod{x^{n-m+1}}</script><p>因此就可以得到 $D^R(x)$ 的解法：</p>
<script type="math/tex; mode=display">
\frac{A^R(x)}{B^R(x)} \equiv D^R(x) \pmod{x^{n-m+1}}</script><p>一个多项式求逆就可以求出 $D^R(x)$了，再将 $D^R(x)$ 进行反转就得到了答案。</p>
<p>将求出的 $D(x)$ 回代，再进行一次减法即可求出 $R(x)$。</p>
<p>复杂度与多项式求逆同阶，为 $\mathcal O(n \log n)$ 。</p>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><p>使用 <a href="https://www.luogu.org/problemnew/show/P4512" target="_blank" rel="noopener">[ Luogu P4512 ] 多项式除法</a> 作为测试题，不再区分多项式求逆部分的实现方式。</p>
<p><a href="https://blog.gyx.me/code/template/polynomial/div.cpp">多项式求逆递部分归版本</a>，使用 O2 优化，用时 710 ms</p>
<p>注意求 $D(x)$ 部分的那次卷积是在 $\bmod{x^{n-m+1}}$意义下的，所以 $A^R(x)$ 和 $B^R(x)$ 中高于 $n-m+1$ 的项需要清空（因为 FFT 卷积过程中高次系数也会对低次系数造成影响）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Div</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) ar[i] = a[n - i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) br[i] = b[m - i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n - m + <span class="number">2</span>; i &lt;= n; ++i) ar[i] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n - m + <span class="number">2</span>; i &lt;= m; ++i) br[i] = <span class="number">0</span>;</span><br><span class="line">  Inv(br, invb, n - m + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">int</span> len = Rev((n - m + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  NTT(ar, len, <span class="number">1</span>); NTT(invb, len, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) ar[i] = <span class="number">1l</span>l * ar[i] * invb[i] % mod;</span><br><span class="line">  NTT(ar, len, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - m; ++i) tmp[i] = d[i] = ar[n - m - i];</span><br><span class="line">  len = Rev(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n - m + <span class="number">1</span>; i &lt;= len; ++i) tmp[i] = <span class="number">0</span>;</span><br><span class="line">  NTT(b, len, <span class="number">1</span>); NTT(tmp, len, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) b[i] = <span class="number">1l</span>l * b[i] * tmp[i] % mod;</span><br><span class="line">  NTT(b, len, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) r[i] = mo(a[i] - b[i] + mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="分治-FFT"><a href="#分治-FFT" class="headerlink" title="分治 FFT"></a>分治 FFT</h2><h3 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定长度为 $n-1$ 的数组 $g[1],\dots,g[n-1]$，求长度为 $n$ 的数组 $f[0],\dots,f[n-1]$，其中</p>
<script type="math/tex; mode=display">
f[i]=\sum_{j=1}^if[i-j]g[j]</script><p>边界为 $f[0]=1$，运算在模 998244353 下进行。</p>
<h3 id="解决方法-4"><a href="#解决方法-4" class="headerlink" title="解决方法"></a>解决方法</h3><h4 id="分治求解"><a href="#分治求解" class="headerlink" title="分治求解"></a>分治求解</h4><p>暴力做是 $\mathcal O(n^2)$ 的，考虑将相同的转移一起做以达到优化的目的。</p>
<p>考虑使用类似 CDQ 分治的思想，每次我们求出 $[L, mid]$ 范围内的 $f$ 数组之后，把这部分 $f$ 对 $[mid+1, R]$ 范围内 $f$ 的贡献一起做。</p>
<p>考虑对 $x\in[mid + 1, R]$ 的 $f[x]$ 的贡献 $w_x$，有</p>
<script type="math/tex; mode=display">
w_x=\sum_{i=l}^{mid} f[i]g[x-i]</script><p>因此 $w$ 数组可以卷积求了，注意求 $w_x$ 时后半段的 $f$ 需要认为是 $0$，否则就存在右区间内部的贡献了。</p>
<p>总的时间复杂度为</p>
<script type="math/tex; mode=display">
T(n) = 2T(\frac{n}{2}) + \mathcal O(n \log n) = \mathcal O(n \log^2 n)</script><h4 id="多项式求逆-1"><a href="#多项式求逆-1" class="headerlink" title="多项式求逆"></a>多项式求逆</h4><p>一阶分治 FFT 是可以看作卷积处理的。</p>
<p>不妨设将数组看成多项式，有</p>
<script type="math/tex; mode=display">
F(x)=\sum_{i=0}^{n-1}f[i]x^i\ ,\ G(x)=\sum_{i=0}^{n-1}g[i]x^i</script><p>将两个多项式卷积，有</p>
<script type="math/tex; mode=display">
F(x)G(x)=\sum_{i=0}^{\infty}x^i\sum_{j}f[i-j]g[j]=F(x)-f[0]</script><p>后一个等式成立的原因是，注意到后一个求和就是 $f[i]$ 的形式，所以只有 $f[0]$ 没有被计数</p>
<p>求 $f$ 数组可以看作是 $\bmod{x^n}$ 意义下进行的，因此有</p>
<script type="math/tex; mode=display">
F(x)G(x) \equiv F(x)-f[0] \pmod x^n\ \Rightarrow\ F(x) \equiv \frac{f_0}{1-G(x)} \equiv (1-G(x))^{-1} \pmod x^n</script><p>于是一遍多项式求逆就可以求出来了，复杂度为 $\mathcal O(n\log n)$</p>
<h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><p>使用 <a href="https://www.luogu.org/problemnew/show/P4721" target="_blank" rel="noopener">[ Luogu P4721 ] 分治 FFT</a> 作为测试题，多项式求逆采用递归版本。</p>
<ul>
<li><p><a href="https://blog.gyx.me/code/template/polynomial/divfft1.cpp">分治版本</a>，使用 O2 优化，用时 974 ms</p>
</li>
<li><p><a href="https://blog.gyx.me/code/template/polynomial/divfft2.cpp">多项式求逆版本</a>，使用 O2 优化，用时 261 ms</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) a[i] = mo(mod - a[i]);</span><br><span class="line">  Inv(a, b, n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) print(b[i], <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="多项式求导和积分"><a href="#多项式求导和积分" class="headerlink" title="多项式求导和积分"></a>多项式求导和积分</h2><h3 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个 $n$ 次多项式 $A(x)$ ，求一个 $n-1$ 次多项式 $B(x)$ ，和一个 $n+1$ 次多项式 $C(x)$，满足</p>
<script type="math/tex; mode=display">
B(x)=A'(x)\ ,\ C(x)=\int A(x)</script><h3 id="解决方法-5"><a href="#解决方法-5" class="headerlink" title="解决方法"></a>解决方法</h3><p>直接按照定义做即可，有</p>
<script type="math/tex; mode=display">
B(x)=\sum_{i=1}^{n}ia_ix^{i-1}\ ,\ C(x)=\sum_{i=1}^{n}\frac{a_ix^{i+1}}{i+1}</script><p>我们一般认为 $C(x)$ 的常数项为 $0$ ，复杂度显然为 $\mathcal O(n)$。</p>
<h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Der</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) a[i - <span class="number">1</span>] = <span class="number">1l</span>l * i * a[i] % mod;</span><br><span class="line">  a[n - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Int</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i) a[i] = <span class="number">1l</span>l * a[i - <span class="number">1</span>] * qpow(i, mod - <span class="number">2</span>) % mod;</span><br><span class="line">  a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="多项式-ln"><a href="#多项式-ln" class="headerlink" title="多项式 ln"></a>多项式 ln</h2><h3 id="问题描述-6"><a href="#问题描述-6" class="headerlink" title="问题描述"></a>问题描述</h3><p>给出 $n$ 次多项式 $A(x)$，求一个 $\bmod{x^{n+1}}$ 下的多项式 $B(x)$，满足 </p>
<script type="math/tex; mode=display">
B(x) \equiv \ln A(x)\pmod{x^{n+1}}</script><p>所有运算在模 998244353 下进行。</p>
<h3 id="解决方法-6"><a href="#解决方法-6" class="headerlink" title="解决方法"></a>解决方法</h3><p>设 $F(x)=\ln x$，则 $B(x)=F(A(x))$ 。</p>
<p>对 $B(x)$ 求导，根据链式法则，有</p>
<script type="math/tex; mode=display">
B'(x)=F'(A(x))A'(x)=\frac{A'(x)}{A(x)}</script><p>因此对 $A(x)$ 分别进行求导和求逆，卷积即可求出 $B’(x)$ ，再对其进行积分即可。</p>
<p>复杂度与多项式求逆同阶，为 $\mathcal O(n \log n)$ 。</p>
<h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><p>使用 <a href="https://www.luogu.org/problemnew/show/P4725" target="_blank" rel="noopener">[ Luogu P4725 ] 多项式对数函数</a> 作为测试题，不再区分多项式求逆部分的实现方式。</p>
<p><a href="https://blog.gyx.me/code/template/polynomial/ln.cpp">多项式求逆递部分归版本</a>，使用 O2 优化，用时 682 ms</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Ln</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  Inv(a, b, n); Der(a, n);</span><br><span class="line">  <span class="keyword">int</span> len = Rev(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  NTT(a, len, <span class="number">1</span>); NTT(b, len, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) a[i] = <span class="number">1l</span>l * a[i] * b[i] % mod;</span><br><span class="line">  NTT(a, len, <span class="number">-1</span>); Int(a, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><iframe src="/donate/?AliPayQR=/img/AliPayQR.png&amp;WeChatQR=/img/WeChatQR.png&amp;GitHub=https://github.com/sgcolin## GitHub URL, e.g. https://github.com/Kaiyuan/donate-page&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://blog.gyx.me/2019/03/05/polynomial/" data-id="cjxothvcf000zg8ufqbsfwyx8" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAK4AAACuCAAAAACKZ2kyAAABwklEQVR42u3ay4qFMBAFQP//p53tgJg53TFRhsrqEuSmdNH0I8cRr/Oyrvt3O7/3x888tnBxcae553CNucnx1/8Zv8D4LFxc3J3c3jHjcFb9HGMDLi7ul7kzoS3/BLi4uP+JmxQ2HwpkuLi4Q26eguTBK0l0FtZquLi4E9y8S7nu95L+Li4ubot7Flc+GsmDVOF0XFzcLdw8oOT0XlskL5NwcXFXc5P2RLLTu6JR/jS4uLhbuMkxeUJTTYamUhxcXNxl3N6g9KlRa3U8g4uLu5Pb+6NqOVQdrtwWP7i4uIu566B5StQct+Di4i7jVhug+Sil2lKJXgwXF/dV7kzx82wJdFur4eLivsp9aqDSS5vKgQwXF3eaWx2ZlJOS/A5IcFUUFxf3C9xq66R8IyzAFQIZLi7uRm6+kwTE6uWM27YpLi7uS9x8IDo/fC08g4uLu5h7FlevZMpf8sizJFxc3GXcfM1cw+o1ZKsNFFxc3Ge5+Ugjv4qRc/MLYbi4uPu5M0XRY3VYtVbDxcX9MLe3U22p4OLifpnbG5bk9dYfxRUuLu5GbnVYMj9k7RVUuLi4e7i94DLfEEnao1P9XVxc3A73B+1MSOcaRe8bAAAAAElFTkSuQmCC">Share</a><div class="tags"><a href="/tags/Math/">Math</a></div><div class="post-nav"><a class="pre" href="/2019/04/03/mathjaxtest/">MathJax Test</a><a class="next" href="/2019/02/04/goodbye-wuxu/">Goodbye Wuxu</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: '8118f21e816f9e04ef25',
  clientSecret: 'd300b272239621b202a0bcf947eff66d9891d870',
  repo: 'Speak',
  owner: 'SGColin',
  admin: ['SGColin'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Notes/">Notes</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Summary/">Summary</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Travel/">Travel</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/OI/" style="font-size: 15px;">OI</a> <a href="/tags/Life/" style="font-size: 15px;">Life</a> <a href="/tags/Blog/" style="font-size: 15px;">Blog</a> <a href="/tags/Math/" style="font-size: 15px;">Math</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/07/04/wander/">Wander Ⅰ</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/06/17th-birthday/">17th Birthday</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/04/goodbye-oi/">Goodbye OI</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/14/cts2019-apio2019/">CTS 2019  & APIO 2019</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/27/derivation/">Essence of Derivation</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/12/heoi2019/">HEOI 2019</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/03/mathjaxtest/">MathJax Test</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/05/polynomial/">Templates of Polynomial</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/04/goodbye-wuxu/">Goodbye Wuxu</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/08/noip2018/">NOIP 2018</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="mailto:m15831738392@163.com" title="Contact me" target="_blank">Contact me</a><ul></ul><a href="https://github.com/sgcolin" title="Fork me on GitHub" target="_blank">Fork me on GitHub</a><ul></ul><a href="https://czyhe.me/" title="Czyhe" target="_blank">Czyhe</a><ul></ul><a href="https://www.cnblogs.com/ZH-comld/" title="Zh_comld" target="_blank">Zh_comld</a><ul></ul><a href="https://www.cnblogs.com/ErkkiErkko/" title="ErkkiErkko" target="_blank">ErkkiErkko</a><ul></ul><a href="https://captainslow.cf/" title="Captainslow" target="_blank">Captainslow</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">SGColin's Space.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async="async"></script></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>