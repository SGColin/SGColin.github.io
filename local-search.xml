<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>AtCoder Regular Contest 061</title>
    <link href="/2022/07/01/ARC061/"/>
    <url>/2022/07/01/ARC061/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="c---many-formulas">C - Many Formulas</h1><blockquote><p>给定一个数字串，可以在任意位置添加加号，问所有表达式结果的和是多少。</p></blockquote><p>考虑一个前缀后面补一个新的数字： +如果断开，那么前缀的贡献是前面的结果 +如果不断开，那么前缀的贡献是前面除去最后一段 + 最后一段 <spanclass="math inline">\(\times 10\)</span> + 最后一个数字的贡献就是数值<span class="math inline">\(\times 2^{len}\)</span>，即可能的划分方案数</p><p>记 <span class="math inline">\(f_i\)</span> 表示前缀 <spanclass="math inline">\(i\)</span> 的答案，<spanclass="math inline">\(g_i\)</span> 表示前缀 <spanclass="math inline">\(i\)</span> 最后一段的答案，有：</p><p><span class="math display">\[\begin{array}{l}f_i &amp;= 2^i * digit_i + f_{i-1} + (f_{i-1} - g_{i-1}) + g_{i-1}\times 10\\g_i &amp;= 2^i * digit_i + g_{i-1} \times 10\end{array}\]</span></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;  </span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;  <br><span class="hljs-keyword">using</span> ll = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">char</span> c = getchar();  <br>    <span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);  <br>    <span class="hljs-keyword">for</span> (; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);  <br>    <span class="hljs-keyword">return</span> f ? -x : x;  <br>&#125;  <br>  <br><span class="hljs-keyword">char</span> s[<span class="hljs-number">11</span>];  <br>  <br>ll f[<span class="hljs-number">11</span>], g[<span class="hljs-number">11</span>];  <br>  <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s + <span class="hljs-number">1</span>);  <br>    <span class="hljs-keyword">int</span> len = <span class="hljs-built_in">strlen</span>(s + <span class="hljs-number">1</span>);  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, pw = <span class="hljs-number">1</span>; i &lt;= len; ++i, pw = pw * <span class="hljs-number">2</span>) &#123;  <br>        f[i] = pw * (s[i] - <span class="hljs-string">&#x27;0&#x27;</span>) + f[i - <span class="hljs-number">1</span>] * <span class="hljs-number">2</span> + g[i - <span class="hljs-number">1</span>] * <span class="hljs-number">9</span>;  <br>        g[i] = pw * (s[i] - <span class="hljs-string">&#x27;0&#x27;</span>) + g[i - <span class="hljs-number">1</span>] * <span class="hljs-number">10</span>;  <br>    &#125;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, f[len]);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="d---snukes-coloring">D - Snuke's Coloring</h1><blockquote><p>给定一个 <span class="math inline">\(H\times W\)</span>的网格，初始所有位置都是白色，然后给定 <spanclass="math inline">\(n\)</span> 个点染成黑色。问所有的九宫格里，黑色点数为 <span class="math inline">\(0\dots9\)</span> 的九宫格分别有多少个。</p></blockquote><p>初始所有的九宫格都是白色，然后每次加入一个点模拟一下即可。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;  </span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;  <br><span class="hljs-keyword">using</span> ll = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">char</span> c = getchar();  <br>    <span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);  <br>    <span class="hljs-keyword">for</span> (; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);  <br>    <span class="hljs-keyword">return</span> f ? -x : x;  <br>&#125;  <br>  <br><span class="hljs-built_in">unordered_map</span>&lt;ll, <span class="hljs-keyword">bool</span>&gt; vis;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">pos</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1l</span>l * x * <span class="hljs-number">1000000000</span> + y;&#125;  <br>  <br>ll ans[<span class="hljs-number">10</span>];  <br>  <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-keyword">int</span> h = rd(), w = rd();  <br>    ans[<span class="hljs-number">0</span>] = <span class="hljs-number">1l</span>l * (h - <span class="hljs-number">2</span>) * (w - <span class="hljs-number">2</span>);  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n = rd(); n; --n) &#123;  <br>        <span class="hljs-keyword">int</span> x = rd(), y = rd();  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> a = max(<span class="hljs-number">1</span>, x - <span class="hljs-number">2</span>); a &lt;= min(x, h - <span class="hljs-number">2</span>); ++a)  <br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> b = max(<span class="hljs-number">1</span>, y - <span class="hljs-number">2</span>); b &lt;= min(y, w - <span class="hljs-number">2</span>); ++b) &#123;  <br>                <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;  <br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> dx = <span class="hljs-number">0</span>; dx &lt; <span class="hljs-number">3</span>; ++dx)  <br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> dy = <span class="hljs-number">0</span>; dy &lt; <span class="hljs-number">3</span>; ++dy) cnt += vis[pos(a + dx, b + dy)];  <br>                --ans[cnt]; ++ans[cnt + <span class="hljs-number">1</span>];  <br>            &#125;  <br>        vis[pos(x, y)] = <span class="hljs-number">1</span>;  <br>    &#125;  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans[i]);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="e---snukes-subway-trip">E - Snuke's Subway Trip</h1><blockquote><p><span class="math inline">\(n\)</span> 个点 <spanclass="math inline">\(m\)</span> 条边的无向图，每个边有一个颜色。一个路径的初始代价是 <span class="math inline">\(1\)</span>，每换一次颜色代价 <span class="math inline">\(+1\)</span> ，求 <spanclass="math inline">\(1\)</span> 到 <spanclass="math inline">\(n\)</span> 的最短路。</p></blockquote><p>考虑直接建分层图（每个点的实点建立 <spanclass="math inline">\(m\)</span> 个虚点，虚点间连原图的边）。</p><p>真实的点向对应的虚点连边权为 <span class="math inline">\(1\)</span>，虚点之间连原图的边边权为 <span class="math inline">\(0\)</span>，最终答案除 <span class="math inline">\(2\)</span> 即可。</p><p>可以发现有用的点其实只有 <spanclass="math inline">\(\mathcal{O}(n+m)\)</span>，因此可以直接建图做（用一个 <code>unordered_map</code> ）。</p><p>然后在图上跑 01-BFS 即可，复杂度 <spanclass="math inline">\(\mathcal{O}(n+m)\)</span> 。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;  </span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;  <br><span class="hljs-keyword">using</span> ll = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">char</span> c = getchar();  <br>    <span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);  <br>    <span class="hljs-keyword">for</span> (; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);  <br>    <span class="hljs-keyword">return</span> f ? -x : x;  <br>&#125;  <br>  <br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 500007  </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> M 2000007  </span><br>  <br><span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; id[N];  <br>  <br><span class="hljs-keyword">int</span> tot, hd[N];  <br>  <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><span class="hljs-keyword">int</span> to, nxt; <span class="hljs-keyword">bool</span> w;&#125; e[M];  <br>  <br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v, <span class="hljs-keyword">bool</span> w)</span> </span>&#123;  <br>    e[++tot].to = v; e[tot].w = w; e[tot].nxt = hd[u]; hd[u] = tot;  <br>    e[++tot].to = u; e[tot].w = w; e[tot].nxt = hd[v]; hd[v] = tot;  <br>&#125;  <br>  <br><span class="hljs-keyword">int</span> dis[N];  <br>  <br><span class="hljs-keyword">bool</span> vis[N];  <br>  <br><span class="hljs-built_in">deque</span>&lt;<span class="hljs-keyword">int</span>&gt; q;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-keyword">int</span> n = rd(), m = rd();  <br>    <span class="hljs-keyword">int</span> totn = n;  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;  <br>        <span class="hljs-keyword">int</span> u = rd(), v = rd(), c = rd();  <br>        <span class="hljs-keyword">if</span> (!id[u][c]) &#123;id[u][c] = ++totn; add(u, totn, <span class="hljs-number">1</span>);&#125;  <br>        <span class="hljs-keyword">if</span> (!id[v][c]) &#123;id[v][c] = ++totn; add(v, totn, <span class="hljs-number">1</span>);&#125;  <br>        add(id[u][c], id[v][c], <span class="hljs-number">0</span>);  <br>    &#125;  <br>    <span class="hljs-built_in">memset</span>(dis, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span>(dis));  <br>    dis[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>; q.push_back(<span class="hljs-number">1</span>);  <br>    <span class="hljs-keyword">while</span> (!q.empty()) &#123;  <br>        <span class="hljs-keyword">int</span> u = q.front(); q.pop_front();  <br>        <span class="hljs-keyword">if</span> (vis[u]) <span class="hljs-keyword">continue</span>; vis[u] = <span class="hljs-number">1</span>;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = hd[u], v; i; i = e[i].nxt) &#123;  <br>            <span class="hljs-keyword">if</span> (dis[u] + e[i].w &lt; dis[v = e[i].to]) &#123;  <br>                dis[v] = dis[u] + e[i].w;  <br>                e[i].w ? q.push_back(v) : q.push_front(v);  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, dis[n] == dis[<span class="hljs-number">0</span>] ? <span class="hljs-number">-1</span> : dis[n] / <span class="hljs-number">2</span>);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="f---card-game-for-three">F - Card Game for Three</h1><blockquote><p>三个人 A,B,C ，每个人分别有 <spanclass="math inline">\(n,m,k\)</span> 张卡，每张卡的卡面都可能是 A/B/C之一。 从 A 开始翻牌，每次翻到的牌子上写的是谁，下一个翻牌的就是谁。轮到某个人时，如果他没有牌了就胜利，问总共 <spanclass="math inline">\(3^{n+m+k}\)</span> 种方案中，A胜利的方案数有多少。</p></blockquote><p>这道题目的出发点完全想错了，不能将三个人分开想，因为有可能会有 A - B- C - A 循环。</p><p>考虑将整个操作序列连起来（长度 <spanclass="math inline">\(n+m+k\)</span>），每个操作序列一定对应于一种牌序。</p><p>那么也就是要求：某个前缀有 <span class="math inline">\(n\)</span> 个A ，且这段前缀内 B, C 的数量对应不超过 <spanclass="math inline">\(m,k\)</span> 。</p><ul><li>前一个条件避免数重，强制最后一个是 A 即可。</li><li>后一个条件考虑容斥做，由于长度限制容易发现两个反例只会出现一个：</li></ul><p><span class="math display">\[\begin{array}{l}ans &amp;= \displaystyle \sum_{len=n}^{n+m+k} {len - 1\choose n -1}\bigg({2^{len - n} - \sum_{a = m+1}^{len - n}{len - n\choosea}-\sum_{b=k+1}^{len - n}{len - n\choose b}}\bigg)3^{n+m+k-len}\end{array}\]</span> 设 <span class="math inline">\(f_x=\sum_{i=m}^x{x\choosei}\)</span> ，然后用组合数定义优化这个东西：</p><p><span class="math display">\[f_x = \sum_{i=m}^x{x\choose i} = \sum_{i=m}^x \bigg({x-1\choosei}+{x-1\choose i - 1}\bigg) = 2f_{x-1} + {x - 1\choose m - 1}\]</span> 就变成 <span class="math inline">\(\mathcal{O}(n+m+k)\)</span>的了。。。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;  </span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;  <br><span class="hljs-keyword">using</span> ll = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">char</span> c = getchar();  <br>    <span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);  <br>    <span class="hljs-keyword">for</span> (; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);  <br>    <span class="hljs-keyword">return</span> f ? -x : x;  <br>&#125;  <br>  <br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 1000007  </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mod 1000000007  </span><br>  <br><span class="hljs-keyword">namespace</span> Comb &#123;  <br>    <span class="hljs-keyword">int</span> fac[N], ifac[N];  <br>  <br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fpow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> t)</span> </span>&#123;  <br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;  <br>        <span class="hljs-keyword">for</span> (; t; t &gt;&gt;= <span class="hljs-number">1</span>, x = <span class="hljs-number">1l</span>l * x * x % mod)  <br>            <span class="hljs-keyword">if</span> (t &amp; <span class="hljs-number">1</span>) res = <span class="hljs-number">1l</span>l * res * x % mod;  <br>        <span class="hljs-keyword">return</span> res;  <br>    &#125;  <br>  <br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;  <br>        fac[<span class="hljs-number">0</span>] = ifac[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; N; ++i) fac[i] = <span class="hljs-number">1l</span>l * fac[i - <span class="hljs-number">1</span>] * i % mod;  <br>        ifac[N - <span class="hljs-number">1</span>] = fpow(fac[N - <span class="hljs-number">1</span>], mod - <span class="hljs-number">2</span>);  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = N - <span class="hljs-number">2</span>; i; --i) ifac[i] = <span class="hljs-number">1l</span>l * ifac[i + <span class="hljs-number">1</span>] * (i + <span class="hljs-number">1</span>) % mod;  <br>    &#125;  <br>  <br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span> </span>&#123;  <br>        <span class="hljs-keyword">if</span> (n &lt; m) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1l</span>l * fac[n] * ifac[m] % mod * ifac[n - m] % mod;  <br>    &#125;  <br>&#125;  <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> Comb;  <br>  <br>ll pw2[N] = &#123;<span class="hljs-number">1</span>&#125;, pw3[N] = &#123;<span class="hljs-number">1</span>&#125;, f1[N], f2[N];  <br>  <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    init();  <br>    ll ans = <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">int</span> n = rd(), m = rd(), k = rd();  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; N; ++i) &#123;  <br>        pw2[i] = (pw2[i - <span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">1</span>) % mod;  <br>        pw3[i] = pw3[i - <span class="hljs-number">1</span>] * <span class="hljs-number">3</span> % mod;  <br>        f1[i] = (<span class="hljs-number">2</span> * f1[i - <span class="hljs-number">1</span>] + C(i - <span class="hljs-number">1</span>, m)) % mod;  <br>        f2[i] = (<span class="hljs-number">2</span> * f2[i - <span class="hljs-number">1</span>] + C(i - <span class="hljs-number">1</span>, k)) % mod;  <br>    &#125;  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = n; l &lt;= n + m + k; ++l) &#123;  <br>        ll w = ((pw2[l - n] - f1[l - n] - f2[l - n]) % mod + mod) % mod;  <br>        ans = (ans + C(l - <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>) * w % mod * pw3[n + m + k - l]) % mod;  <br>    &#125;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
      <category>AtCoder</category>
      
      <category>AtCoder Regular Contest</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Dynamic Programming</tag>
      
      <tag>STL</tag>
      
      <tag>01-BFS</tag>
      
      <tag>Combinatorics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AtCoder Regular Contest 060</title>
    <link href="/2022/06/30/ARC060/"/>
    <url>/2022/06/30/ARC060/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="c---tak-and-cards">C - Tak and Cards</h1><blockquote><p>给定 <span class="math inline">\(n\)</span>个有序数字，求有多少个下标集，对应的数字平均数是 <spanclass="math inline">\(A\)</span></p></blockquote><p>数据范围很小，用背包计数就好了，注意枚举的上下界。 <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">char</span> c = getchar();<br>    <span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);<br>    <span class="hljs-keyword">return</span> f ? -x : x;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 57</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> M 5007</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> B 2500</span><br><br>ll f[N][M];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = rd(), A = rd();<br>    f[<span class="hljs-number">0</span>][B] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        <span class="hljs-keyword">int</span> w = rd() - A;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = max(-B, -B + w); v &lt;= min(B, B + w); ++v)<br>            f[i][v + B] = f[i - <span class="hljs-number">1</span>][v + B] + f[i - <span class="hljs-number">1</span>][v - w + B];<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, f[n][B] - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure> # D- Digit Sum &gt; 给定两个数字 <span class="math inline">\(n\ (n\le10^{11})\)</span> 和 <span class="math inline">\(s\)</span>，求最小的进制 <span class="math inline">\(b\)</span> ，使得 <spanclass="math inline">\(n\)</span> 在 <spanclass="math inline">\(b\)</span> 进制下的数位和等于 <spanclass="math inline">\(s\)</span> 。</p><p>一道典型的根号讨论题目。</p><ul><li>当 <span class="math inline">\(b\le \sqrt{n}\)</span>时，直接暴力验证。</li><li>当 <span class="math inline">\(b\ge \sqrt{n}\)</span>时，数字最多是两位数，可以写成 <spanclass="math inline">\(n=pb+q,s=p+q\)</span> ，联立得 <spanclass="math inline">\(n-s=p(b-1)\)</span></li></ul><p>注意后一种情况判断要求：<span class="math inline">\(b\ge \sqrt{n},\0\le q&lt; b\)</span></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;  </span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;  <br><span class="hljs-keyword">using</span> ll = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">calc</span><span class="hljs-params">(ll n, ll b)</span> </span>&#123;  <br>    ll ans = <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">for</span> (; n; ans += n % b, n /= b);  <br>    <span class="hljs-keyword">return</span> ans;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    ll n, s;  <br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; s;  <br>    <span class="hljs-keyword">if</span> (n &lt; s) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;  <br>    <span class="hljs-keyword">if</span> (n == s) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, n + <span class="hljs-number">1</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;  <br>    ll lim = <span class="hljs-built_in">sqrt</span>(n);  <br>    <span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">2</span>; i &lt;= lim; ++i)  <br>        <span class="hljs-keyword">if</span> (calc(n, i) == s) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, i); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;  <br>    n -= s;  <br>    ll ans = <span class="hljs-number">1e18</span>;  <br>    <span class="hljs-keyword">for</span> (ll i = <span class="hljs-built_in">sqrt</span>(n); i &gt;= <span class="hljs-number">1</span>; --i)  <br>        <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) &#123;  <br>            <span class="hljs-keyword">if</span> (i &gt;= lim &amp;&amp; s - n / i &lt; i + <span class="hljs-number">1</span> &amp;&amp; s &gt;= n / i) ans = min(ans, i + <span class="hljs-number">1</span>);  <br>            <span class="hljs-keyword">if</span> (n / i &gt;= lim &amp;&amp; s - i &lt; n / i + <span class="hljs-number">1</span> &amp;&amp; s &gt;= i) ans = min(ans, n / i + <span class="hljs-number">1</span>);  <br>        &#125;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans == <span class="hljs-number">1e18</span> ? <span class="hljs-number">-1</span> : ans);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="e---tak-and-hotels">E - Tak and Hotels</h1><blockquote><p>给定数轴上的 <span class="math inline">\(n\)</span>个点，每次查询两个点 <span class="math inline">\(a,b\)</span> ： 问从<span class="math inline">\(a\)</span> 到 <spanclass="math inline">\(b\)</span> ，在给定的点之间跳跃，每次距离不超过<span class="math inline">\(L\)</span> ，最少多少次。</p></blockquote><p>考虑倍增，设 <span class="math inline">\(mx_{i,j}\)</span> 表示从<span class="math inline">\(i\)</span> 向右跳 <spanclass="math inline">\(2^j\)</span>步，最多能跳到哪里，组合的时候记得判一下最后一步即可。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;  </span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;  <br><span class="hljs-keyword">using</span> ll = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">char</span> c = getchar();  <br>    <span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);  <br>    <span class="hljs-keyword">for</span> (; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);  <br>    <span class="hljs-keyword">return</span> f ? -x : x;  <br>&#125;  <br>  <br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 100007   </span><br>  <br><span class="hljs-keyword">int</span> r[N][<span class="hljs-number">18</span>], x[N];  <br>  <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-keyword">int</span> n = rd();  <br>    <span class="hljs-keyword">int</span> t = log2(n) + <span class="hljs-number">1</span>;  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) x[i] = rd();  <br>    <span class="hljs-keyword">int</span> l = rd(), q = rd();  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, rpos = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;  <br>        <span class="hljs-keyword">while</span> (rpos &lt; n &amp;&amp; x[rpos + <span class="hljs-number">1</span>] - x[i] &lt;= l) ++rpos;  <br>        r[i][<span class="hljs-number">0</span>] = rpos;  <br>    &#125;  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= t; ++i)  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>; l &lt;= n; ++l) r[l][i] = r[r[l][i - <span class="hljs-number">1</span>]][i - <span class="hljs-number">1</span>];  <br>  <br>    <span class="hljs-keyword">for</span> (; q; --q) &#123;  <br>        <span class="hljs-keyword">int</span> a = rd(), b = rd();  <br>        <span class="hljs-keyword">if</span> (a &gt; b) swap(a, b);  <br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = t; ~i; --i)  <br>            <span class="hljs-keyword">if</span> (r[a][i] &lt; b) &#123;  <br>                ans += (<span class="hljs-number">1</span> &lt;&lt; i);  <br>                a = r[a][i];  <br>            &#125;  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans + <span class="hljs-number">1</span>);  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="f---best-representation">F - Best Representation</h1><blockquote><p>定义无循环节（完整补齐）的字符串是好的。定义将一个串划分为若干好的字符串，这个划分是好的。定义一个划分是最优的，当且仅当划分是好的并且划分的子串数最少。 给定串<span class="math inline">\(S\ (|S|\le 5\times 10^5)\)</span>求最优划分所需的子串数和最优划分个数。</p></blockquote><ul><li>如果 <span class="math inline">\(S\)</span>自己本身无循环节，两个答案都是 <spanclass="math inline">\(1\)</span></li><li>如果 <span class="math inline">\(S\)</span>所有字母都相同，第一个答案是 <span class="math inline">\(n\)</span>，第二个是 <span class="math inline">\(1\)</span></li><li>如果 <span class="math inline">\(S\)</span>有循环节且所有字母都不同，第一个答案是 <spanclass="math inline">\(2\)</span> （在任意循环节中间切开）</li></ul><p>对于第三种情况枚举分割点计数，需要快速判断一个前缀/后缀有无循环节。</p><p>对正反两个串都做一下 kmp 就可以了，若 <spanclass="math inline">\((n-nxt[n])\ |\ n\)</span> 则有循环节。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 500007</span><br><br><span class="hljs-keyword">char</span> s[N];<br><br><span class="hljs-keyword">int</span> nxt[N], nxtr[N];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">pre</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (nxt[x] == <span class="hljs-number">0</span>) || (x % (x - nxt[x]) &gt; <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">suf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (nxtr[x] == <span class="hljs-number">0</span>) || (x % (x - nxtr[x]) &gt; <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">int</span> len = <span class="hljs-built_in">strlen</span>(s + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">bool</span> fl = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>, pos; i &lt;= len; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] != s[i - <span class="hljs-number">1</span>]) fl = <span class="hljs-number">1</span>;<br>        pos = nxt[i - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">while</span> (pos &amp;&amp; s[pos + <span class="hljs-number">1</span>] != s[i]) pos = nxt[pos];<br>        <span class="hljs-keyword">if</span> (pos != <span class="hljs-number">0</span>) nxt[i] = pos + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> nxt[i] = (s[<span class="hljs-number">1</span>] == s[i]);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!fl) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n1\n&quot;</span>, len); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br>    <span class="hljs-keyword">if</span> (pre(len)) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;1\n1&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;2&quot;</span>);<br>    reverse(s + <span class="hljs-number">1</span>, s + <span class="hljs-number">1</span> + len);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>, pos; i &lt;= len; ++i) &#123;<br>        pos = nxtr[i - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">while</span> (pos &amp;&amp; s[pos + <span class="hljs-number">1</span>] != s[i]) pos = nxtr[pos];<br>        <span class="hljs-keyword">if</span> (pos != <span class="hljs-number">0</span>) nxtr[i] = pos + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> nxtr[i] = (s[<span class="hljs-number">1</span>] == s[i]);<br>    &#125;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; ++i)<br>        <span class="hljs-keyword">if</span> (pre(i) &amp;&amp; suf(len - i)) ++ans;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
      <category>AtCoder</category>
      
      <category>AtCoder Regular Contest</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knapsack Problem</tag>
      
      <tag>Threshold Optimization</tag>
      
      <tag>Binary Lifting</tag>
      
      <tag>Greedy</tag>
      
      <tag>KMP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>A Little Charity Guarantees Almost Envy-Freeness</title>
    <link href="/2022/06/24/Almost-EFX/"/>
    <url>/2022/06/24/Almost-EFX/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原文地址：<a href="https://arxiv.org/abs/1907.04596">arXiv :[1907.04596]</a></p><p>收录于 SODA 2020 的一篇论文，关于不可分割物体的公平分配。</p><h2 id="问题模型">问题模型</h2><p><span class="math inline">\(m\)</span> 个商品（全集 <spanclass="math inline">\(\mathbf{M}\)</span> ）分配给 <spanclass="math inline">\(n\)</span> 个竞争者，也就是求集合 <spanclass="math inline">\(\mathbf M\)</span> 的一个划分 <spanclass="math inline">\(\\{ \mathbf{X_1},\mathbf{X_2},\dots \mathbf{X_n}\\}\)</span> ，尽可能公平。</p><p>最一般的问题模型，每个人 <span class="math inline">\(i\)</span>对于每个物品集合 <span class="math inline">\(S\subseteq T\)</span>都有一个价值函数 <span class="math inline">\(v_i(S):2^{\mathbf{M}}\to\mathbb{R}_{\ge 0}\)</span></p><ul><li><em>Envy - Free</em>：没有人嫉妒他人，即在任何人眼中，别人获得的商品价值都不比自己高，即<span class="math inline">\(\forall j\ne i, v_i(\mathbf{X_i})\gev_i(\mathbf{X_j})\)</span></li></ul><p>然而很容易证明 <em>Envy - Free</em>的分配不一定存在，比如考虑两个人分一个物品，且两人都认为物品有价值。</p><ul><li><em>EF1 (envy - free up to one good)</em> ：如果 <spanclass="math inline">\(i\)</span> 嫉妒 <spanclass="math inline">\(j\)</span> ，即 <spanclass="math inline">\(v_i(\mathbf{X_i})&lt;v_i(\mathbf{X_j})\)</span>，存在 <span class="math inline">\(g\in \mathbf{X_j}\)</span> ，使 <spanclass="math inline">\(v_i(\mathbf{X_i})\ge v_i(\mathbf{X_j}\setminusg)\)</span></li></ul><p>前人的工作已经证明 <em>EF1</em>的分配一定存在，并且有快速计算的算法<a href="">[1]</a>。</p><hr /><p>抱歉，这篇文章要等到期末后再更新了～</p>]]></content>
    
    
    <categories>
      
      <category>Summary</category>
      
      <category>Paper Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Game Theory</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Connectivity : From DFS to Dominator Tree</title>
    <link href="/2022/06/01/connectivity/"/>
    <url>/2022/06/01/connectivity/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>「 连通性：从深度优先搜索到支配树 」探讨一些关于连通性的算法。</p>]]></content>
    
    
    <categories>
      
      <category>Summary</category>
      
      <category>Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DFS and Similar</tag>
      
      <tag>Graphs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AtCoder Beginner Contest 253</title>
    <link href="/2022/05/29/abc253/"/>
    <url>/2022/05/29/abc253/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>A, B 比较简单就不写了。</p><p>我的代码 : <ahref="https://atcoder.jp/contests/abc253/submissions?f.Task=&amp;f.LanguageName=&amp;f.Status=AC&amp;f.User=SGColin">AllSubmissions - SGColin</a></p><h3 id="c.-max---min-query">C. Max - Min Query</h3><blockquote><p>维护一个 multiset ，支持插入一个 <spanclass="math inline">\(x\)</span> ，删除 <spanclass="math inline">\(\min(c_i,s.count(x))\)</span> 个 <spanclass="math inline">\(x\)</span> ，查询最大值-最小值。</p></blockquote><p>开始想想直接模拟复杂度是对的就写了 <code>multiset</code>，<del>没想到<code>multiset</code> 的 <code>lower_bound</code> 太慢了 T了几个点。</del></p><p>Upd : 经提醒应该是 <code>count</code> 函数太慢了，官网描述是"Logarithmic in <a href="http://cplusplus.com/multiset::size">size</a>and linear in the number of matches" ，也就是说复杂度是 <spanclass="math inline">\(\mathcal{O}(k+\log n)\)</span> ，其中 <spanclass="math inline">\(k\)</span> 是查询数字的出现次数，所以加入 <spanclass="math inline">\(10^5\)</span> 个点之后，多查几次就超时了。</p><p>所以改为用 <code>map</code>维护一个计数器，每次某个数字新出现/消失的时候再对 <code>set</code>操作。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">char</span> c = getchar();<br>    <span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);<br>    <span class="hljs-keyword">return</span> f ? -x : x;<br>&#125;<br><br><span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; cnt;<br><br><span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt; s;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = rd();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        <span class="hljs-keyword">int</span> op = rd();<br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">int</span> x = rd();<br>            ++cnt[x];<br>            <span class="hljs-keyword">if</span> (cnt[x] == <span class="hljs-number">1</span>) s.insert(x);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">int</span> x = rd();<br>            <span class="hljs-keyword">int</span> t = min(rd(), cnt[x]);<br>            cnt[x] -= t;<br>            <span class="hljs-keyword">if</span> (cnt[x] == <span class="hljs-number">0</span>) s.erase(x);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, (*--s.end()) - (*s.begin()));<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="d.-fizzbuzz-sum-hard">D. FizzBuzz Sum Hard</h3><blockquote><p>给定 <span class="math inline">\(n,a,b\)</span> 找出 <spanclass="math inline">\([1,n]\)</span> 内不是 <spanclass="math inline">\(a\)</span> 或 <spanclass="math inline">\(b\)</span> 倍数的数字的和。</p></blockquote><p>简单的容斥原理，扣掉 <span class="math inline">\(a,b\)</span>的倍数，加上 <span class="math inline">\(\text{lcm}(a,b)\)</span>的倍数。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">char</span> c = getchar();<br>    <span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);<br>    <span class="hljs-keyword">return</span> f ? -x : x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> b ? gcd(b, a % b) : a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = rd(), a = rd(), b = rd();<br>    ll sum = <span class="hljs-number">1l</span>l * n * (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> ka = n / a;<br>    <span class="hljs-keyword">int</span> kb = n / b;<br>    sum -= <span class="hljs-number">1l</span>l * a * ka * (ka + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    sum -= <span class="hljs-number">1l</span>l * b * kb * (kb + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    ll lcm = <span class="hljs-number">1l</span>l * a * b / gcd(a, b);<br>    ll kl = n / lcm;<br>    sum += <span class="hljs-number">1l</span>l * lcm * kl * (kl + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, sum);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="e.-distance-sequence">E. Distance Sequence</h3><blockquote><p>计数长度为 <span class="math inline">\(n\)</span> 的序列 <spanclass="math inline">\(\{a_i\}\)</span> ：(1) <spanclass="math inline">\(a_i\in[1,m]\)</span> ; (2) <spanclass="math inline">\(\forall i\in[2,n], |a_i-a_{i-1}|\ge k\)</span>.</p></blockquote><p>直接 DP ，设 <span class="math inline">\(f_{i,j}\)</span> 表示长度为<span class="math inline">\(i\)</span> 的序列，结尾是 <spanclass="math inline">\(j\)</span> 的方案数，有： <spanclass="math display">\[f_{i,j}=\sum_{w\in[1,j-k]\cup[j+k,m]} f_{i-1,w}\]</span> 用一个前缀和优化即可，注意下 <spanclass="math inline">\(k=0\)</span> 时不要算重，复杂度 <spanclass="math inline">\(O(nm)\)</span></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">char</span> c = getchar();<br>    <span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);<br>    <span class="hljs-keyword">return</span> f ? -x : x;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 1007</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> M 5007</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mod 998244353</span><br><br><span class="hljs-keyword">int</span> f[N][M], sum[N][M];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fpow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> t)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (; t; t &gt;&gt;= <span class="hljs-number">1</span>, x = <span class="hljs-number">1l</span>l * x * x % mod)<br>        <span class="hljs-keyword">if</span> (t &amp; <span class="hljs-number">1</span>) res = <span class="hljs-number">1l</span>l * res * x % mod;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = rd(), m = rd(), k = rd();<br>    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, fpow(m, n)); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>        f[<span class="hljs-number">1</span>][i] = <span class="hljs-number">1</span>; sum[<span class="hljs-number">1</span>][i] = i;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; ++j) &#123;<br>            <span class="hljs-keyword">int</span> l = max(<span class="hljs-number">0</span>, j - k);<br>            <span class="hljs-keyword">int</span> r = min(m, j + k - <span class="hljs-number">1</span>);<br>            f[i][j] = (sum[i - <span class="hljs-number">1</span>][m] - sum[i - <span class="hljs-number">1</span>][r] + mod) % mod;<br>            f[i][j] = (f[i][j] + sum[i - <span class="hljs-number">1</span>][l]) % mod;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; ++j) <br>            sum[i][j] = (sum[i][j - <span class="hljs-number">1</span>] + f[i][j]) % mod;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, sum[n][m]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="f.-operations-on-a-matrix">F. Operations on a Matrix</h3><blockquote><p>维护一个初始是全 <span class="math inline">\(0\)</span> 的 <spanclass="math inline">\(n\times m\ (n,m\le 2\ast 10^5)\)</span>的矩阵，支持：</p><ul><li>对 <span class="math inline">\([l_i,r_i]\)</span>这些列的每一个元素加 <span class="math inline">\(x\)</span></li><li>将第 <span class="math inline">\(i\)</span> 行全部赋值为 <spanclass="math inline">\(x\)</span></li><li>查询矩阵中 <span class="math inline">\((x_i,y_i)\)</span> 的值</li></ul></blockquote><p>记录每行最后一次被赋值的时间戳 <spanclass="math inline">\(lst_i\)</span> 和赋值 <spanclass="math inline">\(x_i\)</span> ，则答案为 <spanclass="math inline">\(x_i\)</span> + <spanclass="math inline">\([lst,now]\)</span> 这段操作里对 <spanclass="math inline">\(y_i\)</span> 加的值。</p><ul><li><p>在线的做法就是写一个主席树 + 标记持久化；</p></li><li><p>离线的做法就是把后面的贡献写做前缀和差分，然后两个时刻维护一下。</p></li></ul><p>学到了简老师的主席树写法 OwO</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">char</span> c = getchar();<br>    <span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);<br>    <span class="hljs-keyword">return</span> f ? -x : x;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 200007</span><br><br><span class="hljs-keyword">int</span> tot, rttot;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    <span class="hljs-keyword">int</span> ls, rs;<br>    ll sum;<br>&#125; c[N &lt;&lt; <span class="hljs-number">6</span>];<br><br><span class="hljs-keyword">int</span> rot[N], lst[N];<br><br>ll x[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">copy</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rt)</span> </span>&#123;<br>    c[++tot] = c[rt];<br>    <span class="hljs-keyword">return</span> tot;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">upd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;rt, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R, <span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    rt = copy(rt);<br>    <span class="hljs-keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;<br>        c[rt].sum += x; <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (L &lt;= mid) upd(c[rt].ls, l, mid, L, R, x);<br>    <span class="hljs-keyword">if</span> (R &gt; mid) upd(c[rt].rs, mid + <span class="hljs-number">1</span>, r, L, R, x);<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rtl, <span class="hljs-keyword">int</span> rtr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> p)</span> </span>&#123;<br>    ll res = c[rtr].sum - c[rtl].sum;<br>    <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span> res;<br>    <span class="hljs-keyword">if</span> (p &lt;= mid) res += query(c[rtl].ls, c[rtr].ls, l, mid, p);<br>    <span class="hljs-keyword">else</span> res += query(c[rtl].rs, c[rtr].rs, mid + <span class="hljs-number">1</span>, r, p);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = rd(), m = rd(), q = rd();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= q; ++i) &#123;<br>        <span class="hljs-keyword">int</span> op = rd();<br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>) &#123;<br>            ++rttot;<br>            rot[rttot] = rot[rttot - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">int</span> l = rd(), r = rd(), v = rd();<br>            upd(rot[rttot], <span class="hljs-number">1</span>, m, l, r, v);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">int</span> p = rd(); <br>            x[p] = rd(); <br>            lst[p] = rttot;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">int</span> row = rd(), col = rd();<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, x[row] + query(rot[lst[row]], rot[rttot], <span class="hljs-number">1</span>, m, col));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></div></td></tr></table></figure><h3 id="g.-swap-many-times">G. Swap Many Times</h3><blockquote><p>对于 <span class="math inline">\(n\)</span> ，初始化一个序列 <spanclass="math inline">\(a_1,\cdots,a_n\)</span> ，满足 <spanclass="math inline">\(a_i=i\)</span> 。</p><p>对于 <span class="math inline">\(n\)</span> ，有 <spanclass="math inline">\(\frac{n(n+1)}{2}\)</span> 个形如 <spanclass="math inline">\((x,y)\)</span> 的满足 <spanclass="math inline">\(1\le x&lt;y\le n\)</span> 的数对，按照 pair的规则排序。</p><p>给定 <span class="math inline">\(L,R\)</span> ，对于这个 pair序列的第 <span class="math inline">\(L\)</span> 个到第 <spanclass="math inline">\(R\)</span> 个，依次操作：交换 <spanclass="math inline">\(a_x\)</span> 和 <spanclass="math inline">\(a_y\)</span></p><p>求最终的序列。</p></blockquote><p>观察这个序列， <span class="math inline">\(x\)</span> 相同的 pair是连续出现的，考虑对于同一个 <span class="math inline">\(x\)</span>把所有操作都做掉。</p><p>假设以 <span class="math inline">\(x\)</span> 为 <code>first</code>的在 <span class="math inline">\([L,R]\)</span> 内的操作为 <spanclass="math inline">\((x,y_a),(x,y_a+1),\cdots,(x,y_b)\)</span></p><p>那么实际操作的结果就是把序列中 <spanclass="math inline">\(x,y_a,y_a+1,\cdots,y_b\)</span> 这些位置整体向右shift 一个位置。</p><p>枚举 <span class="math inline">\(x\)</span>，然后只需要一个支持某个位置插入删除的数据结构就可以了。</p><p>然后昨天趁机学了一下 rope ，内核是块状链表，理论复杂度 <spanclass="math inline">\(\mathcal{O}(n\sqrt{n})\)</span>，实际表现速度很快。</p><p>只能说非常好用，可惜 Clang 编译不了，是在 Custom Test手动调试的。</p><blockquote><p>p.s. 题解的做法貌似不需要数据结构，好像很精妙</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ext/rope&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> __gnu_cxx;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;<br>    ll x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">char</span> c = getchar();<br>    <span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);<br>    <span class="hljs-keyword">return</span> f ? -x : x;<br>&#125;<br><br>rope&lt;<span class="hljs-keyword">int</span>&gt; s;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = rd();<br>    ll L = rd(), R = rd();<br>    ll l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i) s.push_back(i);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        l = r + <span class="hljs-number">1</span>; r = l + n - i - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (L &lt;= r &amp;&amp; R &gt;= l) &#123;<br>            <span class="hljs-keyword">int</span> ll = max(l, L), rr = min(r, R);<br>            <span class="hljs-keyword">int</span> pl = i + <span class="hljs-number">1</span> + ll - l;<br>            <span class="hljs-keyword">int</span> pr = i + <span class="hljs-number">1</span> + rr - l;<br>            <span class="hljs-keyword">int</span> x = s[pr];<br>            s.erase(pr, <span class="hljs-number">1</span>);<br>            s.insert(pl, s[i]);<br>            s.erase(i, <span class="hljs-number">1</span>);<br>            s.insert(i, x);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, s[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
      <category>AtCoder</category>
      
      <category>AtCoder Beginner Contest</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Dynamic Programming</tag>
      
      <tag>STL</tag>
      
      <tag>Persistent Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Two Identical Machines Scheduling with Agreement Graphs</title>
    <link href="/2022/05/25/machine-scheduling-with-agreement-graph/"/>
    <url>/2022/05/25/machine-scheduling-with-agreement-graph/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><ahref="/material/TCS19_New%20results_in_two%20identical_machines_scheduling_with_agreement_graphs.pdf">Newresults in two identical machines scheduling with agreementgraphs</a></p><p>收录于 TCS 2019的一篇文章，基于许可图的独立双机流水安排问题的一些新进展。</p><h2 id="问题模型">问题模型</h2><p>有 <span class="math inline">\(n\)</span> 个任务，第 <spanclass="math inline">\(i\)</span> 个任务需要的时间是 <spanclass="math inline">\(p_i\)</span> 。</p><p>一共有两台机器，每个任务都需要被连续地安排到某一个机器上完成。</p><p>将任务抽象成点，给定一个许可图，两个任务有边则可以分别在两个机器上同时执行。</p><p>求一个安排方案，最小化最后一个被做完的任务完成时间。</p><p><strong>现有结论：</strong></p><ul><li>许可图是树的情况下，此问题是 NP-Hard 的</li><li>许可图是毛毛虫的情况下，存在 <spanclass="math inline">\(\mathcal{O}(n)\)</span> 求最优解的方法</li></ul><h2 id="毛毛虫">毛毛虫</h2><p>毛毛虫是一种特殊的树，由一个核心路径和若干到路径距离为 <spanclass="math inline">\(1\)</span> 的点构成。</p><h3 id="notation">Notation</h3><table><colgroup><col style="width: 58%" /><col style="width: 41%" /></colgroup><thead><tr class="header"><th style="text-align: center;">Meaning</th><th style="text-align: center;">Notation</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Processing time</td><td style="text-align: center;"><spanclass="math inline">\(p\)</span></td></tr><tr class="even"><td style="text-align: center;">Maximum weighted independent set of theagreement graph <span class="math inline">\(G\)</span></td><td style="text-align: center;"><spanclass="math inline">\(I_p(G)\)</span></td></tr><tr class="odd"><td style="text-align: center;">Weight of <spanclass="math inline">\(I_p(G)\)</span> (<strong>a lower bound on theoptimal makespan</strong>)</td><td style="text-align: center;"><spanclass="math inline">\(\overline{I_p}(G) =\sum_{j\in I_p(G)}p_j\)</span></td></tr><tr class="even"><td style="text-align: center;">Set of neighbors of a job <spanclass="math inline">\(j\)</span> (generalized for a subset <spanclass="math inline">\(J&#39;\)</span>)</td><td style="text-align: center;"><spanclass="math inline">\(N(j)/N(J&#39;)\)</span></td></tr><tr class="odd"><td style="text-align: center;">Set of leaves connected to job <spanclass="math inline">\(j\)</span></td><td style="text-align: center;"><spanclass="math inline">\(Lv(j)\)</span></td></tr><tr class="even"><td style="text-align: center;">Starting time of a job <spanclass="math inline">\(j\)</span></td><td style="text-align: center;"><spanclass="math inline">\(t_j\)</span></td></tr><tr class="odd"><td style="text-align: center;">Minimum starting time of a subset <spanclass="math inline">\(J&#39;\)</span></td><td style="text-align: center;"><spanclass="math inline">\(t_j(J&#39;)=\min_{k\inJ&#39;}\{t_k\}\)</span></td></tr></tbody></table><h3 id="algorithm">Algorithm</h3><p>见原文 [4.2] Caterpillar scheduling algorithm。</p><h3 id="polynomiality-and-optimality-proof">Polynomiality and OptimalityProof</h3><p>为了简单描述，我们称在 MWIS 里的点为黑点，其余点为白点。</p><p>可以发现断掉白点之间的所有边后，这个新的图的性质是所有的边都是黑-白边。</p><blockquote><p><strong>Claim 1.</strong> 对于每个新的连通块 <spanclass="math inline">\(CAT_i\)</span> ，其内的黑点集 <spanclass="math inline">\(S_i^*\)</span> 仍然是 <spanclass="math inline">\(CAT_i\)</span> 的 MWIS</p></blockquote><p>假设存在其他的 MWIS <span class="math inline">\(I_p(CAT_i)\)</span>使得 <span class="math inline">\(\overline{I_p}(CAT_i) &gt; \sum_{j\inS_i^*} p_j\)</span> ，那么我们考虑将 <spanclass="math inline">\(CAT_i\)</span> 这一部分的 MWIS换成这个新的集合，其他部分的 MWIS 不变，那么还原回仍是原图的一个IS，而这个新的 IS 比原来的 MWIS 权值还大，所以矛盾了。 <spanclass="math display">\[\sum_{j \in S^{\prime}} p_{j}=\overline{I_{p}}(C A T)-\sum_{j \inS_{i}^{*}} p_{j}+\overline{I_{p}}\left(C AT_{i}\right)&gt;\overline{I_{p}}(C A T)\]</span></p><blockquote><p><strong>Claim 2.</strong> 对于每个新的连通块 <spanclass="math inline">\(CAT_i\)</span> 的点集 <spanclass="math inline">\(J_i\)</span>，其内任何一个白点子集的点权和不会超过其邻居黑点的点权和</p></blockquote><p>假设存在这样的一个白点集 <span class="math inline">\(W\)</span> 满足<span class="math inline">\(\sum_{j \in W} p_{j} &gt; \sum_{j \in N(W)}p_{j}\)</span> ，那么考虑将 <span class="math inline">\(S_i^*\)</span>换成 <span class="math inline">\(S&#39;= (S_i^*\setminus N(W))\cupW\)</span> ，易证<span class="math inline">\(S&#39;\)</span>也是一个独立集，且比 <span class="math inline">\(S_i^*\)</span>权值和还要大，矛盾。 <span class="math display">\[\sum_{j \in S^{\prime}} p_{j}=\sum_{j \in S_{i}^{*}} p_{j}-\sum_{j \inN(W)} p_{j}+\sum_{j \in W} p_{j}&gt;\sum_{j \in S_{i}^{*}} p_{j}\]</span></p><blockquote><p><strong>Claim 3.</strong> 对于任意白点 <spanclass="math inline">\(\beta\)</span>，其邻居黑点都会被连续地安排在第一个机器上</p></blockquote><p>分类讨论一下，如果是叶子显然；如果不是叶子，假设链上的顺序是 <spanclass="math inline">\(\alpha-\beta-\gamma\)</span> ，那么黑点顺序显然是<span class="math inline">\(\alpha-(\beta\)</span> 的叶子 <spanclass="math inline">\()-\gamma\)</span></p><blockquote><p><strong>Claim 4.</strong> 对于任意两个白点 <spanclass="math inline">\(\alpha,\beta\)</span>，如果他们被连续地安排在了某一个机器上，那么他们一定有公共邻居。</p></blockquote><p>同样分类讨论 <span class="math inline">\(\alpha\)</span> 和 <spanclass="math inline">\(\beta\)</span>的位置关系（分别是主干/叶子）即可。</p><blockquote><p><strong>Claim 5.</strong>对于任意连续安排的白点集，其邻居一定是被连续安排在一个区间内的</p></blockquote><p>前两条的自然结果，当然也需要第二条辅助理解一下，证明黑色一定是连续的。</p><hr /><blockquote><p><strong>Lemma 1.</strong> 每一个白点都会被安排在邻居对应的区间里</p></blockquote><p>反证法，不符合的就两种情况：</p><ol type="1"><li><span class="math inline">\(t_\beta &lt; t(N(\beta ))\)</span>：这种情况不存在，因为算法中每个黑点是连续安排的，如果出现该情况，这个白点会与非邻接的黑点重合，与许可图的要求相冲突。</li><li><span class="math inline">\(t_\beta+p_\beta &gt; t(N(\beta )) +\sum_{j\in N(\beta)} p_j\)</span> ：这种情况不存在，考虑从 <spanclass="math inline">\(\beta\)</span> 往前的第一个满足 <spanclass="math inline">\(t_\alpha=t_{N(\alpha)}\)</span> 的任务 <spanclass="math inline">\(\alpha\)</span> ，那么从 <spanclass="math inline">\(\alpha\)</span> 到 <spanclass="math inline">\(\beta\)</span> 这一段是连续安排的，由事实 <spanclass="math inline">\(5\)</span>，连续安排的白点集，其邻居一定是被连续安排在一个区间内的，因此白点的区间就是<span class="math inline">\([t_\alpha,t_\alpha+\sum_{j\in[\alpha,\beta]}p_j]\)</span> ，黑点的区间就是 <spanclass="math inline">\([t(N([\alpha,\beta])),t(N([\alpha,\beta])) +\sum_{j\in N([\alpha,\beta])} p_j]\)</span> ; 又由事实 <spanclass="math inline">\(2\)</span> ，对于 <spanclass="math inline">\(J_i\)</span>内任何一个白点子集，其点权和不会超过其邻居黑点的点权和，因此有 <spanclass="math inline">\(t_\alpha+\sum_{j\in[\alpha,\beta]} p_j \le\sum_{j\in N([\alpha,\beta])} p_j\)</span> ，因此 <spanclass="math inline">\([\alpha, \beta]\)</span>这一段的白点终止时间不超过黑点，因此作为最后一个完成的白点 <spanclass="math inline">\(\beta\)</span> ，有 <spanclass="math inline">\(t_\beta+p_\beta \le t(N(\beta )) + \sum_{j\inN(\beta)} p_j\)</span></li></ol><blockquote><p><strong>Theorithm 2</strong>. 本算法求出的安排方案为最优解。</p></blockquote><p>由引理 <span class="math inline">\(1\)</span> ，每个 <spanclass="math inline">\(\sigma_i\)</span>所需要的时间就是其中黑点所需的时间，即 <spanclass="math inline">\(\overline{I_p}(CAT_i)\)</span> ，因此总方案 <spanclass="math inline">\(\sigma\)</span> 所需的时间 <spanclass="math inline">\(\sum_{i} \overline{I_p}(CAT_i) =\overline{I_p}(CAT)\)</span> ，即答案下界。</p><h2 id="总结">总结</h2><p>最后放一个 pdf 版的总结：</p><div class="row">    <embed src="/material/notes_SWA.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>Summary</category>
      
      <category>Paper Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Greedy</tag>
      
      <tag>Graphs</tag>
      
      <tag>Scheduling</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fast Fourier Transform and Polynomials Tech</title>
    <link href="/2022/05/18/fft/"/>
    <url>/2022/05/18/fft/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="fundamental">Fundamental</h2><p>放一个算法讨论组上做报告的 ppt :</p><div class="row">    <embed src="/material/fft.pdf" width="100%" height="550" type="application/pdf"></div><h2 id="structure">Structure</h2><h2 id="ntt">NTT</h2><h2 id="application">Application</h2>]]></content>
    
    
    <categories>
      
      <category>Summary</category>
      
      <category>Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Polynomials</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round #787 (Div. 3)</title>
    <link href="/2022/05/06/cf787/"/>
    <url>/2022/05/06/cf787/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="a.-food-for-animals">A. Food for Animals</h2><blockquote><p><span class="math inline">\(a\)</span> 个狗粮，<spanclass="math inline">\(b\)</span> 个猫粮，<spanclass="math inline">\(c\)</span> 个通用粮（都能吃），能不能保证 <spanclass="math inline">\(n\)</span> 个狗 <spanclass="math inline">\(m\)</span> 个猫都有的吃？</p></blockquote><p>每个都先减掉专用的食物，剩下的看通用的够不够分即可。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a = rd(), b = rd(), c = rd();<br>    <span class="hljs-keyword">int</span> n = max(<span class="hljs-number">0</span>, rd() - a), m = max(<span class="hljs-number">0</span>, rd() - b);<br>    <span class="hljs-built_in">puts</span>(n + m &gt; c ? <span class="hljs-string">&quot;NO&quot;</span> : <span class="hljs-string">&quot;YES&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="b.-make-it-increasing">B. Make It Increasing</h2><blockquote><p>给一个数列，每次操作把一个位置整除 <spanclass="math inline">\(2\)</span> ，最少操作多少次使得数列严格递增？</p></blockquote><p>从后往前倒推，答案是固定的，一直做到符合要求即可。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a[<span class="hljs-number">57</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = rd(), ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) a[i] = rd();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i; --i) <br>        <span class="hljs-keyword">if</span> (a[i] &gt;= a[i + <span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-keyword">if</span> (a[i + <span class="hljs-number">1</span>] == <span class="hljs-number">0</span>) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>); <span class="hljs-keyword">return</span>;&#125;<br>            <span class="hljs-keyword">while</span> (a[i] &gt;= a[i + <span class="hljs-number">1</span>]) &#123;++ans; a[i] = a[i] / <span class="hljs-number">2</span>;&#125;<br>        &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="c.-detective-task">C. Detective Task</h2><blockquote><p>有一幅画， <span class="math inline">\(n\)</span>个人看，中间某一时刻被某一个人偷走了。</p><p>问每个人他看的时候画还在不在，答案可能是有 (1) / 无 (0) / 忘记了(?)。</p><p>好人会说实话/忘记了，偷走的人会随机选一个答案，求有多少个嫌疑人。</p></blockquote><ul><li>最后一个说有（1）的人，前面的人都不会是嫌疑人：如果前面的人是嫌疑人，那么他进去的时候应该已经被偷了，他就说谎了。</li><li>第一个说无（0）的人，后面的人都不会是嫌疑人：如果后面的人是嫌疑人，那么他进去的时候还没被偷，他就说谎了</li></ul><p>因此答案是从最后一个说有的人到第一个说无的人这一段的人数。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">string</span> s;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; s;<br>    <span class="hljs-keyword">int</span> n = s.length();<br>    <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;1&#x27;</span>) l = i;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = l; i &lt; n; ++i) <br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;r = i; <span class="hljs-keyword">break</span>;&#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, r - l + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="d.-vertical-paths">D. Vertical Paths</h2><blockquote><p>给一棵树，问最少分成多少个从上到下的链，并输出方案。</p></blockquote><p>显然每个叶子都需要一个链，每个非叶子挑一个叶子挂上就行了，纯考实现。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">char</span> c = getchar();<br>    <span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);<br>    <span class="hljs-keyword">return</span> f ? -x : x;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 200007</span><br><br><span class="hljs-keyword">bool</span> vis[N];<br><br><span class="hljs-keyword">int</span> n, rt, f[N], cnt;<br><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res[N], son[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> bel)</span> </span>&#123;<br>    res[bel].push_back(u);<br>    <span class="hljs-keyword">if</span> (son[u].empty()) &#123;++cnt; <span class="hljs-keyword">return</span>;&#125;<br>    dfs(son[u][<span class="hljs-number">0</span>], bel);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; son[u].size(); ++i) dfs(son[u][i], son[u][i]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br>    n = rd(); cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;res[i].clear(); son[i].clear();&#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        f[i] = rd(); <br>        <span class="hljs-keyword">if</span> (f[i] == i) rt = i;<br>        <span class="hljs-keyword">else</span> son[f[i]].push_back(i);<br>    &#125;<br>    dfs(rt, rt); <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, cnt);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>        <span class="hljs-keyword">if</span> (!res[i].empty()) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, (<span class="hljs-keyword">int</span>)res[i].size());<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> j : res[i]) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, j); <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>        &#125;  <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> t = rd(); t; --t) work();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="e.-replace-with-the-previous-minimize">E. Replace With thePrevious, Minimize</h2><blockquote><p>给一个字符串，每次操作你可以选定一个字符，并把串中的<strong>所有</strong>这个字符换成字典序前一个（a变成 z ）</p><p>问 <span class="math inline">\(k\)</span>次操作内，字符串可能的字典序最小的结果是什么？</p></blockquote><p>首先如果 <span class="math inline">\(k&gt;25\)</span> ，那么我从 z 到b 都操作一遍就都变成 aaaaaaa 这样子了。</p><p>否则也一定不会对 a操作，因为次数不够变回来了，因此操作是单向的，没有循环的。</p><p>因此按照字典序贪心就完事了，维护一个 <spanclass="math inline">\(\Sigma\to \Sigma\)</span>的转移表，每次可以的话往前移动一下。</p><p>需要注意的是利用此前的结果，也就是每次做完之后记得把前缀覆盖一下。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">string</span> s;<br><span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">char</span>&gt; tr;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = rd(), k = rd();<br>    <span class="hljs-built_in">cin</span> &gt;&gt; s;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> i = <span class="hljs-string">&#x27;a&#x27;</span>; i &lt;= <span class="hljs-string">&#x27;z&#x27;</span>; ++i) tr[i] = i;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : s) &#123;<br>        <span class="hljs-keyword">while</span> (k &amp;&amp; tr[i] &gt; <span class="hljs-string">&#x27;a&#x27;</span>) &#123;<br>            --tr[i]; --k;<br>            tr[i] = tr[tr[i]];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> j = i; j &gt;= tr[i]; --j) tr[j] = min(tr[j], tr[i]);<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : s) <span class="hljs-built_in">putchar</span>(tr[i]); <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="f.-vlad-and-unfinished-business">F. Vlad and UnfinishedBusiness</h2><blockquote><p>给一棵树，树上的两个点 <span class="math inline">\(x, y\)</span>，以及一系列点 <span class="math inline">\(a_1, a_2,\dots,a_k\)</span></p><p>求一个最短路径，从 <span class="math inline">\(x\)</span>出发，以任意顺序遍历完 <span class="math inline">\(a_1, a_2,\dots,a_k\)</span> ，最后走到 <span class="math inline">\(y\)</span></p></blockquote><p>首先一个常见的套路（虚树）是，树上遍历一个点集的最短回路，就是所有点按照dfs序一次性访问。</p><p>现在考虑让树以 <span class="math inline">\(x\)</span>为根，现在需要遍历 <spanclass="math inline">\(a_1,a_2,\dots,a_k\)</span> 这些点，最后再走到<span class="math inline">\(y\)</span> 。</p><p>其实可以看成回路遍历点集 <span class="math inline">\(x, a_1,a_2,\dots, a_k,y\)</span> ，最后再把 <spanclass="math inline">\(x\)</span> 到 <spanclass="math inline">\(y\)</span> 的距离（也就是 <spanclass="math inline">\(y\)</span> 的深度）扣掉。</p><p>所以按照 dfs 序依次访问即可，可能比较难写。</p><p>另外一种简单的写法是暴力往根跳，跳到第一个访问到的点即可，往答案里累加新增的点数* 2 。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">char</span> c = getchar();<br>    <span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);<br>    <span class="hljs-keyword">return</span> f ? -x : x;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 200007</span><br><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; e[N], seq;<br><br><span class="hljs-keyword">bool</span> vis[N];<br><br><span class="hljs-keyword">int</span> n, k, x, y, f[N], ans;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> fa, <span class="hljs-keyword">int</span> dep)</span> </span>&#123;<br>    f[u] = fa;<br>    <span class="hljs-keyword">if</span> (u == y) ans = -dep;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u])<br>        <span class="hljs-keyword">if</span> (v != fa) dfs(v, u, dep + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br>    seq.clear();<br>    n = rd(); k = rd(); x = rd(); y = rd();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) vis[i] = <span class="hljs-number">0</span>, e[i].clear();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; ++i) seq.push_back(rd());<br>    seq.push_back(y);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">int</span> u = rd(), v = rd();<br>        e[u].push_back(v); e[v].push_back(u);<br>    &#125;<br>    dfs(x, x, <span class="hljs-number">0</span>);<br>    vis[x] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : seq)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> u = i; !vis[u]; u = f[u]) vis[u] = <span class="hljs-number">1</span>, ans += <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> t = rd(); t; --t) work();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="g.-sorting-pancakes">G. Sorting Pancakes</h2><blockquote><p>给你一个序列，每次操作可以选两个相邻的两个位置一个 <spanclass="math inline">\(-1\)</span> 一个 <spanclass="math inline">\(+1\)</span> ，问最小操作多少次是的序列单减。</p></blockquote><p>看到这种问题一般都是 dp ，就是状态设计需要好好考虑一下。</p><p>设 <span class="math inline">\(f_{i,j}\)</span> 表示考虑了前 <spanclass="math inline">\(i\)</span> 位，前缀和是 <spanclass="math inline">\(j\)</span>的最小操作数，那么转移就是枚举序列最终下一个位置的数字 <spanclass="math inline">\(k\)</span> 。</p><p>即 <span class="math inline">\(f_{i+1,j+k}=\min\{f_{i+1,j+k}, f_{i,j}+ cost (i + 1, j+k)\}\)</span> 其中 <span class="math inline">\(cost(x,w)\)</span> 表示前缀 <span class="math inline">\(x\)</span>在此前基础上变成总和 <span class="math inline">\(w\)</span>的最小代价。</p><p>考虑 <span class="math inline">\(f_{i,j}\)</span> 里已经包含了让前缀<span class="math inline">\(i\)</span>合法的代价，现在其实只需要考虑新一位是 <spanclass="math inline">\(k\)</span> 的代价。</p><p>本质上我们只需要考虑第 <span class="math inline">\(i+1\)</span>位和后面的后缀交流的多少次，即 <spanclass="math inline">\(cost(i+1,j+k)=|\sum_{p=1}^{i+1}a_p-(j+k)|\)</span></p><p>那么怎么保证序列单减呢？把枚举 <span class="math inline">\(k\)</span>的循环放到最外面，从大到小，这样转移是从大到小的，比较妙。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">char</span> c = getchar();<br>    <span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);<br>    <span class="hljs-keyword">return</span> f ? -x : x;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 257</span><br><br><span class="hljs-keyword">int</span> a[N], s[N], f[N][N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = rd(), m = rd();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) <br>        s[i] = s[i - <span class="hljs-number">1</span>] + (a[i] = rd());<br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span>(f));<br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = m; ~k; --k)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= m - k; ++j) <br>                f[i + <span class="hljs-number">1</span>][j + k] = min(f[i + <span class="hljs-number">1</span>][j + k], f[i][j] + <span class="hljs-built_in">abs</span>(j + k - s[i + <span class="hljs-number">1</span>]));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, f[n][m]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
      <category>Codeforces</category>
      
      <category>Codeforces Round</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Dynamic Programming</tag>
      
      <tag>DFS and Similar</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dynamic Programming on Intervals</title>
    <link href="/2022/04/26/dp_interval/"/>
    <url>/2022/04/26/dp_interval/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="normal-problems">Normal Problems</h2><p>区间动态规划的一般形式：枚举长度（阶段），枚举左端点，需要的话再枚举分割点</p><h3 id="unlock-the-padlock">Unlock the Padlock</h3><div class="note note-warning">            <p><ahref="https://codingcompetitions.withgoogle.com/kickstart/round/00000000008caa74/0000000000acef55">Source:Google Kick Start 2022 Round B</a></p><p>一个滚轮密码锁由 <span class="math inline">\(n\)</span>个滚轮组成，每个的范围都是 <span class="math inline">\([0, D-1]\)</span>（循环），初始是 <span class="math inline">\(a_i\)</span> 。</p><p>每次操作选取一个区间 <span class="math inline">\(1 \le l_i \le r_i\le n\)</span> ，将区间内所有滚轮都向上或向下拨一个位置。</p><p>要求 <span class="math inline">\([l_i,r_i]\subseteq[l_{i+1},r_{i+1}]\)</span> ，问最少多少次把所有位置都变成 <spanclass="math inline">\(0\)</span> 。</p>          </div><p>区间只能扩张不能收缩，因此任意时刻拨动的区间内的数字一定要相同。</p><p>如果 <span class="math inline">\(D\)</span> 很小，可以设 <spanclass="math inline">\(f[l][r][k]\)</span> 表示区间 <spanclass="math inline">\([l,r]\)</span> 都调成 <spanclass="math inline">\(k\)</span> 的最小代价，直接 <spanclass="math inline">\(\mathcal O(n^2D^2)\)</span> 求解。</p><p>那么什么时候区间能真的扩张？当且仅当区间内的值和 <spanclass="math inline">\(a_{l-1}\)</span> 或 <spanclass="math inline">\(a_{r+1}\)</span>一样，才能向左或向右扩展一位。</p><p>因此 <strong>任意时刻操作区间的值一定和某个端点相同</strong> ，设<span class="math inline">\(f[l][r][0/1]\)</span> 表示把 <spanclass="math inline">\([l,r]\)</span> 都调成左/右端点的最小操作次数。</p><p>直接每次区间长度扩展 <span class="math inline">\(1\)</span>转移即可，复杂度 <span class="math inline">\(\mathcal O(n^2)\)</span>。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;<br>    ll x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">char</span> c = getchar();<br>    <span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);<br>    <span class="hljs-keyword">return</span> f ? -x : x;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 407</span><br><br><span class="hljs-keyword">int</span> testcase;<br><br>ll n, d, f[N][N][<span class="hljs-number">2</span>], a[N];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">dis</span><span class="hljs-params">(ll a, ll b)</span> </span>&#123;<br>    ll w = <span class="hljs-built_in">abs</span>(a - b);<br>    <span class="hljs-keyword">return</span> min(w, d - w);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getmin</span><span class="hljs-params">(ll &amp;a, ll b)</span> </span>&#123;a = (a &lt; b ? a : b);&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br>    n = rd(); d = rd();<br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span>(f));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        a[i] = rd(); <br>        f[i][i][<span class="hljs-number">0</span>] = f[i][i][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> len = <span class="hljs-number">1</span>; len &lt; n; ++len) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>; l &lt;= n - len + <span class="hljs-number">1</span>; ++l) &#123;<br>            <span class="hljs-keyword">int</span> r = l + len - <span class="hljs-number">1</span>;<br>            getmin(f[l - <span class="hljs-number">1</span>][r][<span class="hljs-number">0</span>], f[l][r][<span class="hljs-number">0</span>] + dis(a[l], a[l - <span class="hljs-number">1</span>]));<br>            getmin(f[l - <span class="hljs-number">1</span>][r][<span class="hljs-number">0</span>], f[l][r][<span class="hljs-number">1</span>] + dis(a[r], a[l - <span class="hljs-number">1</span>]));<br>            getmin(f[l][r + <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], f[l][r][<span class="hljs-number">0</span>] + dis(a[l], a[r + <span class="hljs-number">1</span>]));<br>            getmin(f[l][r + <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], f[l][r][<span class="hljs-number">1</span>] + dis(a[r], a[r + <span class="hljs-number">1</span>]));<br>        &#125;<br>    &#125;<br>  ll ans = min(f[<span class="hljs-number">1</span>][n][<span class="hljs-number">0</span>] + dis(a[<span class="hljs-number">1</span>], <span class="hljs-number">0</span>), f[<span class="hljs-number">1</span>][n][<span class="hljs-number">1</span>] + dis(a[n], <span class="hljs-number">0</span>));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Case #%d: %lld\n&quot;</span>, ++testcase, ans);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> t = rd(); t; --t) work();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="sue-的小球">Sue 的小球</h3><div class="note note-warning">            <p><a href="https://www.luogu.com.cn/problem/P2466">Source: SDOI2008</a></p><p>有 <span class="math inline">\(n\)</span> 个球往下落，初始坐标是<span class="math inline">\(x_i\)</span> ，高度是 <spanclass="math inline">\(h_i\)</span> ，下落速度 <spanclass="math inline">\(v_i\)</span> ，可以下落到正无穷。</p><p>初始坐标在 <span class="math inline">\(x_0\)</span>，每秒可以向左/向右移动 <span class="math inline">\(1\)</span>，经过某个球的坐标时就把这个球拿走，获得当前高度的得分。</p><p>问拿到所有球的前提下，最大得分是多少。</p>          </div><p>得分 <span class="math inline">\(=\sum h_i-\sum\)</span>下降的高度，考虑动态规划求 <span class="math inline">\(\min\sum\)</span>下降的高度。</p><p>问题变为第 <span class="math inline">\(i\)</span> 个位置每秒会消耗<span class="math inline">\(v_i\)</span> ，到一个位置就会停止消耗，是 <ahref="https://www.luogu.com.cn/problem/P1220">关路灯</a> 这个模型。</p><p>考虑把坐标排序之后离散化，拿走的球一定是一个连续的区间，因此我们可以让状态停在某一个端点。</p><p>状态设计比较特殊：设 <spanclass="math inline">\(f[l][r][0/1]\)</span> 表示把 <spanclass="math inline">\([l,r]\)</span>全部拿走，最后停在左/右端点，<strong>从开始到这个时刻的最小总消耗</strong></p><p>那么考虑每次扩展一个位置，那么所耗的时间就是两点距离，<strong>每一秒</strong>的代价就是<span class="math inline">\(\sum_{i\notin [l,r]} v_i\)</span>（所有没接到的球）</p><p>需要注意把初始坐标离散化进去。枚举区间动态规划复杂度 <spanclass="math inline">\(\mathcal O(n^2)\)</span> 。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">double</span> db;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">char</span> c = getchar();<br>    <span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);<br>    <span class="hljs-keyword">return</span> f ? -x : x;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 1007</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fr first</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> sc second</span><br><br><span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span>&gt; p[N];<br><br>db ans, sum[N], f[N][N][<span class="hljs-number">2</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getmin</span><span class="hljs-params">(db &amp;a, db b)</span> </span>&#123;a = (a &lt; b ? a : b);&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = rd(), c = rd();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) p[i].fr = rd(); <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) ans += rd() / <span class="hljs-number">1000.0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) p[i].sc = rd() / <span class="hljs-number">1000.0</span>;<br>    p[++n] = <span class="hljs-built_in">make_pair</span>(c, <span class="hljs-number">0</span>);<br>    sort(p + <span class="hljs-number">1</span>, p + <span class="hljs-number">1</span> + n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>; l &lt;= n; ++l)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> r = <span class="hljs-number">1</span>; r &lt;= n; ++r)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">2</span>; ++k) f[l][r][k] = <span class="hljs-number">1e18</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        sum[i] = sum[i - <span class="hljs-number">1</span>] + p[i].sc;<br>        <span class="hljs-keyword">if</span> (p[i].fr == c) f[i][i][<span class="hljs-number">0</span>] = f[i][i][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> len = <span class="hljs-number">1</span>; len &lt; n; ++len) <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>; l &lt;= n - len + <span class="hljs-number">1</span>; ++l) &#123;<br>            <span class="hljs-keyword">int</span> r = l + len - <span class="hljs-number">1</span>;<br>            db rsum = sum[n] - sum[r] + sum[l - <span class="hljs-number">1</span>];<br>            getmin(f[l - <span class="hljs-number">1</span>][r][<span class="hljs-number">0</span>], f[l][r][<span class="hljs-number">0</span>] + (p[l].fr - p[l - <span class="hljs-number">1</span>].fr) * rsum);<br>            getmin(f[l - <span class="hljs-number">1</span>][r][<span class="hljs-number">0</span>], f[l][r][<span class="hljs-number">1</span>] + (p[r].fr - p[l - <span class="hljs-number">1</span>].fr) * rsum);<br>            getmin(f[l][r + <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], f[l][r][<span class="hljs-number">0</span>] + (p[r + <span class="hljs-number">1</span>].fr - p[l].fr) * rsum);<br>            getmin(f[l][r + <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], f[l][r][<span class="hljs-number">1</span>] + (p[r + <span class="hljs-number">1</span>].fr - p[r].fr) * rsum);<br>        &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.3lf\n&quot;</span>, ans - min(f[<span class="hljs-number">1</span>][n][<span class="hljs-number">0</span>], f[<span class="hljs-number">1</span>][n][<span class="hljs-number">1</span>]));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="cities">Cities</h3><div class="note note-warning">            <p><a href="https://ac.nowcoder.com/acm/contest/14055/C">Source: The45th ICPC Asia Kunming Regional</a></p><p>有 <span class="math inline">\(n\)</span> 个点，第 <spanclass="math inline">\(i\)</span> 个点的颜色是 <spanclass="math inline">\(c_i\)</span> ，保证每种颜色最多出现 <spanclass="math inline">\(15\)</span> 次。</p><p>每次操作可以把<strong>一段连续且颜色相同的</strong>点都改成某个颜色，问最少操作多少次使得所有点颜色相同。</p>          </div><p>先把同样颜色且连续的缩成一段，这样相邻两两颜色都不同，假设有 <spanclass="math inline">\(m\)</span> 段。</p><p>如果所有的颜色都不同的话，那么答案就是 <spanclass="math inline">\(m-1\)</span> ，因为每次只能改颜色相同的。</p><p>但是序列中依旧有颜色相同的，因此需要动态规划求，设 <spanclass="math inline">\(f[l][r]\)</span> 表示把 <spanclass="math inline">\([l,r]\)</span> 变成相同的所需的最少次数。</p><p>转移考虑 <span class="math inline">\(c_l\)</span>有没有单独消耗一次合并：</p><ul><li><p>如果单独消耗了一次就是 <span class="math inline">\(f[l][r] = f[l+ 1][r] + 1\)</span></p></li><li><p>如果不消耗，那么枚举相同的另一个是 <spanclass="math inline">\(k\)</span> ，那么 <spanclass="math inline">\(f[l][r] = f[l + 1][k - 1] + f[k][r] +1\)</span></p></li></ul><p>后面这个方程成立的原因是，我们发现操作总是可以等效到把区间变成和端点颜色相同。</p><p>需要缩点的原因是，后一种方程里的 <spanclass="math inline">\(+1\)</span> 是为了把 <spanclass="math inline">\([l + 1][k - 1]\)</span> 变成和 <spanclass="math inline">\(c_l\)</span> 相同的，不缩会求错。</p><p>枚举区间，再枚举相同颜色，因为题目限制每种颜色最多出现 <spanclass="math inline">\(15\)</span> 次，复杂度 <spanclass="math inline">\(O(15n^2)\)</span> 。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">double</span> db;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">char</span> c = getchar();<br>    <span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);<br>    <span class="hljs-keyword">return</span> f ? -x : x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getmin</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;a = (a &lt; b ? a : b);&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 5007</span><br><br><span class="hljs-keyword">int</span> a[N], f[N][N], lst[N], nxt[N];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = rd(), tot = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, x; i &lt;= n; ++i) &#123;<br>        x = rd();<br>        <span class="hljs-keyword">if</span> (!tot || x != a[tot]) a[++tot] = x;<br>        lst[i] = n + <span class="hljs-number">1</span>;<br>    &#125;<br>    n = tot;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n; i; --i) &#123;<br>        nxt[i] = lst[a[i]];<br>        lst[a[i]] = i;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> len = <span class="hljs-number">2</span>; len &lt;= n; ++len)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>; l &lt;= n - len + <span class="hljs-number">1</span>; ++l) &#123;<br>            <span class="hljs-keyword">int</span> r = l + len - <span class="hljs-number">1</span>;<br>            f[l][r] = f[l + <span class="hljs-number">1</span>][r] + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = nxt[l]; j &lt;= r; j = nxt[j])<br>                getmin(f[l][r], f[l + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + f[j][r] + <span class="hljs-number">1</span>);<br>        &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, f[<span class="hljs-number">1</span>][n]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> t = rd(); t; --t) work();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="dire-wolf">Dire Wolf</h3><div class="note note-warning">            <p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=5115">Source:2014 ICPC Asia Beijing Regional</a></p><p>有 <span class="math inline">\(n\)</span> 个恐狼先锋排成一排，第<span class="math inline">\(i\)</span> 个有 <spanclass="math inline">\(a_i\)</span> 初始攻击力，并且会为两侧的恐狼临时增加 <span class="math inline">\(b_i\)</span>攻击力（死了就没了）</p><p>每次杀掉一个需要承受他当前攻击力的伤害，问杀掉所有的狼，承受最少伤害是多少。</p>          </div><p>设 <span class="math inline">\(f[l][r]\)</span> 表示把 <spanclass="math inline">\([l,r]\)</span>这个区间的所有狼杀掉所需的最小代价。</p><p>枚举最后一只杀掉的狼 <span class="math inline">\(k\)</span>，考虑此时他两侧的狼是谁？</p><p>答案是 <span class="math inline">\(l-1\)</span> 和 <spanclass="math inline">\(r+1\)</span> ，考虑区间 DP的阶段性，我只需要杀死当前枚举的区间的狼，所以两侧的狼都没有死过。</p><p>所以最后一只狼的攻击力是 <span class="math inline">\(a_k+b_{l-1}+b_{r+ 1}\)</span> ，枚举 <span class="math inline">\(k\)</span>更新，复杂度是 <span class="math inline">\(\mathcal O(n^3)\)</span> 的。<span class="math display">\[f[l][r] = \min_{l\le k\le r}\bigg\{f[l][k-1]+f[k+1][r]+a_k+b_{l-1}+b_{r+1}\bigg\}\]</span></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">char</span> c = getchar();<br>    <span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);<br>    <span class="hljs-keyword">return</span> f ? -x : x;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 207</span><br><br><span class="hljs-keyword">int</span> a[N], b[N], testcase;<br><br>ll f[N][N];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = rd();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) a[i] = rd();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) b[i] = rd();<br>    b[n + <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> len = <span class="hljs-number">1</span>; len &lt;= n; ++len)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>; l &lt;= n - len + <span class="hljs-number">1</span>; ++l) &#123;<br>            <span class="hljs-keyword">int</span> r = l + len - <span class="hljs-number">1</span>;<br>            f[l][r] = <span class="hljs-number">1e18</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> p = l; p &lt;= r; ++p) <br>                f[l][r] = min(f[l][r], f[l][p - <span class="hljs-number">1</span>] + f[p + <span class="hljs-number">1</span>][r] + a[p] + b[l - <span class="hljs-number">1</span>] + b[r + <span class="hljs-number">1</span>]);<br>        &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Case #%d: %lld\n&quot;</span>, ++testcase, f[<span class="hljs-number">1</span>][n]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> t = rd(); t; --t) work();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="you-are-the-one">You Are the One</h3><div class="note note-warning">            <p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=4283">Source:2012 ICPC Asia Tianjin Regional Online</a></p><p><span class="math inline">\(n\)</span>个人排成一队依次入栈，任意时刻都可以按栈序弹出栈内的任意人数。</p><p>第 <span class="math inline">\(i\)</span> 个人如果是第 <spanclass="math inline">\(k\)</span> 个出场的，代价是 <spanclass="math inline">\(D_i\ast (k-1)\)</span>，求所有人代价和最小可能是多少。</p>          </div><p>设 <span class="math inline">\(f[l][r]\)</span>表示序列里<strong>只有</strong> <spanclass="math inline">\([l,r]\)</span>这些人（假设区间前后的人不存在），最小代价是多少。</p><p>观察这些人的出入栈的顺序，发现序列会被第一个人何时出栈划分为两个阶段。</p><p>第一个人第一个入栈，假设第 <span class="math inline">\(k\)</span>个出栈（他出栈前只压入第 <span class="math inline">\(2\sim k\)</span>个人）那么序列表现为：</p><ul><li>第 <span class="math inline">\(2\sim k\)</span>个人出入栈，这些人前面没有其他人，代价是 <spanclass="math inline">\(f[l+1][l+k-1]\)</span></li><li>第一个人出栈，前面有 <span class="math inline">\(k-1\)</span>个人，代价是 <span class="math inline">\(D_l\ast(k-1)\)</span></li><li>第 <span class="math inline">\(k+1\sim n\)</span>个人出入栈，这些人前面都增加 <span class="math inline">\(k\)</span>个人，代价是 <spanclass="math inline">\(f[l+k][r]+\sum_{i=l+k+1}^rD_i\ast k\)</span></li></ul><p>枚举 <span class="math inline">\(k\)</span> 更新，复杂度是 <spanclass="math inline">\(\mathcal O(n^3)\)</span> 的。 <spanclass="math display">\[f[l][r] =\min_{1\le k\le r-l+1} \bigg\\{f[l + 1][l +k-1]+D_l\ast(k-1)+f[l+k][r] + \sum_{i=l+k}^r D_i\ast k\bigg\\}\]</span></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">char</span> c = getchar();<br>    <span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);<br>    <span class="hljs-keyword">return</span> f ? -x : x;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 107</span><br><br><span class="hljs-keyword">int</span> testcase;<br><br>ll d[N], sum[N], f[N][N];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getmin</span><span class="hljs-params">(ll &amp;a, ll b)</span> </span>&#123;a = (a &lt; b ? a : b);&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = rd();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        d[i] = rd();<br>        sum[i] = sum[i - <span class="hljs-number">1</span>] + d[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> len = <span class="hljs-number">2</span>; len &lt;= n; ++len)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>; l &lt;= n - len + <span class="hljs-number">1</span>; ++l) &#123;<br>            <span class="hljs-keyword">int</span> r = l + len - <span class="hljs-number">1</span>;<br>            f[l][r] = <span class="hljs-number">1e18</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= len; ++k) <br>                getmin(f[l][r], f[l + <span class="hljs-number">1</span>][l + k - <span class="hljs-number">1</span>] + d[l] * (k - <span class="hljs-number">1</span>) + f[l + k][r] + (sum[r] - sum[l + k - <span class="hljs-number">1</span>]) * k);<br>        &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Case #%d: %lld\n&quot;</span>, ++testcase, f[<span class="hljs-number">1</span>][n]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> t = rd(); t; --t) work();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="二叉查找树">二叉查找树</h3><div class="note note-warning">            <p><a href="https://www.luogu.com.cn/problem/P1864">Source: NOI2009</a></p><p>给定 <span class="math inline">\(n\)</span> 个节点的<code>key,value,times</code> ，修改一个点的 <code>value</code> 代价是<span class="math inline">\(K\)</span> ，修改后要保证两两<code>value</code> 不同。</p><p>然后把这些点建出一个 Treap，定义访问代价 <spanclass="math inline">\(\sum_{i} depth_i\ast times_{i}\)</span>，最小化修改代价 + 访问代价。</p>          </div><p>核心点是 <code>key</code>不能修改，所以中序遍历是固定的，根左侧是左子树，根右侧是右子树。</p><p>考虑在中序遍历上做区间 DP ，枚举谁做根，那么根的 <code>value</code>应当比左右子树的节点 <code>value</code> 要小。</p><p>所以状态里我们还要记一下当前子树的最小 <code>value</code>是多少。</p><p>设 <span class="math inline">\(f[l][r][k]\)</span> 表示中序遍历区间<span class="math inline">\([l,r]\)</span> 内的点建树，里面的点<code>value</code> 权值 <span class="math inline">\(\ge k\)</span>，的最小代价。</p><ul><li><p>如果这个点的权值不需要改（前提 <spanclass="math inline">\(value_{rt}\ge k\)</span>），那么子树里的权值要比他大 <span class="math display">\[f[l][r][k] = \min_{l\le rt\le r}\bigg\{f[l][rt - 1][value_{rt}]+f[rt +1][r][value_{rt}] + \sum_{i=l}^r times_i\bigg\}\]</span></p></li><li><p>如果这个点权值需要改，那么子树的权值下界也是 <spanclass="math inline">\(k\)</span> <span class="math display">\[f[l][r][k] = \min_{l\le rt\le r}\bigg\{f[l][rt - 1][k]+f[rt + 1][r][k] +\sum_{i=l}^r times_i + K\bigg\}\]</span></p></li></ul><p>因为初始两两节点 <code>value</code>就不同，而且可以调整成任意实数，所以方程中对子树权值的约束不用修改。</p><p>答案是 <span class="math inline">\(\min_k f[1][n][k]\)</span>，把权值离散化一下，DP 复杂度是 <span class="math inline">\(\mathcalO(n^4)\)</span> 的。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">char</span> c = getchar();<br>    <span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);<br>    <span class="hljs-keyword">return</span> f ? -x : x;<br>&#125;<br><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; s;<br><br><span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; tr;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 73</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><span class="hljs-keyword">int</span> k, v, t;&#125; c[N];<br><br>ll f[N][N][N], sumt[N];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getmin</span><span class="hljs-params">(ll &amp;a, ll b)</span> </span>&#123;a = (a &lt; b ? a : b);&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = rd(), w = rd();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) c[i].k = rd();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) s.push_back(c[i].v = rd());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) c[i].t = rd();<br>    sort(s.begin(), s.end());<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : s) tr[i] = ++cnt;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) c[i].v = tr[c[i].v];<br>    sort(c + <span class="hljs-number">1</span>, c + <span class="hljs-number">1</span> + n, [](node x, node y)&#123;<span class="hljs-keyword">return</span> x.k &lt; y.k;&#125;);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) sumt[i] = sumt[i - <span class="hljs-number">1</span>] + c[i].t;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> len = <span class="hljs-number">1</span>; len &lt;= n; ++len) <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>; l &lt;= n - len + <span class="hljs-number">1</span>; ++l) &#123;<br>            <span class="hljs-keyword">int</span> r = l + len - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt;= n; ++k) &#123;<br>                f[l][r][k] = <span class="hljs-number">1e18</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> rt = l; rt &lt;= r; ++rt) &#123;<br>                    <span class="hljs-keyword">if</span> (c[rt].v &gt;= k)<br>                        getmin(f[l][r][k], f[l][rt - <span class="hljs-number">1</span>][c[rt].v] + f[rt + <span class="hljs-number">1</span>][r][c[rt].v]);<br>                    getmin(f[l][r][k], f[l][rt - <span class="hljs-number">1</span>][k] + f[rt + <span class="hljs-number">1</span>][r][k] + w);<br>                &#125;<br>                f[l][r][k] += sumt[r] - sumt[l - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>    ll ans = <span class="hljs-number">1e18</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt;= n; ++k) ans = min(ans, f[<span class="hljs-number">1</span>][n][k]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="pre-order">Pre-Order</h3><div class="note note-warning">            <p><a href="https://atcoder.jp/contests/abc252/tasks/abc252_g">Source :AtCoder Beginner Contest 252 G</a></p><p>定义 dfs序：从根开始，每次选择未访问过的最小儿子访问，每个点第一次被访问时记入序列尾。</p><p>现给定 dfs 序，问有多少棵树符合。 <span class="math inline">\(n\le500\)</span></p>          </div><p>考虑多叉树转二叉树（左儿子右兄弟，这是一个双射），那么要求就变为右儿子一定要小于父节点的编号。</p><p>设 <span class="math inline">\(f_{l, r}\)</span> 表示 <spanclass="math inline">\([l,r]\)</span> 这段区间，以 <spanclass="math inline">\(l\)</span> 为根形成这样一棵二叉树的方案数。</p><p>枚举右儿子是 <span class="math inline">\(k\in[l + 1, r], a[k] &gt;a[l]\)</span> ，有转移 <span class="math inline">\(f_{l, r} = \sum_kf_{l,k - 1} \times f_{k, r}\)</span></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;<br>    ll x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">char</span> c = getchar();<br>    <span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);<br>    <span class="hljs-keyword">return</span> f ? -x : x;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 507</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mod 998244353</span><br><br>ll a[N], f[N][N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = rd();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        a[i] = rd(); f[i][i] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> len = <span class="hljs-number">2</span>; len &lt; n; ++len) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">2</span>; l &lt;= n - len + <span class="hljs-number">1</span>; ++l) &#123;<br>            <span class="hljs-keyword">int</span> r = l + len - <span class="hljs-number">1</span>;<br>            f[l][r] = f[l + <span class="hljs-number">1</span>][r];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = l + <span class="hljs-number">1</span>; k &lt;= r; ++k)<br>                <span class="hljs-keyword">if</span> (a[k] &gt; a[l]) f[l][r] = (f[l][r] + <span class="hljs-number">1l</span>l * max(<span class="hljs-number">1l</span>l, f[l + <span class="hljs-number">1</span>][k - <span class="hljs-number">1</span>]) * f[k][r]) % mod;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, f[<span class="hljs-number">2</span>][n]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Summary</category>
      
      <category>Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Dynamic Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AtCoder Grand Contest 002</title>
    <link href="/2022/04/13/agc002/"/>
    <url>/2022/04/13/agc002/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>官方题解：<ahref="https://img.atcoder.jp/agc002/editorial.pdf">https://img.atcoder.jp/agc002/editorial.pdf</a></p>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
      <category>AtCoder</category>
      
      <category>AtCoder Grand Contest</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>AtCoder Grand Contest 001</title>
    <link href="/2022/04/12/agc001/"/>
    <url>/2022/04/12/agc001/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>官方题解：<ahref="https://img.atcoder.jp/agc001/editorial.pdf">https://img.atcoder.jp/agc001/editorial.pdf</a></p><p>听说多做 AGC可以提升智力，于是来尝试提升一下智力<del>（虽然都是抄的题解）</del>。</p><h2 id="a---bbq-easy">A - BBQ Easy</h2><blockquote><p><span class="math inline">\(2n\)</span>个数，最大化两两一组分组后，每组两个数取 <spanclass="math inline">\(\min\)</span> 的和。</p></blockquote><p>从小到大排序之后，两两组合，答案是奇数位置的和。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">char</span> c = getchar();<br><span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);<br><span class="hljs-keyword">for</span> (; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);<br><span class="hljs-keyword">return</span> f ? -x : x;<br>&#125;<br><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; a;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> n = (rd() &lt;&lt; <span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) a.push_back(rd());<br>sort(a.begin(), a.end());<br><span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i += <span class="hljs-number">2</span>) ans += a[i];<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="b---mysterious-light">B - Mysterious Light</h2><blockquote><p>边长为 <span class="math inline">\(n\)</span> 的正三角形 ABC 的边 AB上 <span class="math inline">\(x\)</span> 处平行 BC 射出一条激光。</p><p>碰到边界反射，碰到此前的光线也反射，求回到起点的路径长度。</p></blockquote><p>没看懂官方题解的简单做法。</p><p>首先前两段光路长度和是 <span class="math inline">\(n\)</span>，会切掉两个角，变成一个平行四边形。</p><p>对于平行四边形（边长分别为 <span class="math inline">\(a\)</span> 和<span class="math inline">\(b\)</span> ），光线从一个 <spanclass="math inline">\(120^\circ\)</span> 角出发，沿角平分线射出距离为<span class="math inline">\(f(a,b)\)</span></p><p>有 <span class="math inline">\(f(a,0)=-a, f(a,b) = 2 \ast\displaystyle\lfloor \frac{a}{b}\rfloor \ast b +f(b, a \% b)\)</span>，也就是每次都切短边直到长短边交换，减掉最后一次多算的。</p><p>答案就是 <span class="math inline">\(n+f(x,n-x)\)</span> ，递归形式和gcd 相同，所以复杂度是 <span class="math inline">\(\mathcal O(\logn)\)</span> 。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;<br>ll x = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">char</span> c = getchar();<br><span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);<br><span class="hljs-keyword">for</span> (; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);<br><span class="hljs-keyword">return</span> f ? -x : x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">f</span><span class="hljs-params">(ll a, ll b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> b ? <span class="hljs-number">2</span> * (a / b) * b + f(b, a % b) : -a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>ll n = rd(), x = rd();<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, n + f(x, n - x));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="c---shorten-diameter">C - Shorten Diameter</h2><blockquote><p>给一棵树，每次可以删掉一个叶子，问最少删多少次使得直径不超过 <spanclass="math inline">\(k\)</span></p></blockquote><p>本来想贪心每次删一个直径的端点，但是不对，因为有可能这个点会被保留到最后。</p><p>因为 <span class="math inline">\(n\)</span> 只有 <spanclass="math inline">\(2000\)</span> ，所以可以 <spanclass="math inline">\(\mathcal{O}(n^2)\)</span>暴力，那么枚举中心就好了。</p><ul><li>如果 <span class="math inline">\(k\)</span>是奇数，枚举中心的边，把树分成两棵，根就是这条边的两个端点，每棵只保留深度小于<span class="math inline">\(\lfloor k/2\rfloor\)</span> 的点</li><li>如果 <span class="math inline">\(k\)</span>是偶数，枚举中心的点，以这个点为根，只保留深度小于 <spanclass="math inline">\(\lfloor k/2\rfloor\)</span> 的点</li></ul><p>找到上述情况里需要删除的点最少的情况即可。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">char</span> c = getchar();<br><span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);<br><span class="hljs-keyword">for</span> (; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);<br><span class="hljs-keyword">return</span> f ? -x : x;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 2007</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fr first</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> sc second</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pii pair<span class="hljs-meta-string">&lt;int, int&gt;</span></span><br><br><span class="hljs-built_in">vector</span>&lt;pii&gt; r;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; e[N];<br><br><span class="hljs-keyword">int</span> dep[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u])<br><span class="hljs-keyword">if</span> (dep[v] &lt; <span class="hljs-number">0</span>) &#123;dep[v] = dep[u] + <span class="hljs-number">1</span>; dfs(v);&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> n = rd(), k = rd();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, u, v; i &lt; n; ++i) &#123;<br>u = rd(); v = rd();<br>e[u].pb(v); e[v].pb(u);<br><span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) r.pb(mp(u, v));<br>&#125;<br><span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [u, v] : r) &#123;<br><span class="hljs-built_in">memset</span>(dep, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span>(dep));<br>dep[u] = <span class="hljs-number">0</span>; dep[v] = <span class="hljs-number">0</span>; dfs(u); dfs(v);<br><span class="hljs-keyword">int</span> tmpans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) tmpans += (dep[j] &lt;= k / <span class="hljs-number">2</span>);<br>ans = max(ans, tmpans);<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br><span class="hljs-built_in">memset</span>(dep, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span>(dep));<br>dep[i] = <span class="hljs-number">0</span>; dfs(i);<br><span class="hljs-keyword">int</span> tmpans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) tmpans += (dep[j] &lt;= k / <span class="hljs-number">2</span>);<br>ans = max(ans, tmpans);<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, n - ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="d---arrays-and-palindrome">D - Arrays and Palindrome</h2><blockquote><p>给定序列 <span class="math inline">\(\{A_i\}\)</span> ，满足 <spanclass="math inline">\(\sum A_i=N\)</span> ，需要重排 <spanclass="math inline">\(\{A_i\}\)</span> ，并且构造 <spanclass="math inline">\(\{B_i\}\)</span> ，满足 <spanclass="math inline">\(\sum B_i=N\)</span> ，且满足：</p><p>如果一个长度为 <span class="math inline">\(N\)</span> 的串 <spanclass="math inline">\(S\)</span> 满足（ <spanclass="math inline">\(S[l,r]\)</span> 表示 <spanclass="math inline">\(S[l]S[l+1]\dots S[r]\)</span> 这一段子串）：</p><ul><li><span class="math inline">\(\forall i,\ S[\sum_{j=1}^{i-1}A_j+1,\sum_{j=1}^i A_j]\)</span> 是回文的（也就是按照 <spanclass="math inline">\(A_i\)</span> 分割成若干段子串，都是回文的）</li><li><span class="math inline">\(\forall i,\ S[\sum_{j=1}^{i-1}B_j+1,\sum_{j=1}^i B_j]\)</span> 是回文的（也就是按照 <spanclass="math inline">\(B_i\)</span> 分割成若干段子串，都是回文的）</li></ul><p>那么 <strong>一定能推出</strong> <spanclass="math inline">\(S\)</span> 中全部字符都相同。</p></blockquote><p>好有意思的题目啊！！建议先看官方题解。</p><p>假如我们确定了 <span class="math inline">\(\{A\}\)</span>的顺序，那么 <span class="math inline">\(\{A\}\)</span>把序列分成若干段，每段对称的位置字符要相同。</p><p>我们如果把 <span class="math inline">\(N\)</span> 个位置看作 <spanclass="math inline">\(N\)</span> 个点，那么可以把 <spanclass="math inline">\(A\)</span> 的所有要求对称的位置连一条边。</p><p>现在 <span class="math inline">\(B\)</span>相当于是要补一些边，使得所有点都连通。</p><div class="note note-success">            <p>假设所有的 <span class="math inline">\(A_i\)</span> 均为偶数，那么令<span class="math inline">\(|\{B\}|=|\{A\}|\)</span> ，先让 <spanclass="math inline">\(B_i=A_i\)</span> ，然后 $B_1 B_1-1,B_{|{B}|}B_{|{B}|}+1 $</p><p>那么（除第一段外）每一段的最后一个都和前一段的最后一个连边，连通了两段；</p><p>此外每一段内的连边都是奇偶位置错开的，所以整个图是连通的。</p>          </div><p>然后考虑 <span class="math inline">\(A_i\)</span>有奇数，可以证明最多允许有两段奇数，把这两段放在两边，还是不影响答案的。</p><p>如果奇数长度段超过两个，一定无解，具体证明看官方题解，大概方法就是证明了边数凑不到<span class="math inline">\(n-1\)</span> 。</p><p>感觉这个构造真的很 useful 啊（</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">char</span> c = getchar();<br><span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);<br><span class="hljs-keyword">for</span> (; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);<br><span class="hljs-keyword">return</span> f ? -x : x;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ppb pop_back</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> psb push_back</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ppf pop_front</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> psf push_front</span><br><br><span class="hljs-built_in">deque</span>&lt;<span class="hljs-keyword">int</span>&gt; s, odd;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> m = rd(), n = rd();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, x; i &lt;= n; ++i) &#123;<br>x = rd();<br>(x &amp; <span class="hljs-number">1</span>) ? odd.psb(x) : s.psb(x);<br>&#125;<br><span class="hljs-keyword">if</span> (odd.size() &gt; <span class="hljs-number">2</span>) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Impossible&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br><span class="hljs-keyword">if</span> (odd.size() &gt; <span class="hljs-number">0</span>) s.psf(odd[<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">if</span> (odd.size() &gt; <span class="hljs-number">1</span>) s.psb(odd[<span class="hljs-number">1</span>]);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : s) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, x); <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-comment">//需要注意只有一个元素和第一个元素是1的情况</span><br><span class="hljs-keyword">if</span> (s.size() == <span class="hljs-number">1</span>) s.psb(<span class="hljs-number">0</span>);<br>--s.front(); ++s.back();<br><span class="hljs-keyword">if</span> (s.front() == <span class="hljs-number">0</span>) s.ppf();<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, s.size());<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x : s) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, x);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="e---bbq-hard">E - BBQ Hard</h2><blockquote><p>给定 <span class="math inline">\(N\)</span> 个 <spanclass="math inline">\((A_i,B_i)\)</span> ，求： <spanclass="math display">\[\sum_{i=1}^{n-1}\sum_{j=i+1}^n {A_i+A_j+B_i+B_j\choose A_i+A_j} \mod10^9+7\]</span> 数据范围 <span class="math inline">\(2\le n\le 2\times10^5,1\le a_i,b_i\le 2000\)</span></p></blockquote><div class="note note-success">            <p>只能往右和往上走，计数从 <spanclass="math inline">\((x_0,y_0)\)</span> 到 <spanclass="math inline">\((x_1,y_1)\)</span>的路径方案数，考虑哪些步是横向走，是 <spanclass="math inline">\(\displaystyle{ {x_1-x_0+y_1-y_0} \choose {x_1-x_0}}\)</span> 。</p><p>当然也可以用一个二维递推，令 <code>f[x0][y0]=1</code> ，每次<code>f[i][j] = f[i - 1][j] + f[i][j - 1]</code> ，答案<code>f[x1][y1]</code> 。</p>          </div><p>把式中 <spanclass="math inline">\(\displaystyle{A_i+A_j+B_i+B_j\chooseA_i+A_j}\)</span> 变形为 <span class="math inline">\(\displaystyle{A_i-(-A_j)+B_i-(-B_j)\choose A_i-(-A_j)}\)</span> ，可解读为从 <spanclass="math inline">\((-A_j,-B_j)\)</span> 到 <spanclass="math inline">\((A_i,B_i)\)</span> 的路径数。</p><p>那么把求和改一下形式，两个循环都改成从 <spanclass="math inline">\(1\)</span> 到 <spanclass="math inline">\(n\)</span> ，然后扣掉自己到自己的贡献，再除 <spanclass="math inline">\(2\)</span> 就是答案。 <spanclass="math display">\[ans = \frac{\sum_{i=1}^{N} \sum_{j=1}^{N} \displaystyle{A_{i}+B_{i}+A_{j}+B_{j} \choose A_{i}+B_{i}}-\sum_{i=1}^{N} {2\astA_{i}+2\ast B_{i} \choose 2 \ast A_{i}}}{2}\mod 10^9+7\]</span>前一半考虑用上面提到的递推方法整体一起求（加个偏移量把坐标调成正的）：</p><p>先给所有的 <code>f[-a[i]][-b[i]] += 1</code> ，然后递推完查所有的<code>f[a[i]][b[i]]</code> 即可。</p><p>后一半用组合数直接算就好了。总复杂度 <spanclass="math inline">\(\mathcal{O}(n+4\ast \max a_i\ast \maxb_i)\)</span> 。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">char</span> c = getchar();<br><span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);<br><span class="hljs-keyword">for</span> (; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);<br><span class="hljs-keyword">return</span> f ? -x : x;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> A 4007</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> G 2001</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> M 8007</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 200007</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mod 1000000007</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inv2 500000004</span><br><br><span class="hljs-keyword">int</span> f[A][A], fac[M], ifac[M], x[N], y[N];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fpow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> t = mod - <span class="hljs-number">2</span>)</span> </span>&#123;<br><span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (; t; t &gt;&gt;= <span class="hljs-number">1</span>, x = <span class="hljs-number">1l</span>l * x * x % mod)<br><span class="hljs-keyword">if</span> (t &amp; <span class="hljs-number">1</span>) res = <span class="hljs-number">1l</span>l * res * x % mod;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">mo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (; x &lt; <span class="hljs-number">0</span>; x += mod);<br><span class="hljs-keyword">for</span> (; x &gt;= mod; x -= mod);<br><span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (n &lt; m) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1l</span>l * fac[n] * ifac[m] % mod * ifac[n - m] % mod;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>fac[<span class="hljs-number">0</span>] = ifac[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; M; ++i) fac[i] = <span class="hljs-number">1l</span>l * fac[i - <span class="hljs-number">1</span>] * i % mod;<br>ifac[M - <span class="hljs-number">1</span>] = fpow(fac[M - <span class="hljs-number">1</span>]);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = M - <span class="hljs-number">2</span>; i; --i) ifac[i] = <span class="hljs-number">1l</span>l * ifac[i + <span class="hljs-number">1</span>] * (i + <span class="hljs-number">1</span>) % mod;<br><br><span class="hljs-keyword">int</span> n = rd();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>x[i] = rd(); y[i] = rd();<br>++f[-x[i] + G][-y[i] + G];<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; A; ++i)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; A; ++j)<br>f[i][j] = mo(f[i][j] + f[i - <span class="hljs-number">1</span>][j] + f[i][j - <span class="hljs-number">1</span>]);<br><span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>ans = mo(ans + f[x[i] + G][y[i] + G] - C(<span class="hljs-number">2</span> * (x[i] + y[i]), <span class="hljs-number">2</span> * x[i]));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, <span class="hljs-number">1l</span>l * ans * inv2 % mod);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="f---wide-swap">F - Wide Swap</h2><blockquote><p>给定一个 <span class="math inline">\(\{1,2,\dots,n\}\)</span> 的排列<span class="math inline">\(\{P\}\)</span> ，每次操作：</p><p>选取两个距离至少为 <span class="math inline">\(k\)</span> 的位置<span class="math inline">\(i,j\)</span> 且 <spanclass="math inline">\(|P_i-P_j|=1\)</span> ，交换 <spanclass="math inline">\(i,j\)</span> 两个位置上的数。</p><p>你可以任意次数操作，问可能得到的最小字典序排列是什么。</p></blockquote><p>排列求个逆（即 <span class="math inline">\(Q_{P_i}=i\)</span>），<span class="math inline">\(Q_i\)</span> 的含义就是数字 <spanclass="math inline">\(i\)</span> 的位置。</p><p>问题转化为：相邻并且差值至少为 <span class="math inline">\(k\)</span>的两个 <span class="math inline">\(Q\)</span> 可以交换，<spanclass="math inline">\(Q\)</span>可能最小字典序是什么（小的数字位置靠前）。</p><div class="note note-success">            <p>如果 <span class="math inline">\(|Q_i-Q_j|&lt;k\)</span> ，那么 <spanclass="math inline">\(Q_i\)</span> 和 <spanclass="math inline">\(Q_j\)</span>在序列里的相对顺序永远都不能改变（换到相邻就不能操作了）。</p><p>反之如果两个位置差值 <span class="math inline">\(\ge k\)</span>，只要能换到相邻，就一定可以交换，如果换不到相邻，一定是上面的约束导致的。</p><p>所以如果 <span class="math inline">\(|Q_i-Q_j|\ge k\)</span> ，那么<span class="math inline">\(Q_i\)</span> 和 <spanclass="math inline">\(Q_j\)</span> 在序列里的顺序没有任何要求。</p>          </div><p>只有 " <span class="math inline">\(a\)</span> 一定要在 <spanclass="math inline">\(b\)</span> 前"这种约束的最小字典序排列显然可以用优先队列的拓扑排序求。</p><p>但是边的级别是 <span class="math inline">\(\mathcal{O}(n^2)\)</span>的： <span class="math inline">\(Q_i\)</span> 会向 <spanclass="math inline">\(\forall j&gt;i,Q_j\in[Q_i-k + 1,Q_i +k-1]\)</span> 的所有 <span class="math inline">\(Q_j\)</span> 连边。</p><p>考虑去掉一些没有意义的边：假设 <spanclass="math inline">\((x,y),(y,z),(x,z)\)</span> 都存在，那么 <spanclass="math inline">\((x,z)\)</span> 显然是没必要存的。</p><p>把区间拆成两块 <spanclass="math inline">\([Q_i-k+1,Q_i],[Q_i,Q_i+k-1]\)</span>，这两个区间内部有约束的肯定会两两连边（单向）。</p><p>因此 <span class="math inline">\(Q_i\)</span>并不需要向这里面的全部点连边，完全可以继承区间里最靠前的位置的所有边，然后让自己指向这个位置即可。</p><p>形式化的说，对于某个区间，找到 <span class="math inline">\(pos =\min_{Q_j\in [\text{interval}]} j\)</span> ，那么只需要连 <spanclass="math inline">\(Q_i\to Q_{pos}\)</span> ，其余边都间接继承 <spanclass="math inline">\(Q_{pos}\)</span> 的。</p><p>这样边的级别（也就是拓扑排序复杂度）就是 <spanclass="math inline">\(\mathcal{O}(n)\)</span> 的，找 <spanclass="math inline">\(pos\)</span> 需要单点更新查区间 <spanclass="math inline">\(\min\)</span> ，用线段树复杂度 <spanclass="math inline">\(\mathcal{O}(n\log n)\)</span> 。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">char</span> c = getchar();<br><span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);<br><span class="hljs-keyword">for</span> (; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);<br><span class="hljs-keyword">return</span> f ? -x : x;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 500007</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ls (rt &lt;&lt; 1)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rs (rt &lt;&lt; 1 | 1)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span><br><br><span class="hljs-keyword">int</span> mn[N &lt;&lt; <span class="hljs-number">2</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rt)</span> </span>&#123;<br>mn[rt] = min(mn[ls], mn[rs]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">upd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rt, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (l == r) &#123;<br>mn[rt] = v; <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (k &lt;= mid) upd(ls, l, mid, k, v);<br><span class="hljs-keyword">else</span> upd(rs, mid + <span class="hljs-number">1</span>, r, k, v);<br>pushup(rt);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">qmn</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rt, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) <span class="hljs-keyword">return</span> mn[rt];<br><span class="hljs-keyword">int</span> ans = <span class="hljs-number">1e9</span>;<br><span class="hljs-keyword">if</span> (L &lt;= mid) ans = min(ans, qmn(ls, l, mid, L, R));<br><span class="hljs-keyword">if</span> (R &gt; mid) ans = min(ans, qmn(rs, mid + <span class="hljs-number">1</span>, r, L, R));<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-keyword">int</span> p[N], q[N], deg[N];<br><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; e[N];<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><br><br><span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;, greater&lt;<span class="hljs-keyword">int</span>&gt; &gt;que;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> n = rd(), k = rd();<br><span class="hljs-built_in">memset</span>(mn, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span>(mn));<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) q[p[i] = rd()] = i;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n; i; --i) &#123;<br><span class="hljs-keyword">int</span> j = qmn(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, q[i], min(n, q[i] + k - <span class="hljs-number">1</span>));<br><span class="hljs-keyword">if</span> (j &lt;= n) &#123;e[q[i]].pb(q[j]); ++deg[q[j]];&#125;<br>j = qmn(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, max(<span class="hljs-number">1</span>, q[i] - k + <span class="hljs-number">1</span>), q[i]);<br><span class="hljs-keyword">if</span> (j &lt;= n) &#123;e[q[i]].pb(q[j]); ++deg[q[j]];&#125;<br>upd(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, q[i], i);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br><span class="hljs-keyword">if</span> (!deg[i]) que.push(i);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br><span class="hljs-keyword">int</span> u = q[i] = que.top(); que.pop();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) <br><span class="hljs-keyword">if</span> (!(--deg[v])) que.push(v);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) p[q[i]] = i;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, p[i]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
      <category>AtCoder</category>
      
      <category>AtCoder Grand Contest</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Constructive Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AtCoder Beginner Contest 244</title>
    <link href="/2022/03/29/abc224/"/>
    <url>/2022/03/29/abc224/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>A, B, C 比较简单就不写了。</p><p>我的代码 : <ahref="https://atcoder.jp/contests/abc244/submissions?f.Task=&amp;f.LanguageName=&amp;f.Status=AC&amp;f.User=SGColin">AllSubmissions - SGColin</a></p><h3 id="d.-swap-hats">D. Swap Hats</h3><blockquote><p>给定两个 <code>"RGB"</code> 这个字符串的排列 <spanclass="math inline">\(A,B\)</span> ，每次操作可以交换两个位置。</p><p>问能否正好操作 <span class="math inline">\(10^{18}\)</span> 把 <spanclass="math inline">\(A\)</span> 变成 <spanclass="math inline">\(B\)</span> 。</p></blockquote><p>假设 <code>R=1,G=2,B=3</code>，我们可以通过逆序数奇/偶把所有排列分两类。</p><p>因为只有三个位置，可以发现转换关系的连边是个完全二分图。</p><p>所以根据 <span class="math inline">\(A\)</span> 和 <spanclass="math inline">\(B\)</span> 不同的位数 <spanclass="math inline">\(cnt\)</span> 即可判定是哪种情况。</p><ul><li><span class="math inline">\(cnt=0\)</span>完全相同，一直交换某两位即可。</li><li><span class="math inline">\(cnt=2\)</span>逆序数相同，但排列不同，不可能通过偶数次交换得到。</li><li><span class="math inline">\(cnt=3\)</span>逆序数不同，因为是完全二分图，一定可以通过两次操作把 <spanclass="math inline">\(A\)</span> 变成 <spanclass="math inline">\(B\)</span> ，后面参考 <spanclass="math inline">\(cnt=0\)</span> 操作即可。</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">char</span> a[<span class="hljs-number">3</span>], b[<span class="hljs-number">3</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">char</span> <span class="hljs-title">gc</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> c = getchar();<br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isalpha</span>(c)) c = getchar();<br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i) a[i] = gc();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i) b[i] = gc();<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i) cnt += (a[i] != b[i]);<br>    <span class="hljs-built_in">puts</span>((cnt == <span class="hljs-number">0</span> || cnt == <span class="hljs-number">3</span>) ? <span class="hljs-string">&quot;Yes&quot;</span> : <span class="hljs-string">&quot;No&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="e.-king-bombee">E. King Bombee</h3><blockquote><p>定义无向图 <span class="math inline">\(G=(V,E)\)</span> 的一个长度为<span class="math inline">\(K\)</span> 的路径序列 <spanclass="math inline">\(\{A\}\)</span> ：</p><p>由 <span class="math inline">\(K+1\)</span> 个点编号 <spanclass="math inline">\(A_0,\dots,A_K\in V\)</span> 构成，<spanclass="math inline">\(A_0\)</span> 是起点，<spanclass="math inline">\(A_K\)</span> 是终点，且 <spanclass="math inline">\(\forall 0\le i &lt; K, (A_i, A_{i+1})\inE\)</span></p><p>给定无向图 <span class="math inline">\(G\ (|V|\le 2000,|E|\le2000)\)</span> 求有多少个长度为 <span class="math inline">\(K\ (K\le2000)\)</span> 的路径序列，满足：</p><p>起点为 <span class="math inline">\(S\)</span> ，终点为 <spanclass="math inline">\(T\)</span> ，且点 <spanclass="math inline">\(X\)</span> 在序列中出现偶数次（可以为 <spanclass="math inline">\(0\)</span> ) 。</p></blockquote><p>感觉最近 ABC 每场都会有一道比较暴力的 DP，就看敢不敢写（</p><p>设 <code>f[i][u][0/1]</code> 表示当前考虑长度为 <spanclass="math inline">\(i\)</span> 的路径，起点是 <spanclass="math inline">\(S\)</span> ，终点是 <spanclass="math inline">\(u\)</span> ，当前节点 <spanclass="math inline">\(X\)</span> 在其中出现偶数/奇数次的方案数。</p><p>初始状态 <code>f[0][S][S==X] = 1</code> ，答案<code>f[K][T][0]</code> 。</p><p>转移暴力做就可以了，枚举下一步走哪里（ <spanclass="math inline">\(u\to v\)</span> ）：<code>f[i+1][v][k^(v == X)] += f[i][u][k]</code> 。</p><p>这个题的核心在复杂度计算，外层枚举 <spanclass="math inline">\(i\)</span> 是 <span class="math inline">\(\mathcalO(n)\)</span> 的，内层枚举 <span class="math inline">\(u\)</span> 是<span class="math inline">\(\mathcal O(n)\)</span> 的，枚举 <spanclass="math inline">\(v\)</span> 复杂度怎么算？</p><p>把后两个的复杂度放到一起考虑，就是 <spanclass="math inline">\(\sum_{u=1}^n deg(u) = \mathcal O(m)\)</span></p><p>所以总复杂度是 <span class="math inline">\(\mathcal O(nm)\)</span>的。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">char</span> c = getchar();<br>    <span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);<br>    <span class="hljs-keyword">return</span> f ? -x : x;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 2007</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mod 998244353</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> add(a, b) (a) = ((a) + (b)) % mod</span><br><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; e[N];<br><br><span class="hljs-keyword">int</span> f[N][N][<span class="hljs-number">2</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = rd(), m = rd();<br>    <span class="hljs-keyword">int</span> k = rd(), s = rd(), t = rd(), x = rd();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>        <span class="hljs-keyword">int</span> u = rd(), v = rd();<br>        e[u].push_back(v); e[v].push_back(u);<br>    &#125;<br>    f[<span class="hljs-number">0</span>][s][x == s] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> u = <span class="hljs-number">1</span>; u &lt;= n; ++u)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt;= <span class="hljs-number">1</span>; ++k) &#123;<br>                <span class="hljs-keyword">if</span> (!f[i][u][k]) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) &#123;<br>                    <span class="hljs-keyword">int</span> tar = (k ^ (v == x));<br>                    add(f[i + <span class="hljs-number">1</span>][v][tar], f[i][u][k]);<br>                &#125;<br>            &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, f[k][t][<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="f.-shortest-good-path">F. Shortest Good Path</h3><blockquote><p>题意比较复杂，我简单描述一下。</p><p>定义无向图 <span class="math inline">\(G=(V,E)\)</span> 的一个长度为<span class="math inline">\(K+1\)</span> 的路径序列 <spanclass="math inline">\(\{A\}\)</span> ：</p><p>由 <span class="math inline">\(K+1\)</span> 个点编号 <spanclass="math inline">\(A_0,\dots,A_K\in V\)</span> 构成，<spanclass="math inline">\(A_0\)</span> 是起点，<spanclass="math inline">\(A_K\)</span> 是终点，且 <spanclass="math inline">\(\forall 0\le i &lt; K, (A_i, A_{i+1})\inE\)</span></p><p>定义路径序列 <span class="math inline">\(\{A\}\)</span> 符合要求序列<span class="math inline">\(S\ (|S| = n, S_i = 0/1)\)</span>，当且仅当：</p><p>若 <span class="math inline">\(S_u = 0\)</span> ，则 <spanclass="math inline">\(u\)</span> 在 <spanclass="math inline">\(\{A\}\)</span> 中出现了偶数次（可以为 <spanclass="math inline">\(0\)</span> ）</p><p>若 <span class="math inline">\(S_u = 1\)</span> ，则 <spanclass="math inline">\(u\)</span> 在 <spanclass="math inline">\(\{A\}\)</span> 中出现了奇数次</p><p>那么对于所有的 <span class="math inline">\(S=0,\cdots,2^n-1\)</span>，都会存在一个路径序列满足 <span class="math inline">\(S\)</span>的要求。</p><p>记满足 <span class="math inline">\(S\)</span> 要求的路径序列最短为<span class="math inline">\(f(S)\)</span> ，求 <spanclass="math inline">\(\sum_{S=0}^{2^n-1}f(S)\)</span></p></blockquote><p>看到 ABC 出 <span class="math inline">\(n\le 17\)</span>就是状压或者超级暴力了。</p><p>考虑路径之间互相更新转移，那么状态之间需要区分的，除了当前每个点出现奇数/偶数次以外，还有最后一个点的编号。</p><p>定义符合序列 <span class="math inline">\(S\)</span> 且最后一个点是<span class="math inline">\(u\)</span> 的状态集编号为<code>sta[S][u]</code> 。</p><p>那么对于每一个 <span class="math inline">\(u\to v\)</span> ，对所有的<span class="math inline">\(S\)</span> 连边<code>sta[S][u] -&gt; sta[S ^ (1 &lt;&lt; v)][v]</code></p><p>最后补上初始状态的连边<code>source -&gt; sta[1 &lt;&lt; u][u]</code></p><p>那么跑 BFS 就可以求出来每个状态所需的最小长度了（从<code>source</code> 出发的距离）</p><p>那么 <span class="math inline">\(f(S) = \min_{u}dis[sta[S][u]]\)</span> 即可，复杂度即状态数乘转移数 <spanclass="math inline">\(\mathcal O(n^2\ast 2^n)\)</span></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">char</span> c = getchar();<br>    <span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);<br>    <span class="hljs-keyword">return</span> f ? -x : x;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 17</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> M 5000007</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><br><br><span class="hljs-keyword">int</span> id[<span class="hljs-number">1</span> &lt;&lt; N][N], cnt, dis[M];<br><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; e[M];<br><br><span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = rd(), m = rd();<br>    <span class="hljs-keyword">int</span> S = (<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> s = <span class="hljs-number">0</span>; s &lt;= S; ++s) <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> u = <span class="hljs-number">0</span>; u &lt; n; ++u)<br>            id[s][u] = ++cnt;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>        <span class="hljs-keyword">int</span> u = rd() - <span class="hljs-number">1</span>, v = rd() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> s = <span class="hljs-number">0</span>; s &lt;= S; ++s) &#123;<br>            e[id[s][u]].pb(id[s ^ (<span class="hljs-number">1</span> &lt;&lt; v)][v]);<br>            e[id[s][v]].pb(id[s ^ (<span class="hljs-number">1</span> &lt;&lt; u)][u]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) e[<span class="hljs-number">0</span>].pb(id[<span class="hljs-number">1</span> &lt;&lt; i][i]);<br>  <br>    <span class="hljs-built_in">memset</span>(dis, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span>(dis));<br>    dis[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; q.push(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">while</span> (!q.empty()) &#123;<br>        <span class="hljs-keyword">int</span> u = q.front(); q.pop();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) <br>            <span class="hljs-keyword">if</span> (dis[v] &gt; dis[u] + <span class="hljs-number">1</span>) &#123;dis[v] = dis[u] + <span class="hljs-number">1</span>; q.push(v);&#125;<br>    &#125;<br>    ll ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> s = <span class="hljs-number">1</span>, tmp; s &lt;= S; ++s) &#123;<br>        tmp = <span class="hljs-number">1e9</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> u = <span class="hljs-number">0</span>; u &lt; n; ++u) &#123;<br>            tmp = min(tmp, dis[id[s][u]]);<br>        &#125;<br>        ans += tmp;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="g.-construct-good-path">G. Construct Good Path</h3><blockquote><p>定义无向图 <span class="math inline">\(G=(V,E)\)</span> 的一个长度为<span class="math inline">\(K+1\)</span> 的路径序列 <spanclass="math inline">\(\{A\}\)</span> ：</p><p>由 <span class="math inline">\(K+1\)</span> 个点编号 <spanclass="math inline">\(A_0,\dots,A_K\in V\)</span> 构成，<spanclass="math inline">\(A_0\)</span> 是起点，<spanclass="math inline">\(A_K\)</span> 是终点，且 <spanclass="math inline">\(\forall 0\le i &lt; K, (A_i, A_{i+1})\inE\)</span></p><p>定义路径序列 <span class="math inline">\(\{A\}\)</span> 符合要求序列<span class="math inline">\(S\ (|S| = n, S_i = 0/1)\)</span>，当且仅当：</p><p>若 <span class="math inline">\(S_u = 0\)</span> ，则 <spanclass="math inline">\(u\)</span> 在 <spanclass="math inline">\(\{A\}\)</span> 中出现了偶数次（可以为 <spanclass="math inline">\(0\)</span> ）</p><p>若 <span class="math inline">\(S_u = 1\)</span> ，则 <spanclass="math inline">\(u\)</span> 在 <spanclass="math inline">\(\{A\}\)</span> 中出现了奇数次</p><p>给定连通无向图 <span class="math inline">\(G\)</span> 和要求序列<span class="math inline">\(S\)</span> ，构造一个长度不超过 <spanclass="math inline">\(4\ast |V|\)</span> 的序列符合 <spanclass="math inline">\(S\)</span></p></blockquote><p>图只有连通的性质，那么可以考虑树怎么解决，其他情况找一棵生成树就可以了。</p><p>设 <span class="math inline">\(A_u\)</span> 为 <spanclass="math inline">\(u\)</span> 子树的合法序列：满足 <spanclass="math inline">\(u\)</span> 子树内，除了 <spanclass="math inline">\(u\)</span> 以外其他点都符合要求的一个序列。</p><ul><li><p>强制叶子 <span class="math inline">\(v\)</span> 对应的 <spanclass="math inline">\(A_v=(v)\)</span> 。</p></li><li><p>其他情况如果令 <spanclass="math inline">\(A_u=(u)+A_{son1}+(u)+A_{son2}+\cdots+(u)\)</span>，那么只有 <span class="math inline">\(son\)</span>这些节点会不合法。</p><p>那么对于每个导致不合法的 <span class="math inline">\(son\)</span>，给序列最后接上一个 <span class="math inline">\((son,u)\)</span>就可以保证 <span class="math inline">\(son\)</span> 合法。</p></li></ul><div class="note note-success">            <p>用数学归纳法做正确性证明：<span class="math inline">\(|A_u|\le 4 \astsize_u-3\)</span> ，其中 <span class="math inline">\(size_u\)</span> 为<span class="math inline">\(u\)</span> 子树大小。</p><ul><li><p>对于叶子，<span class="math inline">\(|A_u|=1=4\ast1-3\)</span></p></li><li><p>假设对于一个点 <span class="math inline">\(u\)</span>，所有儿子节点 <span class="math inline">\(son\)</span>都符合，那么这个点的序列：</p><p>必须添加 <span class="math inline">\(cntson + 1\)</span> 个 <spanclass="math inline">\((u)\)</span> ，还有所有的 <spanclass="math inline">\(A_{son}\)</span>，其余的每个补充会增加两个点。</p><p><span class="math display">\[\begin{array}{ll}|A_u| &amp; \le \sum_{son} A_{son} + cntson + 1 + 2 \ast cntson\\\\\       &amp; \le  \sum_{son} (4 \ast size_{son} - 3) + 3\ast cntson +1\\\\\     &amp; = 4 \ast \sum_{son} size_{son} - 3\ast cntson + 3\ast cntson+ 1\\\\\     &amp; = 4 \ast (size_u - 1) + 1\\\\\     &amp; = 4 \ast size_u - 3\end{array}\]</span></p></li></ul>          </div><p>这样就证明了，最后根的序列大小不超过 <span class="math inline">\(4N -3\)</span> 。</p><p>最后序列中如果根节点奇偶性不对，那么随便找一个根节点的儿子 <spanclass="math inline">\(son\)</span> ，补一个 <spanclass="math inline">\((son,u,son)\)</span> 即可修正。</p><p>这样子序列长度的上限刚好是 <span class="math inline">\(4N\)</span>，复杂度 <span class="math inline">\(\mathcal{O}(n)\)</span>。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">char</span> c = getchar();<br>    <span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);<br>    <span class="hljs-keyword">return</span> f ? -x : x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">gn</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> c = getchar();<br>    <span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = getchar());<br>    <span class="hljs-keyword">return</span> c - <span class="hljs-string">&#x27;0&#x27;</span>;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 100007</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><br><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; e[N], res;<br><br><span class="hljs-keyword">bool</span> vis[N], s[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    s[x] ^= <span class="hljs-number">1</span>; res.pb(x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123;<br>    vis[u] = <span class="hljs-number">1</span>; add(u);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u])<br>        <span class="hljs-keyword">if</span> (!vis[v]) &#123; <span class="hljs-comment">//当前点没在树里出现过</span><br>            dfs(v); add(u);<br>            <span class="hljs-keyword">if</span> (s[v]) &#123;add(v); add(u);&#125;<br>        &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = rd(), m = rd();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>        <span class="hljs-keyword">int</span> u = rd(), v = rd();<br>        e[u].pb(v); e[v].pb(u);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) s[i] = gn();<br>  <br>    dfs(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (s[<span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-keyword">int</span> son = e[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>        add(son); add(<span class="hljs-number">1</span>); add(son);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, (<span class="hljs-keyword">int</span>)res.size());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : res) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, x);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="ex.-linear-maximization">Ex. Linear Maximization</h3><blockquote><p>维护一个二维向量集，支持：</p><ol type="1"><li><p>插入一个二维向量 <span class="math inline">\((x,y)\)</span></p></li><li><p>查询集合中和给定向量 <span class="math inline">\((u, v)\)</span>点积的最大值</p></li></ol></blockquote><p><a href="https://www.luogu.com.cn/problem/P3309">[SDOI2014]向量集</a>弱化版，线段树维护凸包即可。</p>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
      <category>AtCoder</category>
      
      <category>AtCoder Beginner Contest</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Dynamic Programming</tag>
      
      <tag>Constructive Algorithm</tag>
      
      <tag>Bitmask</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Google Code Jam to I/O for Women 2022</title>
    <link href="/2022/03/28/codejamio2022/"/>
    <url>/2022/03/28/codejamio2022/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="a.-inversions-organize">A. Inversions Organize</h2><blockquote><p>给你一个 <span class="math inline">\(2n\times 2n\)</span> 的 01矩阵，问你最少反转多少个位置，能够做到上下两半1的个数相同，左右两半1的个数相同。</p></blockquote><p>以中点为原点，设最后四个象限的 1 的个数分别为 <spanclass="math inline">\(a,b,c,d\)</span> 。</p><p>需要满足：<span class="math inline">\(a+b=b+c=c+d=d+a\)</span>，可以推出 <span class="math inline">\(a=c,b=d\)</span> 。</p><p>因此把一三象限 1 的个数调整到相同、二四象限 1的个数调整到相同即可。</p><p>答案就是 <spanclass="math inline">\(|cnt_1-cnt_3|+|cnt_2-cnt_4|\)</span> ，复杂度<span class="math inline">\(\mathcal O(n^2)\)</span>。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">gc</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> c = getchar();<br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isalpha</span>(c)) c = getchar();<br>    <span class="hljs-keyword">return</span> c == <span class="hljs-string">&#x27;I&#x27;</span>;<br>&#125;<br><br><span class="hljs-keyword">int</span> testcase;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Case #%d: &quot;</span>, ++testcase);<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">int</span> m = n * <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; ++j) &#123;<br>            <span class="hljs-keyword">int</span> x = gc();<br>            <span class="hljs-keyword">if</span> (i &lt;= n &amp;&amp; j &lt;= n) a += x;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &lt;= n &amp;&amp; j &gt; n) b += x;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &gt; n &amp;&amp; j &lt;= n) b -= x;<br>            <span class="hljs-keyword">else</span> a -= x;<br>        &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">abs</span>(a) + <span class="hljs-built_in">abs</span>(b));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> t;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; t;<br>    <span class="hljs-keyword">for</span> (; t; t--) work();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><br></p><h2 id="b.-ingredient-optimization">B. Ingredient Optimization</h2><blockquote><p>有 <span class="math inline">\(n\)</span> 批货物，第 <spanclass="math inline">\(i\)</span> 批货物有 <spanclass="math inline">\(L_i\)</span> 个，<spanclass="math inline">\(M_i\)</span> 时刻送达，<spanclass="math inline">\(M_i+E_i\)</span> 时刻起就不能再用了。</p><p>有 <span class="math inline">\(q\)</span> 个订单，第 <spanclass="math inline">\(i\)</span> 个在 <spanclass="math inline">\(O_i\)</span> 时刻 <spanclass="math inline">\((O_{i-1}&lt;O_i)\)</span> ，需要 <spanclass="math inline">\(U\)</span> 个货物制作。</p><p>某一次做不了商店就倒闭了（后面订单都不做），问最优策略下能完成多少个订单。</p></blockquote><p>贪心即可，扫描订单，每次先把当前可用的集合用一个堆维护一下。</p><p>然后优先取用最早过保质期的商品即可，处理需要一些细节，复杂度 <spanclass="math inline">\(\mathcal{O}((n+q)\log n)\)</span>。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">char</span> c = getchar();<br>    <span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);<br>    <span class="hljs-keyword">return</span> f ? -x : x;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 107</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fr first</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> sc second</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pii pair<span class="hljs-meta-string">&lt;int, int&gt;</span></span><br><br><span class="hljs-built_in">vector</span>&lt;pii&gt; q;<br><br><span class="hljs-keyword">int</span> testcase, a[N], b[N];<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-keyword">const</span> node &amp;obj) <span class="hljs-keyword">const</span>&#123;<br>        <span class="hljs-keyword">return</span> b[id] &gt; b[obj.id];<br>    &#125;<br>&#125;;<br><br><span class="hljs-built_in">priority_queue</span>&lt;node&gt; s;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br>    q.clear();<br>    <span class="hljs-keyword">while</span> (!s.empty()) s.pop();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Case #%d: &quot;</span>, ++testcase);<br>    <span class="hljs-keyword">int</span> n = rd(), m = rd(), u = rd();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        <span class="hljs-keyword">int</span> t = rd();<br>        a[i] = rd();<br>        b[i] = t + rd();<br>        q.pb(mp(t, i));<br>        q.pb(mp(b[i], -i));<br>    &#125;<br>    sort(q.begin(), q.end());<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>, fl = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, ptr = <span class="hljs-number">0</span>; i &lt;= m; ++i) &#123;<br>        <span class="hljs-keyword">int</span> t = rd();<br>        <span class="hljs-keyword">while</span> (ptr &lt; <span class="hljs-number">2</span> * m &amp;&amp; q[ptr].fr &lt;= t) &#123;<br>            <span class="hljs-keyword">if</span> (q[ptr].sc &lt; <span class="hljs-number">0</span>) a[-q[ptr].sc] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> s.push((node)&#123;q[ptr].sc&#125;);<br>            ++ptr;<br>        &#125;<br>        <span class="hljs-keyword">int</span> tmp = u;<br>        <span class="hljs-keyword">while</span> (tmp &amp;&amp; !s.empty()) &#123;<br>            <span class="hljs-keyword">int</span> id = s.top().id;<br>            <span class="hljs-keyword">int</span> del = min(a[id], tmp);<br>            tmp -= del; a[id] -= del;<br>            <span class="hljs-keyword">if</span> (a[id] == <span class="hljs-number">0</span>) s.pop();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (tmp) fl = <span class="hljs-number">0</span>;<br>        ans += fl;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> t;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; t;<br>    <span class="hljs-keyword">for</span> (; t; t--) work();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><br></p><h2 id="c.-interesting-outing">C. Interesting Outing</h2><blockquote><p>给一棵树，有边权，求一个最短的路径，使得所有点都至少被访问到一次。</p></blockquote><p>定义 <span class="math inline">\(f_{i,0/1}\)</span> 表示 <spanclass="math inline">\(i\)</span> 的子树全部访问完，回到 / 不回到 <spanclass="math inline">\(i\)</span> 的最短路径长度，答案就是 <spanclass="math inline">\(f_{root,1}\)</span></p><p>转移方程：设 <span class="math inline">\(w_{i, son}\)</span> 表示<span class="math inline">\(i\)</span> 和儿子 <spanclass="math inline">\(son\)</span> 之间的边权。</p><p><span class="math inline">\(f_{i,0}=\sum_{son}(f_{son,0}+w_{i,son})\)</span> ， <spanclass="math inline">\(f_{i,1}=f_{i,0}-\max_{son}(f_{son,0}-f_{son,1} +w_{i,son})\)</span></p><p>复杂度 <span class="math inline">\(\mathcal{O}(n)\)</span> 。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">char</span> c = getchar();<br>    <span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);<br>    <span class="hljs-keyword">return</span> f ? -x : x;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 1007</span><br><br><span class="hljs-keyword">int</span> testcase, hd[N], tot;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span> &#123;</span><span class="hljs-keyword">int</span> to, nxt, w;&#125;e[N &lt;&lt; <span class="hljs-number">1</span>];<br><br>ll f[N][<span class="hljs-number">2</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> fa)</span> </span>&#123;<br>    ll mx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = hd[u], v; i; i = e[i].nxt)<br>        <span class="hljs-keyword">if</span> ((v = e[i].to) != fa) &#123;<br>            dfs(v, u);<br>            f[u][<span class="hljs-number">0</span>] += f[v][<span class="hljs-number">0</span>] + <span class="hljs-number">2</span> * e[i].w;<br>            mx = max(mx, f[v][<span class="hljs-number">0</span>] - f[v][<span class="hljs-number">1</span>] + e[i].w);<br>        &#125;<br>    f[u][<span class="hljs-number">1</span>] = f[u][<span class="hljs-number">0</span>] - mx;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Case #%d: &quot;</span>, ++testcase);<br>    tot = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(hd, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(hd));<br>    <span class="hljs-keyword">int</span> n = rd();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">int</span> u = rd(), v = rd(), w = rd();<br>        e[++tot].to = v; e[tot].w = w; e[tot].nxt = hd[u]; hd[u] = tot;<br>        e[++tot].to = u; e[tot].w = w; e[tot].nxt = hd[v]; hd[v] = tot;<br>    &#125;<br>    ll ans = <span class="hljs-number">1e18</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i =  <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(f));<br>        dfs(i, i);<br>        ans = min(ans, min(f[i][<span class="hljs-number">0</span>], f[i][<span class="hljs-number">1</span>]));<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> t = rd(); t; --t) work();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><br></p><h2 id="d.-inventor-outlasting">D. Inventor Outlasting</h2><blockquote><p>给定一个 <span class="math inline">\(R\times C\)</span>的地图，上面有黄色和绿色的点。</p><p>两个人博弈，每次可以选择一个黄色的点操作，不能操作的人输。</p><p>操作就是把这个点染黑，然后从个点按照 X形发散染黑。具体的，就是从这个点开始按照四个 <spanclass="math inline">\(45^\circ\)</span>方向扩展把所有点染黑，直到碰到边界，或当前要染的格子<strong>已经被染黑</strong>后，不继续往这个方向扩展。</p><p>问先手第一步有多少种不同的下法保证必胜。</p></blockquote><p>首先观察这个地图可以拆成两张，按照 <spanclass="math inline">\((\)</span> 行号+列号 <spanclass="math inline">\()\)</span> 的奇偶性可以把图分开，互不影响。</p><p>进一步的，如果把坐标系转 <spanclass="math inline">\(45^\circ\)</span>，可以发现每次操作就相当于把一个以黑色为边界的矩形横竖各切一刀。</p><p>所以其实是把当前的游戏转化成了四个子游戏的并，根据 SG引理，当前状态的 SG 值就是四个子游戏的 SG 值的异或。</p><p>本质不同的游戏数取决于当前“矩形”在原地图中的位置，所以有 <spanclass="math inline">\(O(R^2\times C^2)\)</span> 个。</p><p>每次枚举下一个操作的是哪个位置，复杂度 <spanclass="math inline">\(\mathcal{O}(R\times C)\)</span> ，所以记忆化搜索SG 函数总复杂度 <span class="math inline">\(\mathcal{O}(R^3\timesC^3)\)</span> 。</p><p>需要注意第一次的选择的时候，是把游戏划分为五种情况的并，除了四个子矩形，还有另外一张图（奇偶性不同）。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">char</span> c = getchar();<br>    <span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);<br>    <span class="hljs-keyword">return</span> f ? -x : x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">gc</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> c = getchar();<br>    <span class="hljs-keyword">for</span> (; c != <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; c != <span class="hljs-string">&#x27;X&#x27;</span>; c = getchar());<br>    <span class="hljs-keyword">return</span> c == <span class="hljs-string">&#x27;X&#x27;</span>;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 107</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><br><br><span class="hljs-keyword">bool</span> a[<span class="hljs-number">2</span>][N][N];<br><br><span class="hljs-keyword">int</span> testcase;<br><br><span class="hljs-built_in">unordered_map</span>&lt;ll, <span class="hljs-keyword">int</span>&gt; sg;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">hash_scope</span><span class="hljs-params">(ll id, ll a, ll b, ll c, ll d)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (((a * <span class="hljs-number">200</span> + b) * <span class="hljs-number">200</span> + c) * <span class="hljs-number">200</span> + d) * <span class="hljs-number">2</span> + id;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> lx, <span class="hljs-keyword">int</span> rx, <span class="hljs-keyword">int</span> ly, <span class="hljs-keyword">int</span> ry)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (lx &gt; rx || ly &gt; ry) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    ll h = hash_scope(id, lx, rx, ly, ry);<br>    <span class="hljs-keyword">if</span> (sg.find(h) != sg.end()) <span class="hljs-keyword">return</span> sg[h];<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nxt; nxt.clear();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = lx; x &lt;= rx; ++x)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = ly; y &lt;= ry; ++y)<br>            <span class="hljs-keyword">if</span> (a[id][x][y]) &#123;<br>                <span class="hljs-keyword">int</span> a = dp(id, lx, x - <span class="hljs-number">1</span>, ly, y - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">int</span> b = dp(id, lx, x - <span class="hljs-number">1</span>, y + <span class="hljs-number">1</span>, ry);<br>                <span class="hljs-keyword">int</span> c = dp(id, x + <span class="hljs-number">1</span>, rx, ly, y - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">int</span> d = dp(id, x + <span class="hljs-number">1</span>, rx, y + <span class="hljs-number">1</span>, ry);<br>                nxt.pb(a ^ b ^ c ^ d);<br>            &#125;<br>    sort(nxt.begin(), nxt.end());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, ptr = <span class="hljs-number">0</span>; ; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (ptr &gt;= nxt.size() || nxt[ptr] &gt; i) <span class="hljs-keyword">return</span> sg[h] = i;<br>        <span class="hljs-keyword">for</span> (; ptr &lt; nxt.size() &amp;&amp; nxt[ptr] == i; ++ptr);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br>    sg.clear();<br>    <span class="hljs-built_in">memset</span>(a, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(a));<br>    <span class="hljs-keyword">int</span> r = rd(), c = rd();<br>    <span class="hljs-keyword">int</span> lx = <span class="hljs-number">1e9</span>, ly = <span class="hljs-number">1e9</span>;<br>    <span class="hljs-keyword">int</span> rx = <span class="hljs-number">-1e9</span>, ry = <span class="hljs-number">-1e9</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= r; ++i)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= c; ++j) &#123;<br>            <span class="hljs-keyword">int</span> id = ((i + j) &amp; <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">int</span> x = (i + j) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">int</span> y = (i - j + <span class="hljs-number">100</span>) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> ((a[id][x][y] = gc())) &#123;<br>                lx = min(lx, x); rx = max(rx, x); <br>                ly = min(ly, y); ry = max(ry, y);<br>            &#125;<br>        &#125;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> id = <span class="hljs-number">0</span>; id &lt;= <span class="hljs-number">1</span>; ++id)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = lx; x &lt;= rx; ++x)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = ly; y &lt;= ry; ++y)<br>                <span class="hljs-keyword">if</span> (a[id][x][y]) &#123;<br>                    <span class="hljs-keyword">int</span> a = dp(id, lx, x - <span class="hljs-number">1</span>, ly, y - <span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">int</span> b = dp(id, lx, x - <span class="hljs-number">1</span>, y + <span class="hljs-number">1</span>, ry);<br>                    <span class="hljs-keyword">int</span> c = dp(id, x + <span class="hljs-number">1</span>, rx, ly, y - <span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">int</span> d = dp(id, x + <span class="hljs-number">1</span>, rx, y + <span class="hljs-number">1</span>, ry);<br>                    ans += ((a ^ b ^ c ^ d ^ dp(id ^ <span class="hljs-number">1</span>, lx, rx, ly, ry)) == <span class="hljs-number">0</span>);<br>                &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Case #%d: %d\n&quot;</span>, ++testcase, ans);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> t = rd(); t; --t) work();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Competitions</category>
      
      <category>Google&#39;s Coding Competitions</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Greedy</tag>
      
      <tag>Dynamic Programming</tag>
      
      <tag>Game Theory</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round #777 (Div. 2)</title>
    <link href="/2022/03/19/cf777/"/>
    <url>/2022/03/19/cf777/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>A 和 B 比较简单就不写了。</p><h2 id="c.-madoka-and-childish-pranks">C. Madoka and ChildishPranks</h2><blockquote><p>一个初始是全白的矩阵，每次可以选一个子矩阵染成棋盘（左上角是白色）</p><p>构造一个不超过 <span class="math inline">\(n*m\)</span>次的方法把矩阵染成目标样子，或输出无解。</p></blockquote><p><strong>Key</strong> ：每次染一个 <span class="math inline">\(1\ast2\)</span> 的，可以把右侧的变黑，<span class="math inline">\(2\ast1\)</span> 的可以把下侧的变黑。</p><p>因此对于每一行，我又可以从右往左依次染 <spanclass="math inline">\(1\ast 2\)</span>，除第一列任何位置都可以染黑。</p><p>对于第一列从下往上依次染 <span class="math inline">\(2\ast 1\)</span>，除 <span class="math inline">\((1,1)\)</span> 位置外都可以染黑。</p><p>所以只要 <span class="math inline">\((1,1)\)</span>不是黑色的就都有解。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">char</span> c = getchar();<br><span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);<br><span class="hljs-keyword">for</span> (; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);<br><span class="hljs-keyword">return</span> f ? -x : x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">gn</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">char</span> c = getchar();<br><span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = getchar());<br><span class="hljs-keyword">return</span> c - <span class="hljs-string">&#x27;0&#x27;</span>;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 107</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fr first</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> sc second</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pii pair<span class="hljs-meta-string">&lt;int, int&gt;</span></span><br><br><span class="hljs-keyword">int</span> a[N][N];<br><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;pii,pii&gt;&gt; s;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br>s.clear();<br><span class="hljs-keyword">int</span> n = rd(), m = rd();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) <br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; ++j) a[i][j] = gn();<br><span class="hljs-keyword">if</span> (a[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>); <span class="hljs-keyword">return</span>;&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = m; j &gt; <span class="hljs-number">1</span>; --j)<br><span class="hljs-keyword">if</span> (a[i][j]) s.pb(mp(mp(i,j - <span class="hljs-number">1</span>), mp(i, j)));<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n; i &gt; <span class="hljs-number">1</span>; --i) <br><span class="hljs-keyword">if</span> (a[i][<span class="hljs-number">1</span>]) s.pb(mp(mp(i - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>), mp(i, <span class="hljs-number">1</span>)));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, (<span class="hljs-keyword">int</span>)s.size());<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : s)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d %d\n&quot;</span>, x.fr.fr, x.fr.sc, x.sc.fr, x.sc.sc);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> t = rd(); t; --t) work();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="d.-madoka-and-the-best-school-in-russia">D. Madoka and the BestSchool in Russia</h2><blockquote><p>定义一个数字 <span class="math inline">\(x\)</span> 是好的，当且仅当<span class="math inline">\(x\)</span> 是 <spanclass="math inline">\(d\)</span> 的倍数。</p><p>定义一个数字 <span class="math inline">\(x\)</span>是漂亮的，当且仅当他不能被拆分成两个好的数的乘积（也就是只含有一个 <spanclass="math inline">\(d\)</span> ）</p><p>给你一个好的数 <span class="math inline">\(x\)</span>，问你是否有至少两种不同的方法，把 <spanclass="math inline">\(x\)</span> 拆成若干个漂亮的数的乘积。</p><p>方法不同即拆分得到的数集不同。</p></blockquote><p>因为每个漂亮数有且仅有一个 <span class="math inline">\(d\)</span>，因此 <span class="math inline">\(x\)</span> 里有几个 <spanclass="math inline">\(d\)</span> ，就至多要拆成几个漂亮数。</p><p>先考虑把 <span class="math inline">\(x\)</span> 里的 <spanclass="math inline">\(d\)</span> 都去掉，剩下的数是 <spanclass="math inline">\(y\)</span> ，我们至少得到一种方案是 <spanclass="math inline">\(d,d,\dots,d,d\ast y\)</span></p><ul><li><p>如果 <span class="math inline">\(y\)</span>可以拆分（不是素数），那么就肯定有解；</p></li><li><p>如果 <span class="math inline">\(y\)</span> 不可拆分：</p><ul><li>如果 <span class="math inline">\(d\)</span>不可拆分，肯定无解（没有可拆的了）</li><li>如果 <span class="math inline">\(x\)</span> 里只有两个 <spanclass="math inline">\(d\)</span> ，肯定无解（没有可拆的了）</li><li>如果 <span class="math inline">\(x\)</span> 里有超过三个 <spanclass="math inline">\(d\)</span> ，肯定有解（把 <spanclass="math inline">\(y\)</span> 和 <spanclass="math inline">\(d\)</span> 拆分得到的三个数，分配给另外三个 <spanclass="math inline">\(d\)</span> ）</li><li>如果 <span class="math inline">\(x\)</span> 里正好有三个 <spanclass="math inline">\(d\)</span> ，需要检验一下把 <spanclass="math inline">\(d\)</span> 拆出来的两部分某一部分分给 <spanclass="math inline">\(y\)</span> 会不会形成新的 <spanclass="math inline">\(d\)</span></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">char</span> c = getchar();<br><span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);<br><span class="hljs-keyword">for</span> (; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);<br><span class="hljs-keyword">return</span> f ? -x : x;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 107</span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> x = rd(), d = rd();<br><span class="hljs-keyword">if</span> (x % d != <span class="hljs-number">0</span>) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>); <span class="hljs-keyword">return</span>;&#125;<br><span class="hljs-keyword">if</span> (x / d % d != <span class="hljs-number">0</span>) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>); <span class="hljs-keyword">return</span>;&#125;<br><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (; x % d == <span class="hljs-number">0</span>; x /= d, ++cnt);<br><span class="hljs-keyword">int</span> lim = <span class="hljs-built_in">sqrt</span>(x);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= lim; ++i)<br><span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>); <span class="hljs-keyword">return</span>;&#125;<br><span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">2</span>) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>); <span class="hljs-keyword">return</span>;&#125;<br>lim = <span class="hljs-built_in">sqrt</span>(d);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= lim; ++i)<br><span class="hljs-keyword">if</span> (d % i == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (cnt &gt; <span class="hljs-number">3</span>) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>); <span class="hljs-keyword">return</span>;&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-number">1l</span>l * i * x % d != <span class="hljs-number">0</span> || <span class="hljs-number">1l</span>l * d / i * x % d != <span class="hljs-number">0</span>) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>); <span class="hljs-keyword">return</span>;&#125;<br>&#125;<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> t = rd(); t; --t) work();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="e.-madoka-and-the-sixth-graders">E. Madoka and theSixth-graders</h2><blockquote><p>题意太复杂，我简单说一下，不清楚的看原题。</p><p>给定一个共 <span class="math inline">\(n\)</span>个点的内向基环树森林，开始每个点上有一个数（是 <spanclass="math inline">\(n\)</span> 的排列）。</p><p>每一个时刻所有点按照所在边移动一次，如果某一时刻某个点上有很多数，只保留最小的。</p><p>如果某一时刻某个点上没数了（叶子），那么按照节点编号从小到大依次往里面塞<span class="math inline">\(n+1,n+2,\dots\)</span></p><p>现在给出森林的形态，和经过若干时刻后每个点上的数字 <spanclass="math inline">\(a_1,\dots,a_n\)</span> 。</p><p>请你还原出来一个字典序最小的初始状态，保证有解。</p></blockquote><p><strong>Key 1</strong> ：假设已知经过的时间是 <spanclass="math inline">\(t\)</span> ，那么每个点按照边移动 <spanclass="math inline">\(t\)</span> 步以后的位置上的数字一定是不超过 <spanclass="math inline">\(n\)</span> 的。</p><p>证明：如果是树的部分，那么 <span class="math inline">\(n\)</span>以后的数字永远追不上；如果是环的部分，因为 <spanclass="math inline">\(n\)</span> 以后的数字比 <spanclass="math inline">\(n\)</span> 大，所以都会被舍弃。</p><p><strong>Key 2</strong>：两个点如果在某一步之后同时移动到了同一个点，那么后面的路径都相同（因为每个点只有一个出边）。</p><p><strong>找出经过的时间 <spanclass="math inline">\(t\)</span></strong> ：假设叶子个数是 <spanclass="math inline">\(cnt\)</span> ，序列里最大是 <spanclass="math inline">\(mx\)</span> ，那么 <spanclass="math inline">\(t=\frac{mx - n}{cnt}\)</span> （每一次移动会引进<span class="math inline">\(cnt\)</span> 个数）。</p><hr /><p><strong>每个位置可能会放哪个数？</strong></p><p>根据前面提到的 Key，假设 <span class="math inline">\(u\)</span> 走<span class="math inline">\(t\)</span> 步之后到达的点是 <spanclass="math inline">\(v\)</span> ，那么 <spanclass="math inline">\(u\)</span> 上开始的数字要么是 <spanclass="math inline">\(a_v\)</span> ，要么比 <spanclass="math inline">\(a_v\)</span>大，在移动的过程中某一步被挤掉了。</p><p>也就是说，如果一个点集 <span class="math inline">\(S\)</span>里所有点走 <span class="math inline">\(t\)</span> 步以后到达的点都是<span class="math inline">\(v\)</span>，那么这些点初始状态里有一个必定是 <spanclass="math inline">\(a_v\)</span> ，<strong>其他都比 <spanclass="math inline">\(a_v\)</span> 大</strong>。</p><p>怎么找 <span class="math inline">\(v\)</span>：因为每个点都只有一条出边，因此可以直接倍增找</p><hr /><p><strong>怎么贪心？</strong></p><p>我们先令结果序列 <span class="math inline">\(b_u=a_v\)</span>，也就是假设每个点的初始状态就是走 <spanclass="math inline">\(t\)</span> 步以后的位置上的值。</p><p>设 <span class="math inline">\(S_x=\\{u|b_u=x\\}\)</span>，考虑从小到大放数字 <span class="math inline">\(x\)</span> ：</p><ul><li>如果 <span class="math inline">\(S_x\ne \emptyset\)</span>，那么就把 <span class="math inline">\(x\)</span> 放到 <spanclass="math inline">\(S_x\)</span> 中位置最靠前的</li><li>如果 <span class="math inline">\(S_x=\emptyset\)</span> ，那么就把<span class="math inline">\(x\)</span> 放到 <spanclass="math inline">\(S_1\cup S_2\cup\dots\cup S_{x-1}\)</span>中未使用的最靠前的位置里。</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">char</span> c = getchar();<br>    <span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);<br>    <span class="hljs-keyword">return</span> f ? -x : x;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 100007</span><br><br><span class="hljs-keyword">int</span> f[N][<span class="hljs-number">40</span>], a[N], res[N];<br><br><span class="hljs-keyword">bool</span> vis[N];<br><br><span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; s[N];<br><br><span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt; S;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-keyword">int</span> n = rd();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        f[i][<span class="hljs-number">0</span>] = rd(); vis[f[i][<span class="hljs-number">0</span>]] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">40</span>; ++j)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>            f[i][j] = f[f[i][j - <span class="hljs-number">1</span>]][j - <span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">int</span> mx = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (!vis[i]) ++cnt;<br>        a[i] = rd(); mx = max(mx, a[i]);<br>    &#125;<br>    cnt = (mx - n) / cnt;<br>  <br>    <span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(vis));<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        <span class="hljs-keyword">int</span> u = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">30</span>; k &gt;= <span class="hljs-number">0</span>; --k) <br>            <span class="hljs-keyword">if</span> (cnt &amp; (<span class="hljs-number">1</span> &lt;&lt; k)) u = f[u][k];<br>        res[i] = a[u]; s[res[i]].push(i);<br>        vis[res[i]] = <span class="hljs-number">1</span>; <span class="hljs-comment">//Sx不空</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>        <span class="hljs-keyword">if</span> (vis[i]) s[i].pop(); <span class="hljs-comment">//把i放到Si最靠前的位置</span><br><br>    <span class="hljs-keyword">int</span> nw = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) <br>        <span class="hljs-keyword">if</span> (!vis[i]) &#123;<br>            <span class="hljs-keyword">while</span> (nw &lt;= i) &#123;<br>                <span class="hljs-keyword">while</span> (s[nw].size()) &#123;<br>                    S.insert(s[nw].front());<br>                    s[nw].pop();<br>                &#125;<br>                ++nw;<br>            &#125;<br>            res[*S.begin()] = i; S.erase(S.begin());<br>        &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, res[i]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> t = <span class="hljs-number">1</span>; t; --t) work();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="f.-madoka-and-laziness">F. Madoka and Laziness</h2><blockquote><p>给定一个<strong>没有重复数值的</strong>数列 <spanclass="math inline">\(\{a_i\}\)</span>，问有多少种方式将数列划分为两个峰序列（严格单增再单减）。</p><p>两种划分不同，当且仅当至少某一个峰序列的峰值不同（认为<code>&lt;a,b&gt;</code> 和 <code>&lt;b,a&gt;</code> 相同）。</p></blockquote><p><strong>Key</strong> ：最大值一定是其中一个峰的峰值。</p><p>这个观察有什么用呢？因为一个峰值固定，我们可以得到答案是<strong>O(n)</strong> 的。</p><p>也就是说，我们只需要去检验，其他的每一个值是否有可能成为峰值即可。</p><p>怎么检验呢？只需要判断是否存在一种拆分方式，使得到每个位置之前是升的，过了这个位置之后是降的，并且没给这个序列的元素扔给最大值所在的序列都合法。</p><hr /><p>我们可以假设另一个峰值（峰值B）在最大值（峰值A）的右侧，然后把序列翻过来再做一遍即可。</p><p>这样就有三个阶段：</p><ul><li><strong>到峰值A前：两个序列都上升</strong></li></ul><p>这一阶段序列A里只要单调递增，放多大的都可以。</p><p>我们为了后面序列B还要增的考虑，应该尽量减少序列B在这一部分的最大值。</p><p>设 <span class="math inline">\(f_i\)</span> 为考虑前缀 <spanclass="math inline">\(i\)</span> ，则 <spanclass="math inline">\(a_i\)</span>必定为某一个序列结尾，则另一个序列结尾最小值是多少。</p><p>转移很简单，接在 <span class="math inline">\(a_{i-1}\)</span>后，或接在 <span class="math inline">\(f_{i-1}\)</span> 后。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (a[i] &gt; a[i - <span class="hljs-number">1</span>]) f[i] = min(f[i], f[i - <span class="hljs-number">1</span>]);<br><span class="hljs-keyword">if</span> (a[i] &gt; f[i - <span class="hljs-number">1</span>]) f[i] = min(f[i], a[i - <span class="hljs-number">1</span>]);<br></code></pre></div></td></tr></table></figure><ul><li><strong>峰值A后，峰值B前：序列A下降，序列B上升</strong></li></ul><p>这一阶段因为两个序列单调性不同，所以贪心策略也不同。</p><p>设 <span class="math inline">\(g_{i,0}\)</span> 表示第 <spanclass="math inline">\(i\)</span>个元素放到序列A里，另一个序列（正在上升的序列B）末尾最小是多少。</p><p>设 <span class="math inline">\(g_{i,1}\)</span> 表示第 <spanclass="math inline">\(i\)</span>个元素放到序列B里，另一个序列（正在下降的序列A）末尾最大是多少。</p><p>转移也很简单，讨论一下接在谁后面就好了。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (a[i] &lt; a[i - <span class="hljs-number">1</span>]) g[i][<span class="hljs-number">0</span>] = min(g[i][<span class="hljs-number">0</span>], g[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">if</span> (a[i] &lt; g[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) g[i][<span class="hljs-number">0</span>] = min(g[i][<span class="hljs-number">0</span>], a[i - <span class="hljs-number">1</span>]);<br><span class="hljs-keyword">if</span> (a[i] &gt; a[i - <span class="hljs-number">1</span>]) g[i][<span class="hljs-number">1</span>] = max(g[i][<span class="hljs-number">1</span>], g[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br><span class="hljs-keyword">if</span> (a[i] &gt; g[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]) g[i][<span class="hljs-number">1</span>] = max(g[i][<span class="hljs-number">1</span>], a[i - <span class="hljs-number">1</span>]);<br></code></pre></div></td></tr></table></figure><ul><li><strong>峰值B后：两个序列都下降</strong></li></ul><p>倒着考虑，变成单增的，那么在保证峰值B跟着的序列合法的前提下，另一个序列（留给峰值A的）的最大值要尽可能小。</p><p>因此处理方法同第一个阶段（设为 <span class="math inline">\(h\)</span>数组）。</p><hr /><p>那么怎么判断是否合法嘞？把 <span class="math inline">\(a_i\)</span>放到序列B里，另一个序列合法（ 也就是满足 <code>g[i][1] &gt; h[i]</code>） 就可以啦～</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">char</span> c = getchar();<br>    <span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);<br>    <span class="hljs-keyword">return</span> f ? -x : x;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 500007</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inf 1e9 + 7</span><br><br><span class="hljs-keyword">int</span> n, a[N], f[N], g[N][<span class="hljs-number">2</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calc</span><span class="hljs-params">()</span> </span>&#123;<br>  <br>    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>; <span class="hljs-comment">//maxpos</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        f[i] = g[i][<span class="hljs-number">0</span>] = inf;<br>        g[i][<span class="hljs-number">1</span>] = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">if</span> (a[i] &gt; a[p]) p = i;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= p; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (a[i] &gt; a[i - <span class="hljs-number">1</span>]) f[i] = min(f[i], f[i - <span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">if</span> (a[i] &gt; f[i - <span class="hljs-number">1</span>]) f[i] = min(f[i], a[i - <span class="hljs-number">1</span>]);<br>    &#125;<br>  <br>    g[p][<span class="hljs-number">0</span>] = f[p]; <span class="hljs-comment">//承接第一阶段的最宽松约束</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = p + <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (a[i] &lt; a[i - <span class="hljs-number">1</span>]) g[i][<span class="hljs-number">0</span>] = min(g[i][<span class="hljs-number">0</span>], g[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">if</span> (a[i] &lt; g[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) g[i][<span class="hljs-number">0</span>] = min(g[i][<span class="hljs-number">0</span>], a[i - <span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">if</span> (a[i] &gt; a[i - <span class="hljs-number">1</span>]) g[i][<span class="hljs-number">1</span>] = max(g[i][<span class="hljs-number">1</span>], g[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">if</span> (a[i] &gt; g[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]) g[i][<span class="hljs-number">1</span>] = max(g[i][<span class="hljs-number">1</span>], a[i - <span class="hljs-number">1</span>]);<br>    &#125;<br>  <br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n; i &gt; p; --i) &#123;<br>        <span class="hljs-keyword">if</span> (a[i] &gt; a[i + <span class="hljs-number">1</span>]) f[i] = min(f[i], f[i + <span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">if</span> (a[i] &gt; f[i + <span class="hljs-number">1</span>]) f[i] = min(f[i], a[i + <span class="hljs-number">1</span>]);   <br>        <span class="hljs-keyword">if</span> (g[i][<span class="hljs-number">1</span>] &gt; f[i]) ++ans;<br>    &#125;<br>  <br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    n = rd();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) a[i] = rd();<br>    <span class="hljs-keyword">int</span> ans = calc();<br>    reverse(a + <span class="hljs-number">1</span>, a + <span class="hljs-number">1</span> + n);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans + calc());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
      <category>Codeforces</category>
      
      <category>Codeforces Round</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Dynamic Programming</tag>
      
      <tag>Constructive Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PAT  Autumn 2021</title>
    <link href="/2021/09/11/pat2021/"/>
    <url>/2021/09/11/pat2021/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="background">Background</h2><p>某天心血来潮拉上 Eva 同学一起报名了 PAT ～</p><p>开学前在 <ahref="https://pintia.cn/problem-sets/994805148990160896/problems/type/7">官方题库</a>里刷了两道题热身！<del>其实是想刷完但是太鸽了</del></p><p>然后就到考试时间啦！<del>借着考试翘掉了半天的军训！好耶！</del></p><h2 id="solution-top-level">Solution ( Top Level )</h2><p>代码写的赶时间，比较丑。</p><h3 id="a.-sorted-cartesian-tree">A. Sorted Cartesian tree</h3><div class="note note-warning">            <p>给定 <span class="math inline">\(n\)</span> 个<code>pair&lt;priority, key&gt;</code> ，构建一棵 <spanclass="math inline">\(n\)</span> 个节点的二叉树，满足：</p><ul><li><p>节点 <code>priority</code> 关键字满足堆的性质，即<code>priority</code> 父节点小于子节点</p></li><li><p>节点 <code>key</code> 关键字满足二叉搜索树的性质，即中序遍历<code>key</code> 单调不降</p></li></ul><p>把树建出来，输出 <code>priority</code> 和 <code>key</code> 的<code>Level-order traversal</code> 序列</p>          </div><p>模拟题意 <code>dfs</code> 建树，传一个 <code>set&lt;node&gt;</code>即可。</p><p>求层序遍历一个 <code>bfs</code> 就够了<del>考场上写了个dfn+dep双关键字排序</del></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 37</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">char</span> c = getchar();<br>    <span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);<br>    <span class="hljs-keyword">return</span> f ? -x : x;<br>&#125; <br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><span class="hljs-keyword">int</span> k, p, id;&#125; c[N];<br><br><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-keyword">const</span> node &amp;a, <span class="hljs-keyword">const</span> node &amp;b) &#123;<br>    <span class="hljs-keyword">if</span> (a.p != b.p) <span class="hljs-keyword">return</span> a.p &lt; b.p;<br>    <span class="hljs-keyword">if</span> (a.k != b.k) <span class="hljs-keyword">return</span> a.k &lt; b.k;<br>    <span class="hljs-keyword">return</span> a.id &lt; b.id;<br>&#125;<br><br><span class="hljs-keyword">int</span> ls[N], rs[N], k[N], p[N];<br><br><span class="hljs-built_in">set</span>&lt;node&gt; S;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-built_in">set</span>&lt;node&gt; s)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (s.empty()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    node nw = *s.begin();<br>    s.erase(nw);<br>    <span class="hljs-built_in">set</span>&lt;node&gt; l, r;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> t : s) &#123;<br>        <span class="hljs-keyword">if</span> (t.k &lt;= nw.k) l.insert(t);<br>        <span class="hljs-keyword">else</span> r.insert(t);<br>    &#125;<br>    ls[nw.id] = dfs(l);<br>    rs[nw.id] = dfs(r);<br>    <span class="hljs-keyword">return</span> nw.id;<br>&#125;<br><br><span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = rd();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        c[i].id = i; c[i].k = rd(); c[i].p = rd();<br>        S.insert(c[i]);<br>    &#125;<br>    <span class="hljs-keyword">int</span> ptr = <span class="hljs-number">0</span>, rt = dfs(S);<br>    q.push(rt);<br>    <span class="hljs-keyword">while</span> (!q.empty()) &#123;<br>        <span class="hljs-keyword">int</span> u = q.front(); q.pop();<br>        <span class="hljs-keyword">if</span> (ls[u]) q.push(ls[u]);<br>        <span class="hljs-keyword">if</span> (rs[u]) q.push(rs[u]);<br>        k[++ptr] = c[u].k;<br>        p[ptr] = c[u].p;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, k[i]); <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, k[n]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, p[i]); <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, p[n]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="b.-unity-is-strength">B. Unity is Strength</h3><div class="note note-warning">            <p>给一张有权无向图，以及若干条可以花 <spanclass="math inline">\(w_i\)</span> 连接 <spanclass="math inline">\(u_i,v_i\)</span> 的无向边。</p><p>先输出每个联通块的 "块内最小编号 - 块内最小边权"，按照块大小-最小边权-最小点编号的顺序排序</p><p>然后计算把整个图联通的最小代价，除给定边外，任意两点之间都可以花<span class="math inline">\(10^4\)</span> 的代价连接一条边。</p>          </div><p>并查集模拟题意即可，第一步求出来每个集合的若干信息，然后排序一下。</p><p>之后就是最小生成树，考虑给定边不一定能让整个图联通，最后答案加上（联通块数<span class="math inline">\(-1\)</span> ）<spanclass="math inline">\(\times 10^4\)</span> 即可。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 100007</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inf 1e9</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">char</span> c = getchar();<br><span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);<br><span class="hljs-keyword">for</span> (; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);<br><span class="hljs-keyword">return</span> f ? -x : x;<br>&#125; <br><br><span class="hljs-keyword">int</span> f[N], mn[N], mnid[N], sz[N], totr, totc;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">road</span> &#123;</span><br><span class="hljs-keyword">int</span> u, v, w;<br>&#125;r[N]; <br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">cmp2</span><span class="hljs-params">(road a, road b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> a.w &lt; b.w;<br>&#125; <br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">return</span> x == f[x] ? x : f[x] = find(f[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> w)</span> </span>&#123;<br>a = find(a); b = find(b);<br><span class="hljs-keyword">if</span> (a == b) &#123;<br>mn[a] = min(mn[a], w);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>f[a] = b; sz[b] += sz[a];<br>mnid[b] = min(mnid[b], mnid[a]);<br>mn[b] = min(mn[b], min(mn[a], w));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br><span class="hljs-keyword">int</span> mnid, sz, str;<br>&#125;c[N]; <br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">cmp1</span><span class="hljs-params">(node a, node b)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (a.str != b.str) <span class="hljs-keyword">return</span> a.str &gt; b.str;<br><span class="hljs-keyword">if</span> (a.sz != b.sz) <span class="hljs-keyword">return</span> a.sz &gt; b.sz;<br><span class="hljs-keyword">return</span> a.mnid &lt; b.mnid;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> n = rd();<br><span class="hljs-keyword">int</span> m = rd();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>f[i] = i; mn[i] = inf; mnid[i] = i; sz[i] = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, u, v, w; i &lt;= m; ++i) &#123;<br>u = rd(); v = rd(); w = rd();<br><span class="hljs-keyword">if</span> (w &gt; <span class="hljs-number">0</span>) merge(u, v, w);<br><span class="hljs-keyword">else</span> r[++totr] = (road)&#123;u, v, -w&#125;; <br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br><span class="hljs-keyword">if</span> (f[i] == i) c[++totc] = (node)&#123;mnid[i], sz[i], (mn[i] == inf ? <span class="hljs-number">0</span> : mn[i])&#125;;<br>sort(c + <span class="hljs-number">1</span>, c + <span class="hljs-number">1</span> + totc, cmp1);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; totc; ++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d-%d &quot;</span>, c[i].mnid, c[i].str);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d-%d\n&quot;</span>, c[totc].mnid, c[totc].str);<br><span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>sort(r + <span class="hljs-number">1</span>, r + <span class="hljs-number">1</span> + totr, cmp2);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= totr; ++i) &#123;<br><span class="hljs-keyword">int</span> u = find(r[i].u);<br><span class="hljs-keyword">int</span> v = find(r[i].v);<br><span class="hljs-keyword">if</span> (u != v) &#123;merge(u, v, r[i].w); ans += r[i].w;&#125; <br>&#125;<br><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) <br>cnt += (f[i] == i);<br>ans += (cnt - <span class="hljs-number">1</span>) * <span class="hljs-number">10000</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="c.-manhattan">C. Manhattan</h3><div class="note note-warning">            <p>给定一个序列 <span class="math inline">\(\{ a_i \}\ (1\le a_i\le3)\)</span>，两个人玩（开始双方均为 <spanclass="math inline">\(0\)</span> 分），每次某个人取走最靠前的 <spanclass="math inline">\(a_i\)</span> 加到当前的得分里。</p><p>要求每个人拿完之后，<strong>当前的得分不得少于对方</strong>，问有多少种划分方案，答案<span class="math inline">\(\mod 10^ 9 + 7\)</span></p>          </div><p>裸的 DP 就是 <code>f[i][j]</code> 表示当前考虑前 <spanclass="math inline">\(i\)</span> 个数，第一个人比第二个人多 <spanclass="math inline">\(j\)</span> 的方案数。</p><p>因为 <span class="math inline">\(a_i\le 3\)</span>，所以如果某个人比另一个人多了超过 <spanclass="math inline">\(3\)</span>分，对手就无法满足要求，之后就只能是这个人拿了。</p><p>所以 <code>j</code> 可以把特殊的状态放到一起，范围就只有 <spanclass="math inline">\(9\)</span> 了，复杂度 <spanclass="math inline">\(O (9n)\)</span> ，转移要注意条件。</p><p>实现的时候整体偏移了 <span class="math inline">\(5\)</span> ，也就是<span class="math inline">\(j=5\)</span> 时两个人得分一样。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 100007</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mod 1000000007</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">char</span> c = getchar();<br><span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);<br><span class="hljs-keyword">for</span> (; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);<br><span class="hljs-keyword">return</span> f ? -x : x;<br>&#125; <br><br><span class="hljs-keyword">int</span> f[N][<span class="hljs-number">10</span>];<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> add(a,b) a = (a + b) % mod</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>f[<span class="hljs-number">0</span>][<span class="hljs-number">5</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> n = rd();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, x; i &lt;= n; ++i) &#123;<br>x = rd();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">9</span>; ++j) &#123;<br><span class="hljs-keyword">if</span> (j - x &lt;= <span class="hljs-number">1</span>) add(f[i][<span class="hljs-number">1</span>], f[i - <span class="hljs-number">1</span>][j]);<br><span class="hljs-keyword">if</span> (j + x &gt;= <span class="hljs-number">9</span>) add(f[i][<span class="hljs-number">9</span>], f[i - <span class="hljs-number">1</span>][j]);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span>; j &lt;= <span class="hljs-number">8</span>; ++j) &#123;<br><span class="hljs-keyword">if</span> (j - x &gt; <span class="hljs-number">1</span> &amp;&amp; j - x &lt;= <span class="hljs-number">5</span>) add(f[i][j - x], f[i - <span class="hljs-number">1</span>][j]);<br><span class="hljs-keyword">if</span> (j + x &lt; <span class="hljs-number">9</span> &amp;&amp; j + x &gt;= <span class="hljs-number">5</span>) add(f[i][j + x], f[i - <span class="hljs-number">1</span>][j]);<br>&#125;<br>&#125;<br><span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">9</span>; ++i) add(ans, f[n][i]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="summary">Summary</h2><p>比赛之前比较焦虑（毕竟军训一周都没碰键盘），到考场发现左边坐的是学长。</p><p>开场把三个题都开了，题目描述都十分迷惑（英语太差），结合样例枚举题意读题。</p><blockquote><p>分不清：Preorder 先序；Inorder 中序；Postorder 后序；Level-ordertraversal 层序遍历</p></blockquote><p>过题顺序 T2 - T1 - T3 ，看榜应该是 Rank2，所有题都是一次过非常舒适。</p><p>然后就提前跑路了！因为 Eva同学还在奋战，我就开始快乐的浙传半日游～</p><p>浙传的校园就比较有感觉，总觉得杭电的楼都是一个样子的，缺点大学的气息...</p><p><img src="/img/cuz/cuz1.JPG" /></p><p><img src="/img/cuz/cuz2.JPG" /></p><p><img src="/img/cuz/cuz3.JPG" /></p><figure><img src="/img/cuz/cuz4.JPG" alt="井盖上超级可爱的小王子和狐狸～" /><figcaptionaria-hidden="true">井盖上超级可爱的小王子和狐狸～</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>Competitions</category>
      
      <category>Programming Ability Test</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Union-Find Set</tag>
      
      <tag>Counting</tag>
      
      <tag>DFS and Similar</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AtCoder Beginner Contest 216</title>
    <link href="/2021/08/29/abc216/"/>
    <url>/2021/08/29/abc216/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="e.-amusement-park">E. Amusement Park</h2><div class="note note-warning">            <p>给定 <span class="math inline">\(n\)</span> 个数，最多 <spanclass="math inline">\(k\)</span> 次操作，每次可以拿走某个数 <spanclass="math inline">\(a_i\)</span> 加入得分，然后把 <spanclass="math inline">\(a_i-1\)</span> 放回，问得分最大值，<spanclass="math inline">\(k,a_i\le 2\times 10^9\)</span></p>          </div><p>二分最后剩下的所有数里的最大值为 <spanclass="math inline">\(x\)</span> ，答案是把所有数都拿到 <spanclass="math inline">\(x\)</span> 的得分，然后加上剩下次数个 <spanclass="math inline">\(x\)</span> 的得分。</p><p>需要注意二分上界 <span class="math inline">\(r = 2\times10^9\)</span> ，所以二分 <code>mid = (l + r) / 2</code> 的时候可能会爆<code>int</code> 。<del>坑死我了</del></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 200007</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;<br>    ll x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">char</span> c = getchar();<br>    <span class="hljs-keyword">for</span>(; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);<br>    <span class="hljs-keyword">for</span>(; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);<br>    <span class="hljs-keyword">return</span> f ? -x : x;<br>&#125;<br><br>ll n, k, a[N];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">valid</span><span class="hljs-params">(ll x)</span> </span>&#123;<br>    ll cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) <br>        <span class="hljs-keyword">if</span> (a[i] &gt; x) cnt += a[i] - x;<br>    <span class="hljs-keyword">return</span> cnt &lt;= k;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">sum</span><span class="hljs-params">(ll l, ll r)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (l + r)  * (r - l + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    n = rd(); k = rd();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) a[i] = rd();<br>    ll l = <span class="hljs-number">0</span>, r = <span class="hljs-number">2e9</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        ll mid = (l + r) / <span class="hljs-number">2</span>;<br>        valid(mid) ? r = mid : l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    ll ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) <br>        <span class="hljs-keyword">if</span> (a[i] &gt; l) &#123;<br>            ans += sum(l + <span class="hljs-number">1</span>, a[i]);<br>            k -= a[i] - l;<br>        &#125;<br>    ans += k * l;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="f.-max-sum-counting">F. Max Sum Counting</h2><div class="note note-warning">            <p>有 <span class="math inline">\(n\)</span> 个数对 <spanclass="math inline">\((A_i, B_i)\)</span>构成一个集合，问有多少个子集，满足子集内 <spanclass="math inline">\(A\)</span> 的最大值大于 <spanclass="math inline">\(B\)</span> 的和。</p>          </div><p>考虑枚举最大的 <span class="math inline">\(A\)</span>是谁，将所有数对按照 <span class="math inline">\(A\)</span>从小到大排序，问题转化为选哪些 <span class="math inline">\(B\)</span>。</p><p>假设现在考虑排序后第 <span class="math inline">\(i\)</span>个数对，则 <span class="math inline">\(B_i\)</span> 必选，相当于计数<span class="math inline">\(B_1,\cdots,B_{i-1}\)</span>中选出若干，且总和不超过 <span class="math inline">\(A_i-B_i\)</span>的方案数。</p><p>因为 <span class="math inline">\(A\)</span> 的值域很小，搞一个 01背包计数即可，复杂度 <span class="math inline">\(O(n\times \maxA_i)\)</span> 。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 5007</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mod 998244353</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><br><span class="hljs-keyword">int</span> n, f[N] = &#123;<span class="hljs-number">1</span>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><span class="hljs-keyword">int</span> a, b;&#125; c[N];<br><br><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-keyword">const</span> node &amp;a, <span class="hljs-keyword">const</span> node &amp;b) &#123;<br>    <span class="hljs-keyword">return</span> a.a == b.a ? a.b &lt; b.b : a.a &lt; b.a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;c[i].a);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;c[i].b);<br>    sort(c + <span class="hljs-number">1</span>, c + <span class="hljs-number">1</span> + n);<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>; v &lt;= c[i].a - c[i].b; ++v) <br>            ans = (ans + f[v]) % mod;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = N - <span class="hljs-number">1</span>; v &gt;= c[i].b; --v) <br>            f[v] = (f[v] + f[v - c[i].b]) % mod;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="g.-01sequence">G. 01Sequence</h2><div class="note note-warning">            <p>构造长度为 <span class="math inline">\(n\)</span> 的 <spanclass="math inline">\(01\)</span> 序列，满足 <spanclass="math inline">\(k\)</span> 个形如 “ <spanclass="math inline">\([l_i,r_i]\)</span> 内至少有 <spanclass="math inline">\(x_i\)</span> 个 <spanclass="math inline">\(1\)</span> ” 的条件，且 <spanclass="math inline">\(1\)</span> 的个数最少。</p>          </div><p>将约束条件按照右端点从小到大排序，考虑每个条件当前还未满足的个数。</p><p>则对于每个 <span class="math inline">\(1\)</span>，在可行的范围内往右放的贡献不低于往左放，因此从右边界依次放过来即可。</p><p>查询未满足的个数需要维护一个树状数组，复杂度 <spanclass="math inline">\(O(n\log n)\)</span> 。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 200007</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;<br>    ll x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">char</span> c = getchar();<br>    <span class="hljs-keyword">for</span>(; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);<br>    <span class="hljs-keyword">for</span>(; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);<br>    <span class="hljs-keyword">return</span> f ? -x : x;<br>&#125;<br><br><span class="hljs-keyword">int</span> cur[N], vis[N];<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> lowbit(x) (x &amp; -x)</span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (; x &lt; N; x += lowbit(x)) ++cur[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (; x; x -= lowbit(x)) res += cur[x];<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><span class="hljs-keyword">int</span> l, r, k;&#125; c[N];<br><br><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-keyword">const</span> node &amp;a, <span class="hljs-keyword">const</span> node &amp;b) &#123;<span class="hljs-keyword">return</span> a.r &lt; b.r;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = rd();<br>    <span class="hljs-keyword">int</span> m = rd();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>        c[i].l = rd(); c[i].r = rd(); c[i].k = rd();<br>    &#125;<br>    sort(c + <span class="hljs-number">1</span>, c + <span class="hljs-number">1</span> + m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>        <span class="hljs-keyword">int</span> nw = calc(c[i].r) - calc(c[i].l - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ptr = c[i].r; nw &lt; c[i].k; --ptr) <br>            <span class="hljs-keyword">if</span> (!vis[ptr]) &#123;<br>                add(ptr); ++nw; vis[ptr] = <span class="hljs-number">1</span>;<br>            &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, vis[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="h.-random-robots">H. Random Robots</h2><div class="note note-warning">                      </div>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
      <category>AtCoder</category>
      
      <category>AtCoder Beginner Contest</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knapsack Problem</tag>
      
      <tag>Greedy</tag>
      
      <tag>Binary Search</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AtCoder Beginner Contest 214</title>
    <link href="/2021/08/14/abc214/"/>
    <url>/2021/08/14/abc214/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="d.-sum-of-maximum-weights">D. Sum of Maximum Weights</h2><div class="note note-warning">            <p>给定一棵树，边有边权。计算所有点对路径上最大边权的权值和，范围 <spanclass="math inline">\(n\le 10^5\)</span></p>          </div><p>考虑类似 Kruskal的过程添加树边，则每一条边加入时，对于连通的两个集合间的点对，最大边即为当前边。</p><p>因此在维护并查集的同时维护集合大小即可，贡献为 w <spanclass="math inline">\(\times\)</span> Size(u) <spanclass="math inline">\(\times\)</span> Size(v) ，复杂度 <spanclass="math inline">\(O(n\log n)\)</span></p><h2 id="e.-packing-under-range-regulations">E. Packing Under RangeRegulations</h2><blockquote><p>有 <span class="math inline">\(10^9\)</span>个盒子，每个盒子只能放一个球。有 <span class="math inline">\(n\)</span>个球，第 <span class="math inline">\(i\)</span> 个要放在 <spanclass="math inline">\([l_i,r_i]\)</span>的某一个盒子中，问是否有解，范围 <span class="math inline">\(n\le2\times 10^5\)</span></p></blockquote><p>比较经典的贪心，考虑从左往右放，最紧急的需求肯定是右端点最小的。</p><p>按照右端点排序，依次考虑每个需求，尽量往左放，相当于区间查询最靠左的未覆盖位置，然后修改这个位置的覆盖状态。</p><p>实现可以选择动态开点线段树+线段树上区间内二分，我是用的是<strong>并查集维护下一个未覆盖的位置（疯狂的馒头）。</strong></p><p>因为序列有 <span class="math inline">\(10^9\)</span> 长，使用<code>unordered_map</code> 维护并查集数组，具体实现见代码，复杂度 <spanclass="math inline">\(O(n\log n)\)</span> 。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><span class="hljs-keyword">int</span> l, r;&#125; c[N];<br><br><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-keyword">const</span> node &amp;a, <span class="hljs-keyword">const</span> node &amp;b) &#123;<br>    <span class="hljs-keyword">return</span> a.r == b.r ? a.l &lt; b.l : a.r &lt; b.r;<br>&#125;<br><br><span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; nxt;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> nxt[x] ? nxt[x] = find(nxt[x]) : x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = rd();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;c[i].l = rd(); c[i].r = rd();&#125;<br>    sort(c + <span class="hljs-number">1</span>, c + <span class="hljs-number">1</span> + n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, pos; i &lt;= n; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (!nxt[c[i].l]) &#123;<br>            nxt[c[i].l] = c[i].l + <span class="hljs-number">1</span>; <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        pos = find(c[i].l);<br>        <span class="hljs-keyword">if</span> (pos &gt; c[i].r) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>); <span class="hljs-keyword">return</span>;&#125;<br>        nxt[pos] = pos + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
      <category>AtCoder</category>
      
      <category>AtCoder Beginner Contest</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Union-Find Set</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Freshman Year</title>
    <link href="/2021/07/08/freshman/"/>
    <url>/2021/07/08/freshman/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天是 2021 年 7 月 8 日，星期四。</p><p>一年前的今天，高考最后一门刚刚考完。走出考场，回到自己的教室，拿手机，搬行李，告别。</p><p>离开学校的时候，碰到了还在梳理交通的竞赛教练，问我考的怎么样，然后约了后天要给高一的学弟们上课。</p><p>直到昨晚，暑假回本部给又一届的学弟们上完最后一天课。从二中本部的校门里走出来，回头看看。</p><h2 id="来杭电之前">来杭电之前</h2><p>高考完就跟爸爸妈妈说我<strong>不复读</strong>，当晚就对答案，大概645。报了南科大综评，拿到了还算不错的校考分。</p><p>然后在南校区给高一的同学讲了比较入门的概率，也是那些在一年前的暑假认识的，刚踏入二中大门学弟。</p><p>结束的时候在空空的学校里溜达，想想他们上课时候那种纯粹的热情，一代又一代，多少有一点感慨。</p><p>走之前拍了张照片，想起来一句自认为很应景的话：“<strong>雨过天青云破处，者般颜色做将来</strong>”</p><figure><img src="/img/EZS.png"alt="连着下了两三天的小雨，只剩下竞赛生的二中" /><figcaptionaria-hidden="true">连着下了两三天的小雨，只剩下竞赛生的二中</figcaption></figure><p>出分的晚上比较坦然，提前几分钟查到了分数，比估计的低 9分，都扣在语文上，115 / 134 / 136 / 251。</p><p>之后的几天比较迷茫，听了几个学校的招生宣讲都不尽如人意。南科大那边几度有希望，后来终究是落空。</p><hr /><p>在我想起来杭电这所学校的时候，突然感觉就是要去这里了。</p><p>可能是高二去学军培训喜欢上了杭州这个城市，也可能是对竞赛生涯结束的不甘吧。</p><p>先自己偷偷找 Claris要到了教练的联系方式，问了读研和专业的事情，刘老师的热情的杭州话让人很舒服。</p><p>然后就是小心翼翼地和父母交流，说我自己的想法和考虑，直到最后心里十分踏实地填上了第一志愿。</p><p>录取的结果是数学系，高考分数达到了卓越学院二次选拔的报名分数线，报了卓越学院的招生考试。</p><p>之后的假期写了几个板子，打了几场 CF 恢复一点水平，参加了 HDU的几场内部训练，搬了一套题恰烂钱。</p><p>开学之前和岳老师吃了个饭（竟然还赶上了他生日），让我重心不要全部放到竞赛上，要给自己留个后路。</p><h2 id="初到杭电">初到杭电</h2><p>有一说一假期还是过的比较随意，虽然报名了卓越学院，但是一点没准备，9月份忐忑地就来到杭电啦。</p><p>考试之前自己很没有底气，当时觉得能进计科班就不错了。考完觉得考的还行，因为竞赛里接触过一点高数线代的知识，觉得自己英语阅读也比较会蒙。然后晚上大概九点的时候出成绩了，震惊自己竟然过了英才班的线。</p><p>晚上给爸爸妈妈很激动地打了个电话，有点担心 11 进 9被刷掉，一直到十二点多才睡着。</p><p>第二天面试的时候其实自己比较轻松，感觉面试向来都比较稳<del>比较会吹</del> ，面试单独面，五个老师。</p><p>面试比较自然，老师们的问题基本是跟着我的自我介绍思路走，不过还是有几个问题血压拉满。</p><ol type="1"><li>我努力地强调自己的竞赛水平，然后冯老师问：“现在让你去打区域赛能拿到什么奖项？”</li><li>我介绍了一下高中学校和班级的情况，然后另一个老师问：“你觉得二中和衡一哪个更好？”</li><li>周老师（也是现在的导师）问：“你也不能打一辈子竞赛啊。以后有什么进一步的打算？”我说会读研，以后可能会去当大学老师。导师笑笑说要想当教授，后面得去好点的大学读书。</li></ol><p>面试完出来觉得自己还挺稳的，但是也不敢确定，忐忑到了晚上十点多出了结果。终于还是去学计算机了。</p><p>之后的生活很顺利，见面会，正常上课，班委选举（当了学委）。</p><p>上课的时候强迫自己去提问，回答问题，意识到自己可以做一些<strong>由自己决定的</strong> <strong>想做什么就做什么</strong>的事。</p><p>遇到了自己喜欢的老师，有能够舒适相处，真心相待的一帮同学，慢慢地从高三痛苦自闭的状态走出来了。</p><h2 id="竞赛">竞赛</h2><p>这段话也想写给每个学竞赛过程中感到无力的同行者。</p><p><strong>算法竞赛的魅力在于，通过努力积累或灵机一动，你能够做出越来越难的题目，是一种对自我能力的认可。</strong></p><p><strong>算法竞赛的危险亦在于，你学会的东西越多，认识的厉害的人越多，面对不可计数的强者，很容易陷入自我否定。</strong></p><p>想到杭电之前，很长一段时间都觉得，大学不会再打竞赛了。</p><p>学竞赛的过程中经历的打击，不仅是比赛和上课中受到一众神仙居高临下的压迫感，更多的其实是周围人不经意的否定和安慰。对我来说，这是一种对信心很大的打击，会想要证明自己，亦或是心里感到无力而故作轻松。</p><p>在面临是否买 D的抉择时，我放弃了。不是担心取得不了什么结果，而是觉得压力太大了。</p><p>在选学校的时候，突然想到杭电的那一刻，有种死灰复燃的感觉。</p><p>记起来 NOIP 2018结束的时候，在存真楼下，孙校长和我们几个刚从秦皇岛回来的学生说的几句话：</p><p>“学别的竞赛的，最终的发展和竞赛不一定有关系，但是算法竞赛的学生，最终往往都会选择计算机行业。”</p><p><strong>算法竞赛会在心里埋下一颗种子。</strong></p><p><strong>我不是那种一帆风顺的天才，在受到打击的时候，我会感到无力。</strong></p><p><strong>但当我抛开名利、和他人比较、证明自己这些功利的意义之后，我发现自己还剩下些东西，还能看到初心。</strong></p><p><strong>是对算法的欣赏和热爱，是理解每一个算法、做出每一个题目的瞬间，精神上的享受，这就够了。</strong></p><p>至少在我看来，从我开始接触竞赛，到做出很多重要的选择，我决策的初心从来都不是名利，因为对算法还爱着。决定最终没有买D类，最大的原因还是在那个时刻，竞赛带来的痛苦超过了学习的享受，被一次次的排名裹挟，被各种机会所吸引，我越来越像一个没有自我的机器，越来越被成功学牢牢锁死。而在我选择大学的时候，竞赛对我的意义不再是未来的全部了。我能够静下来，问问自己对算法还有没有那种近乎痴迷的喜爱，能够将它作为一种兴趣去发展，不需要考虑付出和回报，至少在大学，我还是有自由支配自己的权利。</p><p><strong>我还是那个深深爱着算法的小孩，对几十行代码背后的智慧如痴如醉。</strong></p><hr /><ul><li>Gold Medal (30th Place) : The 45th ICPC Asia Jinan Regional Contest,2020</li><li>Gold Medal ( 15th Place) : The 18th Zhejiang Provincial CollegiateProgramming Contest, 2021</li><li>Silver Medal (28th Place) : The 45th ICPC Asia Shenyang RegionalContest, 2021</li></ul><h2 id="课内学习">课内学习</h2><p>第一个学期不会选课，修了系统默认的 25.25 个学分， 第二个学期修了32.25 个学分。</p><p>通识选修只完成了科技发展与科学精神（2/2），大二上应该会把剩下的指标修完。</p><table><colgroup><col style="width: 12%" /><col style="width: 87%" /></colgroup><thead><tr class="header"><th style="text-align: center;">数理基础 (23)</th><th>数分 （6 * 3.5 + 5 * 4.2）、高代（3 * 5 + 2 * 5）、离散（4 *5）、大物1（3 * 5）</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">CS专业课 (14)</td><td>计导（2 * 5）、程设基础（5 * 5）、数据结构（4 * 4.5）、C++面向对象（3 * 5）</td></tr><tr class="even"><td style="text-align: center;">通识教育 (8)</td><td>思修法基（3 * 5）、心理健康（1 * 4.3）、大军（2 * 4.8）、ACM（2 *5）</td></tr><tr class="odd"><td style="text-align: center;">外语类 (8)</td><td>英语精读 A（2 * 4.4 + 2 * 4.6）、英语听说 A（1 * 4.3 + 1 *4.7）、实用翻译（2 * 4.6）</td></tr><tr class="even"><td style="text-align: center;">其他 (3.5)</td><td>大学启示录（1 * 4）、形式与政策（0.5 * 5）、科研实践（1 *5）、体育（1 * 2.1 + 1 * 1.8）</td></tr></tbody></table><p>很幸运的是遇到的老师都很认真负责，老师们对课程内容非常了解，自己遇到问题也都能很好沟通。</p><p>很多课程都觉得自己做的没那么好，对给出的成绩也常常受之有愧。</p><p><strong>数学分析</strong>和<strong>高等代数</strong>两门数学基础课的表现截然相反，让我更清楚地意识到很大程度上我是个兴趣驱动的人。</p><p>对数分的知识体系自己本身可能就不太感兴趣，<del>加上数分课是真的提不起来精神</del>，两个学期的数学分析成绩都不太看的过去，数分上可能要在大三重修了。老师确实想要认真教会我，可是自己确实提不起兴趣去学。经历了数分上的洗礼，数分下还是逼着自己学了学，最后的结果算是马马虎虎吧，确实对不起老师对不起自己。</p><p>很喜欢高代老师的课，很大程度驱动我去花相对比较多的时间在这门课上。两个学期最后的结果都比较好，在自己喜欢的科目上能够看到自己做了些事情，也是让自己很开心的一件事。唯一遗憾的是期末错在了最后一节课老师强调过的一个小点上（证明正定阵需先说明对称）。大二下预定了老师的近世代数。</p><p>也很喜欢 Cathy上的<strong>英语精读</strong>，也算是第一次能让我主动提起来学英语的兴趣。Cathy的课有一种很轻松的气氛，不会按照课本一板一眼的去上，讲的很多东西很受用。</p><p>感谢<strong>程设和OOP（C++）</strong>的老师对我的包容，自己在这两门课上确实有过很幼稚的行为。很佩服将近退休的老师能精确把控很多细节，随手写的代码能一遍过编译什么错都没有。</p><p><strong>离散数学和数据结构</strong>给了我很深刻的教训。两门都是自认为了解比较多的，<strong>数据结构</strong>甚至申请了免听。考前复习的都不是很充分，等上了考场发现要开始脑补一堆一堆的概念。期末离散卷子简单，没暴露出来什么问题。数据结构觉得自己看看书就够了，最后的成绩却不尽如人意，原因只是不知道排序里的一个既定细节，只能悔不当初。</p><p><strong>大学物理和思想道德修养与法律基础</strong>两门课结果意外的好，其实自己认真去学一学还是可以有效果的。中学阶段一直头疼的政治在闭卷的期末考试也写了个差不多。学不会电磁在考场上也做出来了绝大多数题。考试遇到不会的题也不能太着急，多想一会没准就通了。</p><p><strong>体育</strong> 从中考的 <spanclass="math inline">\(18\)</span> 分保底，到大一上的体测 <spanclass="math inline">\(36\)</span>分，痛失两个学期的奖学金，终究还是没逃过身体素质不行这个问题。还是感谢环境逼着我去直面体育，按着体能班的要求大一下结结实实把40次阳光长跑跑完了，也确实让我看到耐力可以有提升，从操场跑一圈就喘不上气，到体测的时候人生第一次把1000米全跑下来，确实是很激动的。也终于在锻炼身体上有了动力，首先是大二下想要和qyy 同学一起学体育舞，其次是想要恰奖学金。</p><h2 id="我的她">我的她</h2><p>只想说爱情的体验是一种很纯粹的幸福。</p><p>愿意为她牺牲自己的一切，无时无刻都会想起她的事情，找不到她会坐如针毡，什么都做不下去。</p><p>她所高兴的事情比她还高兴，她难受的时候会跟着一起哭出来，在爱情中两个人都学会了如何照顾对方。</p><p>两个人在一起呆着常常心有灵犀，做事情反应如出一辙，很多事情不用言语。</p><p>两个人在一起呆着就是最快乐的事情，能够一起学习，散步，她在我的身边就能感受到无比的踏实。</p><p>会走到一起的人终究不会分开。心里对未来有着期盼，静下心来踏踏实实做事，继续加油。</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round #723 (Div. 2)</title>
    <link href="/2021/03/29/cf723/"/>
    <url>/2021/03/29/cf723/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="a.-mean-inequality">A. Mean Inequality</h2><blockquote><p>将 <span class="math inline">\(2n\)</span>个<strong>不同的</strong>数字排成一个循环，使得任意位置的数不是相邻两个数的平均值。</p></blockquote><p>从小到大排序之后，前 <span class="math inline">\(n\)</span> 个和后<span class="math inline">\(n\)</span> 个交替放。</p><p>因为数字两两不同，大的数字不可能是两个小的数字的平均数，小的同理。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">char</span> c = getchar();<br><span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);<br><span class="hljs-keyword">for</span> (; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);<br><span class="hljs-keyword">return</span> f ? -x : x;<br>&#125; <br><br><span class="hljs-keyword">int</span> a[<span class="hljs-number">51</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> n = rd();<br><span class="hljs-keyword">int</span> m = <span class="hljs-number">2</span> * n;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) a[i] = rd();<br>sort(a + <span class="hljs-number">1</span>, a + <span class="hljs-number">1</span> + m);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d &quot;</span>, a[i], a[i + n]);<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> t = rd(); t; --t) work();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="b.-i-hate-1111">B. I Hate 1111</h2><blockquote><p>询问一个正整数 <span class="math inline">\(x\)</span>是否可以拆分成若干个 <spanclass="math inline">\(11,111,1111,\dots\)</span> 的和</p></blockquote><p>根据 <ahref="https://artofproblemsolving.com/wiki/index.php/Chicken_McNugget_Theorem">麦乐鸡定理</a>，<span class="math inline">\(11\)</span> 和 <spanclass="math inline">\(111\)</span> 可以组成大于 <spanclass="math inline">\(11*111-111-11=1099\)</span> 的任何数。</p><p>所以后面的数字都没用了， <span class="math inline">\(x\le1099\)</span> 的部分做一下 <span class="math inline">\(11\)</span> 和<span class="math inline">\(111\)</span> 的完全背包，其他情况都是<code>YES</code> 。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">char</span> c = getchar();<br><span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);<br><span class="hljs-keyword">for</span> (; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);<br><span class="hljs-keyword">return</span> f ? -x : x;<br>&#125; <br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 1100</span><br><br><span class="hljs-keyword">bool</span> f[N];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> x = rd(); <br><span class="hljs-built_in">puts</span>(x &gt;= N ? <span class="hljs-string">&quot;YES&quot;</span> : (f[x] ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">11</span>; i &lt; N; ++i) f[i] |= f[i - <span class="hljs-number">11</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">111</span>; i &lt; N; ++i) f[i] |= f[i - <span class="hljs-number">111</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> t = rd(); t; --t) work();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="c.-potions">C. Potions</h2><blockquote><p>给一个数列，求一个最长的子序列，使得子序列任意前缀和都 <spanclass="math inline">\(\ge 0\)</span></p></blockquote><p>经典的带反悔贪心，用一个小根堆维护拿了的数字。</p><p>每次先把当前的拿了，如果当前的和是负的，就一直去掉堆顶直到合法即可。</p><p>这样子在每次结束的时候都是正的，并且去掉了最少的数。</p><p>等效的贪心是每次放进来如果变成负数就看一下能不能替换堆顶。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">char</span> c = getchar();<br><span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);<br><span class="hljs-keyword">for</span> (; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);<br><span class="hljs-keyword">return</span> f ? -x : x;<br>&#125; <br><br><span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> n = rd();<br><span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>ll nw = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, a; i &lt;= n; ++i) &#123;<br>a = rd(); <br>++ans; nw += a; q.push(-a);<br><span class="hljs-keyword">while</span> (nw &lt; <span class="hljs-number">0</span>) &#123;<br>nw += q.top(); q.pop(); --ans;<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="d.-kill-anton">D. Kill Anton</h2><blockquote><p>给定一个字符集只有 <code>'A','D','O','T'</code>的串，将其重排使得恢复成原来的所需操作次数最大。</p><p>操作一次可以交换两个字符的位置。</p></blockquote><p>猜一下操作次数只和逆序数相关（我一直不太会这种的证明），所以一定可以把同一类字符放到一起。</p><p>记 <code>inv[i][j]</code> 表示字符 <code>i</code>前字符<code>j</code> 的顺序对数，即如果结果串中字符 <code>i</code>在字符 <code>j</code> 前，增加的逆序数。</p><p>因此枚举 <span class="math inline">\(4!\)</span>种排列，计算一下哪一种逆序数最大即可。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> tc[<span class="hljs-number">4</span>] = &#123;<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;N&#x27;</span>, <span class="hljs-string">&#x27;O&#x27;</span>, <span class="hljs-string">&#x27;T&#x27;</span>&#125;;<br><br>ll cnt[<span class="hljs-number">4</span>], inv[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tr</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;A&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;N&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> (c == <span class="hljs-string">&#x27;O&#x27;</span> ? <span class="hljs-number">2</span> : <span class="hljs-number">3</span>);<br>&#125;<br><br><span class="hljs-built_in">string</span> s;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">cin</span> &gt;&gt; s;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i) &#123;<br>cnt[i] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; ++j) inv[i][j] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : s) &#123;<br><span class="hljs-keyword">int</span> i = tr(c);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; ++j)<br><span class="hljs-keyword">if</span> (j != i) inv[i][j] += cnt[j];<br>++cnt[i];<br>&#125;<br>ll ans = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">int</span> p[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, res[<span class="hljs-number">4</span>];<br><span class="hljs-keyword">do</span> &#123;<br>ll tmpans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">4</span>; ++j) tmpans += inv[p[i]][p[j]];<br><span class="hljs-keyword">if</span> (tmpans &gt; ans) &#123;<br>ans = tmpans;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i) res[i] = p[i];<br>&#125;<br>&#125; <span class="hljs-keyword">while</span>(next_permutation(p, p + <span class="hljs-number">4</span>));<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= cnt[res[i]]; ++j) <span class="hljs-built_in">putchar</span>(tc[res[i]]);<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> t;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">cin</span> &gt;&gt; t; t; --t) work();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="e.-oolimry-and-suffix-array">E. Oolimry and Suffix Array</h2><blockquote><p>给定后缀数组，求有多少个串长为 <span class="math inline">\(n\)</span>，字符集大小为 <span class="math inline">\(k\)</span> 的字符串 <spanclass="math inline">\(S\)</span> 符合这个后缀数组</p></blockquote><p>后缀数组 <span class="math inline">\(sa_i\)</span> 记录的是排名第<span class="math inline">\(i\)</span> 位的后缀的开始下标。</p><p>根据字典序要求，<span class="math inline">\(S_{sa_i}\)</span> 和<span class="math inline">\(S_{sa_{i+1}}\)</span> 只有两种关系：<spanclass="math inline">\(S_{sa_i}&lt;S_{sa_{i+1}}\)</span> 或 <spanclass="math inline">\(S_{sa_i}=S_{sa_{i+1}}\)</span></p><p>小于一定是可以的，等于的充要条件是 <spanclass="math inline">\(rank_{sa_i+1}&lt;rank_{sa_{i+1}+1}\)</span>，即去掉第一个字符字典序不变。</p><p>因此我们得到了含有 <span class="math inline">\(n-1\)</span>个不等号的不等式链，假设其中有 <span class="math inline">\(a\)</span>个是 <span class="math inline">\(\le\)</span> 。</p><p>我们枚举有 <span class="math inline">\(i\)</span> 个 <spanclass="math inline">\(\le\)</span> 实际上是 <spanclass="math inline">\(&lt;\)</span> ，那么实际字符集大小是 <spanclass="math inline">\(n-i\)</span> ，方案数就是</p><p><span class="math display">\[\sum_{i=0}^a{a\choose i}{k\choose n-i}={a+k\choose n}\]</span></p><p>等式从组合含义理解，从 <span class="math inline">\(a+k\)</span>个里选 <span class="math inline">\(n\)</span> 个，定价于枚举从前 <spanclass="math inline">\(a\)</span> 个里选 <spanclass="math inline">\(i\)</span> 个，剩余的从后 <spanclass="math inline">\(k\)</span> 个里选。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">char</span> c = getchar();<br><span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);<br><span class="hljs-keyword">for</span> (; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);<br><span class="hljs-keyword">return</span> f ? -x : x;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 200007</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mod 998244353</span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fpow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> t = mod - <span class="hljs-number">2</span>)</span> </span>&#123;<br><span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (; t; t &gt;&gt;= <span class="hljs-number">1</span>, x = <span class="hljs-number">1l</span>l * x * x % mod)<br><span class="hljs-keyword">if</span> (t &amp; <span class="hljs-number">1</span>) res = <span class="hljs-number">1l</span>l * res * x % mod;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">int</span> rk[N], pos[N], fac[N &lt;&lt; <span class="hljs-number">1</span>] = &#123;<span class="hljs-number">1</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> n = rd(), k = rd();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) rk[pos[i] = rd()] = i;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) <br>k += (rk[pos[i] + <span class="hljs-number">1</span>] &lt; rk[pos[i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>]);<br><span class="hljs-keyword">if</span> (k &lt; n) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; ++i) fac[i] = <span class="hljs-number">1l</span>l * fac[i - <span class="hljs-number">1</span>] * i % mod;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, <span class="hljs-number">1l</span>l * fac[k] * fpow(fac[n]) % mod * fpow(fac[k - n]) % mod);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
      <category>Codeforces</category>
      
      <category>Codeforces Round</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Greedy</tag>
      
      <tag>Constructive Algorithm</tag>
      
      <tag>Number Theory</tag>
      
      <tag>Counting</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Render Math Equations in Hexo</title>
    <link href="/2019/06/01/mathjax/"/>
    <url>/2019/06/01/mathjax/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><span class="math display">\[f(a) = \frac{1}{2\pi i}\oint_{\gamma}\frac{f(z)}{z-a}dz\]</span></p><p><a href="https://www.mathjax.org/">Beautiful and accessible math inall browsers - MathJax</a></p><p>This post is used to check out whether the mathjax plugin (<ahref="https://github.com/hexojs/hexo-math">hexo-math</a>) stillworks.</p><h2 id="inline-formula">Inline Formula</h2><p>Consider the sequence of <span class="math inline">\(n\)</span>distinct positive integers: <spanclass="math inline">\(c_1, c_2, \cdots, c_n\)</span>. The child calls avertex-weighted rooted binary tree <strong>good</strong> if and only iffor every vertex <span class="math inline">\(v\)</span>, the weight of<span class="math inline">\(v\)</span> is in the set <spanclass="math inline">\(\{c_1, c_2, \cdots, c_n\}\)</span> . Also ourchild thinks that the <strong>weight</strong> of a vertex-weighted treeis the sum of all vertices' weights.</p><p>Given an integer <span class="math inline">\(m\)</span>, can you forall $s (1  s ≤ m) $ calculate the number of good vertex-weighted rootedbinary trees with weight <span class="math inline">\(s\)</span> ?Please, check the samples for better understanding what trees areconsidered different.</p><p>We only want to know the answer modulo <spanclass="math inline">\(998244353\)</span> ( <spanclass="math inline">\(7 × 17 × 2^{23} + 1\)</span> , a primenumber).</p><h2 id="block-formula">Block Formula</h2><p><span class="math display">\[\int \frac{dx}{cos^2x}=\int sec^2xdx=tan x+C\\]</span></p><p><span class="math display">\[\int \frac{dx}{sin^2x}=\int csc^2xdx=-cot x+C\\]</span></p><p><span class="math display">\[\sum\limits_{i = 0}^{E} w[i]{M \choose i} {N \choose iS}\frac{(iS)!}{(S!)^{i}} \sum\limits_{j = 0}^{E - i} (-1)^{j} {M - i\choose j} {N - iS \choose jS} \frac{(jS)!}{(S!)^{j}} (M - i - j)^{N -iS - jS}\]</span></p><p><span class="math display">\[= \sum\limits_{i = 0}^{E} w[i]{M \choose i} {N \choose iS}\frac{(iS)!}{(S!)^{i}} \sum\limits_{j = i}^{E} (-1)^{j - i} {M - i\choose j - i} {N - iS \choose jS - iS} \frac{(jS - iS)!}{(S!)^{j - i}}(M - j)^{N - jS}\]</span></p><h2 id="matrix">Matrix</h2><p><span class="math display">\[\begin{bmatrix}(\omega_n^0)^0 &amp; (\omega_n^0)^1 &amp; \cdots &amp;(\omega_n^0)^{n-1}\\\\ (\omega_n^1)^0 &amp; (\omega_n^1)^1 &amp; \cdots&amp; (\omega_n^1)^{n-1}\\\\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\\\(\omega_n^{n-1})^0 &amp; (\omega_n^{n-1})^1 &amp; \cdots &amp;(\omega_n^{n-1})^{n-1}\end{bmatrix}\begin{bmatrix}a_0 \\\\a_1 \\\\\vdots \\\\a_{n-1}\end{bmatrix}=\begin{bmatrix}A(\omega_n^0) \\\\A(\omega_n^1) \\\\\vdots \\\\A(\omega_n^{n-1})\end{bmatrix}\]</span></p><p><span class="math display">\[\begin{bmatrix}a_0 \\\\a_1 \\\\\vdots \\\\a_{n-1}\end{bmatrix}=\frac{1}{n}\begin{bmatrix}(\omega_n^{-0})^0 &amp; (\omega_n^{-0})^1 &amp; \cdots &amp;(\omega_n^{-0})^{n-1} \\\\(\omega_n^{-1})^0 &amp; (\omega_n^{-1})^1 &amp; \cdots &amp;(\omega_n^{-1})^{n-1} \\\\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\\\(\omega_n^{-(n-1)})^0 &amp; (\omega_n^{-(n-1)})^1 &amp; \cdots &amp;(\omega_n^{-(n-1)})^{n-1}\end{bmatrix}\begin{bmatrix}A(\omega_n^0) \\\\A(\omega_n^1) \\\\\vdots \\\\A(\omega_n^{n-1})\end{bmatrix}\]</span></p><p>To prevent escaping, you need to use <code>\\\\</code> to make a newline rather than <code>\\</code> .</p><p>For more about the Mathjax symbols, refer to ：<ahref="/material/mathjax-symbol-list.pdf"><strong>The Comprehensive LaTeXSymbol List</strong></a> .</p>]]></content>
    
    
    <categories>
      
      <category>Blog</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2018/11/29/hello-world/"/>
    <url>/2018/11/29/hello-world/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>「 Hello, the lovely world. 」</p><p>「 Stay hungry, Stay foolish. 」</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> this<br>The Zen of Python, by Tim Peters<br><br>Beautiful <span class="hljs-keyword">is</span> better than ugly.<br>Explicit <span class="hljs-keyword">is</span> better than implicit.<br>Simple <span class="hljs-keyword">is</span> better than complex.<br>Complex <span class="hljs-keyword">is</span> better than complicated.<br>Flat <span class="hljs-keyword">is</span> better than nested.<br>Sparse <span class="hljs-keyword">is</span> better than dense.<br>Readability counts.<br>Special cases aren<span class="hljs-string">&#x27;t special enough to break the rules.</span><br><span class="hljs-string">Although practicality beats purity.</span><br><span class="hljs-string">Errors should never pass silently.</span><br><span class="hljs-string">Unless explicitly silenced.</span><br><span class="hljs-string">In the face of ambiguity, refuse the temptation to guess.</span><br><span class="hljs-string">There should be one-- and preferably only one --obvious way to do it.</span><br><span class="hljs-string">Although that way may not be obvious at first unless you&#x27;</span>re Dutch.<br>Now <span class="hljs-keyword">is</span> better than never.<br>Although never <span class="hljs-keyword">is</span> often better than *right* now.<br>If the implementation <span class="hljs-keyword">is</span> hard to explain, it<span class="hljs-string">&#x27;s a bad idea.</span><br><span class="hljs-string">If the implementation is easy to explain, it may be a good idea.</span><br><span class="hljs-string">Namespaces are one honking great idea -- let&#x27;</span>s do more of those!<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Blog</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title></title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
  </entry>
  
  
  
</search>
