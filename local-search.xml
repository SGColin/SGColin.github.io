<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>PAT ( Top Level ) Autumn 2021</title>
    <link href="/2021/09/11/pat2021/"/>
    <url>/2021/09/11/pat2021/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>某天心血来潮拉上 Eva 同学一起报名了 PAT ～</p><p>开学前在 <a href="https://pintia.cn/problem-sets/994805148990160896/problems/type/7">官方题库</a> 里刷了两道题热身！<del>其实是想刷完但是太鸽了</del> </p><h3 id="1001-最小生成树"><a href="#1001-最小生成树" class="headerlink" title="1001 - 最小生成树"></a>1001 - 最小生成树</h3><div class="note note-warning">            <p>给定 $n\ (n\le 500)$ 个 $m$ 条边的图，以及 $k$ 条可补充的边 $(u_i,v_i,w_i)$ </p><p>定义一个点的关键度为：从原图中删掉该点及相邻的边后，补充若干条边，使图连通最小的代价 $\sum w_i$</p><p>问关键度最大的点有哪些（所有方案都无法连通的点认为代价为 $\infty$ , $\infty = \infty$ ）</p>          </div><p>模拟题意即可。首先把原图中所有与该点相邻的边删掉，然后考虑如何补充边使得代价最小。</p><p>按照 MST 的过程，对于剩下的边按照 $w_i$ 从小到大依次考虑，当有效合并次数 $&lt;n-2$ 时关键度即为 $\infty$ 。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br> <br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 507</span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">char</span> c = getchar();<br>    <span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);<br>    <span class="hljs-keyword">return</span> f ? -x : x;<br>&#125;<br><br><span class="hljs-keyword">int</span> n, m, tote, totr, tmp, cnt, f[N];<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><span class="hljs-keyword">int</span> u, v, w;&#125; e[N * N], r[N * N]; <br><br><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-keyword">const</span> node &amp;a, <span class="hljs-keyword">const</span> node &amp;b) &#123;<br>    <span class="hljs-keyword">return</span> a.w &lt; b.w;<br>&#125;<br><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> f[x] == x ? x : f[x] = find(f[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">const</span> node &amp;a)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> u = find(a.u), v = find(a.v);<br>    <span class="hljs-keyword">if</span> (u != v) &#123;++cnt; tmp += a.w; f[u] = v;&#125;<br>&#125; <br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nw)</span> </span>&#123;<br>    tmp = cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) f[i] = i;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= tote; ++i)<br>        <span class="hljs-keyword">if</span> (e[i].u != nw &amp;&amp; e[i].v != nw) merge(e[i]);<br>    <span class="hljs-keyword">if</span> (cnt == n - <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= totr &amp;&amp; cnt &lt; n - <span class="hljs-number">2</span>; ++i) <br>        <span class="hljs-keyword">if</span> (r[i].u != nw &amp;&amp; r[i].v != nw) merge(r[i]);<br>    <span class="hljs-keyword">if</span> (cnt &lt; n - <span class="hljs-number">2</span>) tmp = <span class="hljs-number">1000000000</span>;<br>&#125; <br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    n = rd(); m = rd();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, u, v, w, ty; i &lt;= m; ++i) &#123;<br>        u = rd(); v = rd(); w = rd(); ty = rd();<br>        ty ? e[++tote] = (node)&#123;u, v, <span class="hljs-number">0</span>&#125; : r[++totr] = (node)&#123;u, v, w&#125;;<br>    &#125;<br>    sort(r + <span class="hljs-number">1</span>, r + <span class="hljs-number">1</span> + totr);<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        work(i);<br>        <span class="hljs-keyword">if</span> (tmp &gt; ans) &#123;res.clear(); ans = tmp;&#125;<br>        <span class="hljs-keyword">if</span> (tmp == ans) res.push_back(i);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (ans == <span class="hljs-number">0</span>) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, res[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; res.size(); ++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d&quot;</span>, res[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="1025-长度限制的子序列计数"><a href="#1025-长度限制的子序列计数" class="headerlink" title="1025 - 长度限制的子序列计数"></a>1025 - 长度限制的子序列计数</h3><div class="note note-warning">            <p>给定小写字符串 $S\ (|S|\le 1000)$ ，求 $S$ 长度不超过 $100$ 的本质不同的子序列有多少个。</p>          </div><p>设 $f[i][j]$ 表示前 $i$ 个字符中选取 $j$ 个字符，强制选 $S_i$ ，<strong>与已被计数过的子序列不重复</strong>的子序列个数。</p><p>这里“已被计数过的子序列”是指，两个子序列相同，但最后一个字符选取自不同位置的情况。</p><p>设字符 $c$ 上次出现的位置为 $last_c$ ，则当前字符 $S_i$ 可以转移的位置只有 $last_{S_i},\cdots, i - 1$ 。</p><p>方程为 $f[i][j] = \sum_{k=last_{s_i}}^{i-1} f[k][j - 1]$ ，前缀和优化即可，答案就是所有 $f$ 的和。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 1007</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mod 1000000007</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">char</span> str[N];<br><br><span class="hljs-keyword">int</span> a[N], lst[<span class="hljs-number">26</span>], f[N][<span class="hljs-number">107</span>], s[N][<span class="hljs-number">107</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, str + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">int</span> n = <span class="hljs-built_in">strlen</span>(str + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) a[i] = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = s[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">100</span>; ++j) <br>            <span class="hljs-keyword">if</span> (!lst[a[i]]) f[i][j] = s[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">else</span> f[i][j] = (s[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] - s[lst[a[i]] - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + mod) % mod;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= <span class="hljs-number">100</span>; ++j)<br>            s[i][j] = (s[i - <span class="hljs-number">1</span>][j] + f[i][j]) % mod;<br>        lst[a[i]] = i;<br>    &#125;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; ++i)<br>        ans = (ans + s[n][i]) % mod;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>因为现在没题库可以找原题，先大概回忆下</p><h3 id="A-Sorted-Cartesian-tree"><a href="#A-Sorted-Cartesian-tree" class="headerlink" title="A. Sorted Cartesian tree"></a>A. Sorted Cartesian tree</h3><div class="note note-warning">            <p>给定 $n$ 个 <code>pair&lt;priority, key&gt;</code> ，构建一棵 $n$ 个节点的二叉树，满足：</p><ul><li><p>节点  <code>priority</code> 关键字满足堆的性质，即 <code>priority</code> 父节点小于子节点</p></li><li><p>节点 <code>key</code> 关键字满足二叉搜索树的性质，即中序遍历 <code>key</code> 单调不降</p></li></ul><p>把树建出来，输出 <code>priority</code> 和 <code>key</code> 的 <code>Level-order traversal</code> 序列</p>          </div><p>模拟题意 <code>dfs</code> 建树，传一个 <code>set&lt;node&gt;</code> 即可。</p><h3 id="B-Unity-Strength"><a href="#B-Unity-Strength" class="headerlink" title="B. Unity Strength (?)"></a>B. Unity Strength (?)</h3><div class="note note-warning">            <p>给一张有权无向图，以及若干条可以花 $w_i$ 连接 $u_i,v_i$ 的无向边。</p><p>先输出每个联通块的 “块内最小编号 - 块内最小边权” ，按照块大小-最小边权-最小点编号的顺序排序</p><p>然后计算把整个图联通的最小代价，除给定边外，任意两点之间都可以花 $10^4$ 的代价连接一条边。</p>          </div><p>并查集模拟题意即可，第一步求出来每个集合的若干信息，然后排序一下。</p><p>之后就是最小生成树，考虑给定边不一定能让整个图联通，最后答案加上（联通块数 $-1$ ）$\times 10^4$ 即可。</p><h3 id="C-Manhattan"><a href="#C-Manhattan" class="headerlink" title="C. Manhattan(?)"></a>C. Manhattan(?)</h3><div class="note note-warning">            <p>给定一个序列 ${ a_i }\ (1\le a_i\le 3)$，两个人玩（开始双方均为 $0$ 分），每次某个人取走最靠前的 $a_i$ 加到当前的得分里。</p><p>要求每个人拿完之后，<strong>当前的得分不得少于对方</strong>，问有多少种划分方案，答案 $\mod 10^ 9 + 7$ </p>          </div><p>裸的 DP 就是 <code>f[i][j]</code> 表示当前考虑前 $i$ 个数，第一个人比第二个人多 $j$ 的方案数。</p><p>因为 $a_i\le 3$ ，所以如果某个人比另一个人多了超过 $3$ 分，对手就无法满足要求，之后就只能是这个人拿了。</p><p>所以 <code>j</code> 可以把特殊的状态放到一起，范围就只有 $9$ 了，复杂度 $O (9n)$ ，转移要注意条件。</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>比赛之前比较焦虑（毕竟军训一周都没碰键盘），到考场发现左边坐的是学长。</p><p>开场把三个题都开了， 题目描述都十分迷惑（英语太差），结合样例枚举题意读题。</p><blockquote><p>分不清：Preorder 先序；Inorder 中序；Postorder 后序；Level-order traversal 层序遍历</p></blockquote><p>过题顺序 T2 - T1 - T3 ，看榜应该是 Rank 2，开场大概一个小时完成，都是一次过非常舒适。</p><p>然后就提前跑路了！因为 Eva 同学还在奋战，我就开始快乐的浙传半日游～</p><p>浙传的校园就比较有感觉，总觉得杭电的楼都是一个样子的，缺点大学的气息…</p><p><img src="/img/cuz/cuz1.JPG"></p><p><img src="/img/cuz/cuz2.JPG"></p><p><img src="/img/cuz/cuz3.JPG"></p><p><img src="/img/cuz/cuz4.JPG" alt="井盖上超级可爱的小王子和狐狸～"></p>]]></content>
    
    
    <categories>
      
      <category>Travel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Union-Find Set</tag>
      
      <tag>DFS</tag>
      
      <tag>Counting</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AtCoder Beginner Contest 216</title>
    <link href="/2021/08/29/abc216/"/>
    <url>/2021/08/29/abc216/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Rank : 269 / Score : 2600 / Pen. Time 1:33:12 (+5)</p><a id="more"></a><p>A 题 WA 了一次，为什么 <code>1.6 - floor(1.6) &gt; 0.6</code> ? ? ? </p><h2 id="E-Amusement-Park"><a href="#E-Amusement-Park" class="headerlink" title="E. Amusement Park"></a>E. Amusement Park</h2><div class="note note-warning">            <p>给定 $n$ 个数，最多 $k$ 次操作，每次可以拿走某个数 $a_i$ 加入得分，然后把 $a_i-1$ 放回，问得分最大值，$k,a_i\le 2\times 10^9$</p>          </div><p>二分最后剩下的所有数里的最大值为 $x$ ，答案是把所有数都拿到 $x$ 的得分，然后加上剩下次数个 $x$ 的得分。</p><p>需要注意二分上界 $r  = 2\times 10^9$ ，所以二分 <code>mid = (l + r) / 2</code> 的时候可能会爆 <code>int</code> 。<del>坑死我了</del></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 200007</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;<br>    ll x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">char</span> c = getchar();<br>    <span class="hljs-keyword">for</span>(; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);<br>    <span class="hljs-keyword">for</span>(; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);<br>    <span class="hljs-keyword">return</span> f ? -x : x;<br>&#125;<br><br>ll n, k, a[N];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">valid</span><span class="hljs-params">(ll x)</span> </span>&#123;<br>    ll cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) <br>        <span class="hljs-keyword">if</span> (a[i] &gt; x) cnt += a[i] - x;<br>    <span class="hljs-keyword">return</span> cnt &lt;= k;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">sum</span><span class="hljs-params">(ll l, ll r)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (l + r)  * (r - l + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    n = rd(); k = rd();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) a[i] = rd();<br>    ll l = <span class="hljs-number">0</span>, r = <span class="hljs-number">2e9</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        ll mid = (l + r) / <span class="hljs-number">2</span>;<br>        valid(mid) ? r = mid : l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    ll ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) <br>        <span class="hljs-keyword">if</span> (a[i] &gt; l) &#123;<br>            ans += sum(l + <span class="hljs-number">1</span>, a[i]);<br>            k -= a[i] - l;<br>        &#125;<br>    ans += k * l;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="F-Max-Sum-Counting"><a href="#F-Max-Sum-Counting" class="headerlink" title="F. Max Sum Counting"></a>F. Max Sum Counting</h2><div class="note note-warning">            <p>有 $n$ 个数对 $(A_i, B_i)$ 构成一个集合，问有多少个子集，满足子集内 $A$ 的最大值大于 $B$ 的和。</p>          </div><p>考虑枚举最大的 $A$ 是谁，将所有数对按照 $A$ 从小到大排序，问题转化为选哪些 $B$ 。</p><p>假设现在考虑排序后第 $i$ 个数对，则 $B_i$ 必选，相当于计数 $B_1,\cdots,B_{i-1}$ 中选出若干，且总和不超过 $A_i-B_i$ 的方案数。</p><p>因为 $A$ 的值域很小，搞一个 01 背包计数即可，复杂度 $O(n\times \max A_i)$ 。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 5007</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mod 998244353</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><br><span class="hljs-keyword">int</span> n, f[N] = &#123;<span class="hljs-number">1</span>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><span class="hljs-keyword">int</span> a, b;&#125; c[N];<br><br><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-keyword">const</span> node &amp;a, <span class="hljs-keyword">const</span> node &amp;b) &#123;<br>    <span class="hljs-keyword">return</span> a.a == b.a ? a.b &lt; b.b : a.a &lt; b.a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;c[i].a);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;c[i].b);<br>    sort(c + <span class="hljs-number">1</span>, c + <span class="hljs-number">1</span> + n);<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>; v &lt;= c[i].a - c[i].b; ++v) <br>            ans = (ans + f[v]) % mod;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = N - <span class="hljs-number">1</span>; v &gt;= c[i].b; --v) <br>            f[v] = (f[v] + f[v - c[i].b]) % mod;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="G-01Sequence"><a href="#G-01Sequence" class="headerlink" title="G. 01Sequence"></a>G. 01Sequence</h2><div class="note note-warning">            <p>构造长度为 $n$ 的 $01$ 序列，满足 $k$ 个形如 “ $[l_i,r_i]$ 内至少有 $x_i$ 个 $1$ ” 的条件，且 $1$ 的个数最少。</p>          </div><p>将约束条件按照右端点从小到大排序，考虑每个条件当前还未满足的个数。</p><p>则对于每个 $1$ ，在可行的范围内往右放的贡献不低于往左放，因此从右边界依次放过来即可。</p><p>查询未满足的个数需要维护一个树状数组，复杂度 $O(n\log n)$ 。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 200007</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;<br>    ll x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">char</span> c = getchar();<br>    <span class="hljs-keyword">for</span>(; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);<br>    <span class="hljs-keyword">for</span>(; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);<br>    <span class="hljs-keyword">return</span> f ? -x : x;<br>&#125;<br><br><span class="hljs-keyword">int</span> cur[N], vis[N];<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> lowbit(x) (x &amp; -x)</span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (; x &lt; N; x += lowbit(x)) ++cur[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (; x; x -= lowbit(x)) res += cur[x];<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><span class="hljs-keyword">int</span> l, r, k;&#125; c[N];<br><br><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-keyword">const</span> node &amp;a, <span class="hljs-keyword">const</span> node &amp;b) &#123;<span class="hljs-keyword">return</span> a.r &lt; b.r;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = rd();<br>    <span class="hljs-keyword">int</span> m = rd();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>        c[i].l = rd(); c[i].r = rd(); c[i].k = rd();<br>    &#125;<br>    sort(c + <span class="hljs-number">1</span>, c + <span class="hljs-number">1</span> + m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>        <span class="hljs-keyword">int</span> nw = calc(c[i].r) - calc(c[i].l - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ptr = c[i].r; nw &lt; c[i].k; --ptr) <br>            <span class="hljs-keyword">if</span> (!vis[ptr]) &#123;<br>                add(ptr); ++nw; vis[ptr] = <span class="hljs-number">1</span>;<br>            &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, vis[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="H-Random-Robots"><a href="#H-Random-Robots" class="headerlink" title="H. Random Robots"></a>H. Random Robots</h2><div class="note note-warning">                      </div>]]></content>
    
    
    <categories>
      
      <category>AtCoder</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary Search</tag>
      
      <tag>Knapsack Problem</tag>
      
      <tag>Greedy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Google Kick Start Round E 2021</title>
    <link href="/2021/08/22/kickstart2021e/"/>
    <url>/2021/08/22/kickstart2021e/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Rank : 69 / Score : 87 / Pen. Time 1:51:16 (+1)</p><a id="more"></a><h2 id="A-Shuffled-Anagramsa"><a href="#A-Shuffled-Anagramsa" class="headerlink" title="A. Shuffled Anagramsa"></a>A. Shuffled Anagramsa</h2><div class="note note-warning">            <p>给定字符串 $S$ , 问能否通过重排 $S$ 得到 $T$ , 使得任意位置 $i$ 有 $S_i\not = T_i$ , 可以则给出构造方案</p>          </div><p>做法同 <a href="">AtCoder Beginner Contest 178 F</a> ，不过需要先将字符排序，<strong>构造一个位置映射</strong>。</p><p>设 $S$ 按字符升序排序后字符串为 $A$ ，降序为 $B$ ，考虑讲 $B$ 做若干调整，使得任意 $i$ 有 $A_i\not = B_i$ 。</p><p>结论为：$A$ 升序，$B$ 降序，若有不合法位置，则相同的字符一定只有一类。</p><p>记相同的字符为 $x$ ，相同的区间为 $[l, r]$ ，这是需要交换区间内和区间外的字符。</p><p>考虑将 $B$ 区间外某位置 $i$ 换进区间，那么需要保证 $A_i \ne x$ 且 $B_i \ne x$ ，否则换后依然不合法。</p><p>记录 $A$ 和 $B$ 中出现 $x$ 最靠左的位置 $L$ ，出现 $x$ 最靠右的位置 $R$ 。</p><p>则可以交换的位置 $i\notin [L,R]$ ，若个数 $L - 1 + n - R &gt; r-l+1$ 则有解，和两侧交换就好了。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 10007</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">char</span> s[N];<br><br><span class="hljs-keyword">int</span> n, a[N], b[N], testcase;<br><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; pos[<span class="hljs-number">28</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        s[pos[a[i]].back()] = b[i] + <span class="hljs-string">&#x27;a&#x27;</span> - <span class="hljs-number">1</span>;<br>        pos[a[i]].pop_back();<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) <span class="hljs-built_in">putchar</span>(s[i]);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Case #%d: &quot;</span>, ++testcase);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s + <span class="hljs-number">1</span>);<br>    n = <span class="hljs-built_in">strlen</span>(s + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">28</span>; ++i) pos[i].clear();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        a[i] = b[i] = s[i] - <span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">1</span>;<br>        pos[s[i] - <span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">1</span>].push_back(i);<br>    &#125;<br>    sort(a + <span class="hljs-number">1</span>, a + <span class="hljs-number">1</span> + n);<br>    sort(b + <span class="hljs-number">1</span>, b + <span class="hljs-number">1</span> + n);<br>    reverse(b + <span class="hljs-number">1</span>, b + <span class="hljs-number">1</span> + n);<br>    <span class="hljs-keyword">int</span> x, l = <span class="hljs-number">0</span>, r, L, R;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>        <span class="hljs-keyword">if</span> (a[i] == b[i]) l ? ++r : l = r = i;<br>    x = a[l];<br>    <span class="hljs-keyword">if</span> (!l) &#123;print(); <span class="hljs-keyword">return</span>;&#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>        <span class="hljs-keyword">if</span> (a[i] == x || b[i] == x) &#123;L = i; <span class="hljs-keyword">break</span>;&#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n; i; --i)<br>        <span class="hljs-keyword">if</span> (a[i] == x || b[i] == x) &#123;R = i; <span class="hljs-keyword">break</span>;&#125;<br>    <span class="hljs-keyword">if</span> (L - <span class="hljs-number">1</span> + n - R &lt; (r - l + <span class="hljs-number">1</span>)) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;IMPOSSIBLE&quot;</span>); <span class="hljs-keyword">return</span>;&#125;<br>    <span class="hljs-keyword">int</span> lim = min(L - <span class="hljs-number">1</span>, r - l + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= lim; ++i) swap(b[i], b[l + i - <span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">if</span> (lim == r - l + <span class="hljs-number">1</span>) &#123;print(); <span class="hljs-keyword">return</span>;&#125;<br>    lim = r - l + <span class="hljs-number">1</span> - lim;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= lim; ++i) swap(b[n - i + <span class="hljs-number">1</span>], b[r - i + <span class="hljs-number">1</span>]);<br>    print();<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="B-Birthday-Cake"><a href="#B-Birthday-Cake" class="headerlink" title="B. Birthday Cake"></a>B. Birthday Cake</h2><div class="note note-warning">            <p>切蛋糕。</p>          </div><h2 id="C-Palindromic-Crossword"><a href="#C-Palindromic-Crossword" class="headerlink" title="C. Palindromic Crossword"></a>C. Palindromic Crossword</h2><div class="note note-warning">            <p>给定一个矩阵，有若干障碍，其余位置放字母，要求横着或竖着的，任意<strong>极长</strong>的非障碍位置形成的字符串是回文的。</p><p>现给定一些位置的字母，其余应当放字母的位置用 <code>&#39;.&#39;</code> 代替 ，障碍用 <code>&#39;#&#39;</code> 表示，问最多能推断出多少个位置的字母。</p>          </div><p>预处理一下哪些位置应当是同一个字母，然后对于每一个位置集合（ 并查集 / BFS ），判断是否可以赋值。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> M 1007</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 1000007</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br> <br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;<br>    ll x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">char</span> c = getchar();<br>    <span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);<br>    <span class="hljs-keyword">return</span> f ? -x : x;<br>&#125;<br><br><span class="hljs-keyword">char</span> s[M][M], rep[N];<br><br><span class="hljs-keyword">int</span> testcase, f[N], id[M][M];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x == f[x] ? x : f[x] = find(f[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    a = find(a); b = find(b); f[a] = b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = rd();<br>    <span class="hljs-keyword">int</span> m = rd();<br>    <span class="hljs-keyword">int</span> idcnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; ++j) &#123;<br>            id[i][j] = ++idcnt;<br>            f[idcnt] = idcnt;<br>            <span class="hljs-keyword">char</span> c = getchar();<br>            <span class="hljs-keyword">while</span> (c != <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; c != <span class="hljs-string">&#x27;#&#x27;</span> &amp;&amp; !<span class="hljs-built_in">isalpha</span>(c)) c = getchar();<br>            rep[idcnt] = s[i][j] = c;<br>        &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) s[i][m + <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;#&#x27;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) s[n + <span class="hljs-number">1</span>][i] = <span class="hljs-string">&#x27;#&#x27;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (s[i][j] == <span class="hljs-string">&#x27;#&#x27;</span>) &#123;l = <span class="hljs-number">0</span>; <span class="hljs-keyword">continue</span>;&#125;<br>            <span class="hljs-keyword">if</span> (!l) l = j;<br>            <span class="hljs-keyword">if</span> (s[i][j + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;#&#x27;</span>) &#123;<br>                <span class="hljs-keyword">int</span> len = j - l + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= len / <span class="hljs-number">2</span>; ++k)<br>                    merge(id[i][l + k - <span class="hljs-number">1</span>], id[i][l + len - k]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (s[j][i] == <span class="hljs-string">&#x27;#&#x27;</span>) &#123;l = <span class="hljs-number">0</span>; <span class="hljs-keyword">continue</span>;&#125;<br>            <span class="hljs-keyword">if</span> (!l) l = j;<br>            <span class="hljs-keyword">if</span> (s[j + <span class="hljs-number">1</span>][i] == <span class="hljs-string">&#x27;#&#x27;</span>) &#123;<br>                <span class="hljs-keyword">int</span> len = j - l + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= len / <span class="hljs-number">2</span>; ++k)<br>                    merge(id[l + k - <span class="hljs-number">1</span>][i], id[l + len - k][i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; ++j)<br>            <span class="hljs-keyword">if</span> (s[i][j] != <span class="hljs-string">&#x27;.&#x27;</span>) rep[find(id[i][j])] = s[i][j];<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; ++j) &#123;<br>            ans += (s[i][j] != rep[find(id[i][j])]);<br>            s[i][j] = rep[find(id[i][j])];<br>        &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Case #%d: %d\n&quot;</span>, ++testcase, ans);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; ++j) <span class="hljs-built_in">putchar</span>(s[i][j]);<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> t = rd(); t; --t) work();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h2 id="D-Increasing-Sequence-Card-Game"><a href="#D-Increasing-Sequence-Card-Game" class="headerlink" title="D. Increasing Sequence Card Game"></a>D. Increasing Sequence Card Game</h2><div class="note note-warning">            <p>从 $n!$ 个 $n$ 的全排列中等概率随机一个，问期望有多少个位置 $i$ ，满足 $P_i$ 是 $P_1,\cdots,P_i$ 中的最大值。</p>          </div><p><strong>考虑对每个数分别算贡献</strong>，则数字 $x$ 的贡献就是 $1\times (\ x$ 是所在排列的前缀 $\max$ 的概率 $)$ </p><p>若数字 $x$ 有贡献，则 $x$ 前面只能有小于 $x$ 的数字，考虑枚举 $x$ 前面有 $i$ 个数字：<br>$$<br>p(x) = \frac{\sum_{i=0}^{x-1} {x-1\choose i}i!(n- i - 1)!}{n!} = \sum_{i=0}^{x-1}\frac{(x-1)!(n-i-1)!}{(x-1-i)!n!}<br>=\frac{1}{x}\sum_{i=1}^{x}\frac{x!\times (n-i)!}{ (x-i)!\times n!}<br>$$</p><p>看起来可以配成组合数作比，于是：<br>$$<br>p(x)=\frac{1}{x}\sum_{i=1}^{x}\frac{x!}{(x-i)!}\frac{(n-i)!}{ n!}=\frac{1}{x}\sum_{i=1}^{x}\frac{x!}{i!(x-i)!}\frac{(n-i)!\times i!}{n!}<br>=\frac{1}{x}\sum_{i=1}^{x}\frac{x\choose i}{n\choose i}<br>$$<br>后面的形式非常好看，但是没什么化简的余地 QAQ 我们换一种配凑：</p><p>$$<br>p(x) =\frac{1}{x}\sum_{i=1}^{x}\frac{x!}{n!}\frac{(n-i)!}{(x-i)!}=\frac{1}{x}\sum_{i=1}^{x}\frac{x!(n-x)!}{n!}\frac{(n-i)!}{(x-i)!(n-x)!}=\frac{1}{x}\sum_{i=1}^{x}\frac{n-i\choose n-x}{n\choose x}<br>$$<br>发现分母可以提出来了，而且分子也可以用经典性质化简（组合数一列的和等于右下角）：<br>$$<br>p(x) = \frac{1}{x\times {n\choose x}}\sum_{i=1}^x{n-i\choose n-x} = \frac{n\choose n - x + 1}{x\times {n\choose x}} = \frac{x}{x(n-x+1)} = \frac{1}{n-x+1}<br>$$<br>故答案：<br>$$<br>ans = \sum_{x=1}^n\frac{1}{n-x+1} = \sum_{x=1}^n \frac{1}{x}\approx \ln(n)<br>$$</p><p>随着 $n$ 变大，真实答案和 $\ln(n)$ 的误差不会超过  <code>eps</code> 的要求，证明见<a href="https://codingcompetitions.withgoogle.com/kickstart/round/000000000043585c/000000000085a709#analysis">官方题解</a> 。</p><p>因此只需预处理较小范围，较大范围直接用 <code>log</code> 函数即可。 </p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 10000007</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br> <br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>&#123;<br>    ll x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">bool</span> f = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">char</span> c = getchar();<br>    <span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = getchar()) f |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (; <span class="hljs-built_in">isdigit</span>(c); c = getchar()) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);<br>    <span class="hljs-keyword">return</span> f ? -x : x;<br>&#125;<br><br><span class="hljs-keyword">int</span> testcase;<br><br><span class="hljs-keyword">double</span> ans[N];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br>    ll n = rd();<br>    <span class="hljs-keyword">if</span> (n &lt; N) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Case #%d: %.10lf\n&quot;</span>, ++testcase, ans[n]);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Case #%d: %.10lf\n&quot;</span>, ++testcase, ans[N - <span class="hljs-number">1</span>] + <span class="hljs-built_in">log</span>(n) - <span class="hljs-built_in">log</span>(N - <span class="hljs-number">1</span>));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; N; ++i)<br>        ans[i] = ans[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1.0</span> / i;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> t = rd(); t; --t) work();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>KickStart</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Union-Find Set</tag>
      
      <tag>Constructive Algorithms</tag>
      
      <tag>Combination</tag>
      
      <tag>Probability</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AtCoder Beginner Contest 214</title>
    <link href="/2021/08/14/abc214/"/>
    <url>/2021/08/14/abc214/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><table><thead><tr><th align="center">ID</th><th align="center">A</th><th align="center">B</th><th align="center">C</th><th align="center">D</th><th align="center">E</th><th align="center">F</th><th align="center">G</th><th align="center">H</th></tr></thead><tbody><tr><td align="center">Status</td><td align="center">Done</td><td align="center">Done</td><td align="center">Done</td><td align="center">Done</td><td align="center">Done</td><td align="center">Accepted</td><td align="center">Wating</td><td align="center">Wating</td></tr></tbody></table><h2 id="D-Sum-of-Maximum-Weights"><a href="#D-Sum-of-Maximum-Weights" class="headerlink" title="D. Sum of Maximum Weights"></a>D. Sum of Maximum Weights</h2><div class="note note-warning">            <p>给定一棵树，边有边权。计算所有点对路径上最大边权的权值和，范围 $n\le 10^5$</p>          </div><p>考虑类似 Kruskal 的过程添加树边，则每一条边加入时，对于连通的两个集合间的点对，最大边即为当前边。</p><p>因此在维护并查集的同时维护集合大小即可，贡献为 w $\times$ Size(u) $\times$ Size(v) ，复杂度 $O(n\log n)$ </p><h2 id="E-Packing-Under-Range-Regulations"><a href="#E-Packing-Under-Range-Regulations" class="headerlink" title="E. Packing Under Range Regulations"></a>E. Packing Under Range Regulations</h2><div class="note note-warning">            <p>有 $10^9$ 个盒子，每个盒子只能放一个球。有 $n$ 个球，第 $i$ 个要放在 $[l_i,r_i]$ 的某一个盒子中，问是否有解，范围 $n\le 2\times 10^5$</p>          </div><p>比较经典的贪心，考虑从左往右放，最紧急的需求肯定是右端点最小的。</p><p>按照右端点排序，依次考虑每个需求，尽量往左放，相当于区间查询最靠左的未覆盖位置，然后修改这个位置的覆盖状态。</p><p>实现可以选择动态开点线段树+线段树上区间内二分，我是用的是<strong>并查集维护下一个未覆盖的位置（疯狂的馒头）。</strong></p><p>因为序列有 $10^9$ 长，使用 <code>unordered_map</code> 维护并查集数组，具体实现见代码，复杂度 $O(n\log n)$ 。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><span class="hljs-keyword">int</span> l, r;&#125; c[N];<br><br><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-keyword">const</span> node &amp;a, <span class="hljs-keyword">const</span> node &amp;b) &#123;<br>    <span class="hljs-keyword">return</span> a.r == b.r ? a.l &lt; b.l : a.r &lt; b.r;<br>&#125;<br><br><span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; nxt;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> nxt[x] ? nxt[x] = find(nxt[x]) : x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = rd();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;c[i].l = rd(); c[i].r = rd();&#125;<br>    sort(c + <span class="hljs-number">1</span>, c + <span class="hljs-number">1</span> + n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, pos; i &lt;= n; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (!nxt[c[i].l]) &#123;<br>            nxt[c[i].l] = c[i].l + <span class="hljs-number">1</span>; <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        pos = find(c[i].l);<br>        <span class="hljs-keyword">if</span> (pos &gt; c[i].r) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>); <span class="hljs-keyword">return</span>;&#125;<br>        nxt[pos] = pos + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>AtCoder</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Union-Find Set</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AtCoder Beginner Contest 213</title>
    <link href="/2021/08/08/abc213/"/>
    <url>/2021/08/08/abc213/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Unsolved: 7 / 8 </p><h2 id="E-Stronger-Takahashi"><a href="#E-Stronger-Takahashi" class="headerlink" title="E. Stronger Takahashi"></a>E. Stronger Takahashi</h2><div class="note note-warning">            <p>给定一张 $n\times m$ 的地图，有砖块和空地，要从 $(1,1)$ 到 $(n,m)$ ，可以向四个方向非砖块处走。</p><p>可以使用魔法，将某个 $2\times 2$ 的区域内砖块变为空地，问最小使用次数，数据范围 $2\le n, m\le 500$ 。</p>          </div><p>赛时的做法比较暴力，建图最段路，评测 2 s + 1024 M 的宽松条件放过去了。</p><p>具体的建图是将每个 $2\times 2$ 的区域抽象为一个点，再将这个点拆为入点和出点，中间连 $1$ 代表使用魔法。</p><ul><li><p>对于空地，向四个方向的点连边，代表从当前点移出不需要代价；</p></li><li><p>对于砖块，向所在的四个区域入点连 $0$ 边，相当于强制让砖块进入某个区域使用魔法。</p></li></ul><p>然后每个区域出点向自己包含的 $4$ 个点和周围直接可达的 $8$ 个点连 $0$ 边，代表使用后可达的范围。</p><p>点的级别是 $10^6$ ，边的级别是 $10^7$ ，图比较稀疏 Dijkstra 最短路可以跑过。</p><hr><div class="note note-success">            <p>使用 $0/1$  BFS 处理：花费的代价为 $0/1$ 去走下一步，即边权只有 $0/1$ 两类求最短路。</p><p>采用 <strong>双端队列</strong> <code>deque</code> ，每次取队头是当前最短距离：</p><ul><li><p>每次 $0$ 边扩展的点，最短路距离与当前点相同，放到队头</p></li><li><p>每次 $1$ 边扩展的点，最段路距离不会队尾小，放到队尾</p></li></ul><p>具体的，可以发现<strong>任意时刻队中最多只会有两个不同的距离，且相差为 $1$ ，因此可得最短路的正确性 。</strong></p><p>巧妙的是此时双端队列维护得到的序列，与 Dijkstra 优先队列的效果相同，而维护堆的 $\log$​ 省掉了。</p><p><strong>注意 <code>vis</code> 标记不是入队时打而是出队时打，因为当前点此前可能走 $1$​ 边被入队过</strong>。</p><p>类似的题目： <a class="btn" href="https://atcoder.jp/contests/abc176/tasks/abc176_d"  title="AtCoder" target="_blank">ABC 176D</a> <a class="btn" href="https://atcoder.jp/contests/arc084/tasks/arc084_b"  title="AtCoder" target="_blank">ARC 084D</a> <a class="btn" href="https://codeforces.com/problemset/problem/1064/D"  title="CodeForces" target="_blank">CF 1064D</a> <a class="btn" href="https://codeforces.com/gym/100625/problem/J"  title="CodeForces" target="_blank">GYM 100625 J</a>  <a class="btn" href="https://codeforces.com/blog/entry/22276"  title="CodeForces" target="_blank">Toturial on CodeForces</a></p>          </div><p>在本题中考虑把砖块不可行的约束放到进入该点上，建图就比较显然了：</p><ul><li><p>$0$ 边即为向上下左右移动，<strong>目的地是空地</strong>即可</p></li><li><p>$1$ 边即使用魔法，从某个点使用魔法可达的范围为：以当前点为中心的 $5\times 5$ 的区域抠掉四个角</p></li></ul><p>不需要担心同一个 $2\times 2$​​ 的区域使用魔法超过一次，不会访问同一区域两个点，因为开始可以直接走后一次的点。</p><h2 id="F-Common-Prefixes"><a href="#F-Common-Prefixes" class="headerlink" title="F. Common Prefixes"></a>F. Common Prefixes</h2><p>SA 板子题。</p><h2 id="G-Connectivity-2"><a href="#G-Connectivity-2" class="headerlink" title="G. Connectivity 2"></a>G. Connectivity 2</h2><p>状压DP 比较有意思</p><h2 id="H-Stroll"><a href="#H-Stroll" class="headerlink" title="H. Stroll"></a>H. Stroll</h2><p>没看题，回头看</p>]]></content>
    
    
    <categories>
      
      <category>AtCoder</category>
      
    </categories>
    
    
    <tags>
      
      <tag>0/1 BFS</tag>
      
      <tag>Suffix Array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AtCoder Regular Contest 124</title>
    <link href="/2021/07/26/arc124/"/>
    <url>/2021/07/26/arc124/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="A-LR-Constraints"><a href="#A-LR-Constraints" class="headerlink" title="A. LR Constraints"></a>A. LR Constraints</h2><div class="note note-warning">            <p>给一个数列赋值，值域 $[1,k]$ ，对于每个 $k$ ，约束第一次出现的位置或最后一次出现的位置，求方案数</p>          </div><p>维护一下对于每个位置，当前有多少种方案，复杂度 $O(n)$</p><h2 id="B-XOR-Matching-2"><a href="#B-XOR-Matching-2" class="headerlink" title="B. XOR Matching 2"></a>B. XOR Matching 2</h2><div class="note note-warning">            <p>给定两个长度相同的数列 $A,B$ ，求有哪些 $x$ ，使得将 $B$ 重排后，任意位置 $A_i\ \text{xor}\ B_i = x$ </p>          </div><p>重排后有 $\forall 1\le i,j\le n,\ A_i\ \text{xor}\ B_i=A_j\ \text{xor}\ B_j\Rightarrow A_i\ \text{xor}\ A_j=B_i\ \text{xor}\ B_j$​​​​ </p><p>也就是说，要满足重排后, （$A_i$​​ 与所有其他 $A$​​ 的异或值）与（$B_i$​​ 与所有其他 $B$​​​​ 的异或值）<strong>一一对应</strong></p><p>约束条件很强，我们只需要处理 $A_1$​ 与其他 $A$ 的异或值，然后找可能对应的 $B$ 即可，复杂度 $O(n^2\log n)$​​ </p><h2 id="C-LCM-of-GCDs"><a href="#C-LCM-of-GCDs" class="headerlink" title="C. LCM of GCDs"></a>C. LCM of GCDs</h2><div class="note note-warning">            <p>给定 $n$ 个 pair，每个 pair 中的数一个放入 $A$ 集，另一个放入 $B$​ 集，最大化 $lcm[\ gcd(A),\ gcd(B)\ ]$</p>          </div><p>集合的最大公约数一定是每个数的因子，将第一个 pair 里的两个数求出所有的约数，枚举答案。</p><p>如果存在一种方案使得答案为 $[x,y]$​​ 的倍数，那么对于每个 pair $(a,b)$​​ ，有 $x|a,\ y|b$​ 或者 $x|b,\ y|a$​ ​​</p><p>暴力检验即可，复杂度 $O\big(div(A_{1a})div(A_{1b})n\big)$​</p><h2 id="D-Yet-Another-Sorting-Problem"><a href="#D-Yet-Another-Sorting-Problem" class="headerlink" title="D. Yet Another Sorting Problem"></a>D. Yet Another Sorting Problem</h2><div class="note note-warning">            <p>一个 $n+m$​ 的排列，每次选择前 $n$​ 个中一个和后 $m$​ 个中一个交换，问交换成单位置换所需最少次数</p>          </div><p>如果没有位置选择的限制，还原一个 $n$​​ 的排列所需最少交换次数为 $n\ -$ 排列所对应的环数。</p><div class="note note-success">            <p>将排列 $p$​​ 视作置换，将位置视为点，每个数由当前位置指向目标位置，即建边 $i\to p_i$​​ 得到若干个环。</p><p>我们的目标是让所有的 $i$​ 满足 $i \to i$​ ，即 $\forall i, p_i = i$​ ​变为单位置换。</p><p>因此对于某次交换，操作都会形如将 $p_i$​ 和 $p_{p_i}$​​ 进行交换，也就是将第 $i$ 位的数和第 $p_i$ 位的数交换。</p><p>那么对于原来所在环中的结构 $i\to p_i\to p_{p_i}$​ ，变换后第 $i$​ 个位置上变为 $p_{p_i}$​ ，而第 $p_i$ 位上的数变为 $p_i$​​​ </p><p>也就是说，对于每个环，每次交换相当于将环上的一个 $a\to b\to c$ 结构变为 $a\to c，b\to b$​​​​​ </p><p>目标是形成 $n$​ 个自环，因此每个环需要环长 $-\ 1$​ 次移动才能将环内归位，而不同的环之间还原过程无关。</p>          </div><p>考虑位置选择的限制条件，我们将前 $n$ 个点染成黑色，后 $m$ 个点染成白色。</p><p>可以发现，每次可以操作的约束条件等价于<strong>每次删掉的边要满足连接的两个点颜色不同</strong>。</p><ol><li><p>对于一个由若干段白黑交替连接的环，我们一定可以通过白点吃指向的黑色的点，将整个环变成只剩下一个黑色，然后用这个黑色删掉所有其他白色，总次数为<strong>环长</strong> $-1$​ </p></li><li><p>对于一个只有某一种颜色的环，我们需要考虑“引入”另一种颜色，需要花费一步的代价进行一次交换引入，然后分析如上，此时环长因为引入 $+1$​​ ，因此总次数为<strong>原来环长</strong> $+1$​​</p></li><li><p>考虑都有“引入”需求，但颜色不同的两个单色环，此时某一个环引入对方的某个元素，相当于帮助了对方引入，因此两个环之需要一次“引入” ，并且两个环共享的引入的长度 ，总次数为<strong>第一个环长+第二个环长</strong></p></li></ol><p>综上，对于双色环，我们所需次数为环长 $-1$ ，单色环先默认代价为环长 $+1$ ，每匹配上一对总代价 $-2$ 。</p><p>此外本题无需考虑太过复杂，首先同色单色环之间融合没有意义（可比较前后代价），其次不需要考虑单色环和双色环的融合，这种情况可以看作先将双色环归位，再取某一个长度为 $1$​​​​​​ 的自环与单色环进行融合。</p><p>处理过程中只涉及 dfs 找环，总复杂度 $O(n)$</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> cntl = <span class="hljs-number">0</span>, cntr = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n + m; ++i)<br><span class="hljs-keyword">if</span> (!bl[i] &amp;&amp; i != p[i]) &#123;<br>++tot; dfs(i);<br>ans += len[tot];<br><span class="hljs-keyword">if</span> (l[tot] &amp;&amp; r[tot]) --ans;<br><span class="hljs-keyword">else</span> &#123;l[tot] ? ++cntl : ++cntr; ++ans;&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans - min(cntl, cntr) * <span class="hljs-number">2</span>);<br></code></pre></div></td></tr></table></figure><h2 id="E-Pass-to-Next"><a href="#E-Pass-to-Next" class="headerlink" title="E. Pass to Next"></a>E. Pass to Next</h2><p>比赛没来得及看的题，回头做。</p><h2 id="F-Chance-Meeting"><a href="#F-Chance-Meeting" class="headerlink" title="F. Chance Meeting"></a>F. Chance Meeting</h2><p>比赛没来得及看的题，回头做。</p>]]></content>
    
    
    <categories>
      
      <category>AtCoder</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Sort</tag>
      
      <tag>Conbination</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>热爱生活</title>
    <link href="/2021/07/08/freshman/"/>
    <url>/2021/07/08/freshman/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天是 2021 年 7 月 8 日，星期四。</p><p>一年前的今天，高考最后一门刚刚考完。走出考场，回到自己的教室，拿手机，搬行李，告别。</p><p>离开学校的时候，碰到了还在梳理交通的竞赛教练，问我考的怎么样，然后约了后天要给高一的学弟们上课。</p><p>直到昨晚，暑假回本部给又一届的学弟们上完最后一天课。从二中本部的校门里走出来，回头看看。</p><h2 id="来杭电之前"><a href="#来杭电之前" class="headerlink" title="来杭电之前"></a>来杭电之前</h2><p>高考完就跟爸爸妈妈说我<strong>不复读</strong>，当晚就对答案，大概 645。报了南科大综评，拿到了还算不错的校考分。</p><p>然后在南校区给高一的同学讲了比较入门的概率，也是那些在一年前的暑假认识的，刚踏入二中大门学弟。</p><p>结束的时候在空空的学校里溜达，想想他们上课时候那种纯粹的热情，一代又一代，多少有一点感慨。</p><p>走之前拍了张照片，想起来一句自认为很应景的话：“<strong>雨过天青云破处，者般颜色做将来</strong>”</p><p><img src="/img/EZS.png" alt="连着下了两三天的小雨，只剩下竞赛生的二中"></p><p>出分的晚上比较坦然，提前几分钟查到了分数，比估计的低 9 分，都扣在语文上，115 / 134 / 136 / 251。</p><p>之后的几天比较迷茫，听了几个学校的招生宣讲都不尽如人意。南科大那边几度有希望，后来终究是落空。</p><hr><p>在我想起来杭电这所学校的时候，突然感觉就是要去这里了。</p><p>可能是高二去学军培训喜欢上了杭州这个城市，也可能是对竞赛生涯结束的不甘吧。</p><p>先自己偷偷找 Claris 要到了教练的联系方式，问了读研和专业的事情，刘老师的热情的杭州话让人很舒服。</p><p>然后就是小心翼翼地和父母交流，说我自己的想法和考虑，直到最后心里十分踏实地填上了第一志愿。</p><p>录取的结果是数学系，高考分数达到了卓越学院二次选拔的报名分数线，报了卓越学院的招生考试。</p><p>之后的假期写了几个板子，打了几场 CF 恢复一点水平，参加了 HDU 的几场内部训练，搬了一套题恰烂钱。</p><p>开学之前和岳老师吃了个饭（竟然还赶上了他生日）， 让我重心不要全部放到竞赛上，要给自己留个后路。</p><h2 id="初到杭电"><a href="#初到杭电" class="headerlink" title="初到杭电"></a>初到杭电</h2><p>有一说一假期还是过的比较随意，虽然报名了卓越学院，但是一点没准备，9 月份忐忑地就来到杭电啦。</p><p>考试之前自己很没有底气，当时觉得能进计科班就不错了。考完觉得考的还行，因为竞赛里接触过一点高数线代的知识，觉得自己英语阅读也比较会蒙。然后晚上大概九点的时候出成绩了，震惊自己竟然过了英才班的线。</p><p>晚上给爸爸妈妈很激动地打了个电话，有点担心 11 进 9 被刷掉，一直到十二点多才睡着。</p><p>第二天面试的时候其实自己比较轻松，感觉面试向来都比较稳 <del>比较会吹</del> ，面试单独面，五个老师。</p><p>面试比较自然，老师们的问题基本是跟着我的自我介绍思路走，不过还是有几个问题血压拉满。</p><ol><li><p>我努力地强调自己的竞赛水平，然后冯老师问：“现在让你去打区域赛能拿到什么奖项？”</p></li><li><p>我介绍了一下高中学校和班级的情况，然后另一个老师问：“你觉得二中和衡一哪个更好？”</p></li><li><p>周老师（也是现在的导师）问：“你也不能打一辈子竞赛啊。以后有什么进一步的打算？”<br> 我说会读研，以后可能会去当大学老师。导师笑笑说要想当教授，后面得去好点的大学读书。</p></li></ol><p>面试完出来觉得自己还挺稳的，但是也不敢确定，忐忑到了晚上十点多出了结果。终于还是去学计算机了。</p><p>之后的生活很顺利，见面会，正常上课，班委选举（当了学委）。</p><p>上课的时候强迫自己去提问，回答问题，意识到自己可以做一些 <strong>由自己决定的</strong> <strong>想做什么就做什么</strong> 的事。</p><p>遇到了自己喜欢的老师，有能够舒适相处，真心相待的一帮同学，慢慢地从高三痛苦自闭的状态走出来了。</p><h2 id="竞赛"><a href="#竞赛" class="headerlink" title="竞赛"></a>竞赛</h2><p>这段话也想写给每个学竞赛过程中感到无力的同行者。</p><p><strong>算法竞赛的魅力在于，通过努力积累或灵机一动，你能够做出越来越难的题目，是一种对自我能力的认可。</strong></p><p><strong>算法竞赛的危险亦在于，你学会的东西越多，认识的厉害的人越多，面对不可计数的强者，很容易陷入自我否定。</strong></p><p>想到杭电之前，很长一段时间都觉得，大学不会再打竞赛了。</p><p>学竞赛的过程中经历的打击，不仅是比赛和上课中受到一众神仙居高临下的压迫感，更多的其实是周围人不经意的否定和安慰。对我来说，这是一种对信心很大的打击，会想要证明自己，亦或是心里感到无力而故作轻松。 </p><p>在面临是否买 D 的抉择时，我放弃了。不是担心取得不了什么结果，而是觉得压力太大了。</p><p>在选学校的时候，突然想到杭电的那一刻，有种死灰复燃的感觉。</p><p>记起来 NOIP 2018 结束的时候，在存真楼下，孙校长和我们几个刚从秦皇岛回来的学生说的几句话：</p><p>“学别的竞赛的，最终的发展和竞赛不一定有关系，但是算法竞赛的学生，最终往往都会选择计算机行业。”</p><p><strong>算法竞赛会在心里埋下一颗种子。</strong></p><p><strong>我不是那种一帆风顺的天才，在受到打击的时候，我会感到无力。</strong></p><p><strong>但当我抛开名利、和他人比较、证明自己这些功利的意义之后，我发现自己还剩下些东西，还能看到初心。</strong></p><p><strong>是对算法的欣赏和热爱，是理解每一个算法、做出每一个题目的瞬间，精神上的享受，这就够了。</strong></p><p>至少在我看来，从我开始接触竞赛，到做出很多重要的选择，我决策的初心从来都不是名利，因为对算法还爱着。决定最终没有买 D 类，最大的原因还是在那个时刻，竞赛带来的痛苦超过了学习的享受，被一次次的排名裹挟，被各种机会所吸引，我越来越像一个没有自我的机器，越来越被成功学牢牢锁死。而在我选择大学的时候，竞赛对我的意义不再是未来的全部了。我能够静下来，问问自己对算法还有没有那种近乎痴迷的喜爱，能够将它作为一种兴趣去发展，不需要考虑付出和回报，至少在大学，我还是有自由支配自己的权利。</p><p><strong>我还是那个深深爱着算法的小孩，对几十行代码背后的智慧如痴如醉。</strong></p><hr><ul><li>Gold Medal (30th Place) : The 45th ICPC Asia Jinan Regional Contest, 2020</li><li>Gold Medal ( 15th Place) : The 18th Zhejiang Provincial Collegiate Programming Contest, 2021</li><li>Silver Medal (28th Place) : The 45th ICPC Asia Shenyang Regional Contest, 2021</li></ul><h2 id="课内学习"><a href="#课内学习" class="headerlink" title="课内学习"></a>课内学习</h2><p>第一个学期不会选课，修了系统默认的 25.25 个学分， 第二个学期修了 32.25​ 个学分。</p><p>通识选修只完成了科技发展与科学精神（2/2），大二上应该会把剩下的指标修完。</p><table><thead><tr><th align="center">数理基础 (23)</th><th>数分 （6 * 3.5 + 5 * 4.2）、高代（3 * 5 + 2 * 5）、离散（4 * 5）、大物1（3 * 5）</th></tr></thead><tbody><tr><td align="center">CS专业课 (14)</td><td>计导（2 * 5）、程设基础（5 * 5）、数据结构（4 * 4.5）、C++ 面向对象（3 * 5）</td></tr><tr><td align="center">通识教育 (8)</td><td>思修法基（3 * 5）、心理健康（1 * 4.3）、大军（2 * 4.8）、ACM（2 * 5）</td></tr><tr><td align="center">外语类 (8)</td><td>英语精读 A（2 * 4.4 + 2 * 4.6）、英语听说 A（1 * 4.3 + 1 * 4.7）、实用翻译（2 * 4.6）</td></tr><tr><td align="center">其他 (3.5)</td><td>大学启示录（1 * 4）、形式与政策（0.5 * 5）、科研实践（1 * 5）、体育（1 * 2.1 + 1 * 1.8）</td></tr></tbody></table><p>很幸运的是遇到的老师都很认真负责，老师们对课程内容非常了解，自己遇到问题也都能很好沟通。</p><p>很多课程都觉得自己做的没那么好，对给出的成绩也常常受之有愧。</p><p><strong>数学分析</strong>和<strong>高等代数</strong>两门数学基础课的表现截然相反，让我更清楚地意识到很大程度上我是个兴趣驱动的人。</p><p>对数分的知识体系自己本身可能就不太感兴趣，<del>加上数分课是真的提不起来精神</del>，两个学期的数学分析成绩都不太看的过去，数分上可能要在大三重修了。老师确实想要认真教会我，可是自己确实提不起兴趣去学。经历了数分上的洗礼，数分下还是逼着自己学了学，最后的结果算是马马虎虎吧，确实对不起老师对不起自己。</p><p>很喜欢高代老师的课，很大程度驱动我去花相对比较多的时间在这门课上。两个学期最后的结果都比较好，在自己喜欢的科目上能够看到自己做了些事情，也是让自己很开心的一件事。唯一遗憾的是期末错在了最后一节课老师强调过的一个小点上（证明正定阵需先说明对称）。大二下预定了老师的近世代数。</p><p>也很喜欢 Cathy 上的<strong>英语精读</strong>，也算是第一次能让我主动提起来学英语的兴趣。 Cathy 的课有一种很轻松的气氛，不会按照课本一板一眼的去上，讲的很多东西很受用。</p><p>感谢<strong>程设和OOP（C++）</strong>的老师对我的包容，自己在这两门课上确实有过很幼稚的行为。很佩服将近退休的老师能精确把控很多细节，随手写的代码能一遍过编译什么错都没有。</p><p><strong>离散数学和数据结构</strong> 给了我很深刻的教训。两门都是自认为了解比较多的，<strong>数据结构</strong>甚至申请了免听。考前复习的都不是很充分，等上了考场发现要开始脑补一堆一堆的概念。期末离散卷子简单，没暴露出来什么问题。数据结构觉得自己看看书就够了，最后的成绩却不尽如人意，原因只是不知道排序里的一个既定细节，只能悔不当初。</p><p><strong>大学物理和思想道德修养与法律基础</strong> 两门课结果意外的好，其实自己认真去学一学还是可以有效果的。中学阶段一直头疼的政治在闭卷的期末考试也写了个差不多。学不会电磁在考场上也做出来了绝大多数题。考试遇到不会的题也不能太着急，多想一会没准就通了。</p><p><strong>体育</strong> 从中考的 $18$ 分保底，到大一上的体测 $36$ 分，痛失两个学期的奖学金，终究还是没逃过身体素质不行这个问题。还是感谢环境逼着我去直面体育，按着体能班的要求大一下结结实实把 40 次阳光长跑跑完了，也确实让我看到耐力可以有提升，从操场跑一圈就喘不上气，到体测的时候人生第一次把 1000 米全跑下来，确实是很激动的。也终于在锻炼身体上有了动力，首先是大二下想要和 qyy 同学一起学体育舞，其次是想要恰奖学金。</p><h2 id="我的她"><a href="#我的她" class="headerlink" title="我的她"></a>我的她</h2><p>只想说爱情的体验是一种很纯粹的幸福。</p><p>愿意为她牺牲自己的一切，无时无刻都会想起她的事情，找不到她会坐如针毡，什么都做不下去。</p><p>她所高兴的事情比她还高兴，她难受的时候会跟着一起哭出来，在爱情中两个人都学会了如何照顾对方。</p><p>两个人在一起呆着常常心有灵犀，做事情反应如出一辙，很多事情不用言语。</p><p>两个人在一起呆着就是最快乐的事情，能够一起学习，散步，她在我的身边就能感受到无比的踏实。</p><p>会走到一起的人终究不会分开。心里对未来有着期盼，静下心来踏踏实实做事，继续加油。</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Render Math Equations in Hexo</title>
    <link href="/2019/06/01/mathjax/"/>
    <url>/2019/06/01/mathjax/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>$$<br>f(a) = \frac{1}{2\pi i}\oint_{\gamma}\frac{f(z)}{z-a}dz<br>$$</p><p><a href="https://www.mathjax.org/">Beautiful and accessible math in all browsers - MathJax</a> </p><p>This post is used to check out whether the mathjax plugin (<a href="https://github.com/hexojs/hexo-math">hexo-math</a>) still works.</p><h2 id="Inline-Formula"><a href="#Inline-Formula" class="headerlink" title="Inline Formula"></a>Inline Formula</h2><p>Consider the sequence of $n$ distinct positive integers: $c_1, c_2, \cdots, c_n$. The child calls a vertex-weighted rooted binary tree <strong>good</strong> if and only if for every vertex $v$, the weight of $v$ is in the set ${c_1, c_2, \cdots, c_n}$ . Also our child thinks that the <strong>weight</strong> of a vertex-weighted tree is the sum of all vertices’ weights.</p><p>Given an integer $m$, can you for all $s (1 \le  s ≤ m) $ calculate the number of good vertex-weighted rooted binary trees with weight $s$ ? Please, check the samples for better understanding what trees are considered different.</p><p>We only want to know the answer modulo $998244353$ ( $7 × 17 × 2^{23} + 1$ , a prime number).</p><h2 id="Block-Formula"><a href="#Block-Formula" class="headerlink" title="Block Formula"></a>Block Formula</h2><p>$$<br>\int \frac{dx}{cos^2x}=\int sec^2xdx=tan x+C\<br>$$</p><p>$$<br>\int \frac{dx}{sin^2x}=\int csc^2xdx=-cot x+C\<br>$$</p><p>$$<br>\sum\limits_{i = 0}^{E} w[i]{M \choose i} {N \choose iS} \frac{(iS)!}{(S!)^{i}} \sum\limits_{j = 0}^{E - i} (-1)^{j} {M - i \choose j} {N - iS \choose jS} \frac{(jS)!}{(S!)^{j}} (M - i - j)^{N - iS - jS}<br>$$</p><p>$$<br>= \sum\limits_{i = 0}^{E} w[i]{M \choose i} {N \choose iS} \frac{(iS)!}{(S!)^{i}} \sum\limits_{j = i}^{E} (-1)^{j - i} {M - i \choose j - i} {N - iS \choose jS - iS} \frac{(jS - iS)!}{(S!)^{j - i}} (M - j)^{N - jS}<br>$$</p><h2 id="Matrix"><a href="#Matrix" class="headerlink" title="Matrix"></a>Matrix</h2><p>$$<br>\begin{bmatrix}<br>(\omega_n^0)^0 &amp; (\omega_n^0)^1 &amp; \cdots &amp; (\omega_n^0)^{n-1}\\ (\omega_n^1)^0 &amp; (\omega_n^1)^1 &amp; \cdots &amp; (\omega_n^1)^{n-1}\\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>(\omega_n^{n-1})^0 &amp; (\omega_n^{n-1})^1 &amp; \cdots &amp; (\omega_n^{n-1})^{n-1}<br>\end{bmatrix}<br>\begin{bmatrix}<br>a_0 \\<br>a_1 \\<br>\vdots \\<br>a_{n-1}<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>A(\omega_n^0) \\<br>A(\omega_n^1) \\<br>\vdots \\<br>A(\omega_n^{n-1})<br>\end{bmatrix}<br>$$</p><p>$$<br>\begin{bmatrix}<br>a_0 \\<br>a_1 \\<br>\vdots \\<br>a_{n-1}<br>\end{bmatrix}<br>=<br>\frac{1}{n}<br>\begin{bmatrix}<br>(\omega_n^{-0})^0 &amp; (\omega_n^{-0})^1 &amp; \cdots &amp; (\omega_n^{-0})^{n-1} \\<br>(\omega_n^{-1})^0 &amp; (\omega_n^{-1})^1 &amp; \cdots &amp; (\omega_n^{-1})^{n-1} \\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>(\omega_n^{-(n-1)})^0 &amp; (\omega_n^{-(n-1)})^1 &amp; \cdots &amp; (\omega_n^{-(n-1)})^{n-1}<br>\end{bmatrix}<br>\begin{bmatrix}<br>A(\omega_n^0) \\<br>A(\omega_n^1) \\<br>\vdots \\<br>A(\omega_n^{n-1})<br>\end{bmatrix}<br>$$</p><div class="note note-warning">            <p>To prevent escaping, you need to use <code>\\\\</code> to make a new line rather than <code>\\</code> .</p>          </div><div class="note note-success">            <p>For more about the Mathjax symbols, refer to <a href="/material/mathjax-symbol-list.pdf">The Comprehensive LaTeX Symbol List</a> .</p>          </div>]]></content>
    
    
    <categories>
      
      <category>Blog</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2018/11/29/hello-world/"/>
    <url>/2018/11/29/hello-world/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>「 Hello, the lovely world. 」</p><p>「 Stay hungry, Stay foolish. 」</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> this<br>The Zen of Python, by Tim Peters<br><br>Beautiful <span class="hljs-keyword">is</span> better than ugly.<br>Explicit <span class="hljs-keyword">is</span> better than implicit.<br>Simple <span class="hljs-keyword">is</span> better than complex.<br>Complex <span class="hljs-keyword">is</span> better than complicated.<br>Flat <span class="hljs-keyword">is</span> better than nested.<br>Sparse <span class="hljs-keyword">is</span> better than dense.<br>Readability counts.<br>Special cases aren<span class="hljs-string">&#x27;t special enough to break the rules.</span><br><span class="hljs-string">Although practicality beats purity.</span><br><span class="hljs-string">Errors should never pass silently.</span><br><span class="hljs-string">Unless explicitly silenced.</span><br><span class="hljs-string">In the face of ambiguity, refuse the temptation to guess.</span><br><span class="hljs-string">There should be one-- and preferably only one --obvious way to do it.</span><br><span class="hljs-string">Although that way may not be obvious at first unless you&#x27;</span>re Dutch.<br>Now <span class="hljs-keyword">is</span> better than never.<br>Although never <span class="hljs-keyword">is</span> often better than *right* now.<br>If the implementation <span class="hljs-keyword">is</span> hard to explain, it<span class="hljs-string">&#x27;s a bad idea.</span><br><span class="hljs-string">If the implementation is easy to explain, it may be a good idea.</span><br><span class="hljs-string">Namespaces are one honking great idea -- let&#x27;</span>s do more of those!<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Blog</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title></title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
  </entry>
  
  
  
</search>
