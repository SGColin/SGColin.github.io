{"meta":{"title":"Yixiong Gao","subtitle":"a junior interested in TCS and CP.","description":null,"author":"Colin Gao","url":"http://blog.gyx.me","root":"/"},"pages":[{"title":"","date":"2023-09-24T17:34:02.790Z","updated":"2023-04-14T05:45:24.939Z","comments":false,"path":"about/index.html","permalink":"http://blog.gyx.me/about/index.html","excerpt":"","text":""},{"title":"Colin's Diary","date":"2023-04-14T09:13:03.000Z","updated":"2023-04-16T14:29:32.870Z","comments":true,"path":"diary/index.html","permalink":"http://blog.gyx.me/diary/index.html","excerpt":"","text":"你好呀，这里是 Colin 的流水账日记和一些小想法。 如果你能找到这里，估计你现在也挺无聊的，四处逛逛吧！相信你能找到有意思的事情。 Link: Spring 2023"},{"title":"Colin's Diary - Spring 2023","date":"2023-04-14T09:13:03.000Z","updated":"2023-04-21T01:28:19.803Z","comments":true,"path":"diary/spring2023.html","permalink":"http://blog.gyx.me/diary/spring2023.html","excerpt":"","text":"March 2023 / 03 / 06 陪 Eva 同学去看脸伤，卡着两点之后去吃了顿海底捞，学生 69 折还挺爽的。 路上看到 Bank of China ，我说我是 Bank of Eva ，Eva 说她是 Bank of Colin : ) 2023 / 03 / 07 上午讨论班，讲完综述ppt之后，和老师讨论得出结论，这个问题我们做不了（） 老师说重点在找到自己有想法的问题，感觉自己对科研能否有产出的焦虑日益增加，反而静不下心来... 2023 / 03 / 08 妇女节 半夜拉肚子好几回，早上烧起来了，感觉人有点飘，就去医院了。 到了发热门诊一量，39.9，医生直接让我先把退烧药吃上。差点就40了，还准备发个说说呢。 流感检测采样走的是鼻子，有点痛。医生听到我没得过新冠的时候愣了一下，然后确认了好几遍。。。 抽完血，坐在大厅等结果，又困又飘，跟 Eva 开玩笑说要是新冠阳了我体测直接申请免测 : ) 出来结果不是流感，除了白细胞高以外别的指标都贼健康，甚至比我入学体检还健康，看来是逃不过体测了。 退烧药起效后觉得自己又行了，下午直接 VP ！然后又烧起来了开始飘，开摆。 晚上腹泻加剧自己去买了盒蒙脱石散，感觉明天也很难过啊。 2023 / 03 / 09 腹泻发烧，但是不是流感不是新冠，貌似就是急性肠胃炎引起的？？ 下午无心学习，跟 Eva 一起打个 Div.2 愉悦身心，连最短路都不会做了。。。 EC-Final April 2023 / 04 / 01 愚人节 去打工，我说今天的题很简单，小孩们说老师我们都知道今天是愚人节 😂 2023 / 04 / 02 下午训练疯狂手误罚时爆炸，老年选手码力是真不行了。。 晚上接爸爸妈妈来杭州！去钱塘江边（下沙拐角处）逛了一圈，离谱的是河道里竟然没水？？？ 2023 / 04 / 03 昨天晚饭吃的比较性寒，加上江边风大又给干急性肠胃炎了。。。 早上起来上吐下泻，上午的课干脆翘了在寝室睡觉。下午缓过来了带小 Eva 去见了爸爸妈妈！ 晚上一起在 in77 吃了青花椒砂锅鱼，然后绕着湖走了一个多小时去看西湖印象，不得不说艺谋是真的懂浪漫！ 小 Eva 第一次见家长貌似顺利完成了 : ) 2023 / 04 / 04 今天带爸爸妈妈把杭电算是完整的转了一圈： 东南门 - 月雅湖 - 小花园 - 四教 - 三鼎问天 - 三教 - 操场 - 学活 - 七教 - 六教 - 八教（实验室） - 体育馆 - 生活区操场 - 食堂！ 美食城的饭竟然能让爸爸满意，开心 : ) 2023 / 04 / 07 出发去长沙参加 ORSC 2023！ 9:40 下课赶 10:25 的高铁，地铁出站到高铁检票口冲刺了 5min 比跑 1km 还累，好在赶上了（当天其他票都没了）。 下午报道入住之后，四个人偷偷去宾馆旁边的湖玩，然后开了船！除了有点冷体验良好，第一次开船非常刺激。 2023 / 04 / 08 上午是合照，然后观看学会给各位院士颁奖。 中午宾馆外的草坪在举办婚礼，感觉很有意思，开场所有的伴郎伴娘一起跳了一支舞。 下午出发的时候发现婚礼的蛋糕没被分完，直接一人切了一块（感谢新郎新娘的无私馈赠）。 下午的大会报告我竟然听懂了？？？虽然只是听几位教授简单介绍自己的工作，但是还是很开心没有罚坐。 晚上在宾馆开摆。本来打算打一下十点的 cf 但是实在太累了就睡了。。 2023 / 04 / 09 上午的新老论坛十分有趣，成功的前辈们都在强调学术品位和工作质量，但年轻的老师们都在提问基金申请相关的问题。。 对于大家十分实际的提问和前辈们在强调的兴趣和品位，张老师表示：上岸的不懂还泡在水里的痛苦～ 收获：1. 前期多读顶会顶刊，尽量避免看水刊，培养学术品位。2. 博士毕业别着急入职，多做几年博士后，自由 + 积累实力。 下午去了橘子洲，湘江两岸景色很好，环岛走了一个小多小时终于和心心念念的毛爷爷像合影啦！ 晚饭是高铁上的麦当当，和小 Eva 一起吃了一个奥利奥麦旋风，2023的第一个冰激凌～ 2023 / 04 / 10 下午团支部大会结束之后商量团建的事情。 觉得最近天气不错，于是决定来一场说走就走的旅行！一起去千岛湖！ 讨论了一下直接定在下周二，晚上就直接开始收集大家的意向了。 这可能就是年轻的好处吧，不用考虑太多，想到了就可以去做。 2023 / 04 / 11 上午的讨论，张老师把之前想的算法近似比证出来了，感觉自己花的时间确实有点少。。。 下午训练发现 cf 爆炸了，去 QOJ 打了 ICPC 湾湾省赛，各种手误十分担心省赛状态。 2023 / 04 / 12 早上的阳光长跑终于启动啦！ 团建最终有 15 人报名，超过了预计的一半，大家都愿意来参与还是很开心的。 下午商量好了去千岛湖团建的具体内容，给大家一起买了高铁票，希望团建一切顺利吧。 2023 / 04 / 13 博弈论课听的有点蒙，感觉得找时间自己去看看 Tim Roughgarden 的算法博弈论。 晚上组会准备了一些东西，但最后也没轮到我讲，嗐。。。最重要的还是自己多总结吧。 2023 / 04 / 14 昨晚 emo 到太晚了，直接睡过了早八课（with Eva presentation 的 ppt）。。。 然后小 Eva 今天来例假了，没精神心情好像也不太好，不敢惹不敢惹。。。 下午听了一个 CCFAI 多智能体协同的在线会议，李老师也在，讨论了很多关于研究如何落地的问题。 矛盾的是，感觉自己决定去做学术有很大一部分的原因是想远离工业圈。。。 2023 / 04 / 15 省赛日，杭师大好大，从考场到食堂骑车都要十分钟。 退役之战了，也没啥心理压力，但是比赛体验实在是差，见 知乎链接 。 最后亚军也算是比较好的结局了，但是触手可及的杯着实让我难以释怀（ 但是算法竞赛总是有遗憾的嘛，人生也是如此，是时候前往一下个阶段了。 2023 / 04 / 16 今天被神秘人士告知昨天省赛的 J 再调一调参数我队可能就过了。。。 好不容易找回来的心态又大破防了一次，难顶。在杭图摆烂睡了一下午。 最难接受的是我都决定要退役了又告诉我这种消息，心有不甘啊。。。 2023 / 04 / 18 团建出发去千岛湖！"}],"posts":[{"title":"Anton Trygub Contest (1st Universal Cup, Stage 4: Ukraine)","slug":"official/ucup/1/4/sol","date":"2023-11-29T16:00:00.000Z","updated":"2023-12-07T11:05:19.971Z","comments":true,"path":"official/ucup/1/4/sol/","link":"","permalink":"http://blog.gyx.me/official/ucup/1/4/sol/","excerpt":"","text":"Overview Links: 补题链接, 题面, 官方题解 ID Difficulty (0-5) Topic Status Code A 0 Greedy Solved A.cpp B 3 Counting Solved B.cpp C D 1 Constructive Algorithms, Shortest Path Solved D.cpp E 1 Constructive Algorithms Solved E.cpp F 2 Constructive Algorithms, Brute Force Solved F.cpp G 4 Bitmasks, DP Upsolved G.cpp H I 2 Counting, DP Solved I.cpp J 3 Inversions Solved J.cpp K 0 DFS Solved K.cpp L M N A. Adjacent Product Sum 重排一个环形数列，最大化重排后的相邻两数乘积之和。 由排序不等式，感性理解一下应该是大的挨在一起，小的挨在一起。 所以排序之后左右交替放就行了，复杂度 \\(O(n\\log n)\\) 。 *B. Binary Arrays and Sliding Sums 给定 \\(n,k\\) , 考虑所有长度为 \\(n\\) 的二进制序列 \\(a_0,a_2,\\dots,a_{n-1}\\) : 令 \\(f_i=\\sum_{j=0}^{k-1}a_{(i+j)\\mod n}\\) 得到序列 \\(f_0,f_1,\\dots,f_{n-1}\\) ，求有多少个本质不同的 \\(f\\) 。 \\(T\\ (T\\le 10^5)\\) 组询问，每次问一对 \\(n,k\\ (2 \\le k &lt; n \\le 10^6 )\\) 。 下述过程中，所有下标均在模 \\(n\\) 意义下。 有 \\(a_i-a_{i-k}=f_i-f_{i-1}\\in[-1,1]\\) ，当不为 \\(0\\) 时一定能确定 \\(a_i\\) 和 \\(a_{i-k}\\) 的取值，否则两者可能同为 \\(0\\) 或同为 \\(1\\) 。 按照间隔为 \\(k\\) 分组，会分成 \\(g=gcd(n,k)\\) 个“环”，每个环长为 \\(n/g\\) 。 每个环中只要有一个位置能确定（有一个 \\(f_i-f_{i-1}\\neq 0\\) ），整个环的取值都能确定。 考虑每个环对 \\(f\\) 的贡献，容易发现对于每连续 \\(k\\) 个位置，每个环都恰好占走了 \\(k/g\\) 个位置。 因此对于某个 \\(a\\) 数列，我们去考虑和他 \\(f\\) 数组一致（冲突）的数列的特征，按照环考虑： 对于可以从 \\(f\\) 唯一确定的环，显然这些位置必须和 \\(a\\) 保持一致。 否则是全 \\(0\\) / 全 \\(1\\) 环（称作特殊环），由于每个环对 \\(f\\) 的贡献位置个数一致，所以只要全 \\(1\\) 环的“环个数”一致即可。 因此我们按 \\(f\\) 划分出等价类：特殊环位置的集合一致（个数+下标），全 \\(1\\) 环的个数一致，非特殊环对应位置完全一致。 因此对应特征计数：枚举特殊环数 \\(k\\) ，特殊环下标集选法 \\({g\\choose k}\\)，全 \\(1\\) 环个数选法 \\((k+1)\\) ，非特殊环方案数 \\((2^{n/g}-2)^{g-k}\\) 。 \\[ \\begin{array}{ll} ans &amp;= \\sum_{k=0}^g(k+1){g\\choose k}(2^{n/g}-2)^{g-k}\\\\ &amp;= \\sum_{k=0}^g{g\\choose k}(2^{n/g}-2)^{g-k}+ \\sum_{k=0}^g k\\times \\frac{g!}{k!(g-k)!}\\times (2^{n/g}-2)^{g-k}\\\\ &amp;= \\sum_{k=0}^g{g\\choose k}(2^{n/g}-2)^{g-k}+ g\\sum_{k=1}^g {g-1\\choose k-1}\\times (2^{n/g}-2)^{g-k}\\\\ &amp;=((2^{n/g}-2) + 1)^g + g\\times ((2^{n/g}-2) + 1)^{g-1} \\end{array} \\] 快速幂计算即可，复杂度 \\(O(T\\log n)\\) 。 D. Distance Parities 一个 \\(n\\ (n\\le 500)\\) 个点的无向图，给定任意两点最短路奇偶性，构造一个图符合要求。 构造一个图 \\(G\\) ：对于任意两点，给定性质中如果要求是奇数距离就给两点间加一条边，否则不加。 证明：这个图 \\(G\\) 符合要求 \\(\\Leftrightarrow\\) 存在一个图 \\(G&#39;\\) 符合要求。 左推右显然，证明右推左，若 \\(G&#39;\\) 符合要求，那么对于任意点对 \\(u,v\\) ： 若距离为奇数，则在 \\(G\\) 中两点距离为 \\(1\\) 符合要求； 若距离为偶数，则必然存在一个点 \\(w\\) ，在 \\(G&#39;\\) 中到两个点距离为奇数（例如 \\(u\\to v\\) 最短路上，除掉 \\(u,v\\) 的第一个点），则在 \\(G\\) 中 \\(w\\) 和两个点都有一条边，因此 \\(G\\) 中两点距离为 \\(2\\) 符合要求。 因此判断 \\(G\\) 是否合法即可，Floyd-Warshall 复杂度 \\(O(n^3)\\) 。 E. Excellent XOR Problem 长度为 \\(n\\ (n\\le 10^5)\\) 的数列 \\(a_i\\ (0\\le a_i&lt; 2^{30})\\) ，将数列划分成多于一段，使得每段异或和两两不同。 如果全部异或和不为 \\(0\\) ，任意切分两段异或和不同。 否则考虑从左往右第一个不为 \\(0\\) 的数字 \\(a_x\\) ： 对于某个 \\(p\\in[x+1,n-1]\\) ，如果 \\([x+1,p]\\) 异或和不为 \\(0\\) 也不为 \\(a_x\\) ，那么找到了一种分三段的方法。 否则，数列中除了 \\(0\\) 以外，是偶数个 \\(a_x\\) ，这种情况一定无解。 所以找到 \\(a_x\\) 之后扫一遍就可以了，复杂度 \\(O(n)\\) 。 F. F*** 3-Colorable Graphs 给一个连通二分图 \\(K_{n,m}\\ (2\\le n,m\\le 10^4)\\)，问最少加多少边使得这个图不能三染色。 不加边，二分图可以二染色。 加一条边，随便把这条边的一个端点染成第三种颜色就保证了相邻不同，此时可以三染色。 加两条边，如果有公共点，把一个公共点染成第三种颜色；否则四个不同的端点如果构成了 \\(K_4\\) ，则需要四染色，否则四个点中至少有一对点没有边相连，把这两个点都染成第三种颜色后，其他维持二分图染色不变，依然可以三染色。 加三条边，因为是连通二分图且两侧都有至少两个点，必定存在长度为 \\(3\\) 的链，必能补成 \\(K_4\\) ，需要四染色。 因此如果能加两条边补出 \\(K_4\\) 答案就是 \\(2\\) ，否则答案是 \\(3\\) 。 因为二分图中不能有奇环，因此唯一的情况是图中存在四元环。 考虑暴力，枚举左侧点 \\(u\\) ，枚举 \\(u\\) 的邻居 \\(v\\) ，枚举 \\(v\\) 的邻居 \\(u&#39;\\) ，当 \\(u&#39;\\neq u\\) 时对 \\(u&#39;\\) 累加计数器。 当遇到一个 \\(u&#39;\\) 被累计了两次的时候，就找到了答案。否则不存在四元环。 暴力复杂度是对的，对于每个 \\(u\\) ，每个 \\(u&#39;\\) 只会枚举到 \\(O(1)\\) 次，否则找到答案结束，因此复杂度是 \\(O(n^2)\\) 的。 当然也可以直接上四元环计数，复杂度 \\(O(m\\sqrt{m})\\) 。 *G. Graph Problem With Small n 给一个 \\(n\\ (2\\le n\\le 24)\\) 个点的无向图，判断是否任意点对间存在从一个出发另一个结束的哈密顿路径。 设 \\(dp[S][u][v]=0/1\\) 表示经过的点集为 \\(S\\) ，起点为 \\(u\\) 终点为 \\(v\\) 的路径是否存在，这个dp是 \\(O(n^32^n)\\) 的。 进一步设 \\(dp[S][u]\\) 表示经过点击为 \\(S\\) ，起点为 \\(u\\) 的可能的终点集合，新 dp 的值相当于之前 dp 的值的状压。 初始化 \\(dp[\\{u\\}][u] = \\{u\\}\\) ，求 \\(dp[S][u]\\) 时考虑第一步走 \\(u\\to v\\) ，那么方程是： \\[ dp[S][u] = \\bigcup_{v\\in S} dp[S/\\{u\\}][v] \\] 枚举 \\(S,u\\) 之后枚举 \\(u\\) 邻居 \\(v\\) ，现在复杂度降低到了 \\(O(n^22^n)\\) 。 换个思路，直接考虑有哪些 \\(v\\) 在 \\(dp[S][u]\\) 中，我们考虑路径的最后一步 \\(w\\to v\\) ，需要保证 \\(w\\) 在 \\(S/\\{v\\}\\) 对应状态的可能终点中（即 \\(dp[S/\\{v\\}][u]\\) 中），并且 \\(w\\) 和 \\(v\\) 有边相连。 预处理每个人的邻居集 \\(N_i\\) ，条件等价于 \\(dp[S/\\{v\\}][u]\\) 和 \\(N_v\\) 有交，即方程是： \\[ dp[S][u] = \\bigcup_{dp[S/\\{v\\}][u]\\ \\cap\\ N_v\\neq \\emptyset} \\{v\\} \\] 枚举 \\(S,u,v\\) 判断是 \\(O(1)\\) 的，因此这个转移的思路复杂度也是 \\(O(n^22^n)\\) 的。 这个转移的好处是 \\(dp[S][u]\\) 的值只依赖于 \\(dp[*][u]\\) ，换句话说，可以 \\(O(n2^n)\\) 求出对某个特定 \\(u\\) 的所有 dp 值。 考虑 \\(O(n2^n)\\) 求出所有的 \\(dp[*][0]\\) ，即从 \\(0\\) 出发的所有可能的集合的可能的终点。 考虑一条 \\(u\\) 开始 \\(v\\) 结束的哈密顿路径，必定经过 \\(0\\) ，点集可以拆成两段 \\(S\\) 和 \\(U/S \\cup \\{0\\}\\) （互补集合都加上 \\(0\\) ）。 因此对于 \\(dp[S][0]\\) 中的每个点 \\(u\\) ，都可以和 \\(dp[U/S\\cup\\{0\\}][u]\\) 中的每个点 \\(v\\) 匹配。 再次使用状压的思路，设 \\(ans[u]\\) 表示 \\(u\\) 出发可能的哈密顿路径终点集合。 枚举 \\(S\\) ，枚举 \\(S\\) 中的点 \\(u\\) ，令 \\(ans[u] = ans[u] \\operatorname{or} dp[U/S\\cup\\{0\\}]\\) 即可。 这样总复杂度神奇的降到了 \\(O(n2^n)\\) ，空间复杂度 \\(O(2^n)\\) 。 由于 1s 需要的计算量达到了 2e8 所以需要比较精细的实现，实测不同的实现方法常数甚至有 5 倍的差距。 可能的卡常方法： \\(S\\) 不包含 \\(0\\) 的状态是没有用的，所以可以删去一半的集合，\\(2^n\\to 2^{n-1}\\) 卡掉一半的常数。 多使用位运算及 __builtin 系列函数加快枚举集合内元素，而不直接 \\(O(n)\\) 枚举： 1for (int ts = S, v; ts; ts &amp;= ~-ts) v = __builtin_ffs(ts) - 1; I. Increasing Grid 一个 \\(n\\times m\\ (1\\le n\\times m\\le 2\\times 10^5)\\) 的矩阵，每个位置的数字在 \\(1\\sim n+m\\) 之间。 现给定一些位置的取值，问其他位置有多少种不同的合法填法，使得每行从左往右递增，每列从上到下递增。 观察发现 \\(A_{ij}\\) 的值只能是 \\(i+j-1\\) 或 \\(i+j\\) ，选了 \\(i+j-1\\) 左上角的所有数字就确定了，否则右下角所有数字都确定了。 因此所有数字分成两类，一类能推出所有左上角，一类能推出所有右下角，先把冲突无解的情况判掉。 因此存在一个从左下到右上的分界线，每次向上或向右，计数矩阵填法等价于计数分界线选法。 处理出来每个位置是必定在左上/必定在右下/都可以，然后从左下向右上dp分界线方案数，复杂度 \\(O(n\\times m)\\) 。 注意一个位置如果上方必须是边界就不能往右延伸了。 *J. Jewel of Data Structure Problems 给定一个排列 \\((1\\le n,q \\le 2\\times 10^5)\\)，支持交换两个位置，查询最长的子序列，其逆序对数为奇数。 结论大杂烩。 整体逆序数为 \\(0\\) 的情况（排列为 \\(1,2,\\dots,n\\) ），答案为 \\(-1\\) 。 如果整个排列逆序对数为奇数，答案是 \\(n\\) 。 否则考虑每个数 \\(p_i\\) 产生的逆序对数 \\(c_i\\) （前面比他大的个数+后面比他小的个数），如果存在一个 \\(c_i\\) 是奇数，删掉对应的 \\(p_i\\) 即可，答案是 \\(n-1\\) 。 否则所有 \\(c_i\\) 都是偶数，考虑序列中的任意一个逆序对 \\((p_i,p_j)\\) ，这个逆序对在 \\(c_i,c_j\\) 中都被考虑了一次，所以把这两个位置删掉，逆序对的减少量一定是奇数，所以答案最差 \\(n-2\\) 。 于是只需要维护： 当前逆序数是否为 \\(0\\) （排列是否为 \\(1,2,\\dots,n\\) ）：维护 \\(p_i\\neq i\\) 的个数，交换两个操作下可以 \\(O(1)\\) 维护。 总逆序数奇偶性：考虑交换 \\(p_i,p_j\\) ，容易发现 \\(p_k\\ (k\\in (i,j))\\) 参与的逆序对数奇偶性不会发生变化（按值和 \\(p_i,p_j\\) 的关系分三段讨论），而 \\(p_i,p_j\\) 的交换必然导致增加/删除了一个由 \\(p_i,p_j\\) 构成的逆序对，因此每次操作总逆序数奇偶性一定改变，即交换两个元素排列的奇偶性一定改变。而一个排列可以通过 \\(n-\\) 环数次交换变成 \\(1,2,\\dots,n\\) ，所以其逆序对数的奇偶性与 \\(n-\\) 环数相同，初始化复杂度 \\(O(n)\\) 。 是否有一个 \\(c_i\\) 为奇数（所有的 \\(c_i\\) 的奇偶性）：考虑 \\(c_i\\) 的计算方法，假设 \\(i\\) 前面比 \\(p_i\\) 大的数字有 \\(x\\) 个，那么 \\(c_i=x+[p_i-1-(i - 1 - x)]=2x+p_i-i\\) ，所以 \\(c_i\\) 的奇偶性只和 \\(i,p_i\\) 有关，只有交换两个的操作可以 \\(O(1)\\) 维护。 总复杂度 \\(O(n+q)\\) ，不需要任何数据结构，实在优雅。 K. King of Swapping 对于 \\(n\\) 的排列，给定 \\(m\\) 个操作 \\(a_i,b_i\\) 代表如果 \\(p_{a_i}&gt;p_{b_i}\\) 则可以交换这两个数。 问使用给定的操作任意多次，是否能把任意一个 \\(n\\) 的排列变成任意另一个 \\(n\\) 的排列。 其实是问能否交换任意两个位置（反证即可），把操作看成有向边，也就是要判断图是否强连通。 判一下原图和反图 \\(1\\) 是否都能到所有点即可（这是整个图强连通的等价命题），复杂度 \\(O(n)\\) 。","categories":[{"name":"Official Contests","slug":"Official-Contests","permalink":"http://blog.gyx.me/categories/Official-Contests/"}],"tags":[]},{"title":"Training Records - Minming Fan Club","slug":"summary/minming-fan-club","date":"2023-08-31T16:00:00.000Z","updated":"2023-10-22T00:17:46.260Z","comments":true,"path":"summary/minming-fan-club/","link":"","permalink":"http://blog.gyx.me/summary/minming-fan-club/","excerpt":"","text":"Season: 2023-2024 (the 48th ICPC &amp; the 9th CCPC) Team Members: Yixiong GAO(G), Zhehan YU(YU), Shangkun ZHENG(Z), Yu HE(H), Fangzhao YAN(YA). Contests Date Contest Team Rank Solved Award 2023/09/23 2023-2024 ICPC Asia EC Online II G,YU,YA 71 / 2339 7 / 13 - 2023/10/28 IEEE Xtreme 17.0 G,YU,Z 11 / 7091 19 / 26 Hong Kong Championship 2023/11/05 2023 CCPC Harbin Onsite G,YU,Z 14 / 244 6 / 13 Gold Medal 2023/11/12 2023 CCPC Shenzhen Onsite G,YU,Z 85 / 268 4 / 13 Bronze Medal 2023/11/19 2023 ICPC Asia Macau Regional (Observer) G,YU 17 / 77 5 / 11 Quickest Solver of E &amp; J 2023/12/04 2023 ICPC Asia Jinan Regional G,YU,H 45 / 346 7 / 13 Silver Medal Virt. Contests Date Contest Team Solved UpSolved 2023/09/19 2018-2019 ICPC Asia Jiaozuo Regional G,YU 7 / 12 7 / 12 2023/09/21 2019-2020 ICPC Southeastern European Regional G,YU,YA 7 / 11 7 / 11 2023/09/26 2020-2021 ICPC Asia Seoul Regional G,YU 9 / 12 9 / 12 2023/09/27 2022-2023 ICPC Asia Manila Regional G,YU,Z 10 / 12 10 / 12 2023/09/30 2021-2022 ICPC Southwestern European Regional G,YU,YA 9 / 12 9 / 12 2023/10/12 COMPFEST 13 - Finals G,H,Z 10 / 13 10 / 13 2023/10/14 COMPFEST 14 - Preliminary G,YU,Z 10 / 13 10 / 13 2023/10/17 2022-2023 ICPC Asia Shenyang Regional G,YU 5 / 13 6 / 13 2023/10/19 2018-2019 ICPC Asia East Continent Finals G,YU,Z 4 / 12 4 / 12 2023/10/20 2020-2021 ICPC NERC Southern and Volga Russian Regional G,YU,Z 13 / 14 13 / 14 2023/10/21 2017-2018 ICPC Asia East Continent League Finals G,YU,Z 9 / 13 9 / 13 2023/10/30 2023年中国大学生程序设计竞赛女生专场 G,YU,Z 9 / 12 9 / 12 2023/11/01 2020 CCPC Finals G,YU,Z 6 / 13 6 / 13 2023/11/10 2023 CCPC Guilin Onsite G,YU,Z 6 / 13 7 / 13 2023/11/22 2022-2023 ICPC Central Europe Regional G,YU,H 7 / 13 8 / 13 2023/11/25 2023-2024 ICPC Asia Nanjing Regional G,YU,H 7 / 13 7 / 13 2023/11/26 2023-2024 ICPC Southwestern European Regional G,YU,YA 6 / 13 6 / 13 2023/11/29 Anton Trygub Contest 1 (The 1st UCup, Stage 4: Ukraine) G,YU,H 8 / 14 8 / 14","categories":[{"name":"Summary","slug":"Summary","permalink":"http://blog.gyx.me/categories/Summary/"}],"tags":[]},{"title":"Basic Algebra I : Monoids and Groups","slug":"abstract-algebra/monoids-and-groups","date":"2023-02-02T03:21:07.000Z","updated":"2023-04-14T05:43:20.336Z","comments":true,"path":"abstract-algebra/monoids-and-groups/","link":"","permalink":"http://blog.gyx.me/abstract-algebra/monoids-and-groups/","excerpt":"","text":"Concepts from Set Theory THE POWER SET OF A SET Power Set \\(\\mathscr{P}(S)=\\{s|s\\subseteq S\\},\\ |\\mathscr{P}(S)|=2^{|S|}\\) . THE CARTESIAN PRODUCT SET. MAPS Cartesian Product Set \\(S\\times T = \\{(s,t)|s\\in S, t\\in T\\},\\ |S\\times T| = |S||T|\\) . Map of a set \\(S\\) into a set \\(T\\) ( \\(S \\stackrel{\\alpha}{\\rightarrow} T\\) ) : domain \\(S\\) , co-domain \\(T\\) , a subset \\(\\alpha\\) of \\(S\\times T\\) having properties: For any \\(s \\in S\\) there exists a \\(t \\in T\\) such that \\((s, t) \\in \\alpha\\). \"Single-valuedness\": If \\((s, t)\\) and \\(\\left(s, t^{\\prime}\\right) \\in \\alpha\\) then \\(t=t^{\\prime}\\). Composite / Product / Resultant of \\(\\alpha\\) and \\(\\beta\\) : \\((\\beta \\alpha)(s)=\\beta(\\alpha(s))\\) . Composition of maps satisfies the associative law : \\(\\gamma(\\beta\\alpha)=(\\gamma\\beta)\\alpha\\) Surjective : if im \\(\\alpha=T\\), that is, if the range coincides with the co-domain. Injective : if distinct elements of \\(S\\) have distinct images in \\(T\\), that is, if \\(s_1 \\neq s_2 \\Rightarrow \\alpha\\left(s_1\\right) \\neq \\alpha\\left(s_2\\right)\\). Bijective (a one to one correspondence) : If \\(\\alpha\\) is both injective and surjective. \\(S \\stackrel{\\alpha}{\\rightarrow} T\\) is bijective if and only if there exists a map \\(T \\stackrel{\\beta}{\\rightarrow} S\\) such that \\(\\beta \\alpha=1_S\\) and \\(\\alpha \\beta=1_T\\). Proof. Suppose \\(S \\stackrel{\\alpha}{\\rightarrow} T\\) is bijective. Consider the subset \\(\\beta\\) of \\(T \\times S\\) of elements \\((\\alpha(s), s)\\). If \\(t \\in T\\), surjectivity of \\(\\alpha\\) implies there is an \\(s\\) in \\(S\\) such that \\(\\alpha(s)=t\\). Hence condition 1 in the definition of a map from \\(T\\) to \\(S\\) holds for the set \\(\\beta\\) of pairs \\((\\alpha(s), s) \\in T \\times S\\). Condition 2 holds for \\(\\beta\\) by the injectivity of \\(\\alpha\\), since if \\(\\left(t, s_1\\right)\\) and \\(\\left(t, s_2\\right)\\) are in \\(\\beta\\), then \\(\\alpha\\left(s_1\\right)=t\\) and \\(\\alpha\\left(s_2\\right)=t\\), so \\(s_1=s_2\\). Hence we have the map \\(T \\stackrel{\\beta}{\\rightarrow} S\\). If \\(s \\in S\\), the facts that \\((s, \\alpha(s)) \\in \\alpha\\) and \\((\\alpha(s), s) \\in \\beta\\) imply that \\(\\beta(\\alpha(s))=s\\). Thus \\(\\beta \\alpha=1_s\\). If \\(t \\in T\\), we have \\(t=\\alpha(s), s \\in S\\), and \\((t, s) \\in\\) \\(\\beta\\), so \\(\\beta(t)=s \\in S\\). Hence \\(\\alpha(\\beta(t))=\\alpha(s)=t\\), so \\(\\alpha \\beta=1_T\\). Conversely, suppose \\(S \\stackrel{\\alpha}{\\rightarrow} T, T \\stackrel{\\beta}{\\rightarrow} S\\) satisfy \\(\\beta \\alpha=1_S, \\alpha \\beta=1_T\\). If \\(t \\in T\\), let \\(s=\\beta(t)\\). Then \\(\\alpha(s)=\\) \\(\\alpha(\\beta(t))=t\\); hence \\(\\alpha\\) is surjective. Next suppose \\(\\alpha\\left(s_1\\right)=\\alpha\\left(s_2\\right)\\) for \\(s_i \\in S\\). Then \\(s_1=\\) \\(\\beta\\left(\\alpha\\left(s_1\\right)\\right)=\\beta\\left(\\alpha\\left(s_2\\right)\\right)=s_2\\), and \\(\\alpha\\) is injective. Inverse with \"dressing-undressing principle\" : \\((\\beta \\alpha)^{-1}=\\alpha^{-1} \\beta^{-1}\\) . EQUIVALENCE RELATIONS. FACTORING A MAP Equivalence Relation : Reflexive property \\(aEa\\) , Symmetry \\(a E b \\Rightarrow b E a\\) , Transitivity \\(a E b\\ \\text{and}\\ b E c \\Rightarrow a E c\\) . equivalence class determined by \\(a\\) : \\(\\bar{a}_E\\) (or simply \\(\\bar{a}\\) ) \\(=\\{b \\in S \\mid b E a\\}\\). An equivalence relation is equivalent to that of a partition of a set. \\(\\pi_E =\\{\\bar{a} \\mid a \\in S\\}\\). the quotient set of \\(S\\) relative to the relation \\(E\\) : \\(S / E=\\pi=\\{\\bar{a} \\mid a \\in S\\}\\) , a subset of the power set \\(\\mathscr{P}(S)\\) of \\(S\\). natual map : \\(v: a \\rightarrow \\bar{a} .\\) Inverse Image : Construct \\(E_\\alpha\\) by map \\(S \\stackrel{\\alpha}{\\rightarrow} T\\) : \\(a E_\\alpha b\\Leftrightarrow \\alpha(a)=\\alpha(b)\\) , then \\(\\alpha^{-1}(c)=\\{a\\in S|\\alpha(a)=c\\}\\) \\(\\bar{\\alpha}:S/E_\\alpha\\to T\\) the map of \\(S/E_{\\alpha}\\) induced by \\(\\alpha\\) : \\(\\bar{\\alpha}(\\bar{a})=\\alpha(a),\\ \\bar{a}=\\alpha^{-1}(\\alpha(a))\\) , injective. Factorization of map \\(\\alpha\\) : \\(\\alpha=\\bar{\\alpha}v\\) ，where \\(v\\) is the natural map of \\(S\\) to \\(S/E_\\alpha\\) . 进入正题！ 研究角度：1. 本身性质；2. 子结构（子群、正规子群）；3. 映射关系（群同构，群同态） Monoids of Transformations and Abstract Monoids semi-group. 半群：封闭性，结合律。 monoid. 幺半群 \\((M,p,1)\\) ：封闭性，结合律，单位元。 submonoid. 子幺半群 \\((N,p,1)\\) ：集合包含 \\(N\\subseteq M\\) ，是幺半群。 set of transformations of S. 在 \\(S\\) 上的变换集 \\(M(S)\\) ：包含所有 \\(S\\to S\\) 的函数的集合，\\(|M(S)|=|S|^{|S|}\\) 。 monoid of transformations. 变换幺半群：\\((M(S), \\text{映射复合}, 1_S)\\) 的子群 Groups of Transformations and Abstract Groups group. 群 \\((G,p,1)\\) ：封闭性，结合律，单位元，所有元素可逆。 subgroup. 子群 \\((H,p,1)\\) ：集合包含 \\(H\\subseteq G\\) ，是群。记作 \\(H\\le G\\) 。 the group of invertible elements of M. 幺半群 \\(M\\) 中可逆元组成的群 \\(U(M)\\) ：容易验证是一个群。 symmetric group of the set S. \\(S\\) 的对称群 \\(\\text{Sym}\\ S=U(M(S))\\) : \\(S\\) 上的可逆变换构成的群（全体双射）。 group of transformations. 变换群：对称群 \\(\\text{Sym}\\ S\\) 的子群。 symmetric group on n letters. \\(n\\) 元对称群 \\(S_n\\) ：\\(\\{1,2,\\dots n\\}\\) 的全体排列构成的群，\\(|S_n|=n!\\) 。 permutation group. 置换群：有限元对称群 \\(S_n\\) 的子群。 Isomorphism. Cayley's theorem isomorphic. 幺半群/群同构：存在双射 \\(\\eta:M\\to M&#39;\\) ，保运算 \\(\\eta(xy)=\\eta(x)\\eta(y)\\) ，且 \\(\\eta(1)=1&#39;\\) （可由保运算推出）。 isomorphism. 同构函数 \\(\\eta\\) ，可能不止一个，例如 \\((\\mathbb{R},+,0)\\) 和 \\((\\mathbb{R}^+,\\cdot\\ ,1)\\) 的同构函数可以取 \\(\\eta(x)=a^x\\ (a&gt;0,a\\not= 1)\\) 。 同构是一个等价关系，可以通过单位映射实现自反性，同构函数的求逆和复合实现对称性和传递性。 Cayley 定理： (1) 任意幺半群 \\(M\\) 同构于一个交换幺半群；(2) 任意群 \\(G\\) 同构于一个交换群。 （1）对 \\(M\\) 中的每个元素 \\(a\\) 定义左平移变换 \\(a_L:M\\to M, a_L(x)=ax\\) ，则 \\(M\\) 同构于变换幺半群 \\(M_L=\\{a_L|a\\in M\\}\\) 。 （2）同理构造，额外验证对求逆元封闭：\\(1_L=(a^{-1}a)_L=(a^{-1})_La_L\\) ，即 \\(a_L\\) 的逆是 \\((a^{-1})_L\\) 。 推论：任意 \\(n\\) 阶有限群同构于一个 \\(n\\) 元置换群。 Generalized Associativity. Commutativity 广义结合律： 由结合律可导出 \\((\\prod_{i=1}^na_i)(\\prod_{j=1}^m a_{j+n})=\\prod_{i=1}^{n+m} a_k\\) ，进一步可定义整数次幂运算 \\(a^n\\) 和 \\(a^{-n}=(a^{-1})^n\\) commute. 称 \\(a,b\\in M\\) 是可交换的，当且仅当 \\(ab=ba\\) 。对于一组可交换的元素连乘，运算的顺序并不重要。 commutative monoid. 交换幺半群：幺半群 \\(M\\) ，任意两元素 \\(a,b\\) 均可交换。 abelian groups (commutative groups). 阿贝尔群（交换群）：群 \\(G\\) ，任意两元素 \\(a,b\\) 均可交换。 centralizer of a. \\(a\\) 的中心化子 \\(C(a)\\) ： \\(M\\) 中与 \\(a\\) 可交换的元素集。易证 \\(C(a)\\) 是 \\(M\\) 的子幺半群，定义同样适用于群。 引理：幺半群 \\(M\\) 的若干个子幺半群的交仍然是幺半群，群 \\(G\\) 的若干个子群的交仍然是群。 将中心化子的定义扩展到集合，定义集合 \\(A\\) 的中心化子 \\(C(A) = \\cap_{a\\in A} C(a)\\) ，由引理 \\(C(A)\\) 是子幺半群（子群）。 the center of M. \\(M\\) 的中心 \\(C(M)\\) ：含义是 \\(M\\) 中可以与所有元素交换的元素集，显然包含 \\(1\\) 。 在交换幺半群/交换群中我们常用加号来代替乘号来表示对应运算，用 \\(0\\) 代替 \\(1\\) 来表示单位元。 Submonoids and Subgroups Generated by a Subset. Cyclic Groups the submonoid generated by S. 由 \\(S\\) 生成的子幺半群 \\(\\langle S\\rangle\\) ：对于 \\(S\\subseteq M\\) ， \\(M\\) 中包含 \\(S\\) 的最小的子幺半群。 抽象刻画（存在性）：取所有包含 \\(S\\) 的子群求交即为 \\(\\langle S\\rangle\\) ，且 \\(\\langle S\\rangle\\) 是任意包含 \\(S\\) 的子群的子群； 构造性证明：\\(\\langle S\\rangle=\\{1,s_1s_2\\cdots s_r|s_i\\in S, r \\text{为有穷正整数}\\}\\) ，首先右侧是个幺半群，然后证互相包含： 由幺半群的运算封闭性， \\(\\langle S\\rangle\\) 包含右侧构成的幺半群； 右侧的集合包含 \\(S\\) （取 \\(r=1\\) ) ，由存在性引理，进一步的右侧的幺半群包含 \\(\\langle S\\rangle\\) 。 the subgroup generated by S. 由 \\(S\\) 生成的子群 \\(\\langle S \\rangle\\) ：定义同上述，\\(\\langle S\\rangle=\\{1,s_1s_2\\cdots s_r|s_i\\ \\text{or}\\ s_i^{-1}\\in S, r \\text{为有穷正整数}\\}\\) cyclic group. 循环群：由一个元素的集合生成的群 \\(G=\\langle a\\rangle=\\{a^k|k\\in \\mathbb{Z}\\}\\) ，显然是一个阿贝尔群（可交换）。 任意无限循环群都与 \\((\\mathbb{Z},+,0)=\\langle1\\rangle\\) 同构，通过映射 \\(n\\to a^n\\) 。 任意有限阶（\\(n\\) 阶）循环群都与 \\(n\\) 次单位根生成的循环群 \\(U_n=\\{x|x^n=1\\}\\) 同构。 循环群的子群是循环群； 无限循环群 \\(\\langle a\\rangle\\) 的子群都是无限的，且 \\(s\\to \\langle a^s\\rangle\\) 是 \\(\\mathbb{N}\\) 到 \\(\\langle a\\rangle\\) 的全体子群的双射（ \\(a\\) 任意次幂生成的群两两不同）； \\(n\\) 阶循环群 \\(\\langle a\\rangle\\) 的子群的阶都是 \\(n\\) 的因数，且对于 \\(n\\) 的每个因数 \\(q\\) ，有且仅有一个 \\(\\langle a\\rangle\\) 的子群阶为 \\(q\\) 。 这个 \\(q\\) 阶子群可以被构造性的刻画：\\(H=\\{b|b\\in \\langle a\\rangle,b^q=1\\}\\) 。 the order of a 元素 \\(a\\) 的阶 \\(o(a)\\) ：若 \\(\\langle a \\rangle\\) 是无限群 \\(\\langle a \\rangle=+\\infty\\) ；否则 \\(o(a)=|\\langle a\\rangle|=r\\) ，其中 \\(r\\) 是满足 \\(a^r=1\\) 的最小正整数。 若 \\(a^m=1\\) ，则 \\(o(a) | m\\) 。 若 \\(o(a)=r&lt;+\\infty\\) ，则 \\(o(a^k)=[r,k]/k=r/(r,k)\\) ，因此 \\(o(a^k)|r\\) 。 exponent of a finite group G. 有限群 \\(G\\) 的方次数 \\(\\text{exp}\\ G=\\) 最小的正整数 \\(e\\) ，满足 \\(\\forall x \\in G,\\ x^e=1\\) 。 定理：有限交换群是循环群的充要条件为方次数等于阶数（ \\(\\text{exp}\\ G = |G|\\) ）。 引理 1. 设 \\(G\\) 为有限交换群，设 \\(g,h\\in G\\) 且 \\(o(g)=m,o(h)=n,(m,n)=1\\) ，则 \\(o(gh)=mn\\) 。 \\((gh)^{mn}=g^{mn}h^{mn}=(g^m)^n(h^n)^m=1\\) 。 假设 \\((gh)^r=1\\) ，设 \\(k=g^r=h^{-r}\\in\\langle g\\rangle \\cap \\langle h\\rangle\\) ，有 \\(o(k)|m,o(k)|n\\Rightarrow o(k)|(m,n)\\Rightarrow o(k)=1\\) 因此 \\(g^r=k=1\\Rightarrow (gh)^r=g^rh^r=h^r=1\\) 因此 \\(m|r,n|r\\Rightarrow [m,n]|r\\) 又 \\((m,n)=1\\) 有 \\(mn|r\\) 。 引理 2. 设 \\(G\\) 为有限交换群，设 \\(g=\\arg\\max_{g\\in G} o(g)\\) ，则 \\(\\text{exp}\\ G=o(g)\\) 。 标准分解 \\(o(g)=p_1^{e_1}p_2^{e_2}\\dots p_s^{e_s},o(h)=p_1^{f_1}p_2^{f_2}\\dots p_s^{f_s}\\ (e_i,f_i\\ge 0)\\) 反证：若 \\(h\\in G, h^{o(g)}\\not =1\\) ，则一定存在某个 \\(f_i&gt; e_i\\) ，不妨设 \\(f_1&gt;e_1\\) 。 接下来我们构造一个与 \\(\\arg\\max\\) 冲突的元素：设 \\(g&#39;=g^{p_1^{e_1}},h&#39;=h^{p_2^{f_2}\\dots p_s^{f_s}}\\) ， 于是有 \\(o(g&#39;)=p_2^{e_2}\\dots p_s^{e_s},o(h&#39;)=p_1^{f_1}\\) ，那么由引理 1， \\(o(g&#39;h&#39;)=p_1^{f_1}p_2^{e_2}\\dots p_s^{e_s}&gt;o(g)\\) 矛盾。 \" \\(\\Rightarrow\\) \" 证明：由于是循环群 \\(G=\\langle g\\rangle\\) ，\\(|G|=|\\langle g\\rangle|=o(g)=\\text{exp}\\ G\\) 。 \" \\(\\Leftarrow\\) \" 证明：由引理 2，存在 \\(g\\) 使得 \\(\\text{exp}\\ G=o(g)\\) ，又由于交换群 \\(G\\) 满足 \\(\\text{exp}\\ G=|G|\\) ，因此 \\(|G|=o(g)=|\\langle g\\rangle|\\) 。 Cycle Decomposition of Permutations r-cycle \\(r\\) - 循环：若置换 \\(\\gamma\\) 满足去掉稳定点后，满足置换效果是循环，即对于所有不是稳定点的下标 \\(i_1,i_2,\\dots,i_r, (r&gt;1)\\) ： \\[ \\gamma(i_1)=i_2,\\gamma(i_2)=i_3,\\dots,\\gamma(i_{r-1})=i_r,\\gamma(i_r)=i_1 \\] 此时我们称这组数是一个 \\(r\\) - 循环，记作 \\(\\gamma=(i_1i_2\\dots i_r)\\) ，即每个点都会换成右侧的，同理可以记作 \\(\\gamma=(i_2i_3\\dots i_ri_1)\\) 等等。 用排列的复合可得 \\(\\gamma^k(i_j)=i_{j+k}\\) (下标每 \\(r\\) 循环)。明显 \\(\\gamma^r=1\\) 且 \\(\\gamma^k \\not = 1,1\\le k&lt;r\\) ，所以 \\(\\gamma\\) 的阶（order）为 \\(r\\) 。 disjoint 若两个循环包含的元素无交，则称两个循环不相交，对应的排列复合等同于分别运算，此时排列复合是可交换的。 考虑一组循环（对应置换）的连乘积 \\(\\alpha=(i_1i_2\\dots i_{n_1})(j_1j_2\\dots j_{n_2})\\dots(l_1l_2\\dots l_{n_k})\\) ，那么 \\(o(\\alpha)=[n_1,n_2,\\dots,n_m]\\) 。 若我们引入 \\(1\\) - 循环，则很容易得到置换唯一分解为不相交的循环的方法，每次从最小未使用的元素找到一个循环。 transposition 对换：一个 \\(2\\) - 循环，即 \\((ab)\\) 的形式。任何一个 \\(r\\) - 循环都可以拆成 \\(r-1\\) 个对换的乘积，即： \\[ (i_1i_2\\dots i_r)=(i_1i_r)\\dots (i_1i_3)(i_1i_2) \\] 因此一个置换 \\(\\alpha\\) 可以拆成 \\(N(\\alpha)=\\sum (n_i-1)\\) 个对换的乘积。 一个置换的对换分解不是唯一的（在最简单的对换分解基础上可以引入很多额外的对换），但共性是对换个数的奇偶性相同。 对换诱导分裂公式：\\((ab)(ac_1\\dots c_hbd_1\\dots d_k)=(bd_1\\dots d_k)(ac_1\\dots c_h)\\) 。 对换诱导合并公式：\\((ab)(bd_1\\dots d_k)(ac_1\\dots c_h)=(ac_1\\dots c_hbd_1\\dots d_k)\\) 若 \\(N(\\alpha)\\) 为奇数（偶数）则称之为奇（偶）排列，则奇偶排列分别构成了 \\(S_n\\) 的一个子群，且大小相同均为 \\(n!/2\\) 。 Orbits. Coset of a Subgroup G-equivalent 对于集合 \\(S\\) 上的变换群 \\(G\\) 和两元素 \\(x,y\\) ，若存在 \\(\\alpha\\in G\\) 使得 \\(y=\\alpha(x)\\) 则称两元素 \\(G\\) - 等价 \\(x\\sim_G y\\) 。 由于 \\(G\\) 是变换群，容易验证是等价关系：自反有 \\(1_S\\in G\\) ，对称有 \\(\\alpha^{-1}\\in G\\) ，传递是群的封闭性。 G-orbit \\(G\\) - 轨道：由 \\(G\\) - 等价关系导出等价类 \\(Gx=\\{\\alpha(x)|\\alpha\\in G\\}\\) transitive group 传递群：若 \\(G\\) - 轨道只有一个（ \\(S\\) 中全体元素等价）则称 \\(G\\) 是 \\(S\\) 的传递群。 left (right) translations 定义左平移 \\(g_L: x\\to gx\\) ，右平移 \\(g_R:x\\to xg\\) 。 定义变换群 \\(G_L=\\{g_L|g\\in G\\},G_R=\\{g_R|g\\in G\\}\\) ，由于 \\(y=gx\\) 和 \\(y=xg\\) 都是可解的，所以两者都是传递群。 假设 \\(H\\) 是 \\(G\\) 的一个子群，定义 \\(H_L(G)=\\{h_L|h\\in H\\}\\) （ \\(h_L\\) 还是定义在 \\(G\\) 上的），\\(H_L(G)\\) 也是一个变换群（ \\(g\\to g_L\\) 是同构映射）。 则 \\(H_L\\) 导出的轨道 \\(Hx=\\{hx|h\\in H\\}\\) 称作 \\(x\\) 关于 \\(H\\) 的右陪集，易证任意右陪集大小相同，因此 \\(|Hx|=|H1|=|H|\\) 。 假设 \\(G\\) 是有限群，且 \\(|G|=n,|H|=m\\) ，用 \\(H_L(G)\\) - 轨道将 \\(G\\) 划分为 \\(G=Hx_1\\cup Hx_2\\cup\\dots\\cup Hx_r\\) 。 称 \\(r\\) 为 \\(H\\) 在 \\(G\\) 中的指数（index）记作 \\([G:H]\\) 。此时有：1.划分任意两个集合无交； 2. \\(|Hx_i|=|H|=m\\) 。可以得出 \\(n=mr\\) 。 这样就证明了 拉格朗日定理 ：对于有限群 \\(G\\) 的任意子群 \\(H\\) ，有 \\(|G|=|H|[G:H]\\) 。 进一步的，有推论：若 \\(|G|=n\\) ，则对任意 \\(x\\in G\\) 都有 \\(x^n=1\\) 。 证明：假设 \\(|\\langle x\\rangle |=m\\) ，用拉格朗日定理有 \\(n=mr\\) 且 \\(x^m=1\\) ， 故 \\(x^n=(x^m)^r=1\\) 。 结合此前循环群充要条件，能得到非循环群满足 \\(\\text{exp}\\ G&lt;n\\) 。 Congruences. Quotient Monoids and Groups congruence relation 同余关系 \\(\\equiv\\) ：可乘的等价关系。对于幺半群 \\(M\\) ，若 \\(a\\equiv a&#39;,b\\equiv b&#39;\\) ，则有 \\(ab\\equiv a&#39;b&#39;\\) 。 考虑商集 \\(\\overline{M}=M/\\equiv\\) ，包含了所有由同余关系导出的等价类 \\(\\overline{a} = \\{b\\in M|b\\equiv a\\}\\) 。 那么对于 \\(\\overline{M}\\) 中的等价类 \\(\\overline{a},\\overline{a&#39;},\\overline{b}, \\overline{b&#39;}\\) ，有 \\(\\overline{a}=\\overline{a&#39;},\\overline{b}=\\overline{b&#39;}\\) ，由于 \\(ab\\equiv a&#39;b&#39;\\) ，有 \\(\\overline{ab}=\\overline{a&#39;b&#39;}\\) 。 这样我们就获得了一个 \\(\\overline{M}\\) 上良定义的乘法映射 \\(\\overline{M}\\times \\overline{M}\\to \\overline{M}\\) ：\\((\\overline{a},\\overline{b})\\to \\overline{ab}\\) ，记作 \\(\\cdot\\) ，易证 \\((\\overline{M},\\cdot,\\overline{1})\\) 是一个幺半群。 我们称 \\((M/\\equiv, \\cdot, \\overline{1})\\) 为 \\(M\\) 关于 \\(\\equiv\\) 的商幺半群。同样称 \\((G/\\equiv, \\cdot, \\overline{1})\\) 为商群的定义也是正确的。 normal subgroups 正规子群 \\(K\\unlhd G\\) ：满足 \\(\\forall g\\in G, k\\in K, g^{-1}kg\\in K\\) 。 容易发现阿贝尔群的任意子群都是正规子群，因为可交换 \\(g^{-1}kg=kg^{-1}g=k\\) 。 同余关系和正规子群的联系： 同余等价类 \\(K=\\overline{1}\\) 是 \\(G\\) 的正规子群，且对于任意 \\(g\\in G\\) ，有 \\(\\overline{g}=gK=Kg\\) 。 对于任意正规子群 \\(K\\) ，可以由 \\(K\\) 导出同余关系：\\(a\\equiv b\\pmod k\\ \\ \\text{if}\\ \\ a^{-1}b\\in K\\) 。 在此同余关系下，同余等价类的形式为 \\(gK\\) 。 quotient group 商群：由正规子群 \\(K\\) 定义的同余关系导出的商群 \\(\\overline{G}=G/\\equiv \\pmod k\\) 商群中的元素是等价类，形式均为 \\(\\overline{g}=gK\\) ，因此乘法 \\(\\overline{g}\\overline{h}=\\overline{gh}\\) 可以进一步的写作 \\((gK)(hK)=ghK\\) 。 单位元 \\(K=\\overline{1}=1K\\) ，逆元 \\((\\overline{g})^{-1}=\\overline{g^{-1}}=g^{-1}K\\) 。 定义子（幺半）群的乘法：\\(\\forall A,B\\le G, AB=\\{ab|a\\in A, b\\in B\\}\\) 。这样 \\((\\mathscr{P}(G),\\cdot,\\{1\\})\\) 就构成了一个幺半群。 集合的乘法对应了商群中的乘法 \\((gK)(hK)=g(Kh)K=ghK^2=ghK\\) 正规子群的等价判定条件，\\(\\forall g\\in G\\) 满足：（1）\\(g^{-1}Kg\\subset K\\) （2）\\(Kg=gK\\) simple group 单群：只有 \\(G\\) 和 \\(1\\) 两个正规子群的群 \\(G\\ (G\\not = 1)\\) ，对应的同余关系是 \\(=\\) 和全部相同。 交换的单群（阿贝尔单群）只有素数阶循环群。 群 \\(G\\) 的中心 \\(C(G)\\) 的任意子群显然都是正规子群（可交换）。 Homomorphisms homomorphism 同态映射 \\(\\eta\\) ：\\(\\eta(ab)=\\eta(a)\\eta(b),\\eta(1)=1&#39;, \\forall a,b\\in M\\) epimorphiscm 满同态：满射的同态映射； monomorphism 单同态：单射的同态映射。 Sylow's Theorems Sylow I ：假设 \\(|G|\\) 有限，质数 \\(p\\) 满足 \\(p^k||G|\\) ，那么存在子群 \\(H\\le G\\) 且 \\(|H|=p^k\\) 对 \\(|G|\\) 从小到大归纳。\\(|G|=1\\) 时显然成立。现在假设结论对 \\(|G&#39;|&lt;|G|\\) 的所有 \\(G&#39;\\) 都成立。 考虑 \\(G\\) 到自己的共轭作用，有类方程：\\(|G|=|C|+\\sum_{y_i\\in G,y_i\\not\\in C(G)} [G:C(y_i)]\\) 当 \\(|C|\\) 不是 \\(p\\) 的倍数时，由于和是 \\(p\\) 的倍数，因此必然存在 \\(j\\) ，使得 \\([G:C(y_j)]=\\frac{|G|}{|C(y_j)|}\\) 也不是 \\(p\\) 的倍数。那么 \\(|C(y_j)|\\) 就一定是 \\(p^k\\) 的倍数，而且因为 \\(C(y_j)\\not = G\\) ，有 \\(C(y_j)\\le G\\) ，那么根据假设，存在 \\(H\\le C(y_j)\\le G\\) ，满足 \\(|H|=p^k\\) 。 Cauchy 引理，对于有限交换群 \\(G\\) ，如果质数 \\(p||G|\\) ，那么存在 \\(a\\in G, |\\langle a\\rangle|=p\\) 否则 \\(|C|\\) 是 \\(p\\) 的倍数。因为 \\(C\\) 是有限交换群，因此跟去 Cauchy 定理，\\(\\exists c\\in C,|\\langle c\\rangle|=p\\) 。而且 \\(\\langle c\\rangle \\le C\\unlhd G\\) ，是 \\(G\\) 的正规子群。考虑 \\(G/\\langle c\\rangle\\) 这个商群，\\(|G/\\langle c\\rangle|&lt;|G|\\) 且能被 \\(p^{k-1}\\) 整除。由归纳假设存在 \\(K\\le G/\\langle c\\rangle,|K|=p^{k-1}\\) 。那么 \\(K\\) 的形式为 \\(H/\\langle c\\rangle\\) 且 \\(H\\) 是 \\(G\\) 中一个包含 \\(\\langle c\\rangle\\) 的子群。那么有 \\[ |H|=[H:\\langle c\\rangle]|\\langle c\\rangle|=p^{k-1}p=p^k \\]","categories":[{"name":"Summary","slug":"Summary","permalink":"http://blog.gyx.me/categories/Summary/"}],"tags":[{"name":"Algebra","slug":"Algebra","permalink":"http://blog.gyx.me/tags/Algebra/"}]},{"title":"Codeforces Round #848 (Div. 2)","slug":"codeforces/1778","date":"2023-02-01T16:56:00.000Z","updated":"2023-03-20T16:26:10.161Z","comments":true,"path":"codeforces/1778/","link":"","permalink":"http://blog.gyx.me/codeforces/1778/","excerpt":"","text":"A. Flip Flop Sum 枚举修改的位置。复杂度 \\(O(n)\\) 。 123456789int a[N];inline void work() &#123; int n = rd(), sum = 0, dlt = -4; for (int i = 1; i &lt;= n; ++i) &#123; a[i] = rd(); sum += a[i]; if (i &gt; 1) dlt = max(dlt, -2 * (a[i] + a[i - 1])); &#125; printf(&quot;%d\\n&quot;, sum + dlt);&#125; B. The Forbidden Permutation 枚举不符合要求的位置，移动有两种策略： 使 \\(pos(a_i)\\ge pos(a_{i + 1})\\) ，操作次数 \\(pos(a_{i+1})-pos(a_i)\\) 使 \\(pos(a_{i+1})&gt;pos(a_i)+d\\) ，需要保证 \\(d+2\\le n\\) ，操作次数 \\(pos(a_i)+d-pos(a_{i+1}) + 1\\) 复杂度 \\(O(n)\\) 。 12345678910111213int p[N], a[N];inline void work() &#123; int n = rd(), m = rd(), d = rd(), ans = 1e9; rep(i, 1, n) p[rd()] = i; rep(i, 1, m) a[i] = rd(); rep(i, 2, m) &#123; if (p[a[i]] &gt; p[a[i - 1]] &amp;&amp; p[a[i]] &lt;= p[a[i - 1]] + d) &#123; ans = min(ans, p[a[i]] - p[a[i - 1]]); if (d + 2 &lt;= n)ans = min(ans, d - (p[a[i]] - p[a[i - 1]]) + 1); &#125; else &#123;puts(&quot;0&quot;); return;&#125; &#125; printf(&quot;%d\\n&quot;, ans);&#125; C. Flexible String 枚举修改的字符集，有 \\({10\\choose k}\\) 种方案，然后 \\(O(n)\\) 计算在这些字符变成通配符的情况下答案的值。 123456789101112131415161718192021222324252627282930313233343536373839#define N 100007char s[N], t[N];int a[N], n, k, tot;map&lt;char, int&gt; id;inline void work() &#123; n = rd(); k = rd(); tot = 0; id.clear(); scanf(&quot;%s&quot;, s + 1); scanf(&quot;%s&quot;, t + 1); rep(i, 1, n) &#123; if (!id[s[i]]) id[s[i]] = ++tot; a[i] = id[s[i]] - 1; &#125; if (tot &lt;= k) &#123; printf(&quot;%lld\\n&quot;, 1ll * n * (n + 1) / 2); return; &#125; ll ans = 0; vector&lt;int&gt; ok(tot, 0); rep(i, 1, k) ok[tot - i] = 1; do &#123; int len = 0; ll tmpans = 0; rep(i, 1, n) if (ok[a[i]] || s[i] == t[i]) ++len; else &#123; tmpans += 1ll * len * (len + 1) / 2; len = 0; &#125; tmpans += 1ll * len * (len + 1) / 2; ans = max(ans, tmpans); &#125; while(next_permutation(all(ok))); printf(&quot;%lld\\n&quot;, ans);&#125; D. Flexible String Revisit 首先一次操作只会让不同的个数 \\(+1/-1\\) ，所以只跟不同的个数有关，经典的 Markov 链，求首访时间。 设 \\(t[i]\\) 表示有 \\(i\\) 个不同的状态首次到达 \\(0\\) 状态的期望步数，有： \\[ t[0]=0\\\\ t[i]=1+\\frac{i}{n}\\times t[i - 1] + \\frac{n-i}{n}\\times t[i+1],\\ 1&lt;i\\le n \\] 由于 \\(t[0]=0\\) 已知，所以先按照 \\(i=0\\dots n\\) 的顺序扫描，把 \\(t[i]\\) 整理成只和 \\(t[i+1]\\) 有关的形式。 然后由于 \\(t[n]\\) 中到 \\(t[n+1]\\) 的系数 \\(\\frac{n-i}{n}=0\\) ，所以 \\(t[n]\\) 的值已经求得，再逆着扫回来即可。 答案就是 \\(t[\\text{两字符串初始不同的位置数}]\\) ，复杂度 \\(O(n)\\) 。 123456789101112131415161718192021222324252627282930313233#define N 1000007#define mod 998244353 inline int fpow(int x, int t = mod - 2) &#123; int res = 1; for (; t; t &gt;&gt;= 1, x = 1ll * x * x % mod) if (t &amp; 1) res = 1ll * res * x % mod; return res;&#125; char s[N], t[N]; int f[N], dlt[N], k[N]; inline void calc(int n) &#123; int bs = fpow(n); rep(i, 1, n) &#123; int l = 1ll * i * bs % mod, r = 1ll * (n - i) * bs % mod; int cof = fpow((mod + 1 - 1ll * l * k[i - 1] % mod) % mod); dlt[i] = (1ll * dlt[i - 1] * l + 1) % mod * cof % mod; k[i] = 1ll * r * cof % mod; &#125; f[n] = dlt[n]; per(i, n - 1, 1) f[i] = (dlt[i] + 1ll * f[i + 1] * k[i]) % mod;&#125; inline void work() &#123; int n = rd(); calc(n); scanf(&quot;%s&quot;, s + 1); scanf(&quot;%s&quot;, t + 1); int cnt = 0; rep(i, 1, n) cnt += (s[i] != t[i]); printf(&quot;%d\\n&quot;, f[cnt]);&#125; E. The Tree Has Fallen! 给一棵树 \\((n\\le 2\\times 10^5)\\) ，每个点有点权 \\(a_u\\ (a_u\\le 10^9)\\) ，\\(q\\ (q\\le 2\\times 10^5)\\) 次询问： 树以 \\(r_i\\) 为根时，节点 \\(v_i\\) 子树内任选一些节点，点权异或最大值是多少？ 看到询问肯定线性基了，先以 \\(1\\) 为根，处理出来每个点子树的线性基 \\(subtree_u\\) 。 询问讨论一下 \\(r_i\\) 和 \\(v_i\\) 的关系： \\(r_i=v_i\\) ，查询集合为全部点权，答案为 \\(subtree_1\\) 的表出最大值。 \\(r_i\\) 不在 \\(v_i\\) 子树内，\\(v_i\\) 子树不变，则答案为 \\(subtree_{v_i}\\) 的表出最大值。 \\(r_i\\) 在 \\(v_i\\) 子树内，则查询集合为所有点删掉 \\(v_i\\) 的包含 \\(r_i\\) 的儿子的子树。 因此需要完成： 查询 \\(v_i\\) 儿子中，包含 \\(r_i\\) 的是谁。 处理 \\(out_u\\) 表示删掉 \\(u\\) 子树的线性基。 这两个问题求 dfs 序后都可以解决，由于子树 dfs 序连续： 第一个对每个点记录所有儿子的 dfn ，然后在里面二分查找 \\(\\le dfn[r_i]\\) 的最大的。 第二个处理按 dfs 序的前后缀线性基，再左右合并即可。 复杂度 \\(O(n\\log^2(\\max a_u))\\) 。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#define N 200007struct linear_base &#123; #define D 31 int b[D]; void clear() &#123;memset(b, 0, sizeof(b));&#125; void insert(int x) &#123; for (int i = 30; ~i; --i) if ((x &gt;&gt; i) &amp; 1) &#123; if (b[i]) x ^= b[i]; else &#123;b[i] = x; break;&#125; &#125; &#125; int max_xor() &#123; int ans = 0; for (int i = 30; ~i; --i) if (b[i] &amp;&amp; !((ans &gt;&gt; i) &amp; 1)) ans ^= b[i]; return ans; &#125; linear_base operator + (const linear_base &amp;obj) const &#123; linear_base ret = obj; for (int i = 30; ~i; --i) if (b[i]) ret.insert(b[i]); return ret; &#125;&#125; pre[N], suf[N], subtree[N], out[N];int dfn[N], id[N], lst[N], a[N], tot;vector&lt;int&gt; e[N], sondfn[N];void dfs(int u, int fa) &#123; sondfn[u].clear(); subtree[u].clear(); subtree[u].insert(a[u]); id[dfn[u] = ++tot] = u; for (auto v : e[u]) if (v != fa) &#123; dfs(v, u); subtree[u] = subtree[u] + subtree[v]; sondfn[u].pb(dfn[v]); &#125; lst[u] = tot;&#125;inline void work() &#123; tot = 0; int n = rd(); rep(i, 1, n) &#123;a[i] = rd(); e[i].clear();&#125; rep(i, 2, n) &#123;int u = rd(), v = rd(); e[u].pb(v); e[v].pb(u);&#125; dfs(1, 1); pre[0].clear(); suf[n + 1].clear(); rep(i, 1, n) &#123;pre[i] = pre[i - 1]; pre[i].insert(a[id[i]]);&#125; per(i, n, 1) &#123;suf[i] = suf[i + 1]; suf[i].insert(a[id[i]]);&#125; rep(i, 1, n) out[i] = pre[dfn[i] - 1] + suf[lst[i] + 1]; per(i, rd(), 1) &#123; int r = rd(), v = rd(); if (r == v) printf(&quot;%d\\n&quot;, subtree[1].max_xor()); else if (dfn[v] &lt; dfn[r] &amp;&amp; dfn[r] &lt;= lst[v]) &#123; int son = id[*--upper_bound(all(sondfn[v]), dfn[r])]; printf(&quot;%d\\n&quot;, out[son].max_xor()); &#125; else printf(&quot;%d\\n&quot;, subtree[v].max_xor()); &#125;&#125; F. Maximizing Root 以 \\(1\\) 为根的树，每个节点有点权 \\(a_u\\ (a_u\\le 10^3)\\) ，最多 \\(k\\ (0\\le k\\le n\\le 10^5)\\) 次操作，每次操作： 选一个此前未选过的点 \\(v\\) ， 选择一个 \\(v\\) 子树内所有点权的公因数 \\(x\\) ，令 \\(v\\) 子树内所有点权 \\(\\times x\\) 。 问最终 \\(1\\) 号点点权可能的最大值。 首先每个点只能操作一次，所以 \\(a_1\\) 最终最大变成 \\(a_1^2\\) 。 所以我们只需要考虑每个点的子树，在祖先节点操作时，保证子树内能提供 \\(x\\ (x\\le 1000)\\) 所需的最小次数。 因此设 \\(f[u][x]\\) 表示节点 \\(u\\) 子树内，后续祖先操作时，保证 \\(u\\) 子树内能提供 \\(x\\) 的最小操作次数。 若不操作 \\(u\\) ，则需要保证 \\(x|a[u]\\) ，此时方程为 \\(f[u][x] = \\sum f[son][x]\\) 。 若操作 \\(u\\) ，此时需要找到某个最小的 \\(y\\) ，使得 \\(x|y^2\\) ，也就是子树里每个点都包含 \\(y\\) 的情况下，操作一次 \\(u\\) 足以让整个子树都包含 \\(x\\) ，这个预处理即可，称 \\(y\\) 为 \\(mn[x]\\) ，方程为 \\(f[u][x]=1+\\sum f[son][mn[x]]\\) 。 此外，如果 \\(mn[x]\\) 不是 \\(a[u]\\) 的因数，则 \\(f[u][x]\\) 不合法。 最后枚举 \\(1\\) 号点操作时对应的 \\(x\\) 是几即可，复杂度 \\(O(n\\max a_u)\\) 计算量约 \\(10^8\\) 。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#define N 100007int f[N][1001], a[N], G, n, k, inf = 1e9; vector&lt;int&gt; e[N]; int gcd(int a, int b) &#123;return b ? gcd(b, a % b) : a;&#125; inline void getmin(int &amp;a, int b) &#123;a = (a &gt; b ? b : a);&#125; int mn[1001]; void dfs(int u, int fa) &#123; for (auto v : e[u]) if (v != fa) dfs(v, u); f[u][1] = 0; rep(i, 2, 1000) &#123; if (a[u] % i == 0) &#123; f[u][i] = 0; for (auto v : e[u]) if (v != fa) &#123;f[u][i] += f[v][i]; getmin(f[u][i], inf);&#125; int tmp = 1, tar = mn[i]; for (auto v : e[u]) if (v != fa) &#123;tmp += f[v][tar]; getmin(tmp, inf);&#125; getmin(f[u][i], tmp); &#125; else if (a[u] % mn[i] == 0) &#123; f[u][i] = 1; int tar = mn[i]; for (auto v : e[u]) if (v != fa) &#123;f[u][i] += f[v][tar]; getmin(f[u][i], inf);&#125; &#125; else f[u][i] = inf; &#125;&#125; inline void work() &#123; int n = rd(), k = rd(); G = 0; rep(i, 1, n) &#123;a[i] = rd(); G = gcd(G, a[i]); e[i].clear();&#125; rep(i, 2, n) &#123;int u = rd(), v = rd(); e[u].pb(v); e[v].pb(u);&#125; if (k == 0 || G == 1) &#123;printf(&quot;%d\\n&quot;, a[1]); return;&#125; if (k == 1) &#123;printf(&quot;%d\\n&quot;, a[1] * G); return;&#125; dfs(1, 1); per(i, a[1], 1) if (a[1] % i == 0) &#123; int cnt = 0; for (auto v : e[1]) &#123; cnt += f[v][i]; getmin(cnt, inf); &#125; if (cnt &lt; k) &#123;printf(&quot;%d\\n&quot;, a[1] * i); return;&#125; &#125;&#125; int main() &#123; rep(i, 1, 1000) rep(j, 1, 1000) if (j * j % i == 0) &#123;mn[i] = j; break;&#125; for (int t = rd(); t; --t) work(); return 0;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://blog.gyx.me/categories/Codeforces/"},{"name":"Codeforces Round","slug":"Codeforces/Codeforces-Round","permalink":"http://blog.gyx.me/categories/Codeforces/Codeforces-Round/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"},{"name":"DFS and Similar","slug":"DFS-and-Similar","permalink":"http://blog.gyx.me/tags/DFS-and-Similar/"},{"name":"Markov Chains","slug":"Markov-Chains","permalink":"http://blog.gyx.me/tags/Markov-Chains/"},{"name":"Linear Basis","slug":"Linear-Basis","permalink":"http://blog.gyx.me/tags/Linear-Basis/"}]},{"title":"AtCoder Beginner Contest 287","slug":"atcoder/abc287","date":"2023-01-28T15:47:14.000Z","updated":"2023-03-20T16:28:29.793Z","comments":true,"path":"atcoder/abc287/","link":"","permalink":"http://blog.gyx.me/atcoder/abc287/","excerpt":"","text":"ABCD 比较简单就不写了。 E - Karuta 给 \\(n\\) 个字符串 \\(S_i\\ (\\sum |S_i|\\le 10^5)\\) ，问每个串和其他所有串的 LCP 的最大值。 先把所有串建 Trie ，再查一遍，走到计数器只有 \\(1\\) 的时候就停。复杂度 \\(O(n+\\sum |S_i|)\\) 。 1234567891011121314151617181920212223242526272829303132333435int tot;struct node &#123;int cnt, son[26];&#125; c[500007];inline void insert(string &amp;s) &#123; int rt = 0; for (auto x : s) &#123; x -= &#x27;a&#x27;; if (!c[rt].son[x]) c[rt].son[x] = ++tot; rt = c[rt].son[x]; ++c[rt].cnt; &#125;&#125;inline int calc(string &amp;s) &#123; int ans = 0, rt = 0; for (auto x : s) &#123; x -= &#x27;a&#x27;; rt = c[rt].son[x]; if (c[rt].cnt == 1) return ans; ++ans; &#125; return ans;&#125;string str;vector&lt;string&gt; s;int main() &#123; int n; cin &gt;&gt; n; rep(i, 1, n) &#123;cin &gt;&gt; str; s.pb(str); insert(str);&#125; for (auto &amp;st : s) printf(&quot;%d\\n&quot;, calc(st)); return 0;&#125; F - Components 给一棵树 \\((n\\le 5000)\\) ，问有多少个点集的导出子图恰好有 \\(x=0,1,\\dots,n\\) 个联通分量（定义含极大性）。 树形背包计数，加一维 \\(0/1\\) 表示当前点选/不选，如果父子两个都上选会合并一个联通块。复杂度 \\(O(n^2)\\) 。 123456789101112131415161718192021222324252627282930313233343536373839#define N 5007#define mod 998244353inline int add(int x, int y) &#123;return (x + y &gt;= mod ? x + y - mod : x + y);&#125;inline int mul(int x, int y) &#123;return 1ll * x * y % mod;&#125;int f[N][N][2], sz[N], n, g[N][2];vector&lt;int&gt; e[N];void dfs(int u, int fa) &#123; sz[u] = 1; f[u][0][0] = f[u][1][1] = 1; for (auto v : e[u]) if (v != fa) &#123; dfs(v, u); for (int j = 0; j &lt;= sz[u] + sz[v]; ++j) &#123; g[j][0] = f[u][j][0]; g[j][1] = f[u][j][1]; f[u][j][0] = f[u][j][1] = 0; &#125; for (int j = sz[u] + sz[v]; j &gt;= 0; --j) for (int k = max(0, j - sz[u]); k &lt;= min(j, sz[v]); ++k) &#123; f[u][j][0] = add(f[u][j][0], mul(g[j - k][0], add(f[v][k][0], f[v][k][1]))); f[u][j][1] = add(f[u][j][1], add(mul(g[j - k][1], f[v][k][0]), mul(g[j - k][1], f[v][k + 1][1]))); &#125; sz[u] += sz[v]; &#125;&#125;int main() &#123; n = rd(); for (int i = 1; i &lt; n; ++i) &#123; int u = rd(), v = rd(); e[u].pb(v); e[v].pb(u); &#125; dfs(1, 1); for (int i = 1; i &lt;= n; ++i) printf(&quot;%d\\n&quot;, add(f[1][i][0], f[1][i][1])); return 0;&#125; G - Balance Update Query 有 \\(n\\ (n\\le 2\\times 10^5)\\) 组数，开始第 \\(i\\) 组有 \\(b_i\\ (b_i\\le 10^4)\\) 个 \\(a_i\\ (a_i\\le 10^9)\\) ，接下来 \\(q\\) 次操作： 1 x y 把 \\(a_x\\) 修改为 \\(y\\ (y\\le 10^9)\\) 2 x y 把 \\(b_x\\) 修改为 \\(y\\ (y\\le 10^4)\\) 3 x 查询所有数字的前 \\(x\\ (x\\le 10^9)\\) 大和。 离线，离散化全部做过 \\(a_i\\) 的值，以此为下标建立线段树。 节点维护价值区间内数字个数和 \\(\\sum\\) 个数 \\(\\times\\) 价值 ，查询在线段树上二分即可。复杂度 \\(O(n\\log n)\\) 。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#define N 300007#define ls (rt &lt;&lt; 1)#define rs (rt &lt;&lt; 1 | 1)#define mid ((l + r) &gt;&gt; 1)vector&lt;int&gt; w;int a[N], b[N];vector&lt;tii&gt; work;int cnt[N &lt;&lt; 2];ll sum[N &lt;&lt; 2];inline void pushup(int rt) &#123; cnt[rt] = cnt[ls] + cnt[rs]; sum[rt] = sum[ls] + sum[rs]; &#125;void upd(int rt, int l, int r, int p, int dlt) &#123; if (l == r) &#123; cnt[rt] += dlt; sum[rt] += 1ll * dlt * w[l]; return; &#125; p &lt;= mid ? upd(ls, l, mid, p, dlt) : upd(rs, mid + 1, r, p, dlt); pushup(rt);&#125;ll query(int rt, int l, int r, int tot) &#123; if (cnt[rt] &lt; tot) return -1; if (l == r) return 1ll * tot * w[l]; if (cnt[rs] &gt;= tot) return query(rs, mid + 1, r, tot); else return query(ls, l, mid, tot - cnt[rs]) + sum[rs];&#125;int main() &#123; int n = rd(); rep(i, 1, n) &#123;a[i] = rd(); b[i] = rd(); w.pb(a[i]);&#125; int q = rd(); rep(i, 1, q) &#123; int op = rd(), x = rd(); if (op == 1) &#123;int y = rd(); w.pb(y); work.eb(op, x, y);&#125; else if (op == 2) work.eb(op, x, rd()); else work.eb(op, x, 0); &#125; w.pb(-1); sort(all(w)); w.erase(unique(all(w)), w.end()); auto getw = [&amp;](int x) &#123;return lower_bound(all(w), x) - w.begin();&#125;; int m = w.size(); rep(i, 1, n) &#123;a[i] = getw(a[i]); upd(1, 1, m, a[i], b[i]);&#125; for (auto [op, x, y] : work) if (op == 3) printf(&quot;%lld\\n&quot;, query(1, 1, m, x)); else &#123; upd(1, 1, m, a[x], -b[x]); op == 1 ? a[x] = getw(y) : b[x] = y; upd(1, 1, m, a[x], b[x]); &#125; return 0;&#125; Ex - Directed Graph and Query 给定一个 \\(n\\ (n\\le 2000)\\) 个点的有向图，\\(q\\ (q\\le 10^4)\\) 次询问从 \\(s_i\\) 到 \\(t_i\\) 经过的节点编号最大值的最小值。 Floyd 最外层枚举到 \\(k\\) 的含义就是只经过编号为 \\(1\\dots k\\) 的节点的最短路。 因此 bitset 维护传递闭包，每次更新完一个 \\(k\\) 就扫描全部询问，看看有没有已满足的即可。 复杂度 \\(O(\\frac{n^3}{64} + nq)\\) 。 1234567891011121314151617181920#define N 2007#define M 10007int ans[M], s[M], t[M];bitset&lt;N&gt; adj[N];int main() &#123; int n = rd(), m = rd(); rep(u, 1, n) adj[u][u] = true; rep(i, 1, m) &#123;int u = rd(), v = rd(); adj[u][v] = true;&#125; int q = rd(); rep(i, 1, q) &#123;s[i] = rd(); t[i] = rd(); ans[i] = -1;&#125; rep(v, 1, n) &#123; rep(u, 1, n) if (adj[u][v]) adj[u] |= adj[v]; rep(i, 1, q) if (ans[i] == -1 &amp;&amp; adj[s[i]][t[i]]) ans[i] = v; &#125; rep(i, 1, q) printf(&quot;%d\\n&quot;, ans[i] == -1 ? -1 : max(&#123;ans[i], s[i], t[i]&#125;)); return 0;&#125;","categories":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://blog.gyx.me/categories/AtCoder/"},{"name":"AtCoder Beginner Contest","slug":"AtCoder/AtCoder-Beginner-Contest","permalink":"http://blog.gyx.me/categories/AtCoder/AtCoder-Beginner-Contest/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"},{"name":"STL","slug":"STL","permalink":"http://blog.gyx.me/tags/STL/"},{"name":"Shortest Path","slug":"Shortest-Path","permalink":"http://blog.gyx.me/tags/Shortest-Path/"},{"name":"Counting","slug":"Counting","permalink":"http://blog.gyx.me/tags/Counting/"},{"name":"Segment Tree","slug":"Segment-Tree","permalink":"http://blog.gyx.me/tags/Segment-Tree/"}]},{"title":"2022-2023 ICPC Asia Nanjing Regional","slug":"official/icpc/22-nanjing","date":"2023-01-26T09:02:00.000Z","updated":"2023-03-20T16:36:14.520Z","comments":true,"path":"official/icpc/22-nanjing/","link":"","permalink":"http://blog.gyx.me/official/icpc/22-nanjing/","excerpt":"","text":"Summary 比赛地址 ：Codeforces Gym 104128 官方题解 ：SUA Wiki 还没补完：CEFHKL 难度：IDGM - ABEJ - CHKL + F(??) A - Stop, Yesterday Please No More B - Ropeway C - Fabulous Fungus Frenzy D - Chat Program 给定一个长度为 \\(n\\) 的整数序列 \\(a_1, a_2, · · · , a_n\\) 和另外四个整数 \\(k,m,c,d\\) ，最大化序列中第 \\(k\\) 大的值。 操作至多一次：选择一个长度恰为 \\(m\\) 的区间，并将一个长度为 \\(m\\)，首项为 \\(c\\)，公差为 \\(d\\) 的等差序列加到对应位置上。 二分答案第 \\(k\\) 大值为 \\(x\\) ，那么每个位置如果要修改为 \\(\\ge x\\) ，合法的操作起点一定在一个区间范围内。 所以找出能让最多的数字合法的位置开始操作即可，区间加 \\(1\\) 最后求最大值，差分即可，复杂度 \\(O(n\\log (a+c+md))\\) 。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 200007int n, k, m, dlt[N];ll c, d, a[N];inline bool valid(ll x) &#123; for (int i = 1; i &lt;= n; ++i) dlt[i] = 0; auto add = [&amp;](ll l, ll r) &#123; l = max(l, 1ll); r = min(r, n - m + 1ll); if (r &lt; l) return; ++dlt[l]; --dlt[r + 1]; &#125;; for (int i = 1; i &lt;= n; ++i) &#123; if (a[i] &gt;= x) ++dlt[1]; else &#123; if (x - a[i] &lt;= c) add(i - m + 1, i); else if (d != 0) add(i - m + 1, i - ((x - a[i] - c + d - 1) / d)); &#125; &#125; int mx = 0; for (int i = 1; i &lt;= n; ++i) &#123; dlt[i] += dlt[i - 1]; mx = max(mx, dlt[i]); &#125; return mx &gt;= k;&#125;int main() &#123; n = rd(), k = rd(), m = rd(); c = rd(), d = rd(); for (int i = 1; i &lt;= n; ++i) a[i] = rd(); ll l = 0, r = 1e18; while (l &lt; r) &#123; ll mid = (l + r + 1) / 2; valid(mid) ? l = mid : r = mid - 1; &#125; printf(&quot;%lld\\n&quot;, l); return 0;&#125; E - Color the Tree F - Triangles G - Inscryption 最后答案就是加入次数 / 剩余个数，显然减少剩余个数优先级更高。 因此能减就减，此外维护可反悔的机会次数，不够减少又必须减少，即需要反悔的时候反悔即可，复杂度 \\(O(n)\\) 。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;int gcd(int a, int b) &#123;return b ? gcd(b, a % b) : a;&#125;inline void work() &#123; bool fl = false; int n = rd(), cnt = 1, sum = 1, reg = 0; for (int i = 1; i &lt;= n; ++i) &#123; int x = rd(); if (x == 1) &#123;++cnt; ++sum;&#125; else if (x == -1) &#123; --cnt; if (!cnt) &#123; if (reg) &#123;--reg; cnt += 2; sum += 1;&#125; else fl = true; &#125; &#125; else &#123; if (cnt &gt; 1) &#123;--cnt; ++reg;&#125; else &#123;++cnt; ++sum;&#125; &#125; &#125; if (fl) &#123;puts(&quot;-1&quot;); return;&#125; int g = gcd(sum, cnt); printf(&quot;%d %d\\n&quot;, sum / g, cnt / g);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; （赛时脑子抽了还写了个dp维护后缀允许的最多减法次数。。。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 1000007int f[N], a[N];int gcd(int a, int b) &#123;return b ? gcd(b, a % b) : a;&#125;inline void work() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) a[i] = rd(); f[n + 1] = 0; for (int i = n; i; --i) if (a[i] == 0) f[i] = f[i + 1]; else if (a[i] == -1) f[i] = f[i + 1] + 1; else f[i] = max(0, f[i + 1] - 1); int nw = 1, sum = 1; for (int i = 1; i &lt;= n; ++i) if (a[i] == -1) &#123;--nw; if (!nw) &#123;puts(&quot;-1&quot;); return;&#125;&#125; else if (a[i] == 1) &#123;++nw; ++sum;&#125; else &#123; if (nw &lt;= f[i] + 1) &#123;++nw; ++sum;&#125; else --nw; &#125; int g = gcd(nw, sum); printf(&quot;%d %d\\n&quot;, sum / g, nw / g);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; H - Factories Once More I - Perfect Palindrome 由定义所有字符必须都相同，保留出现次数最多的字符，复杂度 \\(O(n)\\) 。 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;int cnt[27];char s[100007];inline void work() &#123; scanf(&quot;%s&quot;, s + 1); for (int i = strlen(s + 1); i; --i) ++cnt[s[i] - &#x27;a&#x27;]; int ans = 0; for (int i = 0; i &lt; 26; ++i) &#123; ans = max(ans, cnt[i]); cnt[i] = 0; &#125; printf(&quot;%d\\n&quot;, (int)strlen(s + 1) - ans);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; *J - Perfect Matching 给定 \\(n\\) 个数 \\(a_1, a_2, \\dots, a_n\\) 如果 \\(|a_i-a_j| =|i-j|\\) 那么 \\(i\\) 和 \\(j\\) 就可以匹配。 每个点只能用来匹配一次，问是否存在完美匹配（全部用上）。 整理绝对值得到 \\(a_i+i=a_j+j\\) 或 \\(a_i-i=a_j-j\\) ，那么可以构造一个二分图。 左侧的点代表所有的 \\(a_i+i\\) ，右侧代表 \\(a_i-i\\) ，如果两个位置某一侧共用同一个点即可匹配。 因此就是一个边匹配，也就是线图是否存在完美匹配。线图的最大匹配算法是经典的，复杂度 \\(O(n)\\) 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define T int typedef pair&lt;T, T&gt; pii;typedef tuple&lt;T, T, T&gt; tii;#define fr first#define sc second#define mp make_pair#define mt make_tuple#define pb push_back#define eb emplace_back#define lowbit(x) ((x) &amp; -(x))#define all(x) (x).begin(), (x).end()#define rep(i, x, y) for (int i = (x); i &lt;= (y); ++i)#define per(i, x, y) for (int i = (x); i &gt;= (y); --i)inline T rd() &#123; T x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 200007int tot, hd[N], a[N];struct edge &#123;int to, nxt;&#125; e[N];inline void add(int u, int v) &#123; e[++tot] = &#123;v, hd[u]&#125;; hd[u] = tot; e[++tot] = &#123;u, hd[v]&#125;; hd[v] = tot;&#125;bool vis[N], used[N];vector&lt;pii&gt; ans;void dfs(int u, int fa) &#123; vis[u] = true; int faid = 0; for (int i = hd[u], v; i; i = e[i].nxt) if (!vis[v = e[i].to]) dfs(v, u); else if (v == fa) faid = (i &gt;&gt; 1); int lst = 0; for (int i = hd[u], v, id; i; i = e[i].nxt) if ((v = e[i].to) != fa &amp;&amp; !used[id = (i &gt;&gt; 1)]) &#123; if (lst) &#123; used[lst] = used[id] = true; ans.eb(lst, id); lst = 0; &#125; else lst = id; &#125; if (lst &amp;&amp; faid) &#123; used[lst] = used[faid] = true; ans.eb(lst, faid); &#125;&#125;vector&lt;int&gt; L, R;inline void work() &#123; int m = rd(); L.clear(); R.clear(); ans.clear(); rep (i, 1, m) &#123;a[i] = rd(); L.pb(a[i] + i); R.pb(a[i] - i);&#125; sort(all(L)); L.erase(unique(all(L)), L.end()); sort(all(R)); R.erase(unique(all(R)), R.end()); auto lid = [&amp;](int x) &#123;return lower_bound(all(L), x) - L.begin() + 1;&#125;; auto rid = [&amp;](int x) &#123;return lower_bound(all(R), x) - R.begin() + 1 + L.size();&#125;; tot = 1; int n = L.size() + R.size(); rep(i, 1, n) &#123;hd[i] = 0; vis[i] = false;&#125; rep(i, 1, m) &#123;used[i] = false; add(lid(a[i] + i), rid(a[i] - i));&#125; rep(i, 1, n) if (!vis[i]) dfs(i, i); if (ans.size() * 2 != m) &#123;puts(&quot;No&quot;); return;&#125; puts(&quot;Yes&quot;); for (auto [x, y] : ans) printf(&quot;%d %d\\n&quot;, x, y);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; K - NaN in a Heap L - Proposition Composition *M - Drain the Water Tank 给一个简单多边形水箱，问把内部的水全部放干最少需要在多少个顶点开口（重力沿 \\(y\\) 轴向下）。 显然每个下表面最低处都要开一个口（即两侧都向上）。 因此就需要找出来左右都比当前高的点（包括一段平台），然后判断是否是水箱的下表面。 如果是一个单点，可以用两个向量的叉积符号判断。 如果是一段平台，只需用平台内点的方向即可（给出点按逆时针，因此下表面应当从左到右出现） 复杂度 \\(O(n)\\) 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define T int inline T rd() &#123; T x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define letp const P // P for Pointstruct P &#123; T x, y; P (T x = 0, T y = 0) : x(x), y(y) &#123;&#125; P operator - (letp &amp;p) const &#123;return &#123;x - p.x, y - p.y&#125;;&#125; T operator | (letp &amp;p) const &#123;return x * p.x + y * p.y;&#125; // dot T operator ^ (letp &amp;p) const &#123;return x * p.y - y * p.x;&#125; // cross // left(counterclockwise) = 1 | on = 0 | right(clockwise) = -1 int ori(letp &amp;p) const &#123;T t = (*this) ^ p; return (t &gt; 0) - (t &lt; 0);&#125;&#125;;int main() &#123; int n = rd(); vector&lt;P&gt; p(n); for (int i = 0; i &lt; n; ++i) &#123;p[i].x = rd(); p[i].y = rd();&#125; auto nxt = [&amp;](const int i) &#123;return i == p.size() - 1 ? 0 : i + 1;&#125;; auto pre = [&amp;](const int i) &#123;return i == 0 ? p.size() - 1 : i - 1;&#125;; int l, r, L = 0, ans = 0; for (; p[L].y == p[pre(L)].y; L = pre(L)); l = r = L; do &#123; while (p[r].y == p[nxt(r)].y) r = nxt(r); if (p[pre(l)].y &gt; p[l].y &amp;&amp; p[nxt(r)].y &gt; p[r].y) &#123; if (l == r) ans += ((p[l] - p[pre(l)]).ori(p[nxt(l)] - p[l]) &gt; 0); else ans += (p[nxt(l)].x &gt; p[l].x); &#125; l = r = nxt(r); &#125; while (l != L); printf(&quot;%d\\n&quot;, ans); return 0;&#125; 为什么数据范围要给可以想 \\(n^2\\) 的做法呢。。。 当时一眼以为判断上下表面要用点在多边形内，复杂度恰好是 \\(n^2\\) ，各种爆精度挂了 \\(4\\) 发才过。。。","categories":[{"name":"Official Contests","slug":"Official-Contests","permalink":"http://blog.gyx.me/categories/Official-Contests/"}],"tags":[{"name":"Geometry","slug":"Geometry","permalink":"http://blog.gyx.me/tags/Geometry/"},{"name":"Graphs","slug":"Graphs","permalink":"http://blog.gyx.me/tags/Graphs/"}]},{"title":"Educational Codeforces Round 142 (Rated for Div. 2)","slug":"codeforces/1792","date":"2023-01-25T13:22:00.000Z","updated":"2023-03-20T16:26:53.104Z","comments":true,"path":"codeforces/1792/","link":"","permalink":"http://blog.gyx.me/codeforces/1792/","excerpt":"","text":"A. GamingForces 每次打两个的技能只对两个 \\(1\\) 有效。 123int n = rd(), cnt = 0;for (int i = 1; i &lt;= n; ++i) cnt += (rd() == 1);printf(&quot;%d\\n&quot;, n - cnt + cnt / 2 + cnt % 2); B. Stand-up Comedian 先 a 再轮流 bc 最后 d 。 123int a = rd(), b = rd(), c = rd(), d = rd();if (b &lt; c) swap(b, c);printf(&quot;%d\\n&quot;, a ? a + c * 2 + min(a + 1, b - c + d) : 1); C. Min Max Sort 一个排列，每次可以选两个数 \\(x,y\\) ，将两者较小的移到开头，较大的移到结尾。 问排成增序所需最小操作次数。 倒着考虑，如果最后结束的时候开头不是 \\(1\\) ，结尾不是 \\(n\\) ，就一定要选一次 \\((1, n)\\) 。 以此类推，每次把最小和最大两个数删除，直到剩余序列是排序好的为止。懒删除复杂度 \\(O(n)\\) 。 12345678910111213141516#define N 200007 int a[N];bool vis[N];inline void work() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123;vis[i] = false; a[i] = rd();&#125; int ans = 0; for (int i = 1, l = 1, r = n; l &lt; r; ++i) &#123; while (vis[a[l]]) ++l; while (vis[a[r]]) --r; if (l &gt;= r) break; if (a[l] != i || a[r] != n - i + 1) ans = i; vis[i] = vis[n - i + 1] = true; &#125; printf(&quot;%d\\n&quot;, ans);&#125; D. Fixed Prefix Permutations 反演一下，考虑 \\(a_j\\) 能对每个 \\(a_i\\) 产生多少贡献，容易发现是 \\(a_j\\) 的逆和 \\(a_i\\) 的最长公共前缀。 把所有 \\(a_j\\) 的逆建一棵 Trie ，然后答案就是 \\(a_i\\) 在 Trie 上能跑到的最深的深度。复杂度 \\(O(nm)\\) 。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define T int typedef pair&lt;T, T&gt; pii;typedef tuple&lt;T, T, T&gt; tii;#define fr first#define sc second#define mp make_pair#define mt make_tuple#define pb push_back#define eb emplace_back#define all(x) (x).begin(), (x).end()inline T rd() &#123; T x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;int n, m, tot;struct node &#123; int son[10]; void clear() &#123;for (int i = 0; i &lt; 10; ++i) son[i] = 0;&#125;&#125; c[1000007];inline void insert(vector&lt;int&gt; &amp;s) &#123; // build trie int rt = 0; for (int j = 0; j &lt; m; ++j) &#123; if (!c[rt].son[s[j]]) c[rt].son[s[j]] = ++tot; rt = c[rt].son[s[j]]; &#125;&#125;inline int search(vector&lt;int&gt; &amp;s) &#123; // find the max depth s could reach int rt = 0; for (int j = 0; j &lt; m; ++j) &#123; if (!c[rt].son[s[j]]) return j; rt = c[rt].son[s[j]]; &#125; return m;&#125;vector&lt;int&gt; a[50007], rev;inline void work() &#123; n = rd(); m = rd(); rev.resize(m); for (int i = 0; i &lt; n; ++i) &#123; a[i].clear(); for (int j = 0; j &lt; m; ++j) &#123; int x = rd() - 1; rev[x] = j; a[i].push_back(x); &#125; insert(rev); &#125; for (int i = 0; i &lt; n; ++i) printf(&quot;%d &quot;, search(a[i])); puts(&quot;&quot;); for (int i = 0; i &lt;= tot; ++i) c[i].clear(); tot = 0;&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; E. Divisors and Table 给定 \\(m_1, m_2\\ (m_1,m_2\\le 10^9)\\) ，问 \\(m_1\\times m_2\\) 有多少个因子出现在了 \\(n\\times n\\) 的乘法表里。 此外，对于所有出现因子，求出来该因子出现的最小的行数。输出这些行数的异或和。 \\(m_1m_2\\le 10^{18}\\) ，至多 \\(10^6\\) 个因子，\\(15\\) 个质因子，分开给的目的应该是不用 pollard rho。 那么对于每个因子 \\(x\\) ，保证列合法，找到其不超过 \\(n\\) 的最大的因子 \\(y\\) ，那么最小的行就是 \\(x/y\\) 。 假设这样的 \\(y\\) 叫 \\(mx[x]\\) ，使用搜索的方法生成因子 \\(x\\) ，那么 \\(mx[x]\\) 这个数组是可以递推的。 （对于某个 \\(x\\) 和 \\(x\\) 包含的质因子 \\(p_i\\) ， \\(mx[x]\\) 可能的来源只有 \\(mx[x/p_i]\\) 或 \\(mx[x/p_i] * p_i\\) ） 搜索的计算量是 \\(\\sum_{x|m_1m_2}\\) \\(x\\) 的质因子个数，因此不会超过 \\(15\\times 10^6\\) 可以接受。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define T int typedef pair&lt;T, T&gt; pii;typedef tuple&lt;T, T, T&gt; tii;#define fr first#define sc second#define mp make_pair#define mt make_tuple#define pb push_back#define eb emplace_back#define all(x) (x).begin(), (x).end()inline T rd() &#123; T x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 5007vector&lt;int&gt; d, fac; // fac : prime factors of nwvector&lt;pii&gt; s; // prime factors of m1m2unordered_map&lt;ll, ll&gt; mx; // maximum divisor &lt;= nint n, tot, ans;void dfs(ll nw, int step) &#123; if (step == s.size()) return; dfs(nw, step + 1); auto [p, t] = s[step]; fac.push_back(p); for (; t; --t) &#123; nw *= p; for (auto x : fac) &#123; ll y = mx[nw / x]; mx[nw] = max(mx[nw], (y * x &lt;= n ? y * x : y)); &#125; if (nw / mx[nw] &lt;= n) &#123;++tot; ans ^= nw / mx[nw];&#125; else break; dfs(nw, step + 1); &#125; fac.pop_back();&#125;inline void work() &#123; n = rd(); mx.clear(); d.clear(); s.clear(); mx[1] = 1; tot = ans = 1; auto getd = [&amp;](int x) &#123; int lim = sqrt(x); for (int i = 2; i &lt;= lim &amp;&amp; i &lt;= x; ++i) while (x % i == 0) &#123;d.pb(i); x /= i;&#125; if (x &gt; 1) d.pb(x); &#125;; getd(rd()); getd(rd()); sort(all(d)); int lst = 0, cnt = 0; for (auto x : d) if (x != lst) &#123; if (lst) s.eb(lst, cnt); lst = x; cnt = 1; &#125; else ++cnt; s.eb(lst, cnt); dfs(1, 0); printf(&quot;%d %d\\n&quot;, tot, ans);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; F. Graph Coloring 给 \\(n\\) 个点的完全图的边红蓝染色，求染色方案数模 \\(998244353\\) ，满足： 至少有一条红边，至少有一条蓝边 对于任何一个大于 \\(2\\) 的点集，其导出子图是红连通或蓝连通的，但不同时成立。 结论：若一幅图不连通，则其补图连通。 归纳证明，首先 \\(1\\) 个点的时候成立。假设 \\(k\\) 个点成立，那么对于新增的一个点： 与 \\(k\\) 个点都连通，那么图中该点连通了所有点。 与 \\(k\\) 个点都不连通，那么补图中该点连通了所有点。 与一些点有边一些点无边，则原图连通即可连上该点，原图不连通则补图即可连上该点。 所以计数时只需要保证红蓝不同时连通即可。 假设 \\(n\\) 个点的答案为 \\(A_n\\) ，对于任意一个解边颜色取反仍然是一个解。 因此我们计数 \\(n\\) 个点，全集只被蓝色连通的方案数 \\(B_n\\) ，有 \\(A_n=2\\times B_n\\) （特殊 \\(A_1=B_1=1\\) ）。 递推考虑 \\(1\\) 号点被加入的情况。 对于 \\(1\\) 号点所在的红色连通分量（极大），由定义每个点和分量外的点的边都是蓝色。 这时想要把 \\(1\\) 号点蓝连通加入，则必定要选分量内的点和分量外的点的边。 无论分量外的点之间的边如何染色，这幅图的生成树必定包含蓝色的边，由开始的结论这幅图只能是蓝连通。 因此递推枚举红色连通分量的大小 \\(k\\) ，则分量内方案数 \\(B_k\\) ，分量外方案数 \\(A_{n-k}\\) ，有： \\[ B_n =\\sum_{k=1}^{n-1} {n - 1\\choose k - 1} B_k A_{n-k},\\ n&gt;1 \\] 递推复杂度 \\(O(n^2)\\) 。 123456789101112131415161718192021222324252627282930313233#define N 5007#define mod 998244353int fac[N], ifac[N]; inline int fpow(int x, int t = mod - 2) &#123; int res = 1; for (; t; t &gt;&gt;= 1, x = 1ll * x * x % mod) if (t &amp; 1) res = 1ll * res * x % mod; return res;&#125; inline ll C(int n, int m) &#123; if (n &lt; m) return 0; return 1ll * fac[n] * ifac[m] % mod * ifac[n - m] % mod;&#125;int b[N] = &#123;0, 1&#125;, a[N] = &#123;0, 1&#125;;int main() &#123; int n = rd(); fac[0] = ifac[0] = 1; rep(i, 1, n) fac[i] = 1ll * fac[i - 1] * i % mod; ifac[n] = fpow(fac[n]); per(i, n - 1, 1) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % mod; rep(i, 2, n) &#123; rep(j, 1, i - 1) b[i] = (b[i] + C(i - 1, j - 1) * b[j] % mod * a[i - j]) % mod; a[i] = 2 * b[i] % mod; &#125; printf(&quot;%d\\n&quot;, (a[n] + mod - 2) % mod); // 去掉全红/蓝的情况 return 0;&#125; 整理系数之后就可以分治 NTT 计算了。复杂度 \\(O(n\\log ^2 n)\\) 。","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://blog.gyx.me/categories/Codeforces/"},{"name":"Educational Codeforces Round","slug":"Codeforces/Educational-Codeforces-Round","permalink":"http://blog.gyx.me/categories/Codeforces/Educational-Codeforces-Round/"}],"tags":[{"name":"Graphs","slug":"Graphs","permalink":"http://blog.gyx.me/tags/Graphs/"},{"name":"Number Theory","slug":"Number-Theory","permalink":"http://blog.gyx.me/tags/Number-Theory/"},{"name":"Counting","slug":"Counting","permalink":"http://blog.gyx.me/tags/Counting/"}]},{"title":"Codeforces Round #844 (Div. 1 + Div. 2)","slug":"codeforces/1782","date":"2023-01-16T02:01:00.000Z","updated":"2023-03-20T16:26:16.675Z","comments":true,"path":"codeforces/1782/","link":"","permalink":"http://blog.gyx.me/codeforces/1782/","excerpt":"","text":"A. Parallel Projection 枚举一下选择的边界点即可。复杂度 \\(O(t(w+d))\\) 。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define T int typedef pair&lt;T, T&gt; pii;typedef tuple&lt;T, T, T&gt; tii;#define mp make_pair#define pb push_back#define mt make_tuple#define all(x) (x).begin(), (x).end()#define lowbit(x) ((x) &amp; -(x))inline T rd() &#123; T x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 100007inline void work() &#123; int w = rd(), d = rd(), h = rd(); int a = rd(), b = rd(), f = rd(), g = rd(); int ans = 1e9; auto calc = [&amp;](int x, int y) &#123; ans = min(ans, h + abs(a - x) + abs(b - y) + abs(f - x) + abs(g - y)); &#125;; for (int i = 0; i &lt;= d; ++i) &#123;calc(0, i); calc(w, i);&#125; for (int i = 0; i &lt;= w; ++i) &#123;calc(i, 0); calc(i, d);&#125; printf(&quot;%d\\n&quot;, ans);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; B. Going to the Cinema \\(a_i\\) 升序排序，显然去的人会是一个前缀。 枚举去了 \\(k\\) 个，只需要检查第 \\(k\\) 个人和第 \\(k+1\\) 个人。复杂度 \\(O(n\\log n)\\) 。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define T int typedef pair&lt;T, T&gt; pii;typedef tuple&lt;T, T, T&gt; tii;#define mp make_pair#define pb push_back#define mt make_tuple#define all(x) (x).begin(), (x).end()#define lowbit(x) ((x) &amp; -(x))inline T rd() &#123; T x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 200007int a[N];inline void work() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) a[i] = rd(); sort(a + 1, a + 1 + n); a[n + 1] = 1e9; int ans = (a[1] &gt; 0); for (int i = 1; i &lt;= n; ++i) &#123; if (i &gt; a[i] &amp;&amp; i &lt; a[i + 1]) ++ans; &#125; printf(&quot;%d\\n&quot;, ans);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; C. Equal Frequencies 枚举用了多少个字符，然后选出现次数最多的那几个即可。好一点的实现可以复杂度 \\(O(n)\\) 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define T int typedef pair&lt;T, T&gt; pii;typedef tuple&lt;T, T, T&gt; tii;#define mp make_pair#define pb push_back#define mt make_tuple#define all(x) (x).begin(), (x).end()#define lowbit(x) ((x) &amp; -(x))inline T rd() &#123; T x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 200007char s[N], t[N];int n, cnt[26], rem[26], id[26];vector&lt;char&gt; add;inline int calc(int m) &#123; int ret = n; for (int i = 0; i &lt; m; ++i) ret -= min(n / m, cnt[i]); return ret;&#125;inline void work() &#123; n = rd(); scanf(&quot;%s&quot;, s + 1); for (int i = 0; i &lt; 26; ++i) cnt[i] = rem[i] = 0; for (int i = 1; i &lt;= n; ++i) ++cnt[s[i] - &#x27;a&#x27;]; for (int i = 0; i &lt; 26; ++i) id[i] = i; sort(id, id + 26, [&amp;](int a, int b) &#123;return cnt[a] &gt; cnt[b];&#125;); sort(cnt, cnt + 26, [&amp;](int a, int b) &#123;return a &gt; b;&#125;); int ans = 1e9, res = 1; for (int i = 1; i &lt;= 26; ++i) if (n % i == 0) &#123; int ret = calc(i); if (ret &lt; ans) &#123;ans = ret; res = i;&#125; &#125; for (int i = 0; i &lt; res; ++i) rem[id[i]] = n / res; printf(&quot;%d\\n&quot;, ans); for (int i = 1; i &lt;= n; ++i) &#123; if (rem[s[i] - &#x27;a&#x27;]) &#123;--rem[s[i] - &#x27;a&#x27;]; t[i] = s[i];&#125; else t[i] = 0; &#125; add.clear(); for (int i = 0; i &lt; res; ++i) if (rem[id[i]]) for (int j = 1; j &lt;= rem[id[i]]; ++j) add.push_back(id[i] + &#x27;a&#x27;); for (int i = 1; i &lt;= n; ++i) if (t[i] == 0) &#123;t[i] = add.back(); add.pop_back();&#125; t[n + 1] = &#x27;\\0&#x27;; puts(t + 1);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; D. Many Perfect Squares 给定 \\(n\\ (n\\le 50)\\) 个数 \\(a_1,\\dots,a_n\\) ，求： \\[ \\max_{0\\le x\\le 10^{18}} \\sum_{i=1}^n [ \\exists t \\in \\mathbb{N}, x+a_i=t^2] \\] 答案至少为 \\(1\\) ，考虑答案 \\(\\ge 2\\) 时，枚举答案包含的某两个 \\(a_i,a_j\\ (a_i\\le a_j)\\) ，则 \\(x\\) 要满足： \\[ \\left\\{ \\begin{array}{l} x+a_i=t_1^2 \\\\ x+a_j=t_2^2 \\end{array} \\right. \\Rightarrow a_j-a_i=t_2^2-t_1^2=(t_2+t_1)(t_2-t_1) \\] 对于一组 \\((a_i,a_j)\\) 只有因数个数级别的可能，因此总共需尝试的 \\(x\\) 只有 \\(O(n^2 \\sqrt[3]{\\max a_i-a_j})\\) 个数。 复杂度 \\(O(n^2\\sqrt{\\max \\Delta}+n^3\\sqrt[3]{\\max \\Delta})\\) 。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define T int typedef pair&lt;T, T&gt; pii;typedef tuple&lt;T, T, T&gt; tii;#define mp make_pair#define pb push_back#define mt make_tuple#define all(x) (x).begin(), (x).end()#define lowbit(x) ((x) &amp; -(x))inline T rd() &#123; T x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 57int a[N], ans;unordered_map&lt;ll, bool&gt; vis; inline void work() &#123; int n = rd(); ans = 1; vis.clear(); for (int i = 1; i &lt;= n; ++i) a[i] = rd(); auto issqr = [&amp;](ll x) &#123; ll rt = sqrt(x); for (ll i = rt - 2; i &lt;= rt + 2; ++i) if (i * i == x) return true; return false; &#125;; auto test = [&amp;](ll x) &#123; int cnt = 0; for (int i = 1; i &lt;= n; ++i) cnt += issqr(a[i] + x); return cnt; &#125;; for (int i = 1; i &lt; n; ++i) for (int j = i + 1; j &lt;= n; ++j) &#123; int x = a[j] - a[i]; int lim = sqrt(x); for (int d = 1; d &lt;= lim; ++d) if (x % d == 0) &#123; int t = x / d - d; if (t &amp; 1) continue; t &gt;&gt;= 1; ll tar = 1ll * t * t - a[i]; if (tar &lt; 0) break; if (vis[tar]) continue; vis[tar] = true; ans = max(ans, test(tar)); &#125; &#125; printf(&quot;%d\\n&quot;, ans);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; E. Rectangle Shrinking 只有一行则面积不会变小：按照左端点排序，依次处理，将左端点增大到此前区间最靠右的位置之后即可。 对于两行，先把高度是 \\(2\\) 的矩形按照上述方法处理后，不再有交。 然后两行分别考虑，找出来所有该行有覆盖的矩形，按照左端点排序，然后扫描： 如果当前块 \\([l_i,r_i]\\) 是两行的： 如果在这一行被完全包含，则删掉当前块这一行的部分即可。 否则将前面的所有区间右端点改为 \\(&lt;l_i\\) 。因为前面的操作保证高度是 \\(2\\) 的不交，所以只会改高度是 \\(1\\) 的，而每个块显然至多只会因为这个操作被修改一次，所以复杂度没问题。 如果当前块 \\([l_i,r_i]\\) 是一行的： 如果被完全包含，直接删掉。 否则将左端点增大到此前区间最靠右的位置之后。 很容易发现面积不会变小，都修改完之后算面积即可。 复杂度 \\(O(n\\log n)\\) 。其实代码大段复制粘贴也不难写。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define T int typedef pair&lt;T, T&gt; pii;typedef tuple&lt;T, T, T&gt; tii;#define mp make_pair#define pb push_back#define mt make_tuple#define all(x) (x).begin(), (x).end()#define lowbit(x) ((x) &amp; -(x))inline T rd() &#123; T x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 200007vector&lt;int&gt; s;struct node &#123;int u, d, l, r;&#125; c[N];inline void work() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; c[i].u = rd(); c[i].l = rd(); c[i].d = rd(); c[i].r = rd(); &#125; // u = 1 &amp;&amp; d = 2 s.clear(); for (int i = 1; i &lt;= n; ++i) if (c[i].u == 1 &amp;&amp; c[i].d == 2) s.pb(i); sort(all(s), [&amp;](int a, int b)&#123;return c[a].l == c[b].l ? c[a].r &lt; c[b].r : c[a].l &lt; c[b].l;&#125;); int r = 0; for (auto x : s) &#123; if (c[x].r &lt;= r) c[x] = (node)&#123;0, 0, 0, 0&#125;; else &#123;c[x].l = max(c[x].l, r + 1); r = c[x].r;&#125; &#125; // u = 1 s.clear(); for (int i = 1; i &lt;= n; ++i) if (c[i].u == 1) s.pb(i); sort(all(s), [&amp;](int a, int b)&#123;return c[a].l == c[b].l ? c[a].r &lt; c[b].r : c[a].l &lt; c[b].l;&#125;); r = 0; for (int i = 0, lim = (int)s.size(), ptr = 0; i &lt; lim; ++i) &#123; int x = s[i]; if (c[x].d == 2) &#123; if (r &gt;= c[x].r) c[x].u = 2; else &#123; for (; ptr &lt; i; ++ptr) if (c[s[ptr]].r &gt;= c[x].l) c[s[ptr]].r = c[x].l - 1; r = c[x].r; &#125; &#125; else &#123; if (c[x].r &lt;= r) c[x] = (node)&#123;0, 0, 0, 0&#125;; else &#123;c[x].l = max(c[x].l, r + 1); r = c[x].r;&#125; &#125; &#125; // d = 2 s.clear(); for (int i = 1; i &lt;= n; ++i) if (c[i].d == 2) s.pb(i); sort(all(s), [&amp;](int a, int b)&#123;return c[a].l == c[b].l ? c[a].r &lt; c[b].r : c[a].l &lt; c[b].l;&#125;); r = 0; for (int i = 0, lim = (int)s.size(), ptr = 0; i &lt; lim; ++i) &#123; int x = s[i]; if (c[x].u == 1) &#123; if (r &gt;= c[x].r) c[x].d = 1; else &#123; for (; ptr &lt; i; ++ptr) if (c[s[ptr]].r &gt;= c[x].l) c[s[ptr]].r = c[x].l - 1; r = c[x].r; &#125; &#125; else &#123; if (c[x].r &lt;= r) c[x] = (node)&#123;0, 0, 0, 0&#125;; else &#123;c[x].l = max(c[x].l, r + 1); r = c[x].r;&#125; &#125; &#125; int tot = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (c[i].u &gt; c[i].d || c[i].l &gt; c[i].r) c[i] = (node)&#123;0, 0, 0, 0&#125;; if (c[i].u) tot += (c[i].d - c[i].u + 1) * (c[i].r - c[i].l + 1); &#125; printf(&quot;%d\\n&quot;, tot); for (int i = 1; i &lt;= n; ++i) printf(&quot;%d %d %d %d\\n&quot;, c[i].u, c[i].l, c[i].d, c[i].r);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://blog.gyx.me/categories/Codeforces/"},{"name":"Codeforces Round","slug":"Codeforces/Codeforces-Round","permalink":"http://blog.gyx.me/categories/Codeforces/Codeforces-Round/"}],"tags":[]},{"title":"AtCoder Regular Contest 153","slug":"atcoder/arc153","date":"2023-01-14T14:20:11.000Z","updated":"2023-03-20T16:28:57.860Z","comments":true,"path":"atcoder/arc153/","link":"","permalink":"http://blog.gyx.me/atcoder/arc153/","excerpt":"","text":"A. AABCDDEFE 找形如 AABCDDEFE 的第 \\(k\\) 大数。 个数只有 \\(10^6\\) 个，枚举（甚至可以排序）找第 \\(k\\) 大。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;vector&lt;int&gt; s;int main() &#123; for (int i = 1, x = 0; i &lt;= 9; ++i) &#123; x = i * 110000000; s.push_back(x); for (int j = 0; j &lt;= 99; ++j) &#123; if (j) &#123;x = x / 100000 * 100000 + 100000; s.push_back(x);&#125; for (int k = 0; k &lt;= 9; ++k) &#123; if (k) &#123;x = x / 100000 * 100000 + k * 11000; s.push_back(x);&#125; for (int l = 0; l &lt;= 9; ++l) &#123; if (l) &#123;x = x / 1000 * 1000 + l * 101; s.push_back(x);&#125; for (int r = 1; r &lt;= 9; ++r) if (r) &#123;x += 10; s.push_back(x);&#125; &#125; &#125; &#125; &#125; sort(s.begin(), s.end()); s.erase(unique(s.begin(), s.end()), s.end()); int n = rd(); printf(&quot;%d\\n&quot;, s[n - 1]); return 0;&#125; B. Grid Rotations 一个字符矩阵 \\((W\\times H\\le 5\\times 10^5)\\) ， \\(n\\ (n\\le 2\\times 10^5)\\) 次操作，最后输出整个矩阵。 每次操作给一个点，把矩阵划分成四个矩形，将四个矩形各自旋转 \\(180^\\circ\\) （放在原位）。 容易发现交换不会改变同行同列关系，因此可以对行列坐标分别维护对应的变化，每次翻转某点分开的前后两个区间。 直接平衡树显然是可以做的，赛中就用 rope 水过去了（同时维护正反两个链表）。 12345inline void inv(int p) &#123; // reverse first p elements and last n - p elements tmp = s; s = r.substr(n - p, p) + r.substr(0, n - p); r = tmp.substr(p, n - p) + tmp.substr(0, p); // reversed sequence&#125; 正经结论是：如果把排列看成环，那么每次操作不会改变任意两数之间的相邻关系。 所以最多只有 \\(2n\\) 个排列（原始正反 + shift），每次直接找是哪个就行了，可以用 1 和 2 的位置确定。 最终复杂度 \\(O(HW + n)\\) 。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;int main() &#123; int H = rd(), W = rd(); vector&lt;int&gt; r(H, 0), c(W, 0); vector&lt;vector&lt;char&gt;&gt; a(H, vector&lt;char&gt;(W)); for (int i = 0; i &lt; H; ++i) for (int j = 0; j &lt; W; ++j) &#123; char c = getchar(); while (!isalpha(c)) c = getchar(); a[i][j] = c; &#125; int n = rd(), r0 = 0, r1 = 1, c0 = 0, c1 = 1; auto upd = [&amp;](int &amp;pos, int m, int p) &#123;pos = (pos &gt; p) * m + p - pos;&#125;; for (int i = 1; i &lt;= n; ++i) &#123; int x = rd() - 1, y = rd() - 1; upd(r1, H, x); upd(r0, H, x); upd(c1, W, y); upd(c0, W, y); &#125; if (r1 == (r0 + 1) % H) for (int i = 0; i &lt; H; ++i) r[(r0 + i) % H] = i; else for (int i = 0; i &lt; H; ++i) r[(r0 + H - i) % H] = i; if (c1 == (c0 + 1) % W) for (int i = 0; i &lt; W; ++i) c[(c0 + i) % W] = i; else for (int i = 0; i &lt; W; ++i) c[(c0 + W - i) % W] = i; for (int i = 0; i &lt; H; ++i) &#123; for (int j = 0; j &lt; W; ++j) putchar(a[r[i]][c[j]]); puts(&quot;&quot;); &#125; return 0;&#125; D. cf 上有一个二元版本 https://codeforces.com/contest/1188/problem/D","categories":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://blog.gyx.me/categories/AtCoder/"},{"name":"AtCoder Regular Contest","slug":"AtCoder/AtCoder-Regular-Contest","permalink":"http://blog.gyx.me/categories/AtCoder/AtCoder-Regular-Contest/"}],"tags":[{"name":"Constructive Algorithm","slug":"Constructive-Algorithm","permalink":"http://blog.gyx.me/tags/Constructive-Algorithm/"}]},{"title":"Line Graph","slug":"algorithms/line-graph","date":"2022-12-24T10:42:01.000Z","updated":"2023-04-14T05:43:18.623Z","comments":true,"path":"algorithms/line-graph/","link":"","permalink":"http://blog.gyx.me/algorithms/line-graph/","excerpt":"","text":"Definition Maximum Matching 边数是偶数的图的线图具有完美匹配；奇数则存在只有一条边没有匹配的方案。 先随便找一棵 dfs 树，然后从深到浅考虑每一个点。 找到所有和它相连的未被匹配的边，除了它连向父亲的边（这条边显然未被匹配）。 如果边是偶数条，两两匹配即可，连向父亲的边会在处理父亲时被匹配上。如果边是奇数条，就把连向父亲的边也加入匹配。 当递归回到根节点时，此时 dfs 树上未匹配的边都是从根节点连向直接子节点的边。 因此偶数条边时都可以匹配上，否则最多剩下一条。一道例题 1234567891011121314151617181920212223242526272829303132333435363738#define N 200007int hd[N], tot = 1;bool vis[N], used[N];struct edge &#123;int to, nxt;&#125; e[N &lt;&lt; 1];vector&lt;tii&gt; ans;void dfs(int u, int fa) &#123; vis[u] = true; int faid = 0; for (int i = hd[u], v; i; i = e[i].nxt) if (!vis[v = e[i].to]) dfs(v, u); else if (v == fa) faid = (i &gt;&gt; 1); int lstid = 0, lstv = 0; for (int i = hd[u], v, id; i; i = e[i].nxt) if ((v = e[i].to) != fa &amp;&amp; !used[id = (i &gt;&gt; 1)]) &#123; if (lstid) &#123; used[lstid] = used[id] = true; ans.eb(lstv, u, v); lstid = lstv = 0; &#125; else &#123;lstid = id; lstv = v;&#125; &#125; if (lstid &amp;&amp; faid) &#123; used[lstid] = used[faid] = true; ans.eb(lstv, u, fa); &#125;&#125;int main() &#123; int n = rd(), m = rd(); for (int i = 1; i &lt;= m; ++i) &#123; int u = rd(), v = rd(); e[++tot].to = v; e[tot].nxt = hd[u]; hd[u] = tot; e[++tot].to = u; e[tot].nxt = hd[v]; hd[v] = tot; &#125; for (int i = 1; i &lt;= n; ++i) if (!vis[i]) dfs(i, i); printf(&quot;%d\\n&quot;, (int)ans.size()); for (auto [u, v, w] : ans) printf(&quot;%d %d %d\\n&quot;, u, v, w); return 0;&#125; 一些简单变式：Edge Pairing , Perfect Matching , Line Graph Matching","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://blog.gyx.me/categories/Algorithms/"}],"tags":[{"name":"Graphs","slug":"Graphs","permalink":"http://blog.gyx.me/tags/Graphs/"}]},{"title":"Codeforces Round #383 (Div. 1)","slug":"codeforces/741","date":"2022-11-29T16:00:00.000Z","updated":"2023-03-20T16:25:37.585Z","comments":true,"path":"codeforces/741/","link":"","permalink":"http://blog.gyx.me/codeforces/741/","excerpt":"","text":"Div. 2 的 AB 比较水就不记录了。 A - Arpa's loud Owf and Mehrdad's evil plan 如果不是排列寄。否则答案必须是奇环环长的倍数，偶环环长一半的倍数。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125; #define N 107ll gcd(ll a, ll b) &#123;return b ? gcd(b, a % b) : a;&#125;bool vis[N];int a[N], deg[N];int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) ++deg[a[i] = rd()]; ll ans = 1; for (int i = 1; i &lt;= n; ++i) &#123; if (!deg[i]) &#123;puts(&quot;-1&quot;); return 0;&#125; if (!vis[i]) &#123; int len = 0; for (int p = i; !vis[p]; p = a[p], ++len) vis[p] = true; if (!(len &amp; 1)) len /= 2; ans = ans / gcd(ans, len) * len; &#125; &#125; printf(&quot;%lld\\n&quot;, ans); return 0;&#125; B - Arpa's weak amphitheater and Mehrdad's valuable Hoses 并查集求出来每个小团体。对于每个小团体，可选的转移方式为单人/全选。 背包先用另一个数组 \\(g\\) 记录 \\(f\\) 经过所有可能的转移的 \\(\\max\\) ，再赋值回 \\(f\\) 更新，复杂度 \\(O(nw)\\)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125; #define N 1007struct DSU &#123; int f[N]; inline void reset(int n) &#123;for (int i = 1; i &lt;= n; ++i) f[i] = i;&#125; int find(int x) &#123;return x == f[x] ? x : f[x] = find(f[x]);&#125; inline bool merge(int x, int y) &#123; x = find(x); y = find(y); return x == y ? false : (f[x] = y, true); &#125;&#125; dsu;int w[N], v[N], f[N], g[N];vector&lt;int&gt; s[N];int main() &#123; int n = rd(), m = rd(), tot = rd(); dsu.reset(n); for (int i = 1; i &lt;= n; ++i) w[i] = rd(); for (int i = 1; i &lt;= n; ++i) v[i] = rd(); for (int i = 1; i &lt;= m; ++i) dsu.merge(rd(), rd()); for (int i = 1; i &lt;= n; ++i) s[dsu.find(i)].push_back(i); auto upd = [&amp;](int W, int V) &#123; for (int i = W; i &lt;= tot; ++i) g[i] = max(g[i], f[i - W] + V); &#125;; for (int i = 1; i &lt;= n; ++i) &#123; if (s[i].empty()) continue; int sumw = 0, sumv = 0; for (auto x : s[i]) &#123; sumw += w[x]; sumv += v[x]; upd(w[x], v[x]); &#125; upd(sumw, sumv); for (int i = 1; i &lt;= tot; ++i) f[i] = max(f[i], g[i]); &#125; printf(&quot;%d\\n&quot;, f[tot]); return 0; &#125; C - Arpa’s overnight party and Mehrdad’s silent entering \\(2\\times n\\) 个人（ \\(n\\) 个情侣）坐成一个环，黑白染色，要求情侣颜色不同，相邻三个中至少有两个颜色。 有意思的构造题。看到黑白染色就两种可能，2-SAT 和 二分图，相邻三个的要求写不成 2-SAT 的约束。 所以就想办法构造二分图，即构造一个图没有奇环。 每个人只有一个固定的情侣，这启示我们也要找一类边，使得每个点只有一个这样的出边，这样一定是偶环（两类边交替）。 容易发现让 \\(2i-1\\) 和 \\(2i\\) 连边即可保证相邻三个颜色不都相同，且符合上述构造要求。二分图染色。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125; #define N 200007#define pb push_backint ty[N], a[N], b[N];vector&lt;int&gt; e[N];void dfs(int u) &#123; for (auto v : e[u]) if (!ty[v])&#123;ty[v] = 3 - ty[u]; dfs(v);&#125;&#125;int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; a[i] = rd(); b[i] = rd(); e[a[i]].pb(b[i]); e[b[i]].pb(a[i]); int u = i * 2, v = i * 2 - 1; e[u].pb(v); e[v].pb(u); &#125; for (int i = 1; i &lt;= n * 2; ++i) if (!ty[i]) &#123;ty[i] = 1; dfs(i);&#125; for (int i = 1; i &lt;= n; ++i) printf(&quot;%d %d\\n&quot;, ty[a[i]], ty[b[i]]); return 0; &#125; D - Arpa’s letter-marked tree and Mehrdad’s Dokhtar-kosh paths 一棵树每条边上有一个字符 (a - v) ，每次询问 \\(u_i\\) 子树内最长的简单路径，满足其上的字符重排可形成回文串。 \\((u,v)\\) 路径信息 \\(=u\\) 到根信息 \\(+v\\) 到根信息 \\(-2*lca(u,v)\\) 到根信息。 字符集只有 \\(22\\) ，状压 \\(u\\) 到根每个字符的奇偶性 \\(s_u\\) ，路径信息即为 \\(s_u\\oplus s_v\\) （lca 信息因为异或两次消掉了） 考虑路径合并，每个点可能的配对方案只有 \\(23\\) 种（异或后为 \\(0\\) 或 \\(2\\) 的幂次，即最多允许一个字符出现奇数次） DSU on Tree，统计此前子树的信息，维护每个状压值的最深深度，保证 lca 是当前点需整个子树先查询后插入。 坑：1. 子树内最长要和儿子的 ans 取 \\(\\max\\) ；2.枚举配对的状态时，得保证存在再更新。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;#define pic pair&lt;int, char&gt;#define lowbit(x) ((x) &amp; -(x))#define N 500007int ch[N], sta[N], mxd[1 &lt;&lt; 22], ans[N], res;int sz[N], mxs[N], dep[N];vector&lt;int&gt; son[N];void dfs(int u, int fa, int S) &#123; sz[u] = 1; dep[u] = dep[fa] + 1; if (u != 1) S ^= (1 &lt;&lt; ch[u]); sta[u] = S; for (auto v : son[u]) &#123; dfs(v, u, S); sz[u] += sz[v]; if (sz[v] &gt; sz[mxs[u]]) mxs[u] = v; &#125;&#125;inline void upd(int u) &#123; // adding information of u into data structures mxd[sta[u]] = max(mxd[sta[u]], dep[u]);&#125;inline void del(int u) &#123; // deleting information of u from data structures mxd[sta[u]] = 0; res = 0;&#125;void upd(int u, int fa) &#123; upd(u); for (auto v : son[u]) if (v != fa) upd(v, u);&#125;void del(int u, int fa) &#123; del(u); for (auto v : son[u]) if (v != fa) del(v, u);&#125;void updans(int u, int del) &#123; // 枚举配对的状态需要保证存在！！！ if (mxd[sta[u]]) res = max(res, dep[u] + mxd[sta[u]] - 2 * del); for (int i = 0; i &lt; 22; ++i) if (mxd[sta[u] ^ (1 &lt;&lt; i)]) res = max(res, dep[u] + mxd[sta[u] ^ (1 &lt;&lt; i)] - 2 * del);&#125;void getans(int u, int del) &#123; updans(u, del); for (auto v : son[u]) getans(v, del);&#125;void dsu(int u, int fa) &#123; for (auto v : son[u]) if (v != fa &amp;&amp; v != mxs[u]) &#123;dsu(v, u); del(v, u);&#125; if (mxs[u]) dsu(mxs[u], u); updans(u, dep[u]); upd(u); for (auto v : son[u]) if (v != fa &amp;&amp; v != mxs[u]) &#123; getans(v, dep[u]); res = max(res, ans[v]); upd(v, u); &#125; ans[u] = res;&#125;int main() &#123; int n = rd(); for (int i = 2; i &lt;= n; ++i) &#123; son[rd()].pb(i); char c = getchar(); while (!isalpha(c)) c = getchar(); ch[i] = (c - &#x27;a&#x27;); &#125; dfs(1, 1, 0); dsu(1, 1); for (int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, ans[i]); return 0;&#125; E - Arpa’s abnormal DNA and Mehrdad’s deep interest","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://blog.gyx.me/categories/Codeforces/"},{"name":"Codeforces Round","slug":"Codeforces/Codeforces-Round","permalink":"http://blog.gyx.me/categories/Codeforces/Codeforces-Round/"}],"tags":[{"name":"Graphs","slug":"Graphs","permalink":"http://blog.gyx.me/tags/Graphs/"},{"name":"DFS and Similar","slug":"DFS-and-Similar","permalink":"http://blog.gyx.me/tags/DFS-and-Similar/"},{"name":"Knapsack Problem","slug":"Knapsack-Problem","permalink":"http://blog.gyx.me/tags/Knapsack-Problem/"},{"name":"Constructive Algorithm","slug":"Constructive-Algorithm","permalink":"http://blog.gyx.me/tags/Constructive-Algorithm/"},{"name":"String Suffix Structures","slug":"String-Suffix-Structures","permalink":"http://blog.gyx.me/tags/String-Suffix-Structures/"}]},{"title":"2022-2023 ICPC Southern and Volga Russian Regional","slug":"official/icpc/22-southern-and-volga-russian","date":"2022-11-28T13:27:07.000Z","updated":"2023-03-20T16:36:24.453Z","comments":true,"path":"official/icpc/22-southern-and-volga-russian/","link":"","permalink":"http://blog.gyx.me/official/icpc/22-southern-and-volga-russian/","excerpt":"","text":"比赛地址 ：Codeforces Contest 1765 待补：CGIJ A - Access Levels 定义 \\(S_i\\) 为可以看第 \\(i\\) 个文档的人的集合，如果 \\(S_i\\subseteq S_j\\) ，那么 \\(i\\) 和 \\(j\\) 可以放到一组。 最小链覆盖，转换成二分图匹配，然后按照链的顺序依次构造即可。注意需要去重（或 \\(S\\) 相同的定序）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;const int maxn=500;int n,m,K,ID[maxn+5],val[maxn+5],ans[maxn+5][maxn+5];char pic[maxn+5][maxn+5];vector&lt;int&gt; e[maxn+5];int ti,vis[maxn+5],who[maxn+5];#define ID(x,y) (((x)&lt;&lt;1)-(y))bool check(int i,int j)&#123; bool fl=true; for (int k=1;k&lt;=n;k++) if (pic[k][i]!=pic[k][j]) &#123;fl=false;break;&#125; if (fl) return i&lt;j; for (int k=1;k&lt;=n;k++) if (pic[k][i]&lt;pic[k][j]) return false; return true;&#125;bool Find(int x)&#123; if (vis[x]==ti) return false; vis[x]=ti; for (auto y:e[x]) if (!who[y] || Find(who[y])) &#123;who[y]=x;return true;&#125; return false;&#125;void DFS(int i)&#123; ID[i]=ID[0];val[i]=++val[0]; if (who[i])&#123; for (int j=1;j&lt;=n;j++) if (pic[j][i]&gt;pic[j][who[i]]) ans[j][ID[0]]=val[i]; DFS(who[i]); &#125; else &#123; for (int j=1;j&lt;=n;j++) if (pic[j][i]==&#x27;1&#x27;) ans[j][ID[0]]=val[i]; &#125;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for (int i=1;i&lt;=n;i++) scanf(&quot;%s&quot;,pic[i]+1); for (int i=1;i&lt;=m;i++) for (int j=1;j&lt;=m;j++) if (check(i,j)) e[j].push_back(i); K=m; for (int i=1;i&lt;=m;i++) ti++,K-=Find(i); ti++; for (int i=1;i&lt;=m;i++) vis[who[i]]=ti; printf(&quot;%d\\n&quot;,K); for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=K;j++) ans[i][j]=1; for (int i=1;i&lt;=m;i++) if (vis[i]&lt;ti) ID[0]++,val[0]=1,DFS(i); for (int i=1;i&lt;=m;i++) printf(&quot;%d&quot;,ID[i]),i&lt;m?putchar(&#x27; &#x27;):puts(&quot;&quot;); for (int i=1;i&lt;=m;i++) printf(&quot;%d&quot;,val[i]),i&lt;m?putchar(&#x27; &#x27;):puts(&quot;&quot;); for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=K;j++) printf(&quot;%d&quot;,ans[i][j]),j&lt;K?putchar(&#x27; &#x27;):puts(&quot;&quot;); return 0;&#125; B - Broken Keyboard 签到。 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 1007char s[N];inline void work() &#123; int n = rd(); scanf(&quot;%s&quot;, s + 1); for (int t = 1, i = 1; i &lt;= n; ++t) &#123; if (t &amp; 1) ++i; else &#123; if (s[i] != s[i + 1]) &#123;puts(&quot;NO&quot;); return;&#125; i += 2; &#125; &#125; puts(&quot;YES&quot;);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; *C - Card Guessing D - Watch the Videos 有 \\(n\\) 个 \\(a_i\\) ，总价格是 \\(\\sum (a_i+1)\\) ，将他们排序，如果相邻的两个 \\(a_i+a_j\\le m\\) ，答案减少 \\(1\\) 。问答案最小多少。 很奇怪的贪心题。双指针维护，尽量保证小的数字两侧都被用到即可，大的组合不上就不用管了。 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 200007int a[N];inline void work() &#123; int n = rd(), m = rd(); for (int i = 1; i &lt;= n; ++i) a[i] = rd(); sort(a + 1, a + 1 + n); ll ans = 0; int l = 1, r = n; for (; l &lt; r; ++l) &#123; while (a[r] + a[l] &gt; m &amp;&amp; r &gt; l) &#123;ans += a[r] + 1; --r;&#125; if (r &gt; l) ans += a[r--]; else break; ans += a[l] + 1; while (a[r] + a[l] &gt; m &amp;&amp; r &gt; l) &#123;ans += a[r] + 1; --r;&#125; if (r &gt; l) --ans; else &#123;++l; break;&#125; &#125; if (l &lt;= r) ans += a[l] + 1; printf(&quot;%lld\\n&quot;, ans);&#125;int main() &#123; work(); return 0;&#125; E - Exchange 签到。 12345678910111213#include&lt;cstdio&gt;using namespace std;int te,A,B,C;int main()&#123; for (scanf(&quot;%d&quot;,&amp;te);te;te--)&#123; scanf(&quot;%d%d%d&quot;,&amp;A,&amp;B,&amp;C); if (B&lt;=C) printf(&quot;%d\\n&quot;,(A+B-1)/B); else puts(&quot;1&quot;); &#125; return 0;&#125; *F - Chemistry Lab 假设已经选好了方案，那么按照 \\((x_i,c_i)\\) 建立凸包，想要兑出最贵的百分比为 \\(x\\) 的药水，一定取在上凸壳上。 由于均匀分布进行随机，因此上凸壳和 \\(x\\) 轴夹住的区域面积再 \\(\\times k\\) 就是答案，dp 上凸壳即可。 将点按照 \\(x\\) 从小到大排序，分段算贡献（梯形面积），注意第一次选取特殊，只有买的代价，没有收益。 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 5007struct node &#123;double x, w, c;&#125; sol[N];double f[N], ans;int main() &#123; int n = rd(), k = rd(); for (int i = 1; i &lt;= n; ++i) &#123;sol[i].x = rd(); sol[i].w = rd(); sol[i].c = rd();&#125; sort(sol + 1, sol + 1 + n, [&amp;](const node &amp;a, const node &amp;b)&#123;return a.x &lt; b.x;&#125;); for (int i = 1; i &lt;= n; ++i) &#123; f[i] = -sol[i].w; // the first one for (int j = 1; j &lt; i; ++j) // the previous one is j f[i] = max(f[i], f[j] + (sol[i].c + sol[j].c) * (sol[i].x - sol[j].x) * k / 200.0 - sol[i].w); ans = max(ans, f[i]); &#125; printf(&quot;%.15lf\\n&quot;, ans); return 0;&#125; *G - Guess the String *H - Hospital Queue 将 \\(n\\) 个人排队，第 \\(i\\) 个人一定要站在前 \\(p_i\\) 个位置，还有若干限制形如 \\(a_i\\) 站在 \\(b_i\\) 之前。 现在对于每个人询问，如果只要求其他人位置合法，这个人能站到最靠前的位置是哪里。保证存在一个合法方案。 先考虑如何求出一个合法方案：用堆代替队列进行拓扑排序，\\(p_i\\) 小的优先。 但对于每个人求最优方案时，很难想办法确定 \\(i\\) 的优先级。因此考虑从后往前放。 建图 \\(b_i\\to a_i\\) ，然后用堆代替队列进行拓扑排序，\\(p_i\\) 大的优先，从后往前放。 对于询问第 \\(i\\) 个人，考虑强制不让 \\(i\\) 进队，则某个位置别人都放不了的时候就必须放 \\(i\\) 了，复杂度 \\(O(n^2\\log n)\\) 。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 2007int deg[N], Deg[N], p[N];vector&lt;int&gt; e[N];priority_queue&lt;pii&gt; q;int main() &#123; int n = rd(), m = rd(); for (int i = 1; i &lt;= n; ++i) p[i] = rd(); for (int i = 1; i &lt;= m; ++i) &#123; int a = rd(), b = rd(); ++Deg[a]; e[b].push_back(a); &#125; for (int i = 1; i &lt;= n; ++i) &#123; while (!q.empty()) q.pop(); for (int j = 1; j &lt;= n; ++j) &#123; deg[j] = Deg[j]; if (!deg[j] &amp;&amp; j != i) q.push(&#123;p[j], j&#125;); &#125; int res = n; while (!q.empty()) &#123; int u = q.top().second; q.pop(); if (p[u] &lt; res) break; --res; for (auto v : e[u]) &#123; --deg[v]; if (!deg[v] &amp;&amp; v != i) q.push(&#123;p[v], v&#125;); &#125; &#125; printf(&quot;%d &quot;, res); &#125; return 0;&#125; *I - Infinite Chess *J - Hero to Zero K - Torus Path 手玩一下发现路径一定会漏掉一个副对角线上的格子，且可以做到只漏掉任意一个，答案就是全部的和减去副对角线最小值。 1234567891011121314151617181920#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn=200;int n;LL ans;int main()&#123; scanf(&quot;%d&quot;,&amp;n); int MIN=2e9; for (int i=1;i&lt;=n;i++) for (int j=1,x;j&lt;=n;j++)&#123; scanf(&quot;%d&quot;,&amp;x); ans+=x; if (i+j==n+1) MIN=min(MIN,x); &#125; printf(&quot;%lld\\n&quot;,ans-MIN); return 0;&#125; L - Project Manager STL 小清新模拟题，注意一定要维护出每天上班且当前有任务要做的集合，否则一定可以卡掉。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 200007inline int trans() &#123; static char s[20]; scanf(&quot;%s&quot;, s + 1); if (s[1] == &#x27;M&#x27;) return 0; if (s[1] == &#x27;T&#x27; &amp;&amp; s[2] == &#x27;u&#x27;) return 1; if (s[1] == &#x27;W&#x27;) return 2; if (s[1] == &#x27;T&#x27; &amp;&amp; s[2] == &#x27;h&#x27;) return 3; if (s[1] == &#x27;F&#x27;) return 4; return (s[2] == &#x27;a&#x27; ? 5 : 6);&#125;queue&lt;int&gt; holiday, order[N];vector&lt;int&gt; workday[N];set&lt;int&gt; s[7], add[7], del[7];priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; work[N];vector&lt;pii&gt; addwork;int ans[N];int main() &#123; int n = rd(), m = rd(), k = rd(); for (int i = 1; i &lt;= n; ++i) for (int t = rd(); t; --t) workday[i].push_back(trans()); for (int i = 1; i &lt;= m; ++i) holiday.push(rd()); for (int i = 1; i &lt;= k; ++i) &#123; for (int t = rd(); t; --t) order[i].push(rd()); int u = order[i].front(); order[i].pop(); work[u].push(i); for (auto d : workday[u]) s[d].insert(u); &#125; for (int i = 0, cnt = 1, K = k; K; ++cnt, i = (i == 6 ? 0 : i + 1)) &#123; if (!holiday.empty() &amp;&amp; cnt == holiday.front()) &#123;holiday.pop(); continue;&#125; addwork.clear(); for (int j = 0; j &lt; 7; ++j) &#123;add[j].clear(); del[j].clear();&#125; for (auto x : s[i]) &#123; int id = work[x].top(); work[x].pop(); if (work[x].empty()) for (auto d : workday[x]) del[d].insert(x); if (order[id].empty()) &#123;--K; ans[id] = cnt;&#125; else &#123; int nxt = order[id].front(); order[id].pop(); addwork.push_back(make_pair(nxt, id)); for (auto d : workday[nxt]) add[d].insert(nxt); &#125; &#125; for (int j = 0; j &lt; 7; ++j) for (auto x : del[j]) s[j].erase(x); for (int j = 0; j &lt; 7; ++j) for (auto x : add[j]) s[j].insert(x); for (auto [x, id] : addwork) work[x].push(id); &#125; for (int i = 1; i &lt;= k; ++i) printf(&quot;%d &quot;, ans[i]); return 0;&#125; M - Minimum LCM 给定 \\(n\\) ，找一对 \\(a+b=n\\) ，最小化 \\(\\text{lcm}(a, b)\\) 猜测 \\(a\\) 是 \\(b\\) 的倍数时最优，所以检查 \\(n\\) 的所有因数即可。 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 1007char s[N];inline void work() &#123; int n = rd(); int ans = 1e9; int lim = sqrt(n); for (int i = 1; i &lt;= lim; ++i) if (n % i == 0) &#123; if (n / i &gt; 1) ans = min(ans, i * (n / i - 1)); if (i &gt; 1) ans = min(ans, (n / i) * (i - 1)); &#125; printf(&quot;%d %d\\n&quot;, ans, n - ans);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; N - Number Reduction 一个很长的数 \\(x\\)（保证以非 \\(0\\) 开头），删掉恰好 \\(k\\ (k&lt; \\lfloor \\log_{10} x\\rfloor)\\) 位，使得剩下的数值最小，且没有前导零。 如果没有 \\(0\\) 就是一个常考面试题，从前往后扫，遇到 \\(x_i&gt;x_{i+1}\\) 即前面的数位比后面大，就把前面的删掉即可。 但是 \\(0\\) 的数位一定不能删吗？形如 \\(x000y....\\) 的数字，如果 \\(x&gt;y\\) ，且 \\(k\\) 足够的时候，是应该把前缀 \\(x000\\) 删掉的。 所以每次当前位置非 \\(0\\) 且前一个位置是 \\(0\\) 的时候，特判一下是否应该（且能够）把前缀删掉。 最后多余的次数从后往前删即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 500007#define pb push_backchar s[N];deque&lt;int&gt; a;inline void work() &#123; a.clear(); scanf(&quot;%s&quot;, s + 1); int n = strlen(s + 1); int k = rd(); a.pb(s[1] - &#x27;0&#x27;); for (int i = 2; i &lt;= n; ++i) &#123; int x = s[i] - &#x27;0&#x27;; if (!k) &#123;a.pb(x); continue;&#125; if (x) &#123; while (!a.empty() &amp;&amp; k &amp;&amp; a.back() &gt; x) &#123;a.pop_back(); --k;&#125; if (!a.empty() &amp;&amp; a.back() == 0 &amp;&amp; k &gt;= a.size() &amp;&amp; x &lt; a.front()) &#123;k -= a.size(); a.clear();&#125; a.push_back(x); &#125; else &#123; while (a.size() &gt; 1 &amp;&amp; k &amp;&amp; a.back() &gt; 0) &#123;a.pop_back(); --k;&#125; a.push_back(x); &#125; &#125; for (; k; --k) a.pop_back(); for (auto x : a) printf(&quot;%d&quot;, x); puts(&quot;&quot;);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125;","categories":[{"name":"Official Contests","slug":"Official-Contests","permalink":"http://blog.gyx.me/categories/Official-Contests/"}],"tags":[{"name":"Geometry","slug":"Geometry","permalink":"http://blog.gyx.me/tags/Geometry/"},{"name":"Graphs","slug":"Graphs","permalink":"http://blog.gyx.me/tags/Graphs/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"},{"name":"Greedy","slug":"Greedy","permalink":"http://blog.gyx.me/tags/Greedy/"},{"name":"STL","slug":"STL","permalink":"http://blog.gyx.me/tags/STL/"}]},{"title":"Circle Inversion","slug":"algorithms/circle-inversion","date":"2022-11-21T02:30:16.000Z","updated":"2023-03-20T16:50:21.790Z","comments":true,"path":"algorithms/circle-inversion/","link":"","permalink":"http://blog.gyx.me/algorithms/circle-inversion/","excerpt":"","text":"Analysis 二维平面上，给定反演中心 \\(O\\) 和半径 \\(r\\) ，定义点 \\(P\\) 基于圆 \\((O,r)\\) 的反演变换：\\(P\\mapsto P&#39; : |OP||OP&#39;|=r^2\\) 。 圆内点反演完在圆外，圆外点反演完在圆内，圆上点是反演变换的不动点。 进一步的我们可以定义图形基于圆 \\(O\\) 的反演（即变换后的点集），容易发现一些结论： 不过 \\(O\\) 的圆 \\(\\Leftrightarrow\\) 不过 \\(O\\) 的圆（先求出在 \\(O\\) 与圆心连线上直径两个端点的反演点再恢复，注意圆心反演后不是圆心！！） 过 \\(O\\) 的直线 \\(\\Leftrightarrow\\) 过 \\(O\\) 的直线（且是同一条直线，不会有变化） 过 \\(O\\) 的圆 \\(\\Leftrightarrow\\) 不过 \\(O\\) 的直线（先求出 \\(O\\) 对应直径的另一个端点的反演点，再求垂直于 \\(O\\) 与反演点连线的直线） 圆内区域反演完之后是反演直线的不包含 \\(O\\) 的半平面 反演前两图形的相对关系，反演后不变（反演前相切，反演后也相切；相交等以此类推） 特殊的，两切于 \\(O\\) 的圆反演后是两平行直线（切点 \\(O\\) 反演后在无穷远处，即两平行直线交于无穷远处） 反演半径一般选取点到中心距离的几何平均。完整计算几何模版见这里。 12345678910111213141516171819202122232425262728293031323334353637383940struct C &#123; P c; double r; C(letp &amp;c = zero, double r = 0.0) : c(c), r(r) &#123;&#125; bool operator == (letc &amp;a) const &#123;return c == a.c &amp;&amp; z(r - a.r);&#125; // 点与圆的关系 : -1 圆上 | 0 圆外 | 1 圆内 int is_in(letp &amp;p) const &#123;double d = p.dis(c); return z(d - r) ? -1 : d &lt; r - eps;&#125; P inverse(letp &amp;p) const &#123; assert(p != c); const P dlt = p - c; return c + dlt * (r * r / dlt.norm()); &#125; tuple&lt;int, C, L&gt; inverse(letl &amp;l) const &#123; letc null_c = C(zero, 0.0); letl null_l = L(zero, zero); if (l.ori(c) == 0) return mt(2, null_c, l); letp v = (l.ori(c) == 1 ? P&#123;l.v.y, -l.v.x&#125; : P&#123;-l.v.y, l.v.x&#125;); const double d = r * r / l.dis(c); letp p = c + unit(v) * d; return mt(1, C&#123;(c + p) / 2, d / 2&#125;, null_l); &#125; tuple&lt;int, C, L&gt; inverse(letc &amp;a) const &#123; letc null_c = C(zero, 0.0); letl null_l = L(zero, zero); letp v = a.c - c; if (a.is_in(c) == -1) &#123; const double d = r * r / (a.r + a.r); return mt(2, null_c, L&#123;c + unit(v) * d, &#123;-v.y, v.x&#125;&#125;); &#125; if (c == a.c) return mt(1, C&#123;c, r * r / a.r&#125;, null_l); const double dis = abs(v); const double k1 = r * r / (dis - a.r), k2 = r * r / (dis + a.r); const double d = (k1 + k2) / 2, rad = (k1 - k2) / 2; return mt(1, C&#123;c + v * (d / dis), rad&#125;, null_l); &#125;&#125;; CF 77 E - Martian Food 给定两个内切的圆，第三个圆位于两圆心连线且与两圆相切，第四个圆开始和前三个圆相切，以此类推。 求第 \\(k\\) 个圆的半径。多组 \\(t\\le 10^4,r,R\\le 10^4,k\\le 10^4\\) 。 以两圆切点反演，前两个圆变成平行直线，后面的圆都与两平行线相切，第三个圆心反演后位于前两圆心连线。 然后朝一侧找到第 \\(k\\) 个圆，再反演回来即得到了答案。注意不能反演圆心，圆心反演完不是圆心！ 12345678inline void work() &#123; static C O = C(zero, 20000); double r1 = rd(), r2 = rd(); L l1 = get&lt;2&gt;(O.inverse(C(P(r1, 0), r1))); L l2 = get&lt;2&gt;(O.inverse(C(P(r2, 0), r2))); C res = C(P((l1.p.x + l2.p.x) / 2, l1.dis(l2) * rd()), l1.dis(l2) / 2); printf(&quot;%.10lf\\n&quot;, get&lt;1&gt;(O.inverse(res)).r);&#125; HDU 6158 - The Designer 求类似上一题图的前 \\(n\\ (n\\le 10^7)\\) 个圆的面积和，多组 \\((t\\le 10^3)\\) 。 判一下如果剩下的圆面积和足够小就不用做了，注意不是面积足够小，而是面积和。 123456789101112131415inline void work() &#123; static C O = C(zero, 200); double r1 = rd(), r2 = rd(); L l1 = get&lt;2&gt;(O.inverse(C(P(r1, 0), r1))); L l2 = get&lt;2&gt;(O.inverse(C(P(r2, 0), r2))); double dlt = l1.dis(l2); C res = C((l1.p + l2.p) / 2, dlt / 2); double ans = get&lt;1&gt;(O.inverse(res)).area(); for (int i = 1, t = 0, n = rd(); i &lt; n; ++i) &#123; (i &amp; 1) ? ++t, res.c.y = t * dlt : res.c.y = -t * dlt; double add = get&lt;1&gt;(O.inverse(res)).area(); if (add * (n - i) &lt; 1e-7) break; ans += add; &#125; printf(&quot;%.5lf\\n&quot;, ans);&#125; 2017 ICPC Nanning Online - Finding the Radius for an Inserted Circle 三个半径为 \\(R\\) 的圆互相切，在中间的弧形边三角形中塞小圆，然后朝着一个角塞，问第 \\(k\\) 个的半径。 反演点就是会往那个角里塞小圆的两个圆的切点。 三个圆变成一对平行直线+一个夹中间的圆，然后朝反方向找第 \\(k\\) 个圆即可。 12345678910int ans[11];int main() &#123; int t; double r; scanf(&quot;%d%lf&quot;, &amp;t, &amp;r); C O = C(zero, r * 2); C c = get&lt;1&gt;(O.inverse(C(P(0, -sqrt(3) * r), r))); for (int i = 1; i &lt;= 10; ++i) &#123;c.c.y -= r * 4; ans[i] = floor(get&lt;1&gt;(O.inverse(c)).r + 1e-8);&#125; for (int i = 1, n; i &lt;= t; ++i) &#123;scanf(&quot;%d&quot;, &amp;n); printf(&quot;%d %d\\n&quot;, n, ans[n]);&#125; return 0;&#125; 2013 ICPC Hangzhou - Problem of Apollonius 求过指定点且与给定两个圆相外切的所有的圆。 关于指定点反演，所求答案就是两个圆的公切线。 12345678910111213inline void work() &#123; C c1; c1.c.x = rd(); c1.c.y = rd(); c1.r = rd(); C c2; c2.c.x = rd(); c2.c.y = rd(); c2.r = rd(); C O; O.c.x = rd(); O.c.y = rd(); O.r = 100; vector&lt;L&gt; s = get&lt;1&gt;(O.inverse(c1)).tangent(get&lt;1&gt;(O.inverse(c2))); vector&lt;C&gt; ans; for (auto x : s) &#123; C inv = get&lt;1&gt;(O.inverse(x)); if (inv.relation(c1) == 1 &amp;&amp; inv.relation(c2) == 1) ans.push_back(inv); &#125; printf(&quot;%d\\n&quot;, (int)ans.size()); for (auto x : ans) printf(&quot;%.10lf %.10lf %.10lf\\n&quot;, x.c.x, x.c.y, x.r);&#125; CF 372 E - Drawing Circles is Fun 给定二维平面内 \\(n\\) 个点, 其中任意两点所在的直线上都不包含原点 \\(O\\) 。 求集合 \\(\\{\\left(P_1, P_2\\right)\\left(P_3, P_4\\right) \\ldots\\left(P_{2 k-1}, P_{2 k}\\right)\\}\\) 的个数（\\(P_i\\) 取自给定的 \\(n\\) 个点），满足: 不存在 \\(i \\neq j, P_i=P_j\\). 对于任意 \\(i \\neq j,\\left(P_{2 i-1}, P_{2 i}\\right)\\left(P_{2 j-1}, P_{2 j}\\right)\\) 满足： 圆 \\(O P_{2 i-1} P_{2 j-1}\\) 和圆 \\(O P_{2 i} P_{2 j}\\) 只有一个交点, 圆 \\(O P_{2 i-1} P_{2 j}\\) 和圆 \\(O P_{2 i} P_{2 j-1}\\) 只有一个交点。 所有圆都过 \\(O\\) 且只有一个交点，所以都相切在 \\(O\\) 。 反演之后就是平行直线，即要求 \\(P_{2 i-1} P_{2 j-1}\\parallel P_{2 i} P_{2 j},\\ P_{2 i-1} P_{2 j}\\parallel P_{2 i} P_{2 j-1}\\) ，即 \\(P_{2 i-1} P_{2 j-1}P_{2 i} P_{2 j}\\) 是平行四边形。 平行四边形的等价条件是对角中点重合且边不重合，换言之，计数选出若干点对，反演后中点重合在同一个点，且不能重合。 处理出来 \\(n^2\\) 个线段的中点。对每个中点，处理出来同角度的每个方向有多少个（即重合）。 相当于 \\(n\\) 个集合里挑若干个（多于一个），每个集合里只能拿至多一个的方案数，即 \\(\\prod (size_i+1) - \\sum size_i - 1\\) 。 坑1： 实现用 pair(中点，方向向量）保存信息，为了保证排序正确（中点相同的挨在一起，相同中点按照方向极角序），不能出现反向的方向向量（共线的必须同一方向），所以 \\(x\\) 为负的时候取反，\\(x=0\\) 且 \\(y&lt;0\\) 的时候取反 。 坑2： 精度要求高，坐标范围 \\([\\frac{1}{50},50]\\) ，反演半径最好取几何平均 \\(1\\) 。 坑3： 最后对集合还要 count 一次。 12345678910111213141516171819202122232425262728293031323334353637383940414243#define mod 1000000007#define ppp pair&lt;P, P&gt;int main() &#123; int n = rd(); vector&lt;P&gt; p(n); vector&lt;ppp&gt; s; for (int i = 0; i &lt; n; ++i) &#123; double a = rd(), b = rd(), c = rd(), d = rd(); p[i].x = a / b; p[i].y = c / d; p[i] = p[i] / p[i].norm(); &#125; for (int i = 0 ; i &lt; n; ++i) for (int j = i + 1; j &lt; n; ++j) &#123; P u = p[i], v = p[j]; P mid = (u + v) / 2, dir = u - v; if (z(dir.x)) &#123;if (dir.y &lt; 0) dir = -dir;&#125; else if (dir.x &lt; -eps) dir = -dir; s.push_back(mp(mid, dir)); &#125; sort(s.begin(), s.end(), [&amp;](ppp &amp;a, ppp &amp;b) &#123; return (a.fr != b.fr) ? a.fr &lt; b.fr : argcmp()(a.sc, b.sc); &#125;); int ans = 0; vector&lt;int&gt; cnt; auto count = [&amp;]() &#123; int prod = 1, sum = 0; for (auto x : cnt) &#123; prod = 1ll * prod * (x + 1) % mod; sum = (sum + x) % mod; &#125; int res = (prod + mod - sum - 1) % mod; ans = (ans + res) % mod; cnt.clear(); &#125;; for (size_t i = 0; i &lt; s.size(); ++i) if (i &gt; 0 &amp;&amp; s[i].fr == s[i - 1].fr) &#123; if (para(s[i].sc, s[i - 1].sc)) ++cnt.back(); else cnt.push_back(1); &#125; else &#123;count(); cnt.push_back(1);&#125; count(); printf(&quot;%d\\n&quot;, ans); return 0;&#125; 2022 ICPC Hefei F - Rescue 给定 \\(n\\le 10^6\\) 个圆，保证所有圆都经过原点。 问 \\(n\\) 个圆的交是否为空，若不为空，则求出交区域内的点离原点最远的距离。 关于原点反演，每个圆就变成了一个半平面，求出来半平面交，问题变成了点到凸包的最近距离。","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://blog.gyx.me/categories/Algorithms/"}],"tags":[{"name":"Geometry","slug":"Geometry","permalink":"http://blog.gyx.me/tags/Geometry/"}]},{"title":"2017-2018 ICPC Asia Tsukuba Regional","slug":"official/icpc/17-tsukuba","date":"2022-11-16T16:00:00.000Z","updated":"2023-03-20T16:35:40.358Z","comments":true,"path":"official/icpc/17-tsukuba/","link":"","permalink":"http://blog.gyx.me/official/icpc/17-tsukuba/","excerpt":"","text":"比赛地址 ：Codeforces Gym 101986 还没补完：DK A - Secret of Chocolate Poles 除了最下面一块黑，每块黑和下面的白组成一块，简单计数。 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 200007 ll f[N], ans;int main() &#123; int l = rd(), k = rd(); f[1] = f[k] = 1; ++k; for (int i = 3; i &lt;= l; ++i) &#123; f[i] += f[i - 2]; if (i &gt; k) f[i] += f[i - k]; &#125; for (int i = 1; i &lt;= l; ++i) ans += f[i]; printf(&quot;%lld\\n&quot;, ans); return 0;&#125; B - Parallel Lines 给定 \\(m\\ (m\\le 16,\\) 偶数\\()\\) 个点，两两配对，问得到的线段平行关系最多有多少组。 注意要求全部点都用上，所以搜索两两配对的方案，可以变成每次给编号最小的那个点找配对点，复杂度变成 \\(\\mathcal{O}((m-1)!!)\\) 。 然后数相同的方向向量的个数，对每个方向向量维护一个计数器即可，复杂度 \\(\\mathcal{O}((m-1)!!)\\) 。计算量约为 \\(2\\times 10^6\\) 。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 17#define M 1007 #define fr first#define sc secondmap&lt;pii, int&gt; f;int gcd(int a, int b) &#123;return b ? gcd(b, a % b) : a;&#125;pii operator - (const pii &amp;a, const pii &amp;b) &#123;return &#123;a.fr - b.fr, a.sc - b.sc&#125;;&#125;pii operator / (const pii &amp;a, const int &amp;k) &#123;return &#123;a.fr / k, a.sc / k&#125;;&#125;pii a[N];bool vis[N];int s[N][N], cnt[M];int n, idcnt, ans, res;inline int c2(int x) &#123;return x * (x - 1) / 2;&#125;inline void add(int x) &#123;res -= c2(cnt[x]); ++cnt[x]; res += c2(cnt[x]);&#125;inline void del(int x) &#123;res -= c2(cnt[x]); --cnt[x]; res += c2(cnt[x]);&#125;// (m - 1)!! = 2027025 void dfs(int p) &#123; if (p == n / 2) &#123;ans = max(ans, res); return;&#125; int A = 0; for (int i = 1; i &lt;= n; ++i) if (!vis[i]) &#123;vis[i] = true; A = i; break;&#125; for (int i = A + 1; i &lt;= n; ++i) if (!vis[i]) &#123; vis[i] = true; add(s[A][i]); dfs(p + 1); vis[i] = false; del(s[A][i]); &#125; vis[A] = false;&#125;int main() &#123; n = rd(); for (int i = 1; i &lt;= n; ++i) &#123;a[i].fr = rd(); a[i].sc = rd();&#125; for (int i = 1; i &lt;= n; ++i) for (int j = i + 1; j &lt;= n; ++j) &#123; pii tmp = (a[i] &lt; a[j] ? a[j] - a[i] : a[i] - a[j]); tmp = tmp / gcd(abs(tmp.fr), abs(tmp.sc)); if (!f[tmp]) f[tmp] = ++idcnt; s[i][j] = f[tmp]; &#125; dfs(0); printf(&quot;%d\\n&quot;, ans); return 0;&#125; *C - Medical Checkup \\(n\\) 个人去依次做检查，第 \\(i\\) 个人检查每个项目都需要 \\(t_i\\) 分钟，必须严格按照 \\(1\\dots \\infty\\) 的顺序做检查。 问 \\(T\\) 时刻每个人都在做或等待做第几个检查。 观察发现对于每个人，从他前面的 \\(\\max t_i\\) 那个人开始，做检查的时间是连续的没有间隔了。 可以当作从 \\(\\arg\\max t_i\\) 开始的火车，每节长度为 \\(t_i\\) ，从某时刻进入一个隧道每秒前进一，隧道每 \\(\\max t_i\\) 一个关卡。 换句话说，除了第一个检查，后面的每个检查都需要 \\(\\max t_i\\) 的时间进行，所以答案就是 \\(\\displaystyle \\lfloor\\frac{T - \\sum_{j=1}^i t_j}{\\max t_i}\\rfloor + 2\\) 。 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;int main() &#123; int n = rd(), t = rd(), mx = 0; for (int i = 1; i &lt;= n; ++i) &#123; int nw = rd(); mx = max(mx, nw); if (t &gt;= 0) t -= nw; // t is the starting time of the second check printf(&quot;%d\\n&quot;, t &lt; 0 ? 1 : t / mx + 2); &#125; return 0;&#125; *E - Black or White 给两个长度为 \\(n\\) 的 \\(01\\) 序列 \\(S,T\\) ，每次可以把第一个序列连续至多 \\(k\\) 个位置刷成 \\(0\\) 或 \\(1\\) 。 问把第一个序列改成第二个最少操作多少次。 设 \\(f[i]\\) 表示把前 \\(i\\) 个刷成正确的最小操作次数。 \\(S[i]=T[i],\\ f[i] \\leftarrow f[i - 1]\\) 枚举刷 \\(i\\) 的那一刷是从第 \\(j\\) 个开始的，\\(f[i]\\leftarrow \\min\\{f[j]+cost(j+1,i)\\}\\) 考虑把一个长度不超过 \\(k\\) 的序列刷出来的最小代价，发现是每次把左右两个一起刷，代价即 段数 \\(/2 + 1\\) 。 \\(f[i] = f[j] + (sum[i] - sum[j + 1] + 1) / 2 + 1\\) 按照 \\(2 * f[j] - sum[j + 1]\\) 决策单调性，单调队列优化一下。 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 500007char s[N], t[N];int sum[N], f[N];deque&lt;int&gt; pos;int main() &#123; pos.push_back(0); int n = rd(), m = rd(); scanf(&quot;%s&quot;, s + 1); scanf(&quot;%s&quot;, t + 1); for (int i = 1; i &lt;= n; ++i) sum[i] = sum[i - 1] + (t[i] != t[i - 1]); // the number of segments in [l, r] : sum[r] - sum[l + 1] + 1 auto val = [&amp;](int p) &#123;return 2 * f[p] - sum[p + 1];&#125;; for (int i = 1; i &lt;= n; ++i) &#123; if (s[i] == t[i]) f[i] = f[i - 1]; else &#123; while (i - pos.front() &gt; m) pos.pop_front(); f[i] = f[pos.front()] + (sum[i] - sum[pos.front() + 1] + 1) / 2 + 1; &#125; while (!pos.empty() &amp;&amp; val(pos.back()) &gt;= val(i)) pos.pop_back(); pos.push_back(i); &#125; printf(&quot;%d\\n&quot;, f[n]); return 0;&#125; *F - Pizza Delivery 给定一张有向图，问把每条边翻转后（临时修改），\\(1\\) 到 \\(2\\) 最短路是否变长 / 不变 / 变短。 原图跑出来 \\(1\\) 的单源最短路 \\(dis[1][u]\\) ，反图跑出来 \\(2\\) 的单源最短路 \\(dis[2][u]\\) 。 原图最短路是 \\(dis[1][2]\\) ，翻转 \\((u\\to v,w)\\) 后经过这条边的最短路是 \\(dis[1][v] + dis[2][u] + w\\) 。 变短可以直接判断。然后如果不是所有最短路都必须经过原来的 \\((u\\to v,w)\\) ，那么最短路不变，否则是变长。 求最短路同时求出 \\(cnt[1][u]\\) 表示原图 \\(1\\) 到 \\(u\\) 的最短路条数，\\(cnt[2][u]\\) 表示反图 \\(2\\) 到 \\(u\\) 的最短路条数。 判断最短路必经边可以哈希（取模）最短路计数。最短路必经边的条件： 在最短路上： \\(dis[1][u]+dis[2][v] + w == dis[1][2]\\) 所有最短路都经过：\\(cnt[1][u]\\times cnt[2][v] \\equiv cnt[1][2]\\pmod {a\\ prime\\ number}\\) 最后考虑一下多条完全相同且在最短路上的重边是否会有问题（即认为每条都是必经边）？ 答案是不会有问题，因为最短路条数是 \\(cnt[1][u]\\times cnt[2][v]\\times k\\) ，可以理解为乘法原理。 upd：当然第二问也可以只保留 \\(1\\) 到 \\(2\\) 最短路中的边，然后建图求桥。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;template&lt;typename T&gt;inline bool getmin(T &amp;a, T b) &#123;return a &gt; b ? (a = b, true) : false;&#125;#define mp make_pair#define N 100007int n, m, tot, hd[N], hdr[N];struct edge&#123;int to, nxt, w;&#125; e[N &lt;&lt; 1];void add(int u, int v, int w) &#123; e[++tot] = &#123;v, hd[u], w&#125;; hd[u] = tot; e[++tot] = &#123;u, hdr[v], w&#125;; hdr[v] = tot;&#125;#define mod 1000000007inline void add(int &amp;a, int b) &#123;a = (a + b &gt;= mod ? a + b - mod : a + b);&#125;bool use[N];int cnt[2][N];ll dis[2][N];typedef pair&lt;ll, int&gt; cur;priority_queue&lt;cur, vector&lt;cur&gt;, greater&lt;cur&gt;&gt; q;inline void dij(int u, int *h, int id) &#123; memset(use, 0, sizeof(use)); dis[id][u] = 0; cnt[id][u] = 1; q.push(mp(0, u)); while (!q.empty()) &#123; int u = q.top().second; q.pop(); if (use[u]) continue; use[u] = true; for (int i = h[u], v; i; i = e[i].nxt) if (getmin(dis[id][v = e[i].to], dis[id][u] + e[i].w)) &#123; cnt[id][v] = cnt[id][u]; q.push(mp(dis[id][v], v)); &#125; else if (dis[id][v] == dis[id][u] + e[i].w) add(cnt[id][v], cnt[id][u]); &#125;&#125; int main() &#123; int n = rd(), m = rd(); for (int i = 1; i &lt;= m; ++i) &#123; int u = rd(), v = rd(), w = rd(); add(u, v, w); &#125; memset(dis, 0x3f, sizeof(dis)); dij(1, hd, 0); dij(2, hdr, 1); ll mnd = dis[0][2]; for (int i = 1; i &lt;= m; ++i) &#123; int u = e[i * 2].to, v = e[i * 2 - 1].to, w = e[i * 2].w; if (dis[0][v] + dis[1][u] + w &lt; mnd) puts(&quot;HAPPY&quot;); else if (dis[0][u] + dis[1][v] + w == mnd &amp;&amp; 1ll * cnt[0][u] * cnt[1][v] % mod == cnt[0][2]) puts(&quot;SAD&quot;); else puts(&quot;SOSO&quot;); &#125; return 0;&#125; UPD：看了下 jiangly 的代码，发现了一个神奇的方法求最短路必经边，尝试描述一下原理： 对于最短路图上的每条边差分，起点点权 \\(+1\\) ，终点点权 \\(-1\\) ，然后按照 Dijkstra 的顺序求前缀和。 那么如果一条边 \\((u,v,w)\\) 在 \\(1\\) 到 \\(2\\) 最短路上 且 \\(val[u]=1\\) ，那么这条边是最短路必经边。 \\(val[u]\\) 的含义是只考虑 Dijkstra 顺序中在 \\(u\\) 之前的所有点，延伸出的最短路当前收敛到了多少条。 也就是当前最短路能走就走，只走 Dijkstra 顺序中在 \\(u\\) 之前的点，然后最终有多少条边可以继续往下走。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;template&lt;typename T&gt;inline bool getmin(T &amp;a, T b) &#123;return a &gt; b ? (a = b, true) : false;&#125;#define mp make_pair#define N 100007int n, m, tot, hd[N], hdr[N];struct edge&#123;int to, nxt, w;&#125; e[N &lt;&lt; 1];void add(int u, int v, int w) &#123; e[++tot] = &#123;v, hd[u], w&#125;; hd[u] = tot; e[++tot] = &#123;u, hdr[v], w&#125;; hdr[v] = tot;&#125;bool use[N];int pos[N], sum[N];ll dis[2][N];typedef pair&lt;ll, int&gt; cur;priority_queue&lt;cur, vector&lt;cur&gt;, greater&lt;cur&gt;&gt; q;inline void dij(int u, int *h, int id) &#123; memset(use, 0, sizeof(use)); dis[id][u] = 0; q.push(mp(0, u)); while (!q.empty()) &#123; int u = q.top().second; q.pop(); if (use[u]) continue; use[u] = true; if (!id) pos[u] = ++pos[0]; for (int i = h[u], v; i; i = e[i].nxt) if (getmin(dis[id][v = e[i].to], dis[id][u] + e[i].w)) q.push(mp(dis[id][v], v)); &#125;&#125; int main() &#123; int n = rd(), m = rd(); for (int i = 1; i &lt;= m; ++i) &#123; int u = rd(), v = rd(), w = rd(); add(u, v, w); &#125; memset(dis, 0x3f, sizeof(dis)); dij(1, hd, 0); dij(2, hdr, 1); ll mnd = dis[0][2]; for (int u = 1; u &lt;= n; ++u) for (int i = hd[u], v; i; i = e[i].nxt) if (dis[0][u] + e[i].w + dis[1][v = e[i].to] == mnd) &#123;++sum[pos[u]]; --sum[pos[v]];&#125; for (int i = 1; i &lt;= n; ++i) sum[i] += sum[i - 1]; for (int i = 1; i &lt;= m; ++i) &#123; int u = e[i * 2].to, v = e[i * 2 - 1].to, w = e[i * 2].w; if (dis[0][v] + dis[1][u] + w &lt; mnd) puts(&quot;HAPPY&quot;); else if (dis[0][u] + dis[1][v] + w == mnd &amp;&amp; sum[pos[u]] == 1) puts(&quot;SAD&quot;); else puts(&quot;SOSO&quot;); &#125; return 0;&#125; G - Rendezvous on a Tetrahedron 两只蚂蚁从正四面体一个顶点开始爬，给定初始面、方向、长度。 爬行路径过程中保证和边角度不变，保证除了开始不会经过任何顶点。问最后两只蚂蚁是否在同一个面。 角度不变相当于在四面体展开的图形上走直线，模拟即可。每次新走到的面都可以用上一个面的三个点判断得出。 讨论比较繁琐，解三角形需要灵活运用一下三角函数公式。\\([0,\\pi]\\) 求角度用 \\(\\arccos\\) 不要用 \\(\\arcsin\\) 。 感觉三角函数递归套起来精度炸飞了。不知道怎么过的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;const double pi = 3.141592653589793;const double sin60 = sqrt(3) / 2.0;// A = 0 | B = 1 | C = 2 | D = 3 || sum = 6vector&lt;int&gt; simulate(int x, int y, int tar, double pos, double ang, double rem) &#123; //printf(&quot;%d %d %d %.3lf %.3lf %.3lf\\n&quot;, x, y, tar, pos, ang, rem); double angtar = acos((2 * pos - 1) / 2.0 / sqrt(pos * pos + 1 - pos)); if (ang &lt; angtar) &#123; double len = pos * sin60 / sin(pi * 2 / 3 - ang); if (rem &lt;= len) return vector&lt;int&gt;&#123;x, y, tar&#125;; return simulate(x, tar, 6 - x - y - tar, sin(ang) / sin(pi * 2 / 3 - ang) * pos, pi / 3 + ang, rem - len); &#125; else &#123; double len = (1 - pos) * sin60 / sin(ang - pi / 3); if (rem &lt;= len) return vector&lt;int&gt;&#123;x, y, tar&#125;; return simulate(tar, y, 6 - x - y - tar, 1 - sin(ang) / sin(ang - pi / 3) * (1 - pos), ang - pi / 3, rem - len); &#125;&#125;int main() &#123; auto rdv = [&amp;]() &#123; char c = getchar(); while (!isalpha(c)) c = getchar(); return c - &#x27;A&#x27;; &#125;; auto getpos = [&amp;]() &#123; int x = rdv(), y = rdv(); double ang = rd() * pi / 180, l = rd(); double step1 = sin60 / sin(pi * 2 / 3 - ang); // The Law of Sines if (step1 &gt;= l) return vector&lt;int&gt;&#123;0, x, y&#125;; else return simulate(x, y, 6 - x - y, sin(ang) / sin(pi * 2 / 3 - ang), pi / 3 + ang, l - step1); &#125;; vector&lt;int&gt; pos1 = getpos(); sort(pos1.begin(), pos1.end()); vector&lt;int&gt; pos2 = getpos(); sort(pos2.begin(), pos2.end()); puts(pos1 == pos2 ? &quot;YES&quot; : &quot;NO&quot;); return 0;&#125; *H - Homework \\(n\\) 个作业，每个作业有释放时间 \\(r_i\\) 截止时间 \\(d_i\\) 种类 \\(A/B\\) 。 每天 \\(x\\) 先选择一个类别，然后如果该类还有没完成且可以完成的任务（ \\(x\\in [r_i,d_i]\\) ），那么做掉 \\(d_i\\) 最小且编号最小的。 问最多 / 最少能完成多少个作业。 注意到 “做掉 \\(d_i\\) 最小且编号最小的” 是正确的贪心结构（是随便选的方案里的最优解）。 最多就是做一个二分图匹配。每天 \\(x\\) 可以匹配 \\(x\\in [r_i,d_i]\\) 的所有 \\(i\\) 。 最少考虑开摆的策略：如果那天存在一类作业当天都做完了，那我自然选择这一类任务；否则就是挑某一类做掉一个。 用最小割描述这个贪心，割的含义就是完成这个任务： 每天最多完成一个作业，拆点 \\((x_l\\to x_r,1)\\) 。 每个 \\(A\\) 类任务：\\((S\\to task_i, 1);\\ \\forall x\\in [r_i,d_i],(task_i\\to x_l,1)\\) 每个 \\(B\\) 类任务：\\(\\forall x\\in [r_i,d_i],(x_r\\to task_i,1);\\ (task_i\\to T, 1)\\) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;inline bool getmin(int &amp;a, int b) &#123;return (a &gt; b ? (a = b, true) : false);&#125;inline bool getmax(int &amp;a, int b) &#123;return (a &lt; b ? (a = b, true) : false);&#125; // F is the type of flowtemplate&lt;const int V, const int E, class F, const F flowInf&gt;struct Flow &#123; int tot = 1, S, T, hd[V], cur[V], dis[V]; struct edge&#123;int to, nxt; F cap;&#125; e[E &lt;&lt; 1]; void clear() &#123;tot = 1; memset(hd, 0, sizeof(hd));&#125; void add(int u, int v, F w) &#123; e[++tot].nxt = hd[u], hd[u] = tot, e[tot].to = v, e[tot].cap = w; e[++tot].nxt = hd[v], hd[v] = tot, e[tot].to = u, e[tot].cap = 0; &#125; inline bool bfs() &#123; static int q[V], qhd, qtl; memcpy(cur, hd, sizeof(hd)); memset(dis, -1, sizeof(dis)); q[qhd = qtl = 1] = S; dis[S] = 0; while (qhd &lt;= qtl) &#123; int u = q[qhd++]; for (int i = hd[u], v; i; i = e[i].nxt) if (dis[v = e[i].to] == -1 &amp;&amp; e[i].cap != 0) &#123; dis[v] = dis[u] + 1; q[++qtl] = v; &#125; &#125; return dis[T] != -1; &#125; F dfs(int u, F rem) &#123; if (u == T) return rem; F flow = 0; for (int i = cur[u], v; i &amp;&amp; rem; i = e[i].nxt) &#123; cur[u] = i; v = e[i].to; F nw = min(rem, e[i].cap); if (nw != 0 &amp;&amp; dis[v] == dis[u] + 1) &#123; int ret = dfs(v, nw); flow += ret; rem -= ret; e[i].cap -= ret; e[i ^ 1].cap += ret; &#125; &#125; if (flow == 0) dis[u] = -1; return flow; &#125; F dinic(int source, int sink) &#123; S = source; T = sink; F flow = 0; while (bfs()) flow += dfs(S, flowInf); return flow; &#125;&#125;;#define N 1207#define M 1000007Flow&lt;N, M, int, 1000000000&gt; f;int l[N], r[N];int main() &#123; int n = rd(), m = rd(); int S = N - 1, T = N - 2; for (int i = 1; i &lt;= 400; ++i) f.add(S, i, 1); for (int i = 1; i &lt;= n; ++i) &#123; l[i] = rd(); r[i] = rd(); f.add(400 + i, T, 1); for (int j = l[i]; j &lt;= r[i]; ++j) f.add(j, 400 + i, 1); &#125; printf(&quot;%d\\n&quot;, f.dinic(S, T)); f.clear(); for (int i = 1; i &lt;= 400; ++i) f.add(i, 400 + i, 1); for (int i = 1; i &lt;= m; ++i) &#123; f.add(S, 800 + i, 1); for (int j = l[i]; j &lt;= r[i]; ++j) f.add(800 + i, j, 1); &#125; for (int i = m + 1; i &lt;= n; ++i) &#123; f.add(800 + i, T, 1); for (int j = l[i]; j &lt;= r[i]; ++j) f.add(400 + j, 800 + i, 1); &#125; printf(&quot;%d\\n&quot;, f.dinic(S, T)); return 0;&#125; UPD： 网络流感觉理论复杂度不对，看了下 jiangly 的代码果然有复杂度正确的 dp 做法。 I - Starting a Scenic Railroad Service 策略 1 就是冲突最大的人的冲突次数 \\(+1\\) ，排序维护一下即可；策略 2 就是任意时刻上车的最多人数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;template&lt;typename T&gt;inline bool getmin(T &amp;a, T b) &#123;return a &gt; b ? (a = b, true) : false;&#125;#define N 200007int sum[N];pii s[N];priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; int l = rd(), r = rd() - 1; s[i] = make_pair(l, r); ++sum[l]; --sum[r + 1]; &#125; sort(s + 1, s + 1 + n); int ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; int l = i, r = n; while (!q.empty() &amp;&amp; q.top() &lt; s[i].first) q.pop(); while (l &lt; r) &#123; int mid = (l + r + 1) / 2; s[mid].first &lt;= s[i].second ? l = mid : r = mid - 1; &#125; q.push(s[i].second); ans = max(ans, r - i + (int)q.size()); &#125; printf(&quot;%d &quot;, ans); ans = 0; for (int i = 1; i &lt; N; ++i) &#123;sum[i] += sum[i - 1]; ans = max(ans, sum[i]);&#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125; *J - String Puzzle 一个长度为 \\(n\\ (n\\le 10^9)\\) 的未知串，给定 \\(a\\) 个位置上的字符，\\(b\\) 个信息，\\(q\\) 次询问是否能知道某个位置的值。 一条信息：\\(1\\le h &lt; l\\le r\\le n\\) ，表示 \\(S[h,h+(r-l)] = S[l,r]\\) ，且所有信息的 \\([l,r]\\) 无交。 首先肯定想先把所有应该相同的位置都找出来，但位置太多了，如果 border 太短可能整个串都要处理。 那么一个经典的思路就是把信息记录在某个特定的位置，所有等价位置都可以找到这个位置，然后打标记/查询。 不妨把这个位置定为可能的最靠前的位置。那么由于 \\([l,r]\\) 无交，每个位置利用哪条信息跳是确定的。 可以发现 \\(S[h,l-1]\\) 是 \\(S[h,r]\\) 天然的 border ，我们直接把 \\(p\\in[l,r]\\) 跳到 \\(h+(p-h)\\mod (l-h)\\) 。 可以发现这样每个信息最多用到一次，查询最靠前的等价位置复杂度就是 \\(O(b)\\) 的。模拟即可。 （当然也可以用 set 维护信息，每次 lower_bound 找到 \\(p\\in[l,r]\\) 那个信息，但是复杂度不会变好就没用） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 1007pair&lt;int, char&gt; hint[N];int y[N], h[N], tot;struct segpair&#123;int l, r, h;&#125; s[N];map&lt;int, char&gt; f;int main() &#123; int n = rd(), a = rd(), b = rd(), q = rd(); for (int i = 1; i &lt;= a; ++i) &#123; int p = rd(); char c = getchar(); while (!isalpha(c)) c = getchar(); hint[i] = &#123;p, c&#125;; &#125; for (int i = 1; i &lt;= b; ++i) &#123;y[i] = rd(); h[i] = rd();&#125; y[b + 1] = n + 1; for (int i = 1; i &lt;= b; ++i) if (h[i]) s[++tot] = &#123;y[i], y[i + 1] - 1, h[i]&#125;; auto find = [&amp;](int p) &#123; if (!tot) return p; for (int i = tot; i; --i) &#123; if (p &gt; s[i].r) return p; if (p &lt; s[i].l) continue; p = s[i].h + (p - s[i].h) % (s[i].l - s[i].h); &#125; return p; &#125;; for (int i = 1; i &lt;= a; ++i) f[find(hint[i].first)] = hint[i].second; for (int i = 1; i &lt;= q; ++i) &#123; int pos = find(rd()); putchar(f.find(pos) == f.end() ? &#x27;?&#x27; : f[pos]); &#125; return 0;&#125; Um_nik 队用了一个奇怪的科技把所有信息拆成 \\(\\log (r-l)\\) 个 \\([h,h+(r-l)]\\) 和 \\([l,r]\\) 无交的信息： 设 \\(len = l-h\\) ，第一组 \\([h,h+len-1],[l,l+len-1]\\) ; 第二组将 \\(len\\) 倍长，\\([h,h+2\\times len-1],[l+len,l + 3\\times len - 1]\\) ; 第三组再倍长，以次类推，然后最后再剩下一小段。简单说就是按照 border 的\\(2^k\\) 倍长划分串。 这样子每组都没有交了，放到这个题就可以直接跳。不知道有啥用，简单记录一下。","categories":[{"name":"Official Contests","slug":"Official-Contests","permalink":"http://blog.gyx.me/categories/Official-Contests/"}],"tags":[{"name":"Geometry","slug":"Geometry","permalink":"http://blog.gyx.me/tags/Geometry/"},{"name":"Shortest Path","slug":"Shortest-Path","permalink":"http://blog.gyx.me/tags/Shortest-Path/"},{"name":"Tricks","slug":"Tricks","permalink":"http://blog.gyx.me/tags/Tricks/"},{"name":"Flows","slug":"Flows","permalink":"http://blog.gyx.me/tags/Flows/"}]},{"title":"2022-2023 ICPC North Western Russia Regional","slug":"official/icpc/22-northwestern-russia","date":"2022-11-14T16:00:00.000Z","updated":"2023-03-20T16:36:19.623Z","comments":true,"path":"official/icpc/22-northwestern-russia/","link":"","permalink":"http://blog.gyx.me/official/icpc/22-northwestern-russia/","excerpt":"","text":"比赛地址 ：Codeforces Gym 104012 待补：DFGHJM A - Absolutely Flat 签到题。 123456789101112131415161718#include&lt;bits/stdc++.h&gt;int ii() &#123; int x; scanf(&quot;%d&quot;, &amp;x); return x;&#125;int main() &#123; int a[4]; for (int i = 0; i &lt; 4; ++i) a[i] = ii(); int b = ii(); std::sort(a, a + 4); if (a[0] == a[1] &amp;&amp; a[0] == a[2] &amp;&amp; a[0] == a[3]) puts(&quot;1&quot;); else if (a[0] + b == a[1] &amp;&amp; a[0] + b == a[2] &amp;&amp; a[0] + b == a[3]) puts(&quot;1&quot;); else puts(&quot;0&quot;);&#125; B - Bricks in the Wall 给一个矩阵由 # 和 . 组成，执行两次操作：在某一行或某一列中选择一段连续的 . ，将其改为 # 。 求两次操作能修改的最大 . 的个数。 分类讨论，两次都选行/列肯定不会冲突，所以维护最大和次大即可。 如果选一行一列，交点处如果是 # 也直接选最大和次大即可，否则要枚举断掉哪个方向。 每行每列的线段开个 set 维护即可。复杂度 \\(\\mathcal{O}(nm\\log \\max(n,m))\\) 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;bits/stdc++.h&gt;using namespace std;#define N 2000007bool mp[N];int u[N], d[N], l[N], r[N];multiset&lt;int, greater&lt;int&gt; &gt; R[N], C[N];inline void work() &#123; int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); auto p = [&amp;](int x, int y) &#123;return (x - 1) * m + y;&#125;; for (int i = 1; i &lt;= n; ++i) R[i].clear(); for (int j = 1; j &lt;= m; ++j) C[j].clear(); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) &#123; char c = getchar(); while (c != &#x27;.&#x27; &amp;&amp; c != &#x27;#&#x27;) c = getchar(); int pos = p(i, j); mp[pos] = (c == &#x27;#&#x27;); u[pos] = d[pos] = l[pos] = r[pos] = 0; &#125; for (int i = 1; i &lt;= n; ++i) for (int j = 1, pos; j &lt;= m; ++j) if (!mp[pos = p(i, j)]) &#123; u[pos] = (i &gt; 1 ? u[p(i - 1, j)] + 1 : 1); l[pos] = (j &gt; 1 ? l[p(i, j - 1)] + 1 : 1); &#125; for (int i = n; i; --i) for (int j = m, pos; j; --j) if (!mp[pos = p(i, j)]) &#123; d[pos] = (i &lt; n ? d[p(i + 1, j)] + 1 : 1); r[pos] = (j &lt; m ? r[p(i, j + 1)] + 1 : 1); &#125; for (int i = 1, pos; i &lt;= n; ++i) &#123; if (!mp[pos = p(i, 1)]) R[i].insert(r[pos]); for (int j = 1; j &lt; m; ++j) if (mp[p(i, j)] &amp;&amp; !mp[pos = p(i, j + 1)]) R[i].insert(r[pos]); &#125; for (int j = 1, pos; j &lt;= m; ++j) &#123; if (!mp[pos = p(1, j)]) C[j].insert(d[pos]); for (int i = 1; i &lt; n; ++i) if (mp[p(i, j)] &amp;&amp; !mp[pos = p(i + 1, j)]) C[j].insert(d[pos]); &#125; int mx = 0, mxx = 0; auto upd = [&amp;](int x) &#123; if (mx &lt; x) &#123;mxx = mx; mx = x;&#125; else if (mxx &lt; x) mxx = x; &#125;; for (int i = 1; i &lt;= n; ++i) &#123; int sz = R[i].size(); if (sz) upd(*R[i].begin()); if (sz &gt; 1) upd(*++R[i].begin()); &#125; int ans = mx + mxx; mx = mxx = 0; for (int j = 1; j &lt;= m; ++j) &#123; int sz = C[j].size(); if (sz) upd(*C[j].begin()); if (sz &gt; 1) upd(*++C[j].begin()); &#125; ans = max(ans, mx + mxx); for (int i = 1; i &lt;= n; ++i) for (int j = 1, pos; j &lt;= m; ++j) if (!mp[pos = p(i, j)]) ans = max(ans, u[pos] + d[pos] + l[pos] + r[pos] - 2 - min(&#123;u[pos], d[pos], l[pos], r[pos]&#125;)); for (int i = 1; i &lt;= n; ++i) for (int j = 1, pos; j &lt;= m; ++j) &#123; if (!mp[pos = p(i, j)]) &#123; int lr = l[pos] + r[pos] - 1; int ud = u[pos] + d[pos] - 1; // cut lr R[i].erase(R[i].lower_bound(lr)); R[i].insert(l[pos] - 1); R[i].insert(r[pos] - 1); mx = 0; mxx = 0; int sz = R[i].size(); if (sz) upd(*R[i].begin()); if (sz &gt; 1) upd(*++R[i].begin()); sz = C[j].size(); if (sz) upd(*C[j].begin()); if (sz &gt; 1) upd(*++C[j].begin()); ans = max(ans, mx + mxx); R[i].erase(R[i].lower_bound(l[pos] - 1)); R[i].erase(R[i].lower_bound(r[pos] - 1)); R[i].insert(lr); // cut ud C[j].erase(C[j].lower_bound(ud)); C[j].insert(u[pos] - 1); C[j].insert(d[pos] - 1); mx = 0; mxx = 0; sz = R[i].size(); if (sz) upd(*R[i].begin()); if (sz &gt; 1) upd(*++R[i].begin()); sz = C[j].size(); if (sz) upd(*C[j].begin()); if (sz &gt; 1) upd(*++C[j].begin()); ans = max(ans, mx + mxx); C[j].erase(C[j].lower_bound(u[pos] - 1)); C[j].erase(C[j].lower_bound(d[pos] - 1)); C[j].insert(ud); &#125; else &#123; mx = 0; mxx = 0; int sz = R[i].size(); if (sz) upd(*R[i].begin()); if (sz &gt; 1) upd(*++R[i].begin()); sz = C[j].size(); if (sz) upd(*C[j].begin()); if (sz &gt; 1) upd(*++C[j].begin()); ans = max(ans, mx + mxx); &#125; &#125; printf(&quot;%d\\n&quot;, ans);&#125;int main() &#123; int t; scanf(&quot;%d&quot;, &amp;t); for (int i = 1; i &lt;= t; ++i) work(); return 0;&#125; C - Computer Network 签到。 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;int ii() &#123; int x; scanf(&quot;%d&quot;, &amp;x); return x;&#125;int main() &#123; int n = ii(); int k = ii(); std::priority_queue&lt;int&gt; vec; for (int i = 0; i &lt; k; ++i) vec.push(0); int a[n]; for (int i = 0; i &lt; n; ++i) a[i] = ii(); std::sort(a, a + n); long long ans&#123;&#125;; for (int i = 0; i &lt; n; ++i) &#123; int x = -vec.top(); vec.pop(); int y = -x - a[i]; ans += x + a[i]; vec.push(y); &#125; std::cout &lt;&lt; ans &lt;&lt; std::endl;&#125; *D - Dice Grid *E - Easily Distinguishable Triangles 给一个矩阵由 #.? 组成，# 代表黑色，. 代表白色，你需要将 ? 的一个角（一半面积）染成黑色。 使得最终对于每个三角形，他所染黑的两条边不和任何其他黑色边界相邻。求方案数。 玩一下发现行列是独立的，换句话说，染色相当于从左右中选一个边染色，上下中选一个边染色。 行列单独计数，以某行为例，如果左右都是黑色的就不行，一侧黑色方案数为 \\(1\\) ，没有黑色方案数为 \\(len+1\\) 。 对每个行 / 列连通块执行上述过程即可。 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;#define N 1007#define mod 998244353char mp[N][N];int main() &#123; int n, ans = 1; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(&quot;%s&quot;, mp[i] + 1); mp[i][0] = mp[i][n + 1] = &#x27;.&#x27;; for (int j = 1, l = 0; j &lt;= n + 1; ++j) if (mp[i][j] == &#x27;?&#x27; &amp;&amp; mp[i][j - 1] != &#x27;?&#x27;) l = j - 1; else if (mp[i][j] != &#x27;?&#x27; &amp;&amp; mp[i][j - 1] == &#x27;?&#x27;) &#123; int cnt = (mp[i][l] == &#x27;#&#x27;) + (mp[i][j] == &#x27;#&#x27;); if (cnt == 2) &#123;puts(&quot;0&quot;); return 0;&#125; ans = 1ll * ans * (cnt ? 1 : j - l) % mod; &#125; &#125; for (int j = 1; j &lt;= n; ++j) &#123; mp[0][j] = mp[n + 1][j] = &#x27;.&#x27;; for (int i = 1, l = 0; i &lt;= n + 1; ++i) if (mp[i][j] == &#x27;?&#x27; &amp;&amp; mp[i - 1][j] != &#x27;?&#x27;) l = i - 1; else if (mp[i][j] != &#x27;?&#x27; &amp;&amp; mp[i - 1][j] == &#x27;?&#x27;) &#123; int cnt = (mp[l][j] == &#x27;#&#x27;) + (mp[i][j] == &#x27;#&#x27;); if (cnt == 2) &#123;puts(&quot;0&quot;); return 0;&#125; ans = 1ll * ans * (cnt ? 1 : i - l) % mod; &#125; &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125; *I - IQ Game \\(n\\le 10^9\\) 个点围成一圈，有 \\(k\\le 200\\) 个是黑点，其余是白点，且 \\(k\\) 个点中有一个是炸弹。 每轮随机选一个点，然后找到他顺时针方向的第一个黑点，如果是炸弹游戏结束，否则将这个黑点变白。 问游戏进行的期望轮数。 首先要有一个核心思路，对于值恒正的随机变量 \\(x\\) ，有 \\(E(x)=\\sum_{i=1}^{\\infty} P(x\\ge i)\\) 。 注意到游戏 \\(k\\) 轮之后必定结束，所以只要求出 \\(0\\le i&lt; k\\) 轮游戏不结束的概率即可。 考虑将换从炸弹处断开，按照逆时针方向以炸弹为起点向后延申，以特殊点分段。 那么游戏不结束的要求就是：第一段里的点不能选，第二段最多选一个，前三段最多选两个，以此类推。 发现要求是前 \\(i\\) 段最多选 \\(i-1\\) 个，设 \\(f[i][j]\\) 表示在前 \\(i\\) 段选了 \\(j\\) 次，没有违背要求的概率，答案就是 \\(\\sum_{j=0}^{k-1} f[n][j]\\) 。 转移枚举最后一段选了几个，然后再将这些插入到此前的操作序列中，即 \\(f[i][j] = \\sum_{k=0}^j f[i-1][j-k]\\times {j\\choose k}\\times (\\frac{len_i}{n})^k\\) 直接做复杂度 \\(\\mathcal{O}(n^3)\\) 的可过，不过转移是个卷积的形式，可以优化到 \\(\\mathcal{O}(n^2\\log n)\\) 。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 207#define mod 998244353inline int fpow(int x, int t) &#123; int res = 1; for (; t; t &gt;&gt;= 1, x = 1ll * x * x % mod) if (t &amp; 1) res = 1ll * res * x % mod; return res;&#125;ll pos[N], p[N][N], c[N][N], f[N][N];int main() &#123; int n = rd(), m = rd(), s = rd(); int invn = fpow(n, mod - 2); for (int i = 0; i &lt;= m; ++i) &#123; c[i][0] = 1; for (int j = 1; j &lt;= i; ++j) c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % mod; &#125; for (int i = 1; i &lt;= m; ++i) &#123; pos[i] = rd(); if (pos[i] &gt; s) pos[i] -= n; &#125; pos[0] = s - n; sort(pos + 1, pos + 1 + m); for (int i = 1; i &lt;= m; ++i) &#123; p[i][0] = 1; p[i][1] = 1ll * (pos[m - i + 1] - pos[m - i]) * invn % mod; for (int j = 2; j &lt;= m; ++j) p[i][j] = p[i][j - 1] * p[i][1] % mod; &#125; f[0][0] = 1; for (int i = 1; i &lt;= m; ++i) for (int j = 0; j &lt; i; ++j) for (int k = 0; k &lt;= j; ++k) f[i][j] = (f[i][j] + c[j][k] * f[i - 1][j - k] % mod * p[i][k]) % mod; ll ans = 0; for (int j = 0; j &lt; m; ++j) ans = (ans + f[m][j]) % mod; printf(&quot;%lld\\n&quot;, ans); return 0;&#125; K - K-Shaped Figures 给定平面上 \\(n\\le 10^3\\) 个线段，问有多少个 \\(K\\) ，定义三条线段构成了一个 K ： 其中两条交于一点，且这一点在第三条线段内（不能是端点） 前两条线在第三条线的同侧，且三条线两两不共线。 做法一 自然的枚举这个中心点，找出来穿过该点的线段 \\(\\{A\\}\\)，和以该点为端点的线段 \\(\\{B\\}\\) ，都按该点为中心极角序排序。 然后对于每个穿过该点的线段 \\(A\\) ，线段两侧的 \\(B\\) 线段下标一定依极角序连续，双指针找出来这个区间即可。 对于不能共线，问题相当于计数给定 \\(n\\) 个集合，先选两个集合，再从这两个集合中各自选一个数的方案数。 考虑减掉不合法的方案数，则答案为 \\({\\sum a_i\\choose 2} - \\sum {a_i\\choose 2}\\) ，分两项维护即可。 为了避免讨论，我们需要保证任意时刻直线每一侧都有点，因此加入四个垂直方向的虚拟点即可。 注意到双指针旋转时，如果角度超过了 \\(180^\\circ\\) 可能会出现问题，所以再插入垂直方向的四条直线即可。 复杂度为 \\(\\mathcal{O}(n^2\\log n)\\) 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 1007#define letp const Pstruct P &#123; ll x, y; P(ll x = 0, ll y = 0) : x(x), y(y) &#123;&#125; P operator + (letp &amp;p) const &#123;return &#123;x + p.x, y + p.y&#125;;&#125; P operator - (letp &amp;p) const &#123;return &#123;x - p.x, y - p.y&#125;;&#125; ll operator | (letp &amp;p) const &#123;return x * p.x + y * p.y;&#125; // dot ll operator ^ (letp &amp;p) const &#123;return x * p.y - y * p.x;&#125; // cross bool operator &lt; (letp &amp;p) const &#123;return x &lt; p.x || (x == p.x &amp;&amp; y &lt; p.y);&#125; bool operator == (letp &amp;p) const &#123;return x == p.x &amp;&amp; y == p.y;&#125; int ori(letp &amp;p) const &#123;ll t = (*this) ^ p; return (t &gt; 0) - (t &lt; 0);&#125;&#125;;vector&lt;P&gt; pt;struct argcmp &#123; bool operator() (letp &amp;a, letp &amp;b) const &#123; const auto quad = [](letp &amp;a) &#123; if (a.y &lt; 0) return 1; if (a.y &gt; 0) return 4; if (a.x &lt; 0) return 5; if (a.x &gt; 0) return 3; return 2; &#125;; const int qa = quad(a), qb = quad(b); if (qa != qb) return qa &lt; qb; const auto t = (a ^ b); return t &gt; 0; &#125;&#125;;struct S &#123; P a, b; int is_on(letp &amp;p) const &#123; if (p == a || p == b) return -1; return (p - a).ori(p - b) == 0 &amp;&amp; ((p - a) | (p - b)) &lt; 0; &#125; int ori(letp &amp;p) const &#123;return (b - a).ori(p - a);&#125;&#125; s[N];vector&lt;pair&lt;P, S&gt;&gt; Cr;vector&lt;P&gt; out;vector&lt;pair&lt;P, int&gt;&gt; Out;inline ll c2(int x) &#123;return 1ll * x * (x - 1) / 2;&#125;inline void work() &#123; int n = rd(); pt.clear(); for (int i = 1; i &lt;= n; ++i) &#123; P a, b; a.x = rd(); a.y = rd(); b.x = rd(); b.y = rd(); pt.push_back(a); pt.push_back(b); s[i] = &#123;a, b&#125;; &#125; sort(pt.begin(), pt.end()); pt.erase(unique(pt.begin(), pt.end()), pt.end()); ll ans = 0; for (auto p : pt) &#123; Cr.clear(); out.clear(); Out.clear(); for (int i = 1; i &lt;= n; ++i) &#123; int fl = s[i].is_on(p); if (fl == 1) &#123; Cr.push_back(make_pair(s[i].a, S&#123;s[i].a, s[i].b&#125;)); Cr.push_back(make_pair(s[i].b, S&#123;s[i].b, s[i].a&#125;)); &#125; else if (fl == -1) &#123; out.push_back(p == s[i].a ? s[i].b : s[i].a); &#125; &#125; if (Cr.empty()) continue; if (out.empty()) continue; Cr.push_back(make_pair(P&#123;p.x - 100000000, p.y&#125;, S&#123;P&#123;p.x - 100000000, p.y&#125;, P&#123;p.x + 1, p.y&#125;&#125;)); Cr.push_back(make_pair(P&#123;p.x + 100000000, p.y&#125;, S&#123;P&#123;p.x + 100000000, p.y&#125;, P&#123;p.x - 1, p.y&#125;&#125;)); Cr.push_back(make_pair(P&#123;p.x, p.y - 100000000&#125;, S&#123;P&#123;p.x, p.y - 100000000&#125;, P&#123;p.x, p.y + 1&#125;&#125;)); Cr.push_back(make_pair(P&#123;p.x, p.y + 100000000&#125;, S&#123;P&#123;p.x, p.y + 100000000&#125;, P&#123;p.x, p.y - 1&#125;&#125;)); auto cmp = [&amp;](P &amp;a, P &amp;b) &#123;return argcmp()(a - p, b - p);&#125;; auto cmpCr = [&amp;](pair&lt;P, S&gt; &amp;a, pair&lt;P, S&gt; &amp;b) &#123;return cmp(a.first, b.first);&#125;; auto cmpOut = [&amp;](pair&lt;P, int&gt; &amp;a, pair&lt;P, int&gt; &amp;b) &#123;return cmp(a.first, b.first);&#125;; sort(Cr.begin(), Cr.end(), cmpCr); sort(out.begin(), out.end(), cmp); auto para = [&amp;](P &amp;a, P &amp;b) &#123;return ((a - p) ^ (b - p)) == 0 &amp;&amp; ((a - p) | (b - p)) &gt; 0;&#125;; for (auto x : out) if (Out.empty() || !para(Out.back().first, x)) Out.push_back(make_pair(x, 1)); else ++Out[Out.size() - 1].second; Out.push_back(make_pair(P&#123;p.x + 1, p.y&#125;, 0)); Out.push_back(make_pair(P&#123;p.x - 1, p.y&#125;, 0)); Out.push_back(make_pair(P&#123;p.x, p.y + 1&#125;, 0)); Out.push_back(make_pair(P&#123;p.x, p.y - 1&#125;, 0)); sort(Out.begin(), Out.end(), cmpOut); int sz = Out.size(); auto nxt = [&amp;](int x) &#123;return x == sz - 1 ? 0 : x + 1;&#125;; auto pre = [&amp;](int x) &#123;return x == 0 ? sz - 1 : x - 1;&#125;; int l = 0, r = 0; auto pos = [&amp;](S &amp;l, P &amp;x) &#123;return l.ori(x) &gt; 0;&#125;; ll sum = 0, del = 0; while (!pos(Cr[0].second, Out[r].first)) r = nxt(r); while (pos(Cr[0].second, Out[r].first)) r = nxt(r); r = pre(r); l = r; while (pos(Cr[0].second, Out[l].first)) l = pre(l); l = nxt(l); for (int i = l; i != nxt(r); i = nxt(i)) &#123; sum += Out[i].second; del += c2(Out[i].second); &#125; for (auto [tmp, s] : Cr) &#123; while (pos(s, Out[nxt(r)].first)) &#123; r = nxt(r); sum += Out[r].second; del += c2(Out[r].second); &#125; while (!pos(s, Out[l].first)) &#123; sum -= Out[l].second; del -= c2(Out[l].second); l = nxt(l); &#125; if (max(abs(tmp.x), abs(tmp.y)) &lt;= 10000000) ans += c2(sum) - del; &#125; &#125; printf(&quot;%lld\\n&quot;, ans);&#125;int main() &#123; int t; scanf(&quot;%d&quot;, &amp;t); for (int i = 1; i &lt;= t; ++i) work(); return 0;&#125; 做法二 因为这题是要求全部的 \\(K\\) 的个数，所以其实暴力的复杂度是对的。 先枚举中心点，再枚举穿过他的线，再枚举所有以它为端点的线计算答案，计算方式与上一做法相同。 同向去重需要一些技巧，比如 unordered_map 以方向向量除 \\(\\gcd\\) 做下标即可统计。 考虑以枚举点为端点的线段数的和，看似是 \\(\\mathcal{O}(n^2)\\) 实际上是 \\(\\mathcal{O}(n)\\) 的，所以总复杂度是 \\(\\mathcal{O}(n^2)\\) 的。 实际上由于 unordered_map 比 sort 常数还大，所以跑起来并不快。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;int gcd(int a, int b) &#123;return b ? gcd(b, a % b) : a;&#125;#define N 1007#define letp const Pstruct P &#123; ll x, y; P(ll x = 0, ll y = 0) : x(x), y(y) &#123;&#125; P operator + (letp &amp;p) const &#123;return &#123;x + p.x, y + p.y&#125;;&#125; P operator - (letp &amp;p) const &#123;return &#123;x - p.x, y - p.y&#125;;&#125; P operator / (int t) const &#123;return &#123;x / t, y / t&#125;;&#125; ll operator | (letp &amp;p) const &#123;return x * p.x + y * p.y;&#125; // dot ll operator ^ (letp &amp;p) const &#123;return x * p.y - y * p.x;&#125; // cross bool operator &lt; (letp &amp;p) const &#123;return x &lt; p.x || (x == p.x &amp;&amp; y &lt; p.y);&#125; bool operator == (letp &amp;p) const &#123;return x == p.x &amp;&amp; y == p.y;&#125; int ori(letp &amp;p) const &#123;ll t = (*this) ^ p; return (t &gt; 0) - (t &lt; 0);&#125;&#125;;vector&lt;P&gt; pt;struct argcmp &#123; bool operator() (letp &amp;a, letp &amp;b) const &#123; const auto quad = [](letp &amp;a) &#123; if (a.y &lt; 0) return 1; if (a.y &gt; 0) return 4; if (a.x &lt; 0) return 5; if (a.x &gt; 0) return 3; return 2; &#125;; const int qa = quad(a), qb = quad(b); if (qa != qb) return qa &lt; qb; const auto t = (a ^ b); return t &gt; 0; &#125;&#125;;struct S &#123; P a, b; int is_on(letp &amp;p) const &#123; if (p == a || p == b) return -1; return (p - a).ori(p - b) == 0 &amp;&amp; ((p - a) | (p - b)) &lt; 0; &#125; int ori(letp &amp;p) const &#123;return (b - a).ori(p - a);&#125;&#125; s[N];vector&lt;P&gt; B;vector&lt;S&gt; A;unordered_map&lt;ll, int&gt; cnt;inline ll trans(P x) &#123; static const ll bs = 10000000; return (x.x + bs) * 2 * bs + (x.y + bs);&#125;inline ll c2(int x) &#123;return 1ll * x * (x - 1) / 2;&#125;inline void work() &#123; int n = rd(); pt.clear(); for (int i = 1; i &lt;= n; ++i) &#123; P a, b; a.x = rd(); a.y = rd(); b.x = rd(); b.y = rd(); pt.push_back(a); pt.push_back(b); s[i] = &#123;a, b&#125;; &#125; sort(pt.begin(), pt.end()); pt.erase(unique(pt.begin(), pt.end()), pt.end()); ll ans = 0; for (auto p : pt) &#123; A.clear(); B.clear(); for (int i = 1; i &lt;= n; ++i) if (p == s[i].a || p == s[i].b) &#123; P dlt = (p == s[i].a ? s[i].b : s[i].a) - p; dlt = dlt / gcd(abs(dlt.x), abs(dlt.y)); B.push_back(dlt); &#125; else if (s[i].is_on(p)) A.push_back(s[i]); for (auto seg : A) &#123; cnt.clear(); int suml = 0, sumr = 0, dell = 0, delr = 0; auto addl = [&amp;](ll x) &#123; suml -= cnt[x]; dell -= c2(cnt[x]); ++cnt[x]; suml += cnt[x]; dell += c2(cnt[x]); &#125;; auto addr = [&amp;](ll x) &#123; sumr -= cnt[x]; delr -= c2(cnt[x]); ++cnt[x]; sumr += cnt[x]; delr += c2(cnt[x]); &#125;; for (auto dlt : B) &#123; int dir = seg.ori(dlt + p); if (dir == 1) addl(trans(dlt)); if (dir == -1) addr(trans(dlt)); &#125; ans += c2(suml) + c2(sumr) - dell - delr; &#125; &#125; printf(&quot;%lld\\n&quot;, ans);&#125;int main() &#123; int t; scanf(&quot;%d&quot;, &amp;t); for (int i = 1; i &lt;= t; ++i) work(); return 0;&#125; L - Limited Swaps 签到。 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;int ii() &#123; int x; scanf(&quot;%d&quot;, &amp;x); return x;&#125;int main() &#123; int n = ii(); int a[n]; for (int i = 0; i &lt; n; ++i) a[i] = ii(); int b[n]; for (int i = 0; i &lt; n; ++i) b[i] = ii(); std::vector&lt;int&gt; ans; for (int i = 0; i &lt; n; ++i) &#123; int k = 0; for (int j = i; j &lt; n; ++j) if (a[j] == b[i]) k = j; for (; k &gt; i; --k) if (abs(a[k - 1] - a[k]) &lt; 2) &#123; puts(&quot;-1&quot;); return 0; &#125; else &#123; ans.push_back(k); std::swap(a[k - 1], a[k]); &#125; &#125; int m = ans.size(); std::cout &lt;&lt; ans.size() &lt;&lt; std::endl; for (int i = 0; i &lt; m; ++i) std::cout &lt;&lt; ans[i] &lt;&lt; &quot; \\n&quot;[i == m - 1];&#125; M - Mex and Cards 给定一个数集，开始 \\(i\\) 有 \\(a_i\\) 个，把数集分成若干个集合，最大化所有分出来的集合 MEX 的和。 支持每次插入 / 删除一个数字，维护答案。 线段树。讨论一下即可。可以做到一个 \\(\\log\\) ，回头再补。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define fr first#define sc second#define mp make_pairusing namespace std;typedef long long LL;const int maxn=200000,maxt=maxn&lt;&lt;2;int n,te,a[maxn+5];int MIN[maxt+5];pair&lt;LL,int&gt; res[maxt+5];inline int Miner(int x,int y) &#123;return a[x]&lt;a[y] || a[x]==a[y] &amp;&amp; x&gt;y?x:y;&#125;pair&lt;LL,int&gt; Find(int L,int R,int p,int who)&#123; if (L==R) return a[L]&lt;=a[who]?mp((LL)(a[who]-a[L])*(L-1),L):mp(0LL,who); int mid=L+(R-L&gt;&gt;1); if (a[who]&lt;a[MIN[p&lt;&lt;1]]) return Find(mid+1,R,p&lt;&lt;1|1,who); else &#123; pair&lt;LL,int&gt; ls=Find(L,mid,p&lt;&lt;1,who); return mp(ls.fr+res[p].fr,res[p].sc); &#125;&#125;void Build(int l,int r,int p=1)&#123; if (l==r) &#123;MIN[p]=l;return;&#125; int mid=l+(r-l&gt;&gt;1); Build(l,mid,p&lt;&lt;1);Build(mid+1,r,p&lt;&lt;1|1); MIN[p]=Miner(MIN[p&lt;&lt;1],MIN[p&lt;&lt;1|1]); res[p]=Find(mid+1,r,p&lt;&lt;1|1,MIN[p&lt;&lt;1]);&#125;void Update(int pos,int l=1,int r=n,int p=1)&#123; if (l==r) return; int mid=l+(r-l&gt;&gt;1); pos&lt;=mid?Update(pos,l,mid,p&lt;&lt;1):Update(pos,mid+1,r,p&lt;&lt;1|1); MIN[p]=Miner(MIN[p&lt;&lt;1],MIN[p&lt;&lt;1|1]); res[p]=Find(mid+1,r,p&lt;&lt;1|1,MIN[p&lt;&lt;1]);&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n);n++; for (int i=1;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]); a[0]=1e9;Build(1,n); printf(&quot;%lld\\n&quot;,Find(1,n,1,0).fr); for (scanf(&quot;%d&quot;,&amp;te);te;te--)&#123; int tp,x;scanf(&quot;%d%d&quot;,&amp;tp,&amp;x);x++; a[x]+=(tp==1?1:-1);Update(x); printf(&quot;%lld\\n&quot;,Find(1,n,1,0).fr); &#125; return 0;&#125; N - New Time 签到。 1234567891011121314151617181920#include&lt;cstdio&gt;using namespace std;int a,b,c,d,ans;int main()&#123; scanf(&quot;%d:%d%d:%d&quot;,&amp;a,&amp;b,&amp;c,&amp;d); if (b&lt;=d)&#123; ans+=d-b; if (a&lt;=c) ans+=c-a; else ans+=24-a+c; &#125; else &#123; ans+=60-b+d; a=(a+1)%24; if (a&lt;=c) ans+=c-a; else ans+=24-a+c; &#125; printf(&quot;%d\\n&quot;,ans); return 0;&#125;","categories":[{"name":"Official Contests","slug":"Official-Contests","permalink":"http://blog.gyx.me/categories/Official-Contests/"}],"tags":[{"name":"Geometry","slug":"Geometry","permalink":"http://blog.gyx.me/tags/Geometry/"},{"name":"STL","slug":"STL","permalink":"http://blog.gyx.me/tags/STL/"},{"name":"Segment Tree","slug":"Segment-Tree","permalink":"http://blog.gyx.me/tags/Segment-Tree/"},{"name":"Probabilities","slug":"Probabilities","permalink":"http://blog.gyx.me/tags/Probabilities/"},{"name":"Tricks","slug":"Tricks","permalink":"http://blog.gyx.me/tags/Tricks/"}]},{"title":"2022 CCPC Guangzhou Site","slug":"official/ccpc/22-guangzhou","date":"2022-11-13T16:00:00.000Z","updated":"2023-03-20T16:35:28.185Z","comments":true,"path":"official/ccpc/22-guangzhou/","link":"","permalink":"http://blog.gyx.me/official/ccpc/22-guangzhou/","excerpt":"","text":"比赛地址 ：Codeforces Gym 104053 待补：ADFGJ B - Ayano and sequences 数据结构题，胖胖补掉了。链接 *C - Customs Controls 2 给定一个 DAG ，保证所有点都能从 \\(1\\) 到达，且都能到达 \\(n\\) 。 要求给每个点分配一个点权，使得从 \\(1\\) 到 \\(n\\) 的所有路径经过的点权和相同。 定义 \\(dis[u]\\) 表示从 \\(1\\) 到 \\(u\\) 的距离，如果要符合最终要求，显然首先 \\(dis[u]\\) 的值要唯一。 考虑对于每个点 \\(v\\) ，图中存在 \\(u\\to v\\) 的边，那么这样的 \\(u\\) 的 \\(dis[u]\\) 也必须相同。 并查集把这样的点缩点，重建图，因为点权是正的，因此如果图中存在环就无解。 否则按照从 \\(1\\) 开始的拓扑序设定 \\(dis[u]\\) 即可，\\(v\\) 的点权就是 \\(dis[v] - dis[u]\\) 的值（原图中存在 \\(u\\to v\\) ）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 200007struct DSU &#123; int f[N]; inline void reset(int x) &#123;for (int i = 1; i &lt;= x; ++i) f[i] = i;&#125; int find(int x) &#123;return x == f[x] ? x : f[x] = find(f[x]);&#125; bool merge(int u, int v) &#123; u = find(u); v = find(v); return (u == v ? false : (f[u] = v, true)); &#125; &#125; dsu;int deg[N], tag[N], val[N];queue&lt;int&gt; q;vector&lt;int&gt; in[N], out[N];inline void work() &#123; int n = rd(), m = rd(); dsu.reset(n); for (int i = 1; i &lt;= n; ++i) &#123;deg[i] = 0; in[i].clear(); out[i].clear();&#125; for (int i = 1; i &lt;= m; ++i) &#123; int u = rd(), v = rd(); in[v].push_back(u); &#125; for (int u = 1; u &lt;= n; ++u) if (!in[u].empty()) &#123; int sy = in[u][0]; for (auto x : in[u]) dsu.merge(x, sy); &#125; for (int u = 1; u &lt;= n; ++u) &#123; int U = dsu.find(u); for (auto v : in[u]) &#123; int V = dsu.find(v); ++deg[U]; out[V].push_back(U); &#125; &#125; int tot = 0, cnt = 0; for (int i = 1; i &lt;= n; ++i) if (dsu.find(i) == i) &#123; ++tot; if (!deg[i]) q.push(i); &#125; while (!q.empty()) &#123; --tot; int u = q.front(); q.pop(); tag[u] = ++cnt; for (auto v : out[u]) &#123; --deg[v]; if (!deg[v]) q.push(v); &#125; &#125; if (tot) &#123;puts(&quot;No&quot;); return;&#125; puts(&quot;Yes&quot;); for (int i = 1; i &lt;= n; ++i) val[i] = tag[dsu.find(i)]; for (int i = 1; i &lt;= n; ++i) &#123; int ans = val[i]; if (!in[i].empty()) ans -= val[in[i][0]]; if (i &lt; n) printf(&quot;%d &quot;, ans); else printf(&quot;%d\\n&quot;, ans); &#125;&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; E - Elevator 签到题，逆序数。要把 \\(x\\) 前面的变成 \\(&gt; x\\) ，后面的变成 \\(\\ge x\\) 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;vector&lt;int&gt; s, s1;#define N 500007int a[N], c[N];#define lowbit(x) ((x) &amp; -(x))inline void add(int p) &#123; for (; p &lt; N; p += lowbit(p)) ++c[p];&#125;inline int sum(int p) &#123; int res = 0; for (; p; p -= lowbit(p)) res += c[p]; return res;&#125;ll presum[N];int main() &#123; int n = rd(), m = rd() - 2; for (int i = 1; i &lt;= n; ++i) &#123; a[i] = rd(); s.push_back(a[i]); &#125; sort(s.begin(), s.end()); s1 = s; for (int i = 1; i &lt;= n; ++i) presum[i] = presum[i - 1] + s1[i - 1]; s.erase(unique(s.begin(), s.end()), s.end()); auto calc = [&amp;](int x) &#123; return lower_bound(s.begin(), s.end(), x) - s.begin() + 1; &#125;; for (int i = 1; i &lt;= n; ++i) &#123; int nw = calc(a[i]); ll tot = sum(nw); add(nw); int p = lower_bound(s1.begin(), s1.end(), a[i]) - s1.begin() + 1; tot += 1ll * p * a[i] - presum[p]; if (tot &gt; m) puts(&quot;-1&quot;); else printf(&quot;%lld\\n&quot;, tot); &#125; return 0;&#125; H - GameX 给定一个数集，双方轮流操作 \\(k\\) 轮，每个人往数集里加入一个非负整数。 先手想让最终数集 MEX 是偶数，后手想要是奇数，问最终结果。 先手想让最终结果是偶数，则必不会加入偶数，只加入奇数；同理后手只会加入偶数。 再注意到如果小的奇数还没加，加大的奇数是没用的，所以一定会从小到大加。模拟即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 2000007bool vis[N];int a[N];vector&lt;int&gt; s;inline void work() &#123; s.clear(); int n = rd(), k = rd(); for (int i = 1; i &lt;= n; ++i) &#123; a[i] = rd(); vis[a[i]] = true; &#125; int A = 1, B = 0; for (int i = 1; i &lt;= k; ++i) &#123; while (vis[A]) A += 2; vis[A] = true; s.push_back(A); while (vis[B]) B += 2; vis[B] = true; s.push_back(B); &#125; int mx = 0; while (vis[mx]) ++mx; puts((mx &amp; 1) ? &quot;Bob&quot; : &quot;Alice&quot;); for (int i = 1; i &lt;= n; ++i) vis[a[i]] =false; for (auto x : s) vis[x] = false;&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; *I - Infection 给一棵树，每个点有 \\(\\frac{a_i}{\\sum a_i}\\) 的概率被选作根，然后被染黑。 若 \\(u\\) 父节点被染黑，则 \\(u\\) 被染黑的概率为 \\(p_u = \\frac{b_u}{c_u}\\) ，问染黑 \\(k=1,2,\\dots, n\\) 个点的概率模 \\(10^9+7\\) 。 考虑一个树上连通点集对答案的贡献： \\[ contri_S = \\sum_{root\\in S}\\bigg(\\frac{a_{root}}{\\sum a}\\prod_{u\\in S,u\\ne root} p_u\\prod_{(u,v)\\in Tree, v\\not\\in S,u\\in S}(1-p_v)\\bigg) \\] 设 \\(F[i][j]\\) 表示以 \\(i\\) 为根的点集中有 \\(j\\) 个点，且未选定初始感染点的贡献和。 \\(G[i][j]\\) 表示已选定初始感染点的贡献和。 树形背包转移，复杂度 \\(\\mathcal{O}(n^2)\\) 。每个点把 \\(G\\) 数组贡献到答案中即可。树形背包实现还是很精细的... 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 2007#define mod 1000000007vector&lt;int&gt; e[N];inline int fpow(int x, int t = mod - 2) &#123; int res = 1; for (; t; t &gt;&gt;= 1, x = 1ll * x * x % mod) if (t &amp; 1) res = 1ll * res * x % mod; return res;&#125;// f[u][v] : choose j nodes in subtree u, without root// g[u][v] : choose j nodes in subtree u, already choose a rootint a[N], p[N], sz[N], f[N][N], g[N][N], ans[N];void dfs(int u, int fa, int pfa) &#123; f[u][0] = 1; for (auto v : e[u]) if (v != fa) &#123; dfs(v, u, p[u]); for (int j = sz[u] + sz[v]; j &gt;= 0; --j) &#123; // 这里本来应该开一个另外的数组来存值，最后再赋值回去的，但是注意到k=0的转移非常好写就直接赋值了 // failed at v f[u][j] = (ll)f[u][j] * (mod + 1 - p[v]) % mod; g[u][j] = (ll)g[u][j] * (mod + 1 - p[v]) % mod; // choose k nodes in subtree v for (int k = max(1, j - sz[u]); k &lt;= min(j, sz[v]); ++k) &#123; f[u][j] = (f[u][j] + (ll)f[u][j - k] * f[v][k]) % mod; g[u][j] = (g[u][j] + (ll)g[u][j - k] * f[v][k] + (ll)f[u][j - k] * g[v][k]) % mod; &#125; &#125; sz[u] += sz[v]; &#125; ++sz[u]; for (int j = sz[u]; j; --j) &#123; f[u][j] = (ll)f[u][j - 1] * p[u] % mod; g[u][j] = (ll)f[u][j - 1] * a[u] % mod; if (j &gt; 1) g[u][j] = (g[u][j] + (ll)g[u][j - 1] * p[u]) % mod; ans[j] = (ans[j] + (ll)g[u][j] * (mod + 1 - pfa)) % mod; // 注意要保证父亲没有选 &#125;&#125;int main() &#123; int n = rd(); for (int i = 1; i &lt; n; ++i) &#123; int u = rd(), v = rd(); e[u].push_back(v); e[v].push_back(u); &#125; int sum = 0; for (int i = 1; i &lt;= n; ++i) &#123; a[i] = rd(); sum += a[i]; p[i] = rd(); p[i] = (ll)p[i] * fpow(rd()) % mod; &#125; sum = fpow(sum); for (int i = 1; i &lt;= n; ++i) a[i] = (ll)a[i] * sum % mod; dfs(1, 1, 0); for (int i = 1; i &lt;= n; ++i) printf(&quot;%d\\n&quot;, ans[i]); return 0;&#125; K - Middle Point Graph 给一幅图，对每个顶点，在三维立方体区域 \\([0,0,0]\\sim[1,1,1]\\) 中随机一个坐标。 对每条边，定义他的坐标是连接的两个顶点的中点。这样就得到了 \\(n+m\\) 个坐标。 问这 \\(n+m\\) 个坐标中，选出四点共平面的方案数的期望。 首先得知道三维空间里随机一个平面的概率是 \\(0\\) ，因为是连续概率。所以四个点都取自原图顶点的期望是 \\(0\\) 。 所以哪些点共面其实是确定的。分讨组成情况即可。我的分讨和题解不太一样： 一条边的两顶点 + 中点 + 额外的一个点：额外的点在哪里都和一条线共面，方案数是 \\(m(n+m-3)\\) 。 三个点通过两条边相连，选择两条边终点 + 外侧的两个端点：方案数是 \\(\\sum_u \\frac{deg_u(deg_u- 1)}{2}\\) ，即每个点选两条边。 三元环三条边中点 + 某个顶点：方案数是 \\(3\\times\\) 三元环个数。 四元环的四个中点：方案数是四元环个数。 求三元环和四元环的复杂度是 \\(\\mathcal{O}(m\\sqrt m)\\) 的，科技不再赘述。 其实如果讨论情况想不全的话，可以暴力随机统计然后找规律（注释掉的代码就是赛时找规律用的）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MOD=1e9+7;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 500007// struct vec &#123;// double x, y, z;// vec operator + (const vec &amp;b) &#123;return &#123;x + b.x, y + b.y, z + b.z&#125;;&#125;// vec operator - (const vec &amp;b) &#123;return &#123;x - b.x, y - b.y, z - b.z&#125;;&#125;// vec operator / (const double &amp;b) &#123;return &#123;x / b, y / b, z / b&#125;;&#125;// &#125; p[N];// bool det(vec a, vec b, vec c) &#123;// double res = a.x * b.y * c.z +// b.x * c.y * a.z + // c.x * a.y * b.z - // a.x * c.y * b.z -// b.x * a.y * c.z - // c.x * b.y * a.z;// return abs(res) &lt;= 1e-8; // &#125;// inline double randp() &#123;// return 1.0 * rand() / RAND_MAX;// &#125;// inline void work() &#123;// int n = rd(), m = rd();// int k = n;// for (int i = 1; i &lt;= n; ++i) &#123;// p[i].x = randp();// p[i].y = randp();// p[i].z = randp();// &#125;// for (int i = 1; i &lt;= m; ++i) &#123;// int u = rd(), v = rd();// p[++n] = (p[u] + p[v]) / 2;// &#125;// int ans = 0;// for (int a = 1; a &lt;= k; ++a)// for (int b = a + 1; b &lt;= k; ++b)// for (int c = b + 1; c &lt;= n; ++c)// for (int d = c + 1; d &lt;= n; ++d) // if (det(p[b] - p[a], p[c] - p[a], p[d] - p[a])) &#123;// ++ans; printf(&quot;%d %d %d %d\\n&quot;, a, b, c, d);// &#125;// printf(&quot;%d\\n&quot;, ans);// &#125;int n,m,X[N],Y[N],d[N],ti,vis[N],cnt[N];vector&lt;int&gt; e[N],h[N];ll ans3,ans4;inline bool cmp(const int &amp;i,const int &amp;j) &#123;return d[i]&lt;d[j] || (d[i]==d[j] &amp;&amp; i&lt;j);&#125;void workz()&#123; n=rd();m=rd(); for (int i=1;i&lt;=n;i++) d[i]=0,cnt[i]=0,e[i].clear(),h[i].clear(); for (int i=1;i&lt;=m;i++)&#123; X[i]=rd();Y[i]=rd();d[X[i]]++;d[Y[i]]++; h[X[i]].push_back(Y[i]);h[Y[i]].push_back(X[i]); &#125; for (int i=1;i&lt;=m;i++) cmp(X[i],Y[i])?e[X[i]].push_back(Y[i]):e[Y[i]].push_back(X[i]); ans3=0; for (int i=1;i&lt;=m;i++)&#123; ti++;for (auto x:e[X[i]]) vis[x]=ti; for (auto x:e[Y[i]]) if (vis[x]==ti) ans3++; &#125; ans4=0; for (int x=1;x&lt;=n;x++)&#123; for (auto y:h[x]) for (auto z:e[y]) if (cmp(x,z)) ans4+=cnt[z],cnt[z]++; for (auto y:h[x]) for (auto z:e[y]) cnt[z]=0; &#125; ll ans=(ll)m*(n+m-3); for (int i=1;i&lt;=n;i++) ans+=(ll)d[i]*(d[i]-1)/2; ans+=3*ans3;ans+=ans4; printf(&quot;%lld\\n&quot;, ans%MOD);&#125;int main() &#123; for (int t = rd(); t; --t) workz(); return 0;&#125; L - Station of Fate \\(n\\) 个人分成 \\(m\\) 个可区分的非空队列的方案数。 顺序有 \\(n!\\) 种，插板法划分成 \\(m\\) 个非空序列，总方案数为 \\(n!{n-1\\choose m - 1}\\) 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 100007#define mod 998244353int fac[N], ifac[N];inline int fpow(int x, int t) &#123; int res = 1; for (; t; t &gt;&gt;= 1, x = 1ll * x * x % mod) if (t &amp; 1) res = 1ll * res * x % mod; return res;&#125;inline int C(int n, int m) &#123; return 1ll * fac[n] * ifac[m] % mod * ifac[n - m] % mod;&#125;inline void work() &#123; int n = rd(), m = rd(); printf(&quot;%lld\\n&quot;, 1ll * fac[n] * C(n - 1, m - 1) % mod);&#125;int main() &#123; fac[0] = ifac[0] = 1; for (int i = 1; i &lt; N; ++i) fac[i] = 1ll * fac[i - 1] * i % mod; ifac[N - 1] = fpow(fac[N - 1], mod - 2); for (int i = N - 2; i; --i) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % mod; for (int t = rd(); t; --t) work(); return 0;&#125;","categories":[{"name":"Official Contests","slug":"Official-Contests","permalink":"http://blog.gyx.me/categories/Official-Contests/"}],"tags":[{"name":"Geometry","slug":"Geometry","permalink":"http://blog.gyx.me/tags/Geometry/"},{"name":"Graphs","slug":"Graphs","permalink":"http://blog.gyx.me/tags/Graphs/"},{"name":"Constructive Algorithm","slug":"Constructive-Algorithm","permalink":"http://blog.gyx.me/tags/Constructive-Algorithm/"},{"name":"Probabilities","slug":"Probabilities","permalink":"http://blog.gyx.me/tags/Probabilities/"}]},{"title":"2020-2021 ICPC Asia Yinchuan Regional","slug":"official/icpc/20-yinchuan","date":"2022-11-08T16:00:00.000Z","updated":"2023-03-20T16:36:05.381Z","comments":true,"path":"official/icpc/20-yinchuan/","link":"","permalink":"http://blog.gyx.me/official/icpc/20-yinchuan/","excerpt":"","text":"Summary 比赛地址 ：Codeforces Gym 104022 待补：CFIL 难度：AEJ - GK - BDM - CFHIL A - Best Player 给定一个三维点集，问去掉哪一维之后本质不同的点最多。 模拟。map&lt;pair&lt;int, int&gt;, bool&gt; 去重。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 107int x[N], y[N], z[N];map&lt;pair&lt;int, int&gt;, bool&gt; vis;int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; x[i] = rd(); y[i] = rd(); z[i] = rd(); &#125; int X = 0, Y = 0, Z = 0; for (int i = 1; i &lt;= n; ++i) &#123; pii nw = make_pair(y[i], z[i]); if (vis[nw]) continue; vis[nw] = true; ++X; &#125; vis.clear(); for (int i = 1; i &lt;= n; ++i) &#123; pii nw = make_pair(x[i], y[i]); if (vis[nw]) continue; vis[nw] = true; ++Z; &#125; vis.clear(); for (int i = 1; i &lt;= n; ++i) &#123; pii nw = make_pair(x[i], z[i]); if (vis[nw]) continue; vis[nw] = true; ++Y; &#125; if (X &gt;= Y &amp;&amp; X &gt;= Z) puts(&quot;X&quot;); else if (Y &gt;= X &amp;&amp; Y &gt;= Z) puts(&quot;Y&quot;); else puts(&quot;Z&quot;); return 0;&#125; *B - The Great Wall 一个长度为 \\(n\\ (1\\le n\\le 10^4)\\) 的数列 \\(a_1,a_2,\\dots,a_n\\)，划分成 \\(k\\) 段，假设第 \\(i\\) 段是 \\([l_i,r_i]\\) ，最大化： \\[ \\sum_{i=1}^k\\bigg(\\max_{l_i\\le j\\le r_i} a_j-\\min_{l_i\\le j\\le r_i} a_j\\bigg) \\] 对 \\(k=1,2,\\dots,n\\) 求出答案。 Trick 题，需要转换一下。注意到 \\[ \\max_{l_i\\le j\\le r_i} a_j-\\min_{l_i\\le j\\le r_i} a_j = \\max_{l_i\\le j,k\\le r_i}\\big(a_j-a_k\\big) \\] 目标优化的方向（要求差值和最大）和差值优化方向（差值最大）相同，所以问题可以变成最大化每段内任选两个的差值和。 设 f[i][j][0/1/2/3] 表示前 \\(i\\) 个分了 \\(j\\) 段，当前一个都没选 / 只选了一个 \\(-a_k\\) / 只选了一个 \\(+a_j\\) / 两个都选了的最大和。 注意初始化为 \\(-\\infty\\) （因为 f[i][j][1] 状态可能有负值），转移要考虑 \\(j=k\\) （选在同一个数）的情况。 空间比较紧，需要把第一维滚动数组。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;template&lt;typename T&gt;inline bool getmax(T &amp;a, T b) &#123;return a &lt; b ? (a = b, true) : false;&#125;#define N 10007#define mp make_pair#define pb push_backint a[N], f[2][N][4];// 1 : - a[y]// 2 : a[x]// 3 : a[x] - a[y]int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) a[i] = rd(); memset(f, 0xcf, sizeof(f)); f[0][0][3] = 0; for (int i = 1; i &lt;= n; ++i) &#123; int nw = (i &amp; 1); int pre = 1 - nw; for (int j = 1; j &lt;= n; ++j) for (int k = 0; k &lt; 4; ++k) f[nw][j][k] = f[pre][j][k]; for (int j = 1; j &lt;= n; ++j) &#123; getmax(f[nw][j][0], f[pre][j - 1][3]); getmax(f[nw][j][1], max(f[pre][j][0], f[pre][j - 1][3]) - a[i]); getmax(f[nw][j][2], max(f[pre][j][0], f[pre][j - 1][3]) + a[i]); getmax(f[nw][j][3], max(&#123;f[pre][j - 1][3], f[pre][j][1] + a[i], f[pre][j][2] - a[i]&#125;)); &#125; &#125; for (int j = 1; j &lt;= n; ++j) printf(&quot;%d\\n&quot;, f[n &amp; 1][j][3]); return 0; &#125; *D - Farm \\(n\\ (n\\le 10^5)\\) 个点的图，有 \\(m\\ (m\\le 5\\times 10^5)\\) 条边可以选择是否加入，求连通最小代价。 此外有 \\(q\\ (q\\le 16)\\) 个要求，每个要求 \\(a_i\\) 和 \\(b_i\\) 两条边中至少有一条被加入。 先把要求涉及到的 \\(2q\\) 条边加入到图中，在此基础上跑 Kruskal ，新加入的边集称作 out 。 out 中的边一定是存在在最终答案中的。再把图清空，只加入 out 中的边，然后按照连通性缩点。 这样子顶点最多只有 \\(64\\) 个，有意义的边最多只有 \\(\\frac{64\\times 63}{2}=2016\\) 条。 然后 \\(2^q\\) 枚举每个条件至少选了哪一个，然后暴力把这些边加入，然后对这 \\(2016\\) 条边再跑 Kruskal 即可。 因为每次不用重新排序，所以复杂度是 \\(\\mathcal{O}(2^q\\times 2016+m\\log m)\\) 的，约 \\(2\\times 10^8\\) 几乎没常数。 *坑：缩点之后每条边的顶点要维护，不能用的时候再 find ，因为每次并查集不是所有点都恢复，find 会找到错误的位置。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 100007#define M 500007#define all(s) (s).begin(), (s).end()struct edge &#123;int u, v, w;&#125; e[M];vector&lt;int&gt; vertex, sel;vector&lt;edge&gt; E, out;map&lt;pair&lt;int, int&gt;, bool&gt; vis;int f[N], id[20][2];int find(int x) &#123;return x == f[x] ? x : f[x] = find(f[x]);&#125;inline bool merge(int u, int v) &#123; u = find(u); v = find(v); return u == v ? false : (f[u] = v, true);&#125;int main() &#123; int n = rd(), m = rd(); for (int i = 1; i &lt;= n; ++i) f[i] = i; for (int i = 1; i &lt;= m; ++i) &#123; int u = rd(), v = rd(), w = rd(); E.push_back(e[i] = &#123;u, v, w&#125;); &#125; sort(all(E), [&amp;](edge &amp;a, edge &amp;b)&#123;return a.w &lt; b.w;&#125;); int q = rd(), cnt = n - 1; for (int i = 0; i &lt; q; ++i) for (int j = 0; j &lt;= 1; ++j) &#123; id[i][j] = rd(); cnt -= merge(e[id[i][j]].u, e[id[i][j]].v); &#125; int add = 0; for (auto ed : E) if (merge(ed.u, ed.v)) &#123;--cnt; add += ed.w; out.push_back(ed);&#125; if (cnt) &#123;puts(&quot;-1&quot;); return 0;&#125; // not connected int ans = 1e9; for (int i = 1; i &lt;= n; ++i) f[i] = i; for (auto ed : out) merge(ed.u, ed.v); for (int i = 1; i &lt;= n; ++i) if (f[i] == i) vertex.push_back(i); for (int i = 1; i &lt;= m; ++i) &#123; e[i].u = find(e[i].u); e[i].v = find(e[i].v); &#125; for (auto ed : E) &#123; // reduction int u = find(ed.u), v = find(ed.v); if (u == v || vis[make_pair(u, v)]) continue; vis[make_pair(u, v)] = true; E[cnt++] = &#123;u, v, ed.w&#125;; &#125; E.resize(cnt); for (int i = 0; i &lt; (1 &lt;&lt; q); ++i) &#123; int tmp = 0; sel.clear(); for (auto x : vertex) f[x] = x; for (int j = 0; j &lt; q; ++j) sel.push_back(id[j][(i &gt;&gt; j) &amp; 1]); sort(all(sel)); sel.erase(unique(all(sel)), sel.end()); for (auto ID : sel) &#123;tmp += e[ID].w; merge(e[ID].u, e[ID].v);&#125; for (auto ed : E) if (merge(ed.u, ed.v)) tmp += ed.w; ans = min(ans, tmp); &#125; printf(&quot;%d\\n&quot;, ans + add); return 0;&#125; E - Isomerism 阅读理解，胖胖做的。 123456789101112131415161718192021222324252627282930313233343536#include&lt;map&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;iostream&gt;using namespace std;int te,A,B,C,D;map&lt;string,int&gt; f;void readi(int &amp;x)&#123; static string s; cin&gt;&gt;s; x=f[s];&#125;int main()&#123; f[&quot;-F&quot;]=8; f[&quot;-Cl&quot;]=7; f[&quot;-Br&quot;]=6; f[&quot;-I&quot;]=5; f[&quot;-CH3&quot;]=4; f[&quot;-CH2CH3&quot;]=3; f[&quot;-CH2CH2CH3&quot;]=2; f[&quot;-H&quot;]=1; for (scanf(&quot;%d&quot;,&amp;te);te;te--)&#123; readi(A);readi(B);readi(C);readi(D); if (A==C || B==D) puts(&quot;None&quot;); else if (A==B || A==D || B==C || C==D)&#123; if (A==B || C==D) puts(&quot;Cis&quot;); else puts(&quot;Trans&quot;); &#125; else &#123; if (A&gt;C &amp;&amp; B&gt;D || A&lt;C &amp;&amp; B&lt;D) puts(&quot;Zasamman&quot;); else puts(&quot;Entgegen&quot;); &#125; &#125; return 0;&#125; G - Photograph \\(n\\ (n\\le 10^5)\\) 个人编号 \\(1\\sim n\\) ，编号为 \\(i\\) 的人身高 \\(h_i\\) ，现在要去拍合照。 给定一个 \\(1\\sim n\\) 的排列 \\(p\\) ，代表 \\(n\\) 个人来的顺序，初始没人，第 \\(i\\) 个加入的是编号为 \\(p_i\\) 的人。 每个人加入之后，都要新拍一张照片，也就是一共会拍 \\(n\\) 张照片。 拍照片时，所有人会按照编号从小到大排列，然后定义照片的和谐度为相邻两个人身高差值的平方和。 形式化的，对于第 \\(k\\) 张照片，假设将 \\(p_1,p_2,\\dots,p_k\\) 从小到大排序后为 \\(q_1,q_2,\\dots, q_k\\) ，和谐度为 \\(\\sum_{i=1}^{k-1}(h_{q_i}-h_{q_{i+1}})^2\\) 现请你求出 \\(n\\) 张照片的和谐度之和。 接下来，\\(Q\\ (Q\\le 100)\\) 次询问，每次将序列向左 Shift \\((k+lastans)\\) 次，再求答案。 时间倒流，开始所有人都在，每次相当于把两个区间合并，链表维护。复杂度 \\(O(nQ)\\) 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define M 10007#define N 100007#define mp make_pairint h[N], p[N], l[N], r[N];set&lt;int&gt; s;int main() &#123; int n = rd(), q = rd(); for (int i = 1; i &lt;= n; ++i) h[i] = rd(); for (int i = 1; i &lt;= n; ++i) p[i] = rd(); ll ans = 0; auto sqr = [&amp;](int x) &#123;return x * x;&#125;; auto pre = [&amp;](int x) &#123;return x == 1 ? n : x - 1;&#125;; auto work = [&amp;](int x) &#123; x = pre(x); s.clear(); ans = 0; ll nw = 0; for (int i = 1; i &lt; n; ++i) &#123; l[i] = i - 1; r[i] = i + 1; nw += sqr(h[i + 1] - h[i]); &#125; l[n] = n - 1; for (int i = 1; i &lt;= n; ++i) &#123; ans += nw; int id = p[x]; if (l[id]) nw -= sqr(h[id] - h[l[id]]); if (r[id]) nw -= sqr(h[id] - h[r[id]]); if (l[id] &amp;&amp; r[id]) nw += sqr(h[l[id]] - h[r[id]]); r[l[id]] = r[id]; l[r[id]] = l[id]; x = pre(x); &#125; &#125;; int st = 1; work(st); printf(&quot;%lld\\n&quot;, ans); for (int i = 1; i &lt;= q; ++i) &#123; int k = (rd() + ans) % n; st = (st + k - 1) % n + 1; work(st); printf(&quot;%lld\\n&quot;, ans); &#125; return 0; &#125; **H - Absolute Space 构造一个大小不超过 \\(100\\) 的点集，满足对于其中任意一个点，集合中恰好都有 \\(n\\ (n\\le 10)\\) 个点与他距离为 \\(1\\) 。 首先对于 \\(n\\le 4\\) 的情况：长度为 \\(1\\) 的线段；正三角形；正四面体；正八面体； 对于 \\(n=k&gt;4\\) 的情况，很容易想到把 \\(k-1\\) 的解复制一份，使得每个点和原本的距离为 \\(1\\) ，但点数会超。 理性思考一下，这个过程其实是 \\(n=1\\) 的解和 \\(n=k-1\\) 的解的闵可夫斯基和。那换成 \\(n=x\\) 和 \\(n=k-x\\) 合并可不可以呢？ 正确性：假设 \\(A\\) 是 \\(n=k_1\\) 的解，\\(B\\) 是 \\(n=k_2\\) 的解，现在相当于证明 \\(\\forall p_a\\in A,p_b\\in B\\) ： \\[ \\sum_{a\\in A,b\\in B} [dis(a + b, p_a + p_b) = 1]=k_1+k_2 \\] 首先注意到：1. \\(a=pa\\) ，会有 \\(k_2\\) 个 \\(b\\) 符合条件；2. \\(b=pb\\) ，会有 \\(k_1\\) 个 \\(a\\) 符合条件; 且这两个情况交集为空，所以已经构成了所求的 \\(k_1+k_2\\) 个点。 对于其他情况，只需要把 \\(A\\) 或 \\(B\\) 里所有点整体沿着三个轴都随机旋转一个角度，就可以避免恰好凑出距离 \\(=1\\) 的情况。 合法性：最小化闵可夫斯基和大小 \\(=size[k-x]\\times size[x]\\) 时，所需的点数分别为：\\(12,16,24,36,64,96\\) 刚好。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define pb push_backconst double eps = 1e-4;#define z(x) (abs((x)) &lt;= eps)#define sqr(x) ((x) * (x)) #define letp const Pstruct P &#123; double x, y, z; P operator + (letp &amp;p) const &#123;return &#123;x + p.x, y + p.y, z + p.z&#125;;&#125; P operator - (letp &amp;p) const &#123;return &#123;x - p.x, y - p.y, z - p.z&#125;;&#125; bool operator == (letp &amp;p) const &#123;return x == p.x &amp;&amp; y == p.y &amp;&amp; z == p.z;&#125; P rotx(double ang) const &#123; double cosa = cos(ang), sina = sin(ang); return &#123;x, y * cosa - z * sina, y * sina + z * cosa&#125;; &#125; P roty(double ang) const &#123; double cosa = cos(ang), sina = sin(ang); return &#123;x * cosa - z * sina, y, x * sina + z * cosa&#125;; &#125; P rotz(double ang) const &#123; double cosa = cos(ang), sina = sin(ang); return &#123;x * cosa - y * sina, x * sina + y * cosa, z&#125;; &#125; inline double dis(letp &amp;p) &#123; return sqrt(sqr(x - p.x) + sqr(y - p.y) + sqr(z - p.z)); &#125;&#125;;inline bool check(vector&lt;P&gt; &amp;s, int n) &#123; for (auto x : s) &#123; int cnt = 0; for (auto y : s) &#123; if (x == y) continue; double d = x.dis(y); if (z(d)) return false; if (z(d - 1.0)) ++cnt; &#125; if (cnt != n) return false; &#125; return true;&#125;inline vector&lt;P&gt; random_rotate(vector&lt;P&gt; &amp;s) &#123; vector&lt;P&gt; res = s; double ang = 360.0 * rand() / RAND_MAX; for (auto &amp;x : res) x = x.rotx(ang); ang = 360.0 * rand() / RAND_MAX; for (auto &amp;x : res) x = x.roty(ang); ang = 360.0 * rand() / RAND_MAX; for (auto &amp;x : res) x = x.rotz(ang); return res;&#125;vector&lt;P&gt; ans[11];int main() &#123; ans[1].pb(&#123;0, 0, 0&#125;); ans[1].pb(&#123;1, 0, 0&#125;); ans[2] = ans[1]; ans[2].pb(&#123;0.5, sqrt(3) / 2, 0&#125;); ans[3] = ans[2]; ans[3].pb(&#123;0.5, sqrt(3) / 6, sqrt(6) / 3&#125;); ans[4].pb(&#123;0, 0, 0&#125;); ans[4].pb(&#123;1, 0, 0&#125;); ans[4].pb(&#123;0, 1, 0&#125;); ans[4].pb(&#123;1, 1, 0&#125;); ans[4].pb(&#123;0.5, 0.5, sqrt(2) / 2&#125;); ans[4].pb(&#123;0.5, 0.5, -sqrt(2) / 2&#125;); for (int i = 5; i &lt;= 10; ++i) &#123; int x = 1, nw = 100; for (int j = 1; j &lt; i; ++j) if (ans[j].size() * ans[i - j].size() &lt; nw) &#123; nw = ans[j].size() * ans[i - j].size(); x = j; &#125; vector&lt;P&gt; p; while (true) &#123; ans[i].clear(); p = random_rotate(ans[x]); for (auto a : p) for (auto b : ans[i - x]) ans[i].pb(a + b); if (check(ans[i], i)) break; &#125; &#125; int n = rd(); printf(&quot;%d\\n&quot;, (int)ans[n].size()); for (auto x : ans[n]) printf(&quot;%.10lf %.10lf %.10lf\\n&quot;, x.x, x.y, x.z); return 0;&#125; J - Let's Play Jigsaw Puzzles! 一个 \\(m\\times m\\) 的矩阵填入 \\(1\\sim m^2\\) ，给定每个权值的四邻接情况，恢复矩阵。 确定左上角之后 BFS 即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 1007#define mp make_pairconst int dx[4] = &#123;-1, 1, 0, 0&#125;;const int dy[4] = &#123;0, 0, -1, 1&#125;;int adj[N * N][4], ans[N][N];queue&lt;pii&gt; q;int main() &#123; int n = rd(); for (int i = 1, m = n * n; i &lt;= m; ++i) for (int j = 0; j &lt; 4; ++j) adj[i][j] = rd(); for (int i = 1, m = n * n; i &lt;= m; ++i) if (adj[i][0] == -1 &amp;&amp; adj[i][2] == -1) &#123; ans[1][1] = i; q.push(mp(1, 1)); break; &#125; while (!q.empty()) &#123; auto [x, y] = q.front(); q.pop(); int num = ans[x][y]; for (int j = 0; j &lt; 4; ++j) if (adj[num][j] != -1) &#123; int tx = x + dx[j]; int ty = y + dy[j]; if (ans[tx][ty]) continue; ans[tx][ty] = adj[num][j]; q.push(mp(tx, ty)); &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; printf(&quot;%d&quot;, ans[i][1]); for (int j = 2; j &lt;= n; ++j) printf(&quot; %d&quot;, ans[i][j]); puts(&quot;&quot;); &#125; return 0; &#125; K - Browser Games 给定 \\(n\\) 个串 \\(S_1,S_2,\\dots,S_n\\) ，对每个 \\(k=1,2,\\dots,n\\) ，问最少选多少个字符串 \\(|\\{T_i\\}|\\) ，使得： 对任意 \\(1\\le i\\le k\\) ，存在一个 \\(T_j\\) ，使得 \\(T_j\\) 是 \\(S_i\\) 的前缀 对任意 \\(k&lt; i\\le n\\) ，不存在一个 \\(T_j\\) ，使得 \\(T_j\\) 是 \\(S_i\\) 的前缀 考虑把 Trie 树建出来，然后倒着一个一个撤销。初始答案就是根结点儿子个数。 每次撤销一个串，路径上的节点以后就都不能选了，且路径上所有点的其他分支都得被覆盖过。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 50007#define mp make_pairinline int trans(char c) &#123; if (c &gt;= &#x27;a&#x27; &amp;&amp; c &lt;= &#x27;z&#x27;) return c - &#x27;a&#x27;; if (c == &#x27;.&#x27;) return 26; return 27;&#125;int tot = 1;struct node&#123;bool tag, vis; int fa, tr[28];&#125; c[3000007];int Ans;int insert(int *s, int len) &#123; int nw = 1; for (int i = 1; i &lt;= len; nw = c[nw].tr[s[i++]]) if (!c[nw].tr[s[i]]) c[c[nw].tr[s[i]] = ++tot].fa = nw; return nw;&#125;void del(int nw, int *s, int len) &#123; while (nw != 1) &#123; if (c[nw].tag) &#123;c[nw].tag = false; --Ans;&#125; // 若原本有标记则要撤销 if (!c[nw].vis) &#123; // 若第一次经过该点，则对所有其他儿子打标记 c[nw].vis = true; for (int i = 0; i &lt; 28; ++i) if (c[nw].tr[i] &amp;&amp; !c[c[nw].tr[i]].vis) &#123;++Ans; c[c[nw].tr[i]].tag = true;&#125; &#125; --len; nw = c[nw].fa; &#125;&#125;char S[N];int s[N][60], pos[N];int len[N], ans[N];int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; scanf(&quot;%s&quot;, S + 1); len[i] = strlen(S + 1); for (int j = 1; j &lt;= len[i]; ++j) s[i][j] = trans(S[j]); pos[i] = insert(s[i], len[i]); &#125; for (int i = 0; i &lt; 28; ++i) if (c[1].tr[i]) &#123;++Ans; c[c[1].tr[i]].tag = true;&#125; ans[n] = Ans; for (int i = n; i; --i) &#123; del(pos[i], s[i], len[i]); ans[i - 1] = Ans; &#125; for (int i = 1; i &lt;= n; ++i) printf(&quot;%d\\n&quot;, ans[i]); return 0; &#125; M - Tower of the Sorcerer 上取整整除分块 + 不可重 ST 表。赛后 1min 过了。","categories":[{"name":"Official Contests","slug":"Official-Contests","permalink":"http://blog.gyx.me/categories/Official-Contests/"}],"tags":[{"name":"Graphs","slug":"Graphs","permalink":"http://blog.gyx.me/tags/Graphs/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"},{"name":"Tricks","slug":"Tricks","permalink":"http://blog.gyx.me/tags/Tricks/"},{"name":"Trie","slug":"Trie","permalink":"http://blog.gyx.me/tags/Trie/"},{"name":"Minkowski Sum","slug":"Minkowski-Sum","permalink":"http://blog.gyx.me/tags/Minkowski-Sum/"}]},{"title":"2022 CCPC Weihai Site","slug":"official/ccpc/22-weihai","date":"2022-11-06T16:00:00.000Z","updated":"2023-03-20T16:35:23.427Z","comments":true,"path":"official/ccpc/22-weihai/","link":"","permalink":"http://blog.gyx.me/official/ccpc/22-weihai/","excerpt":"","text":"比赛地址 ：Codeforces Gym 104023 待补：HLM A - Duna 签到题。答案是五个位置各自的人数和那过冠军的人数的 \\(\\min\\) 。 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;#define N 10007inline int getid() &#123; static string s; static int totid; static map&lt;string, int&gt; id; cin &gt;&gt; s; if (!id[s]) id[s] = ++totid; return id[s];&#125;bool champ[N];int cnt[6], tot;int main() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= 5; ++j) champ[getid()] = true; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; int id = getid(), pos; cin &gt;&gt; pos; tot += champ[id]; cnt[pos]++; &#125; for (int i = 1; i &lt;= 5; ++i) tot = min(tot, cnt[i]); printf(&quot;%d\\n&quot;, tot); return 0;&#125; B - Recruitment 有一个长度为 \\(n\\) 的序列，初始由加号连接。每次把一个加号改成乘号，到最后全部变为乘号，一共有 \\(n\\) 个表达式。 给定 \\(n\\) 个表达式的结果 \\((s_i\\le 10^9)\\) ，构造初始序列和修改过程。 注意到最后的值就是全部的乘积，所以不是 \\(1\\) 的数字个数最多只有 \\(30\\) 个。 注意到把 \\(+1\\) 变成 \\(\\times 1\\) 会让结果变小，且此条件是充要条件，所以先把所有的 \\(1\\) 找出来，放到最后。 然后缩减数列，只会剩下 \\(30\\) 个，最后一个数就是所有的乘积，然后倒着每次尝试分解，搜索分解的树结构即可。 错误 1： \\(2+2=2\\times 2\\) 所以缩减数列的时候不能简单的判断相邻不同 错误 2： 在 auto 遍历 STL 的时候不能修改，所以不能在循环中修改数集 / 将数集传引用来 dfs 导致被修改 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first#define sc second#define mp make_pair#define pb push_back#define N 100007bool del[N];int a[N], res[N], op[N];int A, B;inline bool check(int n, int dlt) &#123; int lim = sqrt(n); for (int i = 1; i &lt;= lim; ++i) if (n % i == 0) if (n - i - n / i == dlt) &#123;A = i; B = n / i; return true;&#125; return false;&#125;int nodecnt, totlim;struct node &#123;int ls = 0, rs = 0, x = 0, tim = 0;&#125; c[N];map&lt;multiset&lt;int&gt;, bool&gt; vis;pii lim[N];bool dfs(int p, set&lt;int&gt; leaf, multiset&lt;int&gt; val) &#123; if (vis[val]) return false; set&lt;int&gt; nxtleaf = leaf; multiset&lt;int&gt; nxtval = val; vis[val] = true; if (p == totlim + 1) return true; for (auto x : leaf) &#123; if (check(c[x].x, lim[p].fr)) &#123; nxtleaf.erase(x); nxtval.erase(nxtval.lower_bound(c[x].x)); c[x].tim = lim[p].sc; c[c[x].ls = ++nodecnt].x = A; c[c[x].rs = ++nodecnt].x = B; nxtleaf.insert(nodecnt - 1); nxtleaf.insert(nodecnt); nxtval.insert(A); nxtval.insert(B); if (dfs(p + 1, nxtleaf, nxtval)) return true; nxtval.erase(nxtval.lower_bound(c[nodecnt].x)); nxtval.erase(nxtval.lower_bound(c[nodecnt - 1].x)); nxtleaf.erase(nodecnt); nxtleaf.erase(nodecnt - 1); c[x].tim = c[x].ls = c[x].rs = 0; nodecnt -= 2; nxtval.insert(c[x].x); nxtleaf.insert(x); &#125; &#125; return false;&#125;int id = 0;void build(int u) &#123; if (!c[u].ls) &#123;res[++id] = c[u].x; return;&#125; build(c[u].ls); op[c[u].tim] = id; build(c[u].rs);&#125;int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) a[i] = rd(); int tot = n, cnt1 = 0; for (int i = n - 1; i; --i) if (a[i] &gt; a[i + 1]) &#123;del[i] = true; ++cnt1; res[tot--] = 1; op[i] = tot;&#125; for (int i = 1; i &lt;= n; ++i) if (i &lt; n &amp;&amp; a[i] &gt; a[i + 1]) &#123;a[i] -= cnt1; --cnt1;&#125; else a[i] -= cnt1; c[nodecnt = 1].x = a[n]; for (int i = n - 1; i; --i) if (!del[i]) lim[++totlim] = make_pair(a[i + 1] - a[i], i); if (!dfs(1, set&lt;int&gt;&#123;1&#125;, multiset&lt;int&gt;&#123;a[n]&#125;)) &#123;puts(&quot;-1&quot;); return 0;&#125; build(1); for (int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, res[i]); puts(&quot;&quot;); for (int i = 1; i &lt; n; ++i) printf(&quot;%d\\n&quot;, op[i]); return 0;&#125; C - Grass 5 给定 \\(n\\) 个点，问能否选五个点 \\(ABCDE\\) 使得 \\(BCDE\\) 和 \\(A\\) 构成的线段两两只交在 \\(A\\) 。 玩一下发现只要不共线总能找到解，于是找到不共线的五个点之后暴力枚举答案。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first#define sc second#define mp make_pair#define pb push_back#define N 25007#define letp const Pstruct P &#123; ll x, y; P operator - (letp &amp;p) const &#123;return &#123;x - p.x, y - p.y&#125;;&#125; ll operator | (letp &amp;p) const &#123;return x * p.x + y * p.y;&#125; // dot ll operator ^ (letp &amp;p) const &#123;return x * p.y - y * p.x;&#125; // cross&#125; a[N], p[6];inline void work() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123;a[i].x = rd(); a[i].y = rd();&#125; if (n &lt;= 4) &#123;puts(&quot;NO&quot;); return;&#125; int tot = 2; p[1] = a[1]; p[2] = a[2]; bool fl = false; for (int i = 3; i &lt;= n &amp;&amp; tot &lt; 5; ++i) if (fl || tot &lt; 4) &#123; p[++tot] = a[i]; if (((p[i] - p[1]) ^ (p[2] - p[1])) != 0) fl = true; &#125; else if (((a[i] - p[1]) ^ (p[2] - p[1])) != 0) &#123; fl = true; p[++tot] = a[i]; &#125; if (tot &lt; 5) &#123;puts(&quot;NO&quot;); return;&#125; puts(&quot;YES&quot;); for (int i = 1; i &lt;= 5; ++i) &#123; bool fl = true; for (int j = 1; j &lt;= 5; ++j) if (j != i) for (int k = 1; k &lt;= 5; ++k) if (k != i &amp;&amp; k != j) if (((p[k] - p[i]) ^ (p[j] - p[i])) == 0 &amp;&amp; ((p[k] - p[i]) | (p[j] - p[i])) &gt;= 0) &#123; fl = false; break; &#125; if (fl) &#123; printf(&quot;%lld %lld\\n&quot;, p[i].x, p[i].y); for (int j = 1; j &lt;= 5; ++j) if (j != i) printf(&quot;%lld %lld\\n&quot;, p[j].x, p[j].y); return; &#125; &#125;&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; D. Sternhalma 胖胖说是签到题。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=5,maxs=1&lt;&lt;19;int te,num[maxn+5];char s[maxn+5][maxn+5];int pic[maxn+5][maxn+5],cnt,ID[maxn+5][maxn+5];int m,SA[maxs+5],f[maxs+5],si[maxs+5];int getop() &#123;char ch=getchar();while (ch!=&#x27;.&#x27; &amp;&amp; ch!=&#x27;#&#x27;) ch=getchar();return ch==&#x27;#&#x27;;&#125;void Fix(int &amp;x,int y) &#123;if (y&gt;x) x=y;&#125;int gettl(int x,int y)&#123; if (num[x]&gt;num[x-1]) return ID[x-1][y-1]; else return ID[x-1][y];&#125;int gettr(int x,int y)&#123; if (num[x]&gt;num[x-1]) return ID[x-1][y]; else return ID[x-1][y+1];&#125;int getl(int x,int y) &#123;return ID[x][y-1];&#125;int getr(int x,int y) &#123;return ID[x][y+1];&#125;int getdl(int x,int y)&#123; if (num[x]&gt;num[x+1]) return ID[x+1][y-1]; else return ID[x+1][y];&#125;int getdr(int x,int y)&#123; if (num[x]&gt;num[x+1]) return ID[x+1][y]; else return ID[x+1][y+1];&#125;inline bool cmp(const int &amp;i,const int &amp;j) &#123;return si[i]&lt;si[j] || si[i]==si[j] &amp;&amp; i&lt;j;&#125;int main()&#123; memset(ID,255,sizeof(ID)); num[1]=3;num[2]=4;num[3]=5;num[4]=4;num[5]=3; for (int i=1;i&lt;=5;i++) for (int j=1;j&lt;=num[i];j++) scanf(&quot;%d&quot;,&amp;pic[i][j]),ID[i][j]=cnt++; memset(f,192,sizeof(f)); f[0]=0; for (int i=1;i&lt;maxs;i++) SA[++m]=i,si[i]=si[i&gt;&gt;1]+(i&amp;1); sort(SA+1,SA+1+m,cmp); for (int k=1,i=SA[k];k&lt;maxs;k++,i=SA[k]) for (int x=1;x&lt;=5;x++) for (int y=1;y&lt;=num[x];y++) if (i&gt;&gt;ID[x][y]&amp;1)&#123; Fix(f[i],f[i^(1&lt;&lt;ID[x][y])]); int tl=gettl(x,y),tr=gettr(x,y); int dl=getdl(x,y),dr=getdr(x,y); int l=getl(x,y),r=getr(x,y); if (tl&gt;=0 &amp;&amp; dr&gt;=0) if ((i&gt;&gt;tl&amp;1)+(i&gt;&gt;dr&amp;1)==1) Fix(f[i],f[i^(1&lt;&lt;tl)^(1&lt;&lt;ID[x][y])^(1&lt;&lt;dr)]+pic[x][y]); if (l&gt;=0 &amp;&amp; r&gt;=0) if ((i&gt;&gt;l&amp;1)+(i&gt;&gt;r&amp;1)==1) Fix(f[i],f[i^(1&lt;&lt;l)^(1&lt;&lt;ID[x][y])^(1&lt;&lt;r)]+pic[x][y]); if (tr&gt;=0 &amp;&amp; dl&gt;=0) if ((i&gt;&gt;tr&amp;1)+(i&gt;&gt;dl&amp;1)) Fix(f[i],f[i^(1&lt;&lt;tr)^(1&lt;&lt;ID[x][y])^(1&lt;&lt;dl)]+pic[x][y]); &#125; for (scanf(&quot;%d&quot;,&amp;te);te;te--)&#123; int S=0; for (int i=1;i&lt;=5;i++) for (int j=1;j&lt;=num[i];j++) S|=getop()&lt;&lt;ID[i][j]; printf(&quot;%d\\n&quot;,f[S]); &#125; return 0;&#125; E. Python Will be Faster than C++ 签到题，发现 \\(a_{n+i} = a_n + (a_n-a_{n-1})i\\) ，然后简单分类讨论一下。 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;#define N 1000int a[N];int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i]; if (a[i] &lt; k) &#123; printf(&quot;Python 3.%d will be faster than C++\\n&quot;, i); return 0; &#125; &#125; int add = a[n] - a[n - 1]; if (add &gt;= 0) puts(&quot;Python will never be faster than C++&quot;); else &#123; k = a[n] - k; add = -add; int ans = k / add; while (ans * add &lt;= k) ++ans; printf(&quot;Python 3.%d will be faster than C++&quot;, n + ans); return 0; &#125; return 0;&#125; F. Mooncake Delivery 注意到路径中每次换颜色必定会把上一段颜色的权值全部收回，所以答案是（每一段权值+下一段起点权值）的 \\(\\max\\) 。 所以其实有两幅图，先跑一遍 floyd ，路径权值为边权的加法，得到每一段颜色相同的权值； 然后再枚举（起点 A，终点B，下一个颜色起点C）建出 A 到 C 新的边，再跑一遍 floyd ，路径权值为边权的 \\(\\max\\) 。 最后再考虑上路径最后一段颜色相同的即可。所有过程复杂度均为 \\(\\mathcal{O}(n^3)\\) 。 错误 1： 因为路径可能只有一段，所以第二幅图要设置一下自己到自己距离为 \\(0\\) 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;#define rep(i, x, y) for(int (i) = (x); (i) &lt;= (y); ++(i))#define per(i, x, y) for(int (i) = (x); (i) &gt;= (y); --(i))template&lt;typename T&gt;inline bool getmin(T &amp;a, T b) &#123;return a &gt; b ? (a = b, true) : false;&#125;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 307#define inf 4000000000000000000llbool e[N][N];int col[N], w[N];ll dis[N][N], mx[N][N], ans[N][N];inline void work() &#123; int n = rd(), m = rd(); rep(i, 1, n) rep(j, 1, n) &#123;e[i][j] = false; mx[i][j] = dis[i][j] = inf;&#125; rep(i, 1, n) col[i] = rd(); rep(i, 1, n) &#123;w[i] = rd(); mx[i][i] = dis[i][i] = 0;&#125; rep(i, 1, m) &#123; int u = rd(), v = rd(); e[u][v] = e[v][u] = true; dis[u][v] = w[v]; dis[v][u] = w[u]; &#125; // floyd for same color rep(k, 1, n) rep(u, 1, n) rep(v, 1, n) getmin(dis[u][v], dis[u][k] + dis[k][v]); rep(u, 1, n) rep(v, 1, n) dis[u][v] += w[u]; // new graph : a path of same color points + an another color point rep(u, 1, n) rep(k, 1, n) if (col[u] == col[k]) rep(v, 1, n) if (col[k] != col[v] &amp;&amp; e[k][v]) getmin(mx[u][v], dis[u][k] + w[v]); // floyd on new graph rep(k, 1, n) rep(u, 1, n) rep(v, 1, n) getmin(mx[u][v], max(mx[u][k], mx[k][v])); // consider adding a path of same color in the end rep(u, 1, n) rep(v, 1, n) &#123; ans[u][v] = mx[u][v]; rep(k, 1, n) if (col[v] == col[k]) getmin(ans[u][v], max(mx[u][k], dis[k][v])); &#125; rep(u, 1, n) &#123; rep(v, 1, n) printf(&quot;%lld &quot;, ans[u][v]); puts(&quot;&quot;); &#125;&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; G. Grade 2 给定 \\(x\\) ，多次询问 \\([l,r]\\) ，计算 \\(\\sum_{k=l}^r[\\operatorname{gcd}(k x \\oplus x, x)=1]\\) 柴老师发现循环节是 \\(2^{\\lceil \\log_2 x\\rceil}\\) ，遂暴力（做差不用讨论写法很简单）。 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 10000007ll gcd(ll a, ll b) &#123;return b ? gcd(b, a % b) : a;&#125;int sum[N];int main() &#123; int x = rd(), n = rd(); int period = 2 &lt;&lt; __lg(x); for (int i = 0; i &lt; period; ++i) sum[i] = sum[i - 1] + (gcd((1ll * i * x) ^ x, x) == 1ll); auto calc = [&amp;](ll p) &#123; return sum[period - 1] * (p / period) + sum[p % period]; &#125;; for (int i = 1; i &lt;= n; ++i) &#123; ll l = rd(), r = rd(); printf(&quot;%lld\\n&quot;, calc(r) - calc(l - 1)); &#125; return 0;&#125; I. Dragon Bloodline 胖胖做的，贪心 + 卡常。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn=50000,LOG=20;int te,n,m;LL a[maxn+5],b[LOG+5],sum;LL now[maxn+5],tem[LOG+5];int K,ID[maxn+5];inline bool cmp(const int &amp;i,const int &amp;j) &#123;return now[i]&gt;now[j] || now[i]==now[j] &amp;&amp; i&gt;j;&#125;bool check(LL mid)&#123; for (int i=0;i&lt;=LOG;i++) tem[i]=b[i]; for (int i=1;i&lt;=n;i++) now[i]=a[i]*mid; for (int j=LOG;j&gt;=0;j--)&#123; for (int i=1;i&lt;=n &amp;&amp; tem[j];i++) if (now[i]&gt;=(1LL&lt;&lt;j))&#123; LL cnt=min(now[i]&gt;&gt;j,tem[j]); now[i]-=cnt&lt;&lt;j; tem[j]-=cnt; &#125; if (!tem[j]) continue; K=0;for (int i=1;i&lt;=n;i++) if (now[i]) ID[++K]=i; if (K&lt;=tem[j]) return true; nth_element(ID+1,ID+tem[j],ID+K+1,cmp); LL lim=now[ID[tem[j]]];int y=ID[tem[j]]; // printf(&quot;[%d]\\n&quot;,tem[j]); int cnt=0; for (int i=1;i&lt;=K;i++) if (now[ID[i]]&gt;lim || now[ID[i]]==lim &amp;&amp; ID[i]&gt;=y) now[ID[i]]=0,cnt++; // printf(&quot;[%d]\\n&quot;,cnt); &#125; for (int i=1;i&lt;=n;i++) if (now[i]) return false; return true;&#125;int main()&#123; for (scanf(&quot;%d&quot;,&amp;te);te;te--)&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); LL L=0,R=0;sum=0; for (int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;a[i]),R=max(R,a[i]); for (int i=0;i&lt;=LOG;i++) b[i]=0; for (int i=0;i&lt;m;i++) scanf(&quot;%lld&quot;,&amp;b[i]),sum+=b[i]&lt;&lt;i; R=sum/R; for (LL mid=L+(R-L&gt;&gt;1);L&lt;=R;mid=L+(R-L&gt;&gt;1)) check(mid)?L=mid+1:R=mid-1; printf(&quot;%lld\\n&quot;,R); &#125; return 0;&#125; J. Eat, Sleep, Repeat 给定 \\(n\\) 个数 \\(a_1, a_2,\\dots, a_n\\) ，两人博弈每次可以让一个数字 \\(-1\\) 。 有若干限制 \\(lim_{x_i}=y_i\\) 表示集合中任意时刻 \\(x_i\\) 出现次数不能超过 \\(y_i\\) 。 无法行动（都是 \\(0\\) 或移动后必定违反限制）的人输，问结果。 注意到值域按照 \\(lim_{x_i} = 0\\) 分成了若干段（补一个 \\(\\lim_{-1}=0\\) ），对于每段考虑： 从小到大扫描每一个限制，若果存在一个 \\(x_i\\) 没有限制，那么比他大的都可以变成他；否则按照限制容纳尽可能多的数。 所以操作次数是固定的，模拟即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 100007int a[N];#define fr first#define sc second#define mp make_pair#define pb push_backvector&lt;pii&gt; lim, tmplim;vector&lt;int&gt; tmp;inline void work() &#123; lim.clear(); int n = rd(), k = rd(); for (int i = 1; i &lt;= n; ++i) a[i] = rd(); sort(a + 1, a + 1 + n); for (int i = 1; i &lt;= k; ++i) &#123; int x = rd(), y = rd(); lim.push_back(mp(x, y)); &#125; lim.push_back(mp(1000000001, 0)); sort(lim.begin(), lim.end()); int ptr = 1, den = -1, mx = 0; ll ans = 0; auto calc = [&amp;]()&#123; int id = 0; ll sum = 0, cnt = tmp.size(); for (auto x : tmp) sum += x; ll fin = 0; for (int i = den + 1, limid = tmplim.size(); i &lt;= mx; ++i, ++id) &#123; if (id &gt;= limid) &#123;fin = i; break;&#125; if (tmplim[id].fr &gt; i) &#123;fin = i; break;&#125; ll t = min(cnt, (ll)tmplim[id].sc); cnt -= t; sum -= t * i; if (!cnt) break; &#125; sum -= cnt * fin; ans += sum; tmp.clear(); tmplim.clear(); &#125;; for (auto [x, y] : lim) &#123; while (ptr &lt;= n &amp;&amp; a[ptr] &lt; x) tmp.pb(a[ptr++]); if (y == 0) &#123;mx = x - 1; calc(); den = x;&#125; else tmplim.push_back(mp(x, y)); &#125; tmplim.clear(); tmp.clear(); puts((ans &amp; 1) ? &quot;Pico&quot; : &quot;FuuFuu&quot;);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; K. I Wanna Maker 数据结构 + 数数。柴老师和胖胖做的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;set&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn=100000,maxq=maxn&lt;&lt;1;int te,n,tp[maxn+5],L[maxn+5],R[maxn+5];int lx,ly,rx,ry;LL ans;struct DATA &#123;int tp,x,y;&#125;;int Q;DATA q[maxq+5];multiset&lt;int&gt; S;inline bool cmp(const DATA &amp;a,const DATA &amp;b) &#123;return a.x&lt;b.x;&#125;int main()&#123; for (scanf(&quot;%d&quot;,&amp;te);te;te--)&#123; scanf(&quot;%d&quot;,&amp;n); bool Z=false; for (int i=1;i&lt;=n;i++)&#123; LL k,x; scanf(&quot;%d%lld%lld&quot;,&amp;tp[i],&amp;k,&amp;x); if (2*x-k*(k-1)&lt;=0)&#123; if (tp[i]==1) Z=true; else L[i]=1,R[i]=0; &#125; else &#123; L[i]=(2*x-k*(k-1))/(2*k); R[i]=(2*x+k*(k-1)+2*k-1)/(2*k); &#125; &#125; if (Z) goto zero; ly=2e9;rx=0; for (int i=1;i&lt;=n;i++) if (tp[i]==1) ly=min(ly,L[i]),rx=max(rx,R[i]); if (ly&gt;rx) goto infty; lx=1;ry=2e9; for (int i=1;i&lt;=n;i++) if (tp[i]==2 &amp;&amp; L[i]&lt;=R[i])&#123; if (ly&lt;=L[i] &amp;&amp; R[i]&lt;=rx) goto zero; if (L[i]&lt;ly &amp;&amp; R[i]&lt;=rx) lx=max(lx,L[i]+1); if (ly&lt;=L[i] &amp;&amp; R[i]&gt;rx) ry=min(ry,R[i]-1); &#125; if (lx&gt;ly || rx&gt;ry) goto zero; if (ry==2e9) goto infty; Q=0; for (int i=1;i&lt;=n;i++) if (tp[i]==2 &amp;&amp; L[i]&lt;=R[i]) if (lx&lt;=L[i] &amp;&amp; L[i]&lt;ly &amp;&amp; rx&lt;R[i] &amp;&amp; R[i]&lt;=ry) q[++Q]=&#123;1,lx,R[i]&#125;,q[++Q]=&#123;-1,L[i]+1,R[i]&#125;; ans=(LL)(ly-lx+1)*(ry-rx+1); sort(q+1,q+1+Q,cmp); S.clear(); for (int i=1,j=2;i&lt;=Q;i=j)&#123; for (j=i;j&lt;=Q &amp;&amp; q[i].x==q[j].x;j++)&#123; if (q[j].tp==1) S.insert(q[j].y); else S.erase(S.lower_bound(q[j].y)); &#125; if (!S.empty())&#123; LL lenr=ry-(*S.begin())+1; LL lenl=(j&lt;=Q?q[j].x:ly+1)-q[i].x; ans-=lenl*lenr; &#125; &#125; printf(&quot;%lld\\n&quot;,ans);continue; zero:puts(&quot;0&quot;);continue; infty:puts(&quot;-1&quot;);continue; &#125; return 0;&#125;","categories":[{"name":"Official Contests","slug":"Official-Contests","permalink":"http://blog.gyx.me/categories/Official-Contests/"}],"tags":[{"name":"Graphs","slug":"Graphs","permalink":"http://blog.gyx.me/tags/Graphs/"},{"name":"Constructive Algorithm","slug":"Constructive-Algorithm","permalink":"http://blog.gyx.me/tags/Constructive-Algorithm/"},{"name":"Counting","slug":"Counting","permalink":"http://blog.gyx.me/tags/Counting/"}]},{"title":"2018-2019 ICPC Asia Nanjing Regional","slug":"official/icpc/18-nanjing","date":"2022-11-03T16:00:00.000Z","updated":"2023-03-20T16:35:45.000Z","comments":true,"path":"official/icpc/18-nanjing/","link":"","permalink":"http://blog.gyx.me/official/icpc/18-nanjing/","excerpt":"","text":"比赛地址 ：Codeforces Gym 101981 还没补完：FHKLM A - Adrien and Austin 给定数集 \\(\\{1,\\dots, n\\}\\) ，每次只能删掉至多 \\(k\\) 个连续的数字，删空的人赢，问最终结果。 若 \\(k=1\\) 直接判解；否则奇数删掉中位数，偶数删掉两个中位数，然后对称操作，先手一定赢。 想出来放 \\(n=0\\) 的 corner case 的出题人真是人才。 12345678910#include&lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; if (n == 0) &#123;puts(&quot;Austin&quot;); return 0;&#125; if (m == 1) &#123;puts((n &amp; 1) ? &quot;Adrien&quot; : &quot;Austin&quot;); return 0;&#125; puts(&quot;Adrien&quot;); return 0;&#125; B - Tournament wqs 二分 + 凸优化。队友做过一摸一样的板子题。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#define fr first#define sc second#define mp make_pairusing namespace std;typedef long long LL;const int maxn=300000;int n,m,a[maxn+5];int que[maxn+5],l[maxn+5],r[maxn+5],p[maxn+5];LL sum[maxn+5],f[maxn+5];int g[maxn+5];#define EOLN(x) ((x)==10 || (x)==13 || (x)==EOF)inline char readc()&#123; static char buf[1&lt;&lt;16],*l=buf,*r=buf; return l==r &amp;&amp; (r=(l=buf)+fread(buf,1,1&lt;&lt;16,stdin),l==r)?EOF:*l++;&#125;template&lt;typename T&gt; int readi(T &amp;x)&#123; T tot=0;char ch=readc(),lst=&#x27;+&#x27;; while (!isdigit(ch)) &#123;if (ch==EOF) return EOF;lst=ch;ch=readc();&#125; while (isdigit(ch)) tot=(tot&lt;&lt;3)+(tot&lt;&lt;1)+(ch^48),ch=readc(); lst==&#x27;-&#x27;?x=-tot:x=tot;return EOLN(ch);&#125;inline LL Sum(int L,int R)&#123; int m=(L+R&gt;&gt;1),A=m-L+1,B=R-m; return (LL)(A-B)*a[m]-(sum[m]-sum[L-1])+(sum[R]-sum[m]);&#125;#define val(j,i) (mp(f[j]+Sum((j)+1,(i))+c,g[j]+1))bool check(LL c)&#123; f[0]=0;g[0]=0; int Head=1,Tail=0; p[++Tail]=0;l[Tail]=1;r[Tail]=n; for (int i=1;i&lt;=n;i++)&#123; pair&lt;LL,int&gt; now=val(p[Head],i); f[i]=now.fr;g[i]=now.sc; int lst=-1; while (Head&lt;=Tail) if (val(p[Tail],l[Tail])&gt;val(i,l[Tail])) lst=l[Tail--]; else &#123; int L=l[Tail],R=r[Tail]; for (int mid=L+(R-L&gt;&gt;1);L&lt;=R;mid=L+(R-L&gt;&gt;1)) val(p[Tail],mid)&gt;val(i,mid)?R=mid-1:L=mid+1; if (L&lt;=r[Tail]) lst=L,r[Tail]=L-1; break; &#125; if (~lst) p[++Tail]=i,l[Tail]=lst,r[Tail]=n; if (Head&lt;=Tail) &#123;l[Head]++;if (l[Head]&gt;r[Head]) Head++;&#125; &#125; return g[n]&lt;=m;&#125;int main()&#123; readi(n);readi(m); for (int i=1;i&lt;=n;i++) readi(a[i]),sum[i]=sum[i-1]+a[i]; LL L=0,R=3e14; for (LL mid=L+(R-L&gt;&gt;1);L&lt;=R;mid=L+(R-L&gt;&gt;1)) check(mid)?R=mid-1:L=mid+1; check(L); printf(&quot;%lld\\n&quot;,f[n]-L*m); return 0;&#125; **C - Cherry and Chocolate 给一棵树，第一个人把某个点染成粉色，第二个人把另一个点染成棕色，第一个人再把另另一个点染成粉色。 定义树的权值为符合下述描述的节点 \\(u\\) 的个数：从 \\(u\\) 到棕色点的路径上经过某个粉色点。 第一个人想最大化权值，第二个人想最小化权值，问最终树的权值。 我们称第一个粉色点为 \\(x\\) ，棕色点为 \\(y\\) ，第二个粉色点为 \\(z\\) 。 我们以第一个人的视角，假设 \\(x,y\\) 已经确定，那么令 \\(x\\) 为根，所有子树里除掉 \\(y\\) 所在的子树以外的全部的点都已经被赚到了。 所以 \\(z\\) 一定会放在 \\(y\\) 所在的子树中。把这个子树拎成以 \\(y\\) 为根， \\(z\\) 能赚回来的是某个子树大小，因此一定选 \\(y\\) 的某个儿子。 因此如果 \\(y\\) 所在的子树已经选定，为了让 \\(z\\) 捞回去的点数最少， \\(y\\) 一定会选在这个子树的重心上。 所以 \\(y\\) 捞回来的值是 \\(sz[\\text{子树}]-mxs[\\text{重心}]\\) ，会把 \\(y\\) 选在使得这个权值最大的子树的重心上。 这样就可以 \\(\\mathcal{O}(n)\\) 检查一个选定的 \\(x\\) 之后最终树的权值了。 那么考虑现在我们已经有了一个方案 \\((x,y,z)\\) ，那么把 \\(x\\) 朝远离 \\(y\\) 的方向移动不会使答案变优。 因此每次需检查的范围都是当前 \\(x\\) 的某个子树，那么每次都选这个范围的重心，就只需要检查 \\(\\mathcal{O}(\\log n)\\) 次。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;inline bool getmin(int &amp;a, int b) &#123;return a &gt; b ? (a = b, true) : false;&#125;inline bool getmax(int &amp;a, int b) &#123;return a &lt; b ? (a = b, true) : false;&#125;#define N 100007bool tag[N]; // [tag[u] = true] : should be tested to be the first pink pointint sz[N], mxs[N];vector&lt;int&gt; e[N];int n, rt, tot, mn;void getcentre(int u, int fa) &#123; sz[u] = 1; mxs[u] = 0; for (auto v : e[u]) if (tag[v] &amp;&amp; v != fa) &#123;getcentre(v, u); sz[u] += sz[v]; mxs[u] = max(mxs[u], sz[v]);&#125; mxs[u] = max(mxs[u], tot - sz[u]); mn = min(mn, mxs[u]);&#125;vector&lt;int&gt; subtree[N];void getsz(int u, int fa, int top) &#123; sz[u] = 1; mxs[u] = 0; subtree[top].push_back(u); for (auto v : e[u]) if (v != fa) &#123;getsz(v, u, top); sz[u] += sz[v]; mxs[u] = max(mxs[u], sz[v]);&#125;&#125;int main() &#123; n = tot = rd(); for (int i = 1; i &lt;= n; ++i) tag[i] = true; for (int i = 1; i &lt; n; ++i) &#123; int u = rd(), v = rd(); e[u].push_back(v); e[v].push_back(u); &#125; int ans = 0; for (rt = 1; tag[rt]; ) &#123; // find the centre mn = 1e9; getcentre(rt, rt); for (int u = 1; u &lt;= n; ++u) if (tag[u] &amp;&amp; mxs[u] == mn) &#123;rt = u; break;&#125; tag[rt] = false; --tot; // find the best brown point in the initial tree // i.e. find a subtree whose centre maximize |subtree| - mxs[centre] int res = n, pos = rt; for (auto u : e[rt]) &#123; subtree[u].clear(); getsz(u, rt, u); int bst = u; for (auto v : subtree[u]) mxs[v] = max(mxs[v], sz[u] - sz[v]); for (auto v : subtree[u]) if (mxs[v] &lt; mxs[bst]) bst = v; int cur = n - sz[u] + mxs[bst]; if (getmin(res, cur)) pos = u; &#125; ans = max(ans, res); for (auto u : e[rt]) if (u != pos) for (auto v : subtree[u]) if (tag[v]) &#123;tag[v] = false; --tot;&#125; rt = pos; &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125; D - Country Meow 求最小球覆盖的半径。 板子题。换一换估价函数类似的题目也可以考虑三分套三分套三分。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;bits/stdc++.h&gt;using namespace std;int n, cnt, i;double R, tmp;const double eps = 1e-5;struct P &#123; double x, y, z; P()&#123;&#125; P(double _x, double _y, double _z) &#123;x = _x; y = _y; z = _z;&#125; P operator + (const P &amp;b) &#123;return P(x + b.x, y + b.y, z + b.z);&#125; P operator - (const P &amp;b) &#123;return P(x - b.x, y - b.y, z - b.z);&#125; P operator * (double b) &#123;return P(x * b, y * b, z * b);&#125; P operator / (double b) &#123;return P(x / b, y / b, z / b);&#125;&#125; a[200007], b[4], O;double dis(const P &amp;a, const P &amp;b) &#123; return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y) + (a.z - b.z) * (a.z - b.z);&#125;double dot(const P &amp;a, const P &amp;b) &#123; return a.x * b.x + a.y * b.y + a.z * b.z;&#125;void ball() &#123; P q[3]; double m[3][3], f[3], L[3], det; int i, j; O.x = O.y = O.z = R = 0; switch(cnt) &#123; case 1 : O = b[0]; break; case 2 : O = (b[0] + b[1]) / 2; R = dis(O, b[0]); break; case 3 : for (i = 0; i &lt; 2; ++i) q[i] = b[i + 1] - b[0]; for (i = 0; i &lt; 2; ++i) for (j = 0; j &lt; 2; ++j) m[i][j] = dot(q[i], q[j]) * 2; for (i = 0; i &lt; 2; ++i) f[i] = dot(q[i], q[i]); if (fabs(det = m[0][0] * m[1][1] - m[0][1] * m[1][0]) &lt; eps) return; L[0] = (f[0] * m[1][1] - f[1] * m[0][1]) / det; L[1] = (f[1] * m[0][0] - f[0] * m[1][0]) / det; O = b[0] + q[0] * L[0] + q[1] * L[1]; R = dis(O, b[0]); break; case 4 : for (i = 0; i &lt; 3; ++i) q[i] = b[i + 1] - b[0 ], f[i] = dot(q[i], q[i]); for (i = 0; i &lt; 3; ++i) for (j = 0; j &lt; 3; ++j) m[i][j] = dot(q[i], q[j]) * 2; det = m[0][0] * m[1][1] * m[2][2] + m[0][1] * m[1][2] * m[2][0] + m[0][2] * m[2][1] * m[1][0] - m[0][2] * m[1][1] * m[2][0] - m[0][1] * m[1][0] * m[2][2] - m[0][0] * m[1][2] * m[2][1]; if (fabs(det) &lt; eps) return; for (j = 0; j &lt; 3; ++j) &#123; for (i = 0; i &lt; 3; ++i) m[i][j] = f[i]; L[j] = (m[0][0] * m[1][1] * m[2][2] + m[0][1] * m[1][2] * m[2][0] + m[0][2] * m[2][1] * m[1][0] - m[0][2] * m[1][1] * m[2][0] - m[0][1] * m[1][0] * m[2][2] - m[0][0] * m[1][2] * m[2][1]) / det; for (i = 0; i &lt; 3; ++i) m[i][j] = dot(q[i], q[j]) * 2; &#125; O = b[0]; for (i = 0; i &lt; 3; ++i) O = O + q[i] * L[i]; R = dis(O, b[0]); &#125;&#125;void minball(int n) &#123; ball(); if (cnt &lt; 4) for (int i = 0; i &lt; n; ++i) if (dis(O, a[i]) - R &gt; eps) &#123; b[cnt++] = a[i]; minball(i); --cnt; if (i &gt; 0) &#123; P t = a[i]; memmove(&amp;a[1], &amp;a[0], sizeof(P) * i); a[0] = t; &#125; &#125;&#125;int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; ++i) scanf(&quot;%lf%lf%lf&quot;, &amp;a[i].x, &amp;a[i].y, &amp;a[i].z); random_shuffle(a, a + n); R = -1; for (i = 0; i &lt; n; ++i) &#123; if (dis(O, a[i]) - R &gt; eps) cnt = 1, b[0] = a[i], minball(i); //printf(&quot;%.12lf %.12lf %.12lf %.12lf\\n&quot;, O.x, O.y, O.z, R); &#125; printf(&quot;%.12lf\\n&quot;, sqrt(R)); return 0;&#125; *E - Eva and Euro coins 给定两个 \\(01\\) 序列 \\(A,B\\) ，每次可以把 \\(A\\) 中连续 \\(k\\) 个相同的位置一起翻转，问是否能把 \\(A\\) 变成 \\(B\\) 。 手玩一下发现：对于 \\(k\\) 个 \\(x=0/1\\) , \\(xx\\dots xxy\\) 和 \\(y x x\\dots x\\) 一定是可以互相转换的。 换言之， \\(k\\) 个相同的字符可以在序列里任意移动，而且与具体是 \\(0/1\\) 无关。 所以把尽可能多的 \\(k\\) 个连续相同的扔掉，看剩下的是否相同即可。用栈维护（字符，个数）即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 1000007#define fr first#define sc second#define pci pair&lt;char, int&gt;int na, nb;pci a[N], b[N];int main() &#123; int n = rd(), k = rd(); if (k == 1) &#123;puts(&quot;Yes&quot;); return 0;&#125; for (int i = 1; i &lt;= n; ++i) &#123; char c = getchar(); while (!isdigit(c)) c = getchar(); if (na &amp;&amp; a[na].fr == c) &#123; ++a[na].sc; if (a[na].sc == k) --na; &#125; else a[++na] = mp(c, 1); &#125; for (int i = 1; i &lt;= n; ++i) &#123; char c = getchar(); while (!isdigit(c)) c = getchar(); if (nb &amp;&amp; b[nb].fr == c) &#123; ++b[nb].sc; if (b[nb].sc == k) --nb; &#125; else b[++nb] = mp(c, 1); &#125; if (na != nb) &#123;puts(&quot;No&quot;); return 0;&#125; for (int i = 1; i &lt;= na; ++i) if (a[i] != b[i]) &#123;puts(&quot;No&quot;); return 0;&#125; puts(&quot;Yes&quot;); return 0;&#125; **F - Frank DAG 随机游走。 队友切了 貌似是 \\(O(n^2)\\) 支持修改一个方程并求解方程组。 一个相关套路题：连接1 G - Pyramid 打表插值/找规律/推式子，柴老师推出来是 \\({n+3\\choose 4}\\) 。 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define mod 1000000007#define inv24 41666667int main()&#123; for (int t = rd(); t; --t) &#123; int n = rd(); printf(&quot;%lld\\n&quot;, 1ll * (n + 3) * (n + 2) % mod * (n + 1) % mod * n % mod * inv24 % mod); &#125; return 0;&#125; *H - Huge Discount I - Magic Potion 最大流板子题。药水当作另一个源点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;inline bool getmin(int &amp;a, int b) &#123;return (a &gt; b ? (a = b, true) : false);&#125;inline bool getmax(int &amp;a, int b) &#123;return (a &lt; b ? (a = b, true) : false);&#125;// F is the type of flowtemplate&lt;const int V, const int E, class F, const F flowInf&gt;struct Flow &#123; int tot = 1, S, T, hd[V], cur[V], dis[V]; struct edge&#123;int to, nxt; F cap;&#125; e[E &lt;&lt; 1]; void clear() &#123;tot = 1; memset(hd, 0, sizeof(hd));&#125; void add(int u, int v, F w) &#123; e[++tot].nxt = hd[u], hd[u] = tot, e[tot].to = v, e[tot].cap = w; e[++tot].nxt = hd[v], hd[v] = tot, e[tot].to = u, e[tot].cap = 0; &#125; inline bool bfs() &#123; static int q[V], qhd, qtl; memcpy(cur, hd, sizeof(hd)); memset(dis, -1, sizeof(dis)); q[qhd = qtl = 1] = S; dis[S] = 0; while (qhd &lt;= qtl) &#123; int u = q[qhd++]; for (int i = hd[u], v; i; i = e[i].nxt) if (dis[v = e[i].to] == -1 &amp;&amp; e[i].cap != 0) &#123; dis[v] = dis[u] + 1; q[++qtl] = v; &#125; &#125; return dis[T] != -1; &#125; F dfs(int u, F rem) &#123; if (u == T) return rem; F flow = 0; for (int i = cur[u], v; i &amp;&amp; rem; i = e[i].nxt) &#123; cur[u] = i; v = e[i].to; F nw = min(rem, e[i].cap); if (nw != 0 &amp;&amp; dis[v] == dis[u] + 1) &#123; int ret = dfs(v, nw); flow += ret; rem -= ret; e[i].cap -= ret; e[i ^ 1].cap += ret; &#125; &#125; if (flow == 0) dis[u] = -1; return flow; &#125; F dinic(int source, int sink) &#123; S = source; T = sink; F flow = 0; while (bfs()) flow += dfs(S, flowInf); return flow; &#125;&#125;;constexpr int N = 1007;constexpr int M = 100007;constexpr int inf = 1e9;Flow&lt;N, M, int, inf&gt; f;int main()&#123; int n = rd(), m = rd(), k = rd(); int S = 0, T = N - 1, P = N - 2; f.add(S, P, k); for (int i = 1; i &lt;= m; ++i) f.add(i + n, T, 1); for (int i = 1; i &lt;= n; ++i) &#123; f.add(S, i, 1); f.add(P, i, 1); for (int j = rd(); j; --j) f.add(i, rd() + n, 1); &#125; printf(&quot;%d\\n&quot;, f.dinic(S, T)); return 0;&#125; J - Prime Game 给定一个数列，定义一个区间的权值为区间所有数的乘积的质因子集大小，求所有区间权值和。 对每个质数计算，用总区间数减掉不包含这个质数的区间数，复杂度 \\(\\mathcal{O}(n\\log(\\max a_i))\\) 。分解质因数用线性筛出 mindiv 。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;cstdio&gt;#include&lt;cctype&gt;using namespace std;typedef long long LL;const int maxn=1000000;int n,a[maxn+5];LL ans;int p[maxn+5],D[maxn+5];bool pri[maxn+5];int lst[maxn+5];#define EOLN(x) ((x)==10 || (x)==13 || (x)==EOF)inline char readc()&#123; static char buf[1&lt;&lt;16],*l=buf,*r=buf; return l==r &amp;&amp; (r=(l=buf)+fread(buf,1,1&lt;&lt;16,stdin),l==r)?EOF:*l++;&#125;template&lt;typename T&gt; int readi(T &amp;x)&#123; T tot=0;char ch=readc(),lst=&#x27;+&#x27;; while (!isdigit(ch)) &#123;if (ch==EOF) return EOF;lst=ch;ch=readc();&#125; while (isdigit(ch)) tot=(tot&lt;&lt;3)+(tot&lt;&lt;1)+(ch^48),ch=readc(); lst==&#x27;-&#x27;?x=-tot:x=tot;return EOLN(ch);&#125;void Make(int n)&#123; for (int i=2;i&lt;=n;i++)&#123; if (!pri[i]) p[++p[0]]=i,D[i]=i; for (int j=1,t;j&lt;=p[0] &amp;&amp; (t=i*p[j])&lt;=n;j++) &#123;pri[t]=true;D[t]=p[j];if (!(i%p[j])) break;&#125; &#125;&#125;int main()&#123; readi(n);Make(maxn); ans=(LL)n*(n+1)/2*p[0]; for (int i=1,x;i&lt;=n;i++)&#123; readi(x); for (int d=D[x];x&gt;1;x/=d,d=D[x])&#123; int len=i-lst[d]-1; ans-=(LL)len*(len+1)/2; lst[d]=i; &#125; &#125; for (int i=1;i&lt;=p[0];i++)&#123; int len=n-lst[p[i]]; ans-=(LL)len*(len+1)/2; &#125; printf(&quot;%lld\\n&quot;,ans); return 0;&#125; K - Kangaroo Puzzle 给一个 \\(20\\times 20\\) 的网格图，每个位置是袋鼠/墙，保证袋鼠联通，构造一个LURD序列使得所有的袋鼠走到一起。 网格太小想一想随机可过，输出 \\(50000\\) 个随机字符就过了。正解是考虑每次合并两个袋鼠，合在一起的肯定不会再分开了。 *L - Lagrange the Chef M - Mediocre String Problem Z 函数 + manacher。","categories":[{"name":"Official Contests","slug":"Official-Contests","permalink":"http://blog.gyx.me/categories/Official-Contests/"}],"tags":[{"name":"String","slug":"String","permalink":"http://blog.gyx.me/tags/String/"},{"name":"Number Theory","slug":"Number-Theory","permalink":"http://blog.gyx.me/tags/Number-Theory/"},{"name":"Divide and Conquer","slug":"Divide-and-Conquer","permalink":"http://blog.gyx.me/tags/Divide-and-Conquer/"}]},{"title":"2019-2020 ICPC Asia Hong Kong Regional","slug":"official/icpc/19-hongkong","date":"2022-10-28T16:00:00.000Z","updated":"2023-03-20T16:35:49.967Z","comments":true,"path":"official/icpc/19-hongkong/","link":"","permalink":"http://blog.gyx.me/official/icpc/19-hongkong/","excerpt":"","text":"比赛地址 ：Codeforces Gym 102452 *A - Axis of Symmetry 给若干面积无交的矩形，求整个图案的所有对称轴。 把线段该连的都连起来，图形内部的线段都删掉。然后判断每个线段是否对称。写了个屎山代码非常垃圾。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef tuple&lt;int, int, int&gt; tii;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;int gcd(int a, int b) &#123;return b ? gcd(b, a % b) : a;&#125;typedef double T;#define let const auto#define lett const T#define letp const P // P for point#define letl const L // L for lineconst T eps = 1e-5;#define z(x) (abs((x)) &lt;= eps) // is zero inline int roundint(double x) &#123; int y = ceil(x); for (int i = y - 2; i &lt;= y + 2; ++i) if (z(x - i)) return i; return 2e9;&#125; struct P &#123; T x, y; P (T x = 0, T y = 0) : x(x), y(y) &#123;&#125; P operator + (letp &amp;p) const &#123;return &#123;x + p.x, y + p.y&#125;;&#125; P operator - (letp &amp;p) const &#123;return &#123;x - p.x, y - p.y&#125;;&#125; P operator * (lett &amp;d) const &#123;return &#123;x * d, y * d&#125;;&#125; P operator / (lett &amp;d) const &#123;return &#123;x / d, y / d&#125;;&#125; P operator - () const &#123;return &#123;-x, -y&#125;;&#125; T operator | (letp &amp;p) const &#123;return x * p.x + y * p.y;&#125; // dot T operator ^ (letp &amp;p) const &#123;return x * p.y - y * p.x;&#125; // cross T norm() const &#123;return x * x + y * y;&#125; P proj (letp &amp;p) const &#123;return (*this) * (((*this) | p) / norm());&#125; P refl (letp &amp;p) const &#123;return proj(p) * 2 - p;&#125;&#125; zero;double abs(letp &amp;p) &#123;return sqrt(p.norm());&#125;P perp(letp &amp;p) &#123;return &#123;-p.y, p.x&#125;;&#125; // turn pi / 2 left(counterclockwise) struct L &#123; P p, v; L shiftl(double d) const &#123;return &#123;p + perp(v) * d / abs(v), v&#125;;&#125; P proj(letp &amp;a) const &#123;return p + v.proj(a - p);&#125; P refl(letp &amp;a) const &#123;return p + v.refl(a - p);&#125; double dis(letp &amp;a) const &#123;return (v ^ (a - p)) / abs(v);&#125; &#125;;#define N 100007vector&lt;P&gt; Pt;map&lt;int, multiset&lt;pii&gt;&gt; H, V;bool check1(L l) &#123; for (auto [x, S] : V) &#123; for (auto [y1, y2] : S) &#123; P p1 = l.refl(P&#123;1.0 * x, 1.0 * y1&#125;), p2 = l.refl(P&#123;1.0 * x, 1.0 * y2&#125;); int tx = roundint(p1.x), ty1 = roundint(p1.y), ty2 = roundint(p2.y); if (ty1 &gt; ty2) swap(ty1, ty2); if (V[tx].count(make_pair(ty1, ty2)) == 0) return false; &#125; &#125; for (auto [y, S] : H) &#123; for (auto [x1, x2] : S) &#123; P p1 = l.refl(P&#123;1.0 * x1, 1.0 * y&#125;), p2 = l.refl(P&#123;1.0 * x2, 1.0 * y&#125;); int ty = roundint(p1.y), tx1 = roundint(p1.x), tx2 = roundint(p2.x); if (tx1 &gt; tx2) swap(tx1, tx2); if (H[ty].count(make_pair(tx1, tx2)) == 0) return false; &#125; &#125; return true;&#125;bool check2(L l) &#123; for (auto [x, S] : V) &#123; for (auto [y1, y2] : S) &#123; P p1 = l.refl(P&#123;1.0 * x, 1.0 * y1&#125;), p2 = l.refl(P&#123;1.0 * x, 1.0 * y2&#125;); int ty = roundint(p1.y), tx1 = roundint(p1.x), tx2 = roundint(p2.x); if (tx1 &gt; tx2) swap(tx1, tx2); if (H[ty].count(make_pair(tx1, tx2)) == 0) return false; &#125; &#125; for (auto [y, S] : H) &#123; for (auto [x1, x2] : S) &#123; P p1 = l.refl(P&#123;1.0 * x1, 1.0 * y&#125;), p2 = l.refl(P&#123;1.0 * x2, 1.0 * y&#125;); int tx = roundint(p1.x), ty1 = roundint(p1.y), ty2 = roundint(p2.y); if (ty1 &gt; ty2) swap(ty1, ty2); if (V[tx].count(make_pair(ty1, ty2)) == 0) return false; &#125; &#125; return true;&#125;inline void work() &#123; H.clear(); V.clear(); Pt.clear(); int n = rd(); int mxx = -1e9, mxy = -1e9, mnx = 1e9, mny = 1e9; for (int i = 1; i &lt;= n; ++i) &#123; int x1 = rd(), y1 = rd(), x2 = rd(), y2 = rd(); Pt.push_back(P&#123;1.0 * x1, 1.0 * y1&#125;); Pt.push_back(P&#123;1.0 * x1, 1.0 * y2&#125;); Pt.push_back(P&#123;1.0 * x2, 1.0 * y1&#125;); Pt.push_back(P&#123;1.0 * x2, 1.0 * y2&#125;); mxx = max(mxx, x2); mnx = min(mnx, x1); mxy = max(mxy, y2); mny = min(mny, y1); V[x1].insert(make_pair(y1, y2)); V[x2].insert(make_pair(y1, y2)); H[y1].insert(make_pair(x1, x2)); H[y2].insert(make_pair(x1, x2)); &#125; // connect segments multiset&lt;pii&gt; tmp; tmp.clear(); for (auto &amp;[x, S] : V) &#123; int R = -1e9; for (auto [l, r] : S) &#123; if (tmp.empty() || l &gt; R) tmp.insert(make_pair(l, r)); else &#123; auto [l1, r1] = *--tmp.end(); tmp.erase(--tmp.end()); int l2 = l, r2 = r; if (r1 == l2) tmp.insert(make_pair(l1, r2)); else &#123; if (l1 != l2) tmp.insert(make_pair(min(l1, l2), max(l1, l2))); if (r1 != r2) tmp.insert(make_pair(min(r1, r2), max(r1, r2))); &#125; &#125; R = max(R, r); &#125; swap(S, tmp); tmp.clear(); &#125; for (auto &amp;[y, S] : H) &#123; int R = -1e9; for (auto [l, r] : S) &#123; if (tmp.empty() || l &gt; R) tmp.insert(make_pair(l, r)); else &#123; auto [l1, r1] = *--tmp.end(); tmp.erase(--tmp.end()); int l2 = l, r2 = r; if (r1 == l2) tmp.insert(make_pair(l1, r2)); else &#123; if (l1 != l2) tmp.insert(make_pair(min(l1, l2), max(l1, l2))); if (r1 != r2) tmp.insert(make_pair(min(r1, r2), max(r1, r2))); &#125; &#125; R = max(R, r); &#125; swap(S, tmp); tmp.clear(); &#125; vector&lt;tii&gt; ans; ans.clear(); // y = midy if (check1(L&#123;&#123;0, (mxy + mny) / 2.0&#125;,&#123;1, 0&#125;&#125;)) &#123; int a = 0, b = 2, c = mny + mxy; int g = gcd(gcd(abs(a), abs(b)), abs(c)); a /= g; b /= g; c /= g; tii res = max(make_tuple(a, b, c), make_tuple(-a, -b, -c)); ans.push_back(res); &#125; // x = midx if (check1(L&#123;&#123;(mxx + mnx) / 2.0, 0&#125;,&#123;0, 1&#125;&#125;)) &#123; int a = 2, b = 0, c = mnx + mxx; int g = gcd(gcd(abs(a), abs(b)), abs(c)); a /= g; b /= g; c /= g; tii res = max(make_tuple(a, b, c), make_tuple(-a, -b, -c)); ans.push_back(res); &#125; // &quot;/&quot; L l1&#123;&#123;0, 0&#125;, &#123;1, 1&#125;&#125;; double mxd = -1e18, mnd = 1e18; for (auto p : Pt) &#123; double d = l1.dis(p); mxd = max(mxd, d); mnd = min(mnd, d); &#125; l1 = l1.shiftl((mxd + mnd) / 2.0); if (check2(l1)) &#123; int a = roundint(2 * l1.v.y); int b = roundint(-2 * l1.v.x); int c = roundint(2 * (l1.p.x * l1.v.y - l1.p.y * l1.v.x)); int g = gcd(gcd(abs(a), abs(b)), abs(c)); a /= g; b /= g; c /= g; tii res = max(make_tuple(a, b, c), make_tuple(-a, -b, -c)); ans.push_back(res); &#125; // &quot;\\&quot; l1 = L&#123;&#123;0, 0&#125;, &#123;1, -1&#125;&#125;; mxd = -1e18, mnd = 1e18; for (auto p : Pt) &#123; double d = l1.dis(p); mxd = max(mxd, d); mnd = min(mnd, d); &#125; l1 = l1.shiftl((mxd + mnd) / 2.0); // 平移到最远点对中间 if (check2(l1)) &#123; int a = roundint(2 * l1.v.y); int b = roundint(-2 * l1.v.x); int c = roundint(2 * (l1.p.x * l1.v.y - l1.p.y * l1.v.x)); int g = gcd(gcd(abs(a), abs(b)), abs(c)); a /= g; b /= g; c /= g; tii res = max(make_tuple(a, b, c), make_tuple(-a, -b, -c)); ans.push_back(res); &#125; printf(&quot;%d\\n&quot;, (int)ans.size()); sort(ans.begin(), ans.end()); reverse(ans.begin(), ans.end()); for (auto [a, b, c] : ans) printf(&quot;%d %d %d &quot;, a, b, c); puts(&quot;&quot;);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; 针对这个题，因为都是边界平行于对称轴的图形之间的对称，所以对称轴必过 \\((\\frac{mnx+mxx}{2},\\frac{mny+mxy}{2})\\) ，找直线好找很多。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef tuple&lt;int, int, int&gt; tii;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;int gcd(int a, int b) &#123;return b ? gcd(b, a % b) : a;&#125;typedef double T;#define let const auto#define lett const T#define letp const P // P for point#define letl const L // L for lineconst T eps = 1e-5;#define z(x) (abs((x)) &lt;= eps) // is zero inline int roundint(double x) &#123; int y = ceil(x); if (z(y - 1 - x)) return y - 1; return (z(y - x) ? y : y + 1);&#125; struct P &#123; T x, y; P (T x = 0, T y = 0) : x(x), y(y) &#123;&#125; P operator + (letp &amp;p) const &#123;return &#123;x + p.x, y + p.y&#125;;&#125; P operator - (letp &amp;p) const &#123;return &#123;x - p.x, y - p.y&#125;;&#125; P operator * (lett &amp;d) const &#123;return &#123;x * d, y * d&#125;;&#125; P operator / (lett &amp;d) const &#123;return &#123;x / d, y / d&#125;;&#125; P operator - () const &#123;return &#123;-x, -y&#125;;&#125; T operator | (letp &amp;p) const &#123;return x * p.x + y * p.y;&#125; // dot T operator ^ (letp &amp;p) const &#123;return x * p.y - y * p.x;&#125; // cross T norm() const &#123;return x * x + y * y;&#125; P proj (letp &amp;p) const &#123;return (*this) * (((*this) | p) / norm());&#125; P refl (letp &amp;p) const &#123;return proj(p) * 2 - p;&#125;&#125; zero;struct L &#123; P p, v; P proj(letp &amp;a) const &#123;return p + v.proj(a - p);&#125; P refl(letp &amp;a) const &#123;return p + v.refl(a - p);&#125; &#125;;map&lt;int, multiset&lt;pii&gt;&gt; H, V;bool check1(L l) &#123; // H &lt;-&gt; H, V &lt;-&gt; V for (auto [x, S] : V) &#123; for (auto [y1, y2] : S) &#123; P p1 = l.refl(P&#123;1.0 * x, 1.0 * y1&#125;), p2 = l.refl(P&#123;1.0 * x, 1.0 * y2&#125;); int tx = roundint(p1.x), ty1 = roundint(p1.y), ty2 = roundint(p2.y); if (ty1 &gt; ty2) swap(ty1, ty2); if (V[tx].count(make_pair(ty1, ty2)) == 0) return false; &#125; &#125; for (auto [y, S] : H) &#123; for (auto [x1, x2] : S) &#123; P p1 = l.refl(P&#123;1.0 * x1, 1.0 * y&#125;), p2 = l.refl(P&#123;1.0 * x2, 1.0 * y&#125;); int ty = roundint(p1.y), tx1 = roundint(p1.x), tx2 = roundint(p2.x); if (tx1 &gt; tx2) swap(tx1, tx2); if (H[ty].count(make_pair(tx1, tx2)) == 0) return false; &#125; &#125; return true;&#125;bool check2(L l) &#123; // H &lt;-&gt; V for (auto [x, S] : V) &#123; for (auto [y1, y2] : S) &#123; P p1 = l.refl(P&#123;1.0 * x, 1.0 * y1&#125;), p2 = l.refl(P&#123;1.0 * x, 1.0 * y2&#125;); int ty = roundint(p1.y), tx1 = roundint(p1.x), tx2 = roundint(p2.x); if (tx1 &gt; tx2) swap(tx1, tx2); if (H[ty].count(make_pair(tx1, tx2)) == 0) return false; &#125; &#125; for (auto [y, S] : H) &#123; for (auto [x1, x2] : S) &#123; P p1 = l.refl(P&#123;1.0 * x1, 1.0 * y&#125;), p2 = l.refl(P&#123;1.0 * x2, 1.0 * y&#125;); int tx = roundint(p1.x), ty1 = roundint(p1.y), ty2 = roundint(p2.y); if (ty1 &gt; ty2) swap(ty1, ty2); if (V[tx].count(make_pair(ty1, ty2)) == 0) return false; &#125; &#125; return true;&#125;inline void work() &#123; H.clear(); V.clear(); int n = rd(); int mxx = -1e9, mxy = -1e9, mnx = 1e9, mny = 1e9; for (int i = 1; i &lt;= n; ++i) &#123; int x1 = rd(), y1 = rd(), x2 = rd(), y2 = rd(); mxx = max(mxx, x2); mnx = min(mnx, x1); mxy = max(mxy, y2); mny = min(mny, y1); V[x1].insert(make_pair(y1, y2)); V[x2].insert(make_pair(y1, y2)); H[y1].insert(make_pair(x1, x2)); H[y2].insert(make_pair(x1, x2)); &#125; multiset&lt;pii&gt; tmp; tmp.clear(); for (auto &amp;[x, S] : V) &#123; int R = -1e9; for (auto [l, r] : S) &#123; if (tmp.empty() || l &gt; R) tmp.insert(make_pair(l, r)); else &#123; auto [l1, r1] = *--tmp.end(); tmp.erase(--tmp.end()); int l2 = l, r2 = r; if (r1 == l2) tmp.insert(make_pair(l1, r2)); // connect segments else &#123; // remove the intersection if (l1 != l2) tmp.insert(make_pair(min(l1, l2), max(l1, l2))); if (r1 != r2) tmp.insert(make_pair(min(r1, r2), max(r1, r2))); &#125; &#125; R = max(R, r); &#125; swap(S, tmp); tmp.clear(); &#125; for (auto &amp;[y, S] : H) &#123; int R = -1e9; for (auto [l, r] : S) &#123; if (tmp.empty() || l &gt; R) tmp.insert(make_pair(l, r)); else &#123; auto [l1, r1] = *--tmp.end(); tmp.erase(--tmp.end()); int l2 = l, r2 = r; if (r1 == l2) tmp.insert(make_pair(l1, r2)); // connect segments else &#123; // remove the intersection if (l1 != l2) tmp.insert(make_pair(min(l1, l2), max(l1, l2))); if (r1 != r2) tmp.insert(make_pair(min(r1, r2), max(r1, r2))); &#125; &#125; R = max(R, r); &#125; swap(S, tmp); tmp.clear(); &#125; vector&lt;tii&gt; ans; ans.clear(); // y = midy if (check1(L&#123;&#123;0, (mxy + mny) / 2.0&#125;,&#123;1, 0&#125;&#125;)) &#123; int a = 0, b = 2, c = mny + mxy; int g = gcd(gcd(abs(a), abs(b)), abs(c)); a /= g; b /= g; c /= g; tii res = max(make_tuple(a, b, c), make_tuple(-a, -b, -c)); ans.push_back(res); &#125; // x = midx if (check1(L&#123;&#123;(mxx + mnx) / 2.0, 0&#125;,&#123;0, 1&#125;&#125;)) &#123; int a = 2, b = 0, c = mnx + mxx; int g = gcd(gcd(abs(a), abs(b)), abs(c)); a /= g; b /= g; c /= g; tii res = max(make_tuple(a, b, c), make_tuple(-a, -b, -c)); ans.push_back(res); &#125; // &quot;/&quot; L l1&#123;&#123;(mxx + mnx) / 2.0, (mxy + mny) / 2.0&#125;, &#123;1, 1&#125;&#125;; if (check2(l1)) &#123; int a = roundint(2 * l1.v.y); int b = roundint(-2 * l1.v.x); int c = roundint(2 * (l1.p.x * l1.v.y - l1.p.y * l1.v.x)); int g = gcd(gcd(abs(a), abs(b)), abs(c)); a /= g; b /= g; c /= g; tii res = max(make_tuple(a, b, c), make_tuple(-a, -b, -c)); ans.push_back(res); &#125; // &quot;\\&quot; l1 = L&#123;&#123;(mxx + mnx) / 2.0, (mxy + mny) / 2.0&#125;, &#123;1, -1&#125;&#125;; if (check2(l1)) &#123; int a = roundint(2 * l1.v.y); int b = roundint(-2 * l1.v.x); int c = roundint(2 * (l1.p.x * l1.v.y - l1.p.y * l1.v.x)); int g = gcd(gcd(abs(a), abs(b)), abs(c)); a /= g; b /= g; c /= g; tii res = max(make_tuple(a, b, c), make_tuple(-a, -b, -c)); ans.push_back(res); &#125; printf(&quot;%d\\n&quot;, (int)ans.size()); sort(ans.begin(), ans.end()); reverse(ans.begin(), ans.end()); for (auto [a, b, c] : ans) printf(&quot;%d %d %d &quot;, a, b, c); puts(&quot;&quot;);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; 看了下比较短的代码，发现都是用边界上所有拐点的对称性来判断的。边界上拐点就是只出现过一次的矩形顶点 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef tuple&lt;int, int, int&gt; tii;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;int gcd(int a, int b) &#123;return b ? gcd(b, a % b) : a;&#125;typedef double T;#define let const auto#define lett const T#define letp const P // P for point#define letl const L // L for lineconst T eps = 1e-5;#define z(x) (abs((x)) &lt;= eps) // is zero inline int roundint(double x) &#123; int y = ceil(x); for (int i = y - 1; i &lt;= y + 1; ++i) if (z(x - i)) return i; return 2e9;&#125; struct P &#123; T x, y; P (T x = 0, T y = 0) : x(x), y(y) &#123;&#125; P operator + (letp &amp;p) const &#123;return &#123;x + p.x, y + p.y&#125;;&#125; P operator - (letp &amp;p) const &#123;return &#123;x - p.x, y - p.y&#125;;&#125; P operator * (lett &amp;d) const &#123;return &#123;x * d, y * d&#125;;&#125; P operator / (lett &amp;d) const &#123;return &#123;x / d, y / d&#125;;&#125; P operator - () const &#123;return &#123;-x, -y&#125;;&#125; T operator | (letp &amp;p) const &#123;return x * p.x + y * p.y;&#125; // dot T operator ^ (letp &amp;p) const &#123;return x * p.y - y * p.x;&#125; // cross bool operator == (letp &amp;p) const &#123;return z(x - p.x) &amp;&amp; z(y - p.y);&#125; bool operator != (letp &amp;p) const &#123;return ! operator == (p);&#125; bool operator &lt; (letp &amp;p) const &#123;return z(x - p.x) ? y &lt; p.y : x &lt; p.x;&#125; bool operator &gt; (letp &amp;p) const &#123;return !(*this &lt; p || *this == p);&#125; T norm() const &#123;return x * x + y * y;&#125; P proj (letp &amp;p) const &#123;return (*this) * (((*this) | p) / norm());&#125; P refl (letp &amp;p) const &#123;return proj(p) * 2 - p;&#125;&#125; zero;struct L &#123; P p, v; P proj(letp &amp;a) const &#123;return p + v.proj(a - p);&#125; P refl(letp &amp;a) const &#123;return p + v.refl(a - p);&#125; &#125;;set&lt;P&gt; s;vector&lt;tii&gt; ans; inline void work() &#123; s.clear(); ans.clear(); int n = rd(), mxx = -1e9, mxy = -1e9, mnx = 1e9, mny = 1e9; auto add = [&amp;](int x, int y) &#123; P nw = P&#123;1.0 * x, 1.0 * y&#125;; if (s.count(nw)) s.erase(nw); else s.insert(nw); &#125;; for (int i = 1; i &lt;= n; ++i) &#123; int x1 = rd(), y1 = rd(), x2 = rd(), y2 = rd(); add(x1, y1); add(x1, y2); add(x2, y1); add(x2, y2); mxx = max(mxx, x2); mnx = min(mnx, x1); mxy = max(mxy, y2); mny = min(mny, y1); &#125; auto check = [&amp;](L l) &#123; for (auto p : s) if (s.count(l.refl(p)) == 0) return false; return true; &#125;; auto addans = [&amp;](int a, int b, int c) &#123; int g = gcd(gcd(abs(a), abs(b)), abs(c)); a /= g; b /= g; c /= g; tii res = max(make_tuple(a, b, c), make_tuple(-a, -b, -c)); ans.push_back(res); &#125;; // y = midy if (check(L&#123;&#123;0, (mxy + mny) / 2.0&#125;,&#123;1, 0&#125;&#125;)) addans(0, 2, mny + mxy); // x = midx if (check(L&#123;&#123;(mxx + mnx) / 2.0, 0&#125;,&#123;0, 1&#125;&#125;)) addans(2, 0, mnx + mxx); // &quot;/&quot; L l1&#123;&#123;(mxx + mnx) / 2.0, (mxy + mny) / 2.0&#125;, &#123;1, 1&#125;&#125;; if (check(l1)) addans(roundint(2 * l1.v.y), roundint(-2 * l1.v.x), roundint(2 * (l1.p.x * l1.v.y - l1.p.y * l1.v.x))); // &quot;\\&quot; l1 = L&#123;&#123;(mxx + mnx) / 2.0, (mxy + mny) / 2.0&#125;, &#123;1, -1&#125;&#125;; if (check(l1)) addans(roundint(2 * l1.v.y), roundint(-2 * l1.v.x), roundint(2 * (l1.p.x * l1.v.y - l1.p.y * l1.v.x))); printf(&quot;%d\\n&quot;, (int)ans.size()); sort(ans.begin(), ans.end()); reverse(ans.begin(), ans.end()); for (auto [a, b, c] : ans) printf(&quot;%d %d %d &quot;, a, b, c); puts(&quot;&quot;);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; B - Binary Tree 给定一棵树，轮流删掉一个满二叉子树，问谁赢。 注意到满二叉树的点数总是奇数，所以答案只和总节点数的奇偶性有关。 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;inline void work() &#123; int x = rd(); puts((x &amp; 1) ? &quot;Alice&quot; : &quot;Bob&quot;); for (int i = 1; i &lt; x; ++i) &#123;rd(); rd();&#125;&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; C - Constructing Ranches 胖胖说是点分治板子题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#define fr first#define sc second#define mp make_pairusing namespace std;typedef long long LL;const int maxn=200000,maxt=maxn&lt;&lt;1,LOG=17;int te,n,a[maxn+5];LL sum[maxn+5],dis[maxn+5],ans;int E,lnk[maxn+5],nxt[(maxn&lt;&lt;1)+5],to[(maxn&lt;&lt;1)+5];int fa[maxn+5],dep[maxn+5],SH[maxn+5],top[maxn+5];int lt[maxn+5],ST[LOG+1][maxn+5],lg[maxn+5];int gr,S,si[maxn+5],ms[maxn+5];bool vis[maxn+5];int m;pair&lt;int,LL&gt; p[maxn+5];LL c[maxt+5];int tr[maxt+5];#define EOLN(x) ((x)==10 || (x)==13 || (x)==EOF)inline char readc()&#123; static char buf[1&lt;&lt;16],*l=buf,*r=buf; return l==r &amp;&amp; (r=(l=buf)+fread(buf,1,1&lt;&lt;16,stdin),l==r)?EOF:*l++;&#125;template&lt;typename T&gt; int readi(T &amp;x)&#123; T tot=0;char ch=readc(),lst=&#x27;+&#x27;; while (!isdigit(ch)) &#123;if (ch==EOF) return EOF;lst=ch;ch=readc();&#125; while (isdigit(ch)) tot=(tot&lt;&lt;3)+(tot&lt;&lt;1)+(ch^48),ch=readc(); lst==&#x27;-&#x27;?x=-tot:x=tot;return EOLN(ch);&#125;inline void Add(int x,int y) &#123;to[++E]=y;nxt[E]=lnk[x];lnk[x]=E;&#125;void DFS(int x,int pre=0)&#123; si[x]=1;SH[x]=0;fa[x]=pre;dep[x]=dep[pre]+1; for (int j=lnk[x];j;j=nxt[j]) if (to[j]!=pre)&#123; DFS(to[j],x);si[x]+=si[to[j]]; if (si[to[j]]&gt;si[SH[x]]) SH[x]=to[j]; &#125;&#125;void HLD(int x,int lst,int pre=0)&#123; lt[x]=++lt[0];ST[0][lt[0]]=a[x];top[x]=lst; if (SH[x]) HLD(SH[x],lst,x); for (int j=lnk[x];j;j=nxt[j]) if (to[j]!=pre &amp;&amp; to[j]!=SH[x]) HLD(to[j],to[j],x);&#125;int Max(int L,int R) &#123;int k=lg[R-L+1];return max(ST[k][L],ST[k][R-(1&lt;&lt;k)+1]);&#125;void getgr(int x,int pre=0)&#123; si[x]=1;ms[x]=0; for (int j=lnk[x],u;j;j=nxt[j]) if ((u=to[j])!=pre &amp;&amp; !vis[u])&#123; getgr(u,x);si[x]+=si[u]; ms[x]=max(ms[x],si[u]); &#125; ms[x]=max(ms[x],S-si[x]); if (!gr || ms[x]&lt;ms[gr]) gr=x;&#125;pair&lt;int,LL&gt; Ask(int x,int y)&#123; int MAX=0;LL S=0; while (top[x]!=top[y])&#123; if (dep[top[x]]&lt;dep[top[y]]) swap(x,y); MAX=max(MAX,Max(lt[top[x]],lt[x])); S+=sum[lt[x]]-sum[lt[top[x]]-1]; x=fa[top[x]]; &#125; if (lt[x]&gt;lt[y]) swap(x,y); MAX=max(MAX,Max(lt[x],lt[y])); S+=sum[lt[y]]-sum[lt[x]-1]; return mp(MAX,S);&#125;void getpair(int x,int fa,int pre=0)&#123; p[++m]=Ask(x,fa); for (int j=lnk[x],u;j;j=nxt[j]) if ((u=to[j])!=pre &amp;&amp; !vis[u]) getpair(to[j],fa,x);&#125;int Find(LL x)&#123; int L=1,R=c[0]; for (int mid=L+(R-L&gt;&gt;1);L&lt;=R;mid=L+(R-L&gt;&gt;1)) x&lt;=c[mid]?R=mid-1:L=mid+1; return L;&#125;void Insert(int x,int y) &#123;for (;x&lt;=c[0];x+=x&amp;-x) tr[x]+=y;&#125;int Sum(int x) &#123;int sum=0;for (;x;x-=x&amp;-x) sum+=tr[x];return sum;&#125;void Count(int x,int fa,int f)&#123; m=0;getpair(x,fa); sort(p+1,p+1+m);c[0]=0; for (int i=1;i&lt;=m;i++) c[++c[0]]=(p[i].fr&lt;&lt;1)-p[i].sc,c[++c[0]]=p[i].sc-a[fa]; sort(c+1,c+1+c[0]);c[0]=unique(c+1,c+1+c[0])-(c+1); for (int i=1;i&lt;=c[0];i++) tr[i]=0; for (int i=1;i&lt;=m;i++)&#123; LL A=c[0]-Find((p[i].fr&lt;&lt;1)-p[i].sc)+1,B=c[0]-Find(p[i].sc-a[fa])+1; ans+=f*Sum(A-1);Insert(B,1); &#125;&#125;void Divide(int x)&#123; vis[x]=true;Count(x,x,1); for (int j=lnk[x],u;j;j=nxt[j]) if (!vis[u=to[j]])&#123; Count(u,x,-1); gr=0;S=si[u];getgr(u);Divide(gr); &#125;&#125;int main()&#123; for (int i=2;i&lt;=maxn;i++) lg[i]=lg[i&gt;&gt;1]+1; for (readi(te);te;te--)&#123; readi(n);for (int i=1;i&lt;=n;i++) readi(a[i]); E=0;for (int i=1;i&lt;=n;i++) lnk[i]=0; for (int i=1,x,y;i&lt;n;i++) readi(x),readi(y),Add(x,y),Add(y,x); DFS(1);lt[0]=0;HLD(1,1); for (int j=1;(1&lt;&lt;j)&lt;=n;j++) for (int i=1;i+(1&lt;&lt;j)-1&lt;=n;i++) ST[j][i]=max(ST[j-1][i],ST[j-1][i+(1&lt;&lt;j-1)]); for (int i=1;i&lt;=n;i++) sum[i]=sum[i-1]+ST[0][i]; for (int i=1;i&lt;=n;i++) vis[i]=false; ans=0;gr=0;S=n;getgr(1);Divide(gr); printf(&quot;%lld\\n&quot;,ans); &#125; return 0;&#125; D - Defining Labels 找 \\(k\\) 进制下的第 \\(X\\) 小数。 12345678910111213141516171819#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int maxl=100000;int te,K,n,a[maxl+5];int main()&#123; for (scanf(&quot;%d&quot;,&amp;te);te;te--)&#123; scanf(&quot;%d%d&quot;,&amp;K,&amp;n); LL pw=K,len=1; while (n&gt;pw) n-=pw,pw*=K,len++; n--; for (int i=0;i&lt;len;i++) a[i]=n%K,n/=K; for (int i=len-1;~i;i--) putchar(a[i]+10-K+48);puts(&quot;&quot;); &#125; return 0;&#125; *E - Erasing Numbers 给定长度为 \\(n\\) 的数列 \\(a_1,a_2,\\dots,a_n\\) ，保证 \\(n\\) 是奇数，\\(a_i\\) 两两不同，每次操作选择相邻的三个数，保留中位数。 最后一定只会剩下一个数字。对于每个 \\(a_i\\) ，询问是否存在一种操作顺序，使得最后剩下的数字是他。 又是奇怪的贪心题。首先如果一个数是中位数，那么它肯定能被留下来。 比如当前考虑的是 \\(x\\) ，令比 \\(x\\) 大的为 \\(1\\) ，比 \\(x\\) 小的为 \\(0\\) ，那么肯定有某一类会多出来。 以 \\(x\\) 为断点将序列分成两段，每一段尽可能消除多的那一类即可（连续 \\(3\\) 个即可少 \\(2\\) 个）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;inline bool getmin(int &amp;a, int b) &#123;return (a &gt; b ? (a = b, true) : false);&#125;inline bool getmax(int &amp;a, int b) &#123;return (a &lt; b ? (a = b, true) : false);&#125;#define N 5007int a[N], b[N];inline int getmax(int l, int r, int tar) &#123; int cnt = 0, sum = 0; for (int i = l; i &lt;= r; ++i) &#123; if (b[i] == tar) &#123; if (cnt) --cnt; else sum += tar; &#125; else &#123; ++cnt; if (cnt &gt;= 3) cnt -= 2; &#125; &#125; return -tar * cnt + sum;&#125;inline void work() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) a[i] = rd(); for (int i = 1; i &lt;= n; ++i) &#123; int sum = 0; for (int j = 1; j &lt;= n; ++j) if (j != i) &#123; b[j] = (a[j] &gt; a[i] ? 1 : -1); sum += b[j]; &#125; if (sum == 0) &#123;putchar(&#x27;1&#x27;); continue;&#125; else &#123; if (sum &gt; 0 &amp;&amp; getmax(1, i - 1, -1) + getmax(i + 1, n, -1) &lt;= 0) &#123;putchar(&#x27;1&#x27;); continue;&#125; if (sum &lt; 0 &amp;&amp; getmax(1, i - 1, 1) + getmax(i + 1, n, 1) &gt;= 0) &#123;putchar(&#x27;1&#x27;); continue;&#125; &#125; putchar(&#x27;0&#x27;); &#125; puts(&quot;&quot;);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; F - Falling Objects 三维计算几何大模拟。 G - Game Design 小清新构造，满足叶子权值 \\(=1\\) ，父节点权值 \\(=\\prod\\) 儿子权值 \\(+1\\) ，根节点给定。 每次分奇偶讨论即可，偶数一个儿子，奇数两个儿子 \\(2\\) 和 \\(x/2\\) ，这样只有 \\(\\log n\\) 个点。 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 200007int tot, fa[N], son[N];int build(int k, int faa) &#123; int u = ++tot; fa[u] = faa; --k; if (k == 0) &#123;son[u] = 1; return u;&#125; if (k &amp; 1) son[u] = son[build(k, u)]; else &#123; son[u] += son[build(2, u)]; son[u] += son[build(k / 2, u)]; &#125; return u;&#125;int main() &#123; int k = rd(); if (k == 1) &#123;puts(&quot;2\\n1\\n1 2&quot;); return 0;&#125; build(k, 0); printf(&quot;%d\\n&quot;, tot); for (int i = 2; i &lt;= tot; ++i) printf(&quot;%d &quot;, fa[i]); puts(&quot;&quot;); for (int i = 1; i &lt;= tot; ++i) printf(&quot;%d &quot;, son[i]); return 0;&#125; H - Hold the Line 胖胖补的，貌似是把大常数双 log 改小常数双 log。链接 **I - Incoming Asteroids 有 \\(n\\) 个集合，强制在线，支持 \\(m\\) 个操作： 申请一个新的 ID，初始权值是 \\(0\\) ，目标值是 \\(y_i\\) ，将 ID 加入给出的 \\(k\\ (k\\le 3)\\) 个集合。 对某个集合中的 ID，令他们的权值增加 \\(w_i\\) 。报告第一次达到目标的人数。 神奇的暴力。考虑一个需求被分成了 \\(k\\) 份，如果要被达到，总有一份要达到总量\\(/k\\) 。 因此在每个插入的集合里都放上一个提醒，如果增量达到了需求，就把所有集合的提醒都撤销，然后重新分 \\(k\\) 份塞进去。 每次提醒当前剩余的需求最多剩下原来的 \\(\\frac{k-1}{k}\\) ，所以复杂度是 \\(\\mathcal{O}(m\\log_{\\frac{k}{k+1}} y_i)\\) ，当 \\(k=3\\) 时可以接受。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first#define sc second#define mp make_pair#define mt make_tuple#define pb push_back#define pii pair&lt;int, int&gt;#define tii tuple&lt;int, int, int&gt;#define all(s) (s).begin(), (s).end()#define N 200007set&lt;pii&gt; s[N];vector&lt;pii&gt; a[N];vector&lt;int&gt; ans, pos;ll need[N], val[N];inline void reset(int id) &#123; pos.clear(); for (auto [w, p] : a[id]) &#123;s[p].erase(mp(w, id)); pos.pb(p);&#125; a[id].clear(); ll nw = 0; for (auto p : pos) nw += val[p]; if (nw &gt;= need[id]) &#123;ans.pb(id); return;&#125; ll w = max(1ull, (need[id] - nw) / pos.size()); for (auto p : pos) &#123; s[p].insert(mp(val[p] + w, id)); a[id].pb(mp(val[p] + w, p)); &#125;&#125; int main() &#123; int n = rd(), m = rd(); int id = 0, lst = 0; for (int i = 1; i &lt;= m; ++i) &#123; int op = rd(); if (op == 1) &#123; need[++id] = rd() ^ lst; int k = rd(); ll w = max(1ll, need[id] / k); for (int p; k; --k) &#123; need[id] += val[p = rd() ^ lst]; s[p].insert(mp(val[p] + w, id)); a[id].pb(mp(val[p] + w, p)); &#125; &#125; else &#123; int x = rd() ^ lst; val[x] += rd() ^ lst; ans.clear(); while (!s[x].empty() &amp;&amp; val[x] &gt;= s[x].begin() -&gt; fr) reset(s[x].begin() -&gt; sc); printf(&quot;%d&quot;, lst = ans.size()); sort(all(ans)); for (auto i : ans) printf(&quot; %d&quot;, i); puts(&quot;&quot;); &#125; &#125; return 0;&#125; J - Junior Mathematician 胖胖说是数位dp板子题。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn=5000,maxk=60,MOD=1e9+7;int te,K,pw[maxn+5];char L[maxn+5],R[maxn+5];int n,a[maxn+5],f[maxn+5][maxk+5][maxk+5][2],ans;inline int ADD(int x,int y) &#123;return x+y&gt;=MOD?x+y-MOD:x+y;&#125;inline int MUL(int x,int y) &#123;return (LL)x*y%MOD;&#125;void DP(int tp)&#123; for (int i=0;i&lt;=n;i++) for (int j=0;j&lt;K;j++) for (int k=0;k&lt;K;k++) f[i][j][k][0]=f[i][j][k][1]=0; f[0][a[0]%K][(K-a[0]*pw[n]%K)%K][1]++; for (int i=0;i&lt;a[0];i++) f[0][i%K][(K-i*pw[n]%K)%K][0]++; for (int i=1;i&lt;=n;i++) for (int j=0;j&lt;K;j++) for (int k=0,F;k&lt;K;k++)&#123; if (F=f[i-1][j][k][0]) for (int t=0;t&lt;10;t++)&#123; int A=(j+t)%K,B=(k+j*t+K-t*pw[n-i]%K)%K; f[i][A][B][0]=ADD(f[i][A][B][0],F); &#125; if (F=f[i-1][j][k][1])&#123; for (int t=0;t&lt;a[i];t++)&#123; int A=(j+t)%K,B=(k+j*t+K-t*pw[n-i]%K)%K; f[i][A][B][0]=ADD(f[i][A][B][0],F); &#125; int A=(j+a[i])%K,B=(k+j*a[i]+K-a[i]*pw[n-i]%K)%K; f[i][A][B][1]=ADD(f[i][A][B][1],F); &#125; &#125; for (int i=0;i&lt;K;i++) ans=ADD(ans,MUL(tp,ADD(f[n][i][0][0],f[n][i][0][1])));&#125;int main()&#123; for (scanf(&quot;%d&quot;,&amp;te);te;te--)&#123; scanf(&quot;%s%s%d&quot;,L,R,&amp;K);n=strlen(R); pw[0]=1;for (int i=1;i&lt;=n;i++) pw[i]=(pw[i-1]*10)%K; n=strlen(L)-1;for (int i=0;i&lt;=n;i++) a[i]=L[i]-&#x27;0&#x27;; reverse(a,a+n+1);a[0]--; for (int i=0;i&lt;=n &amp;&amp; a[i]&lt;0;i++) a[i]+=10,a[i+1]--; while (n&gt;0 &amp;&amp; !a[n]) n--; reverse(a,a+n+1); ans=0; DP(MOD-1); n=strlen(R)-1;for (int i=0;i&lt;=n;i++) a[i]=R[i]-&#x27;0&#x27;; DP(1); printf(&quot;%d\\n&quot;,ans); &#125; return 0;&#125; *K - Key Project 有 \\(n\\ (n\\le 800)\\) 栋楼排成一列，给出相邻两个楼的距离。 有 \\(m\\ (m\\le 50000)\\) 个 A 类人，\\(m\\) 个 B 类人，每个人有两个参数 \\(x,c\\) ，代表位于第 \\(x\\) 栋楼中，聘请的代价是 \\(c\\) 。 称一对人包括一个 A 类人一个 B 类人，代价是聘请他们的代价和 + 他们之间的距离。 现在要聘请 \\(k\\) 对人，代价是聘请每一对的代价之和，求最小代价。对 \\(k=1\\dots m\\) 。 对 \\(k=1\\dots m\\) 即每次考虑新增一对，这提示我们考虑费用流。 为每个建筑建一个点，相邻建筑之间连容量无穷，代价为距离的边。 对于每个 A 类人，连 \\(S\\to x_i\\) ，容量为 \\(1\\) ，代价为 \\(c_i\\) ；对于 B 类人就和 \\(T\\) 以同样的方式相连。 问题变成每次增广流量为 \\(1\\) 的流。直接做 EK 复杂度比较高。 考虑模拟费用流，单次增广复杂度降低到 \\(O(n)\\) 。 因为每次增广的流量只有 \\(1\\) ，所以： 每个点只需要考虑它拥有的最小代价的 A 类人和 B 类人 。用堆维护。 每条边只需要考虑 \\(1\\) 流量时的最小代价，优先考虑退流的负代价边即可。 对每个方向求出来代价的前缀和，那么选择一对点的代价可以拆分成两个位置独立的贡献。 然后扫一遍就可以求出来答案了，注意答案有 A 左 B 右、B 左 A 右两种情况。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i, x, y) for(int i = (x); i &lt;= (y); ++i)#define per(i, x, y) for(int i = (x); i &gt;= (y); --i)template&lt;typename T&gt;inline bool getmin(T &amp;a, T b) &#123;return a &gt; b ? (a = b, true) : false;&#125;template&lt;typename T&gt;inline bool getmax(T &amp;a, T b) &#123;return a &lt; b ? (a = b, true) : false;&#125;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 807#define inf 1e18/*1. lr[i] : the number of backflow unit from i - 1 to i cost for [(i - 1) -&gt; i] = (lr[i] &gt; 0 ? -d[i] : d[i]);2. rl[i] : the number of backflow unit from i to i - 1 cost for [i -&gt; (i - 1)] = (rl[i] &gt; 0 ? -d[i] : d[i]);*/int d[N], lr[N], rl[N], mnA[N], mnB[N];ll cstlr[N], cstrl[N];priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; A[N], B[N];int main() &#123; int n = rd(), m = rd(); rep(i, 2, n) d[i] = rd(); rep(i, 1, m) &#123;int p = rd(); A[p].push(rd());&#125; rep(i, 1, m) &#123;int p = rd(); B[p].push(rd());&#125; /* cost from l to r : (mnA[L] - cstlr[L]) + (mnB[R] + cstlr[R]) cost from r to l : (mnB[L] - cstrl[L]) + (mnA[R] + cstrl[R]) */ ll ans = 0; rep(t, 1, m) &#123; rep(i, 1, n) &#123; // [mnx[i] = 0] : person of type x dosen&#x27;t exist mnA[i] = (A[i].empty() ? 0 : A[i].top()); mnB[i] = (B[i].empty() ? 0 : B[i].top()); &#125; rep(i, 2, n) &#123; cstlr[i] = cstlr[i - 1] + (lr[i] ? -d[i] : d[i]); cstrl[i] = cstrl[i - 1] + (rl[i] ? -d[i] : d[i]); &#125; ll cst = inf; int pA = 0, pB = 0, Al = 0, Bl = 0; rep(i, 1, n) &#123; if (mnA[i] &amp;&amp; (!Al || mnA[Al] - cstlr[Al] &gt; mnA[i] - cstlr[i])) Al = i; if (mnB[i] &amp;&amp; (!Bl || mnB[Bl] - cstrl[Bl] &gt; mnB[i] - cstrl[i])) Bl = i; if (Al &amp;&amp; mnB[i] &amp;&amp; getmin(cst, mnA[Al] - cstlr[Al] + mnB[i] + cstlr[i])) &#123;pA = Al; pB = i;&#125; if (Bl &amp;&amp; mnA[i] &amp;&amp; getmin(cst, mnB[Bl] - cstrl[Bl] + mnA[i] + cstrl[i])) &#123;pA = i; pB = Bl;&#125; &#125; ans += cst; printf(&quot;%lld\\n&quot;, ans); A[pA].pop(); B[pB].pop(); if (pA &lt; pB) rep(i, pA + 1, pB) lr[i] &gt; 0 ? --lr[i] : ++rl[i]; else rep(i, pB + 1, pA) rl[i] &gt; 0 ? --rl[i] : ++lr[i]; &#125; return 0;&#125;","categories":[{"name":"Official Contests","slug":"Official-Contests","permalink":"http://blog.gyx.me/categories/Official-Contests/"}],"tags":[{"name":"Geometry","slug":"Geometry","permalink":"http://blog.gyx.me/tags/Geometry/"},{"name":"Greedy","slug":"Greedy","permalink":"http://blog.gyx.me/tags/Greedy/"},{"name":"Segment Tree","slug":"Segment-Tree","permalink":"http://blog.gyx.me/tags/Segment-Tree/"},{"name":"Tricks","slug":"Tricks","permalink":"http://blog.gyx.me/tags/Tricks/"},{"name":"Flows","slug":"Flows","permalink":"http://blog.gyx.me/tags/Flows/"},{"name":"Divide and Conquer","slug":"Divide-and-Conquer","permalink":"http://blog.gyx.me/tags/Divide-and-Conquer/"}]},{"title":"2019 ICPC World Finals","slug":"official/icpc/19-world-finals","date":"2022-10-20T16:00:00.000Z","updated":"2023-03-20T16:36:00.467Z","comments":true,"path":"official/icpc/19-world-finals/","link":"","permalink":"http://blog.gyx.me/official/icpc/19-world-finals/","excerpt":"","text":"比赛地址 ：Codeforces Gym 102511 A - Azulejos 两排雕像，每排 \\(n\\) 个，每个雕像都有一个高度 \\(h_i\\) 和权值 \\(w_i\\) 。 对每排重新排序，使得：1. 每排 \\(w_i\\) 从左到右严格降序；2. 第一排的每个位置的雕像都比第二排对应位置的高。 贪心，先按照 \\(w_i\\) 从大到小排序，显然只有相同权值之间的可以有位置变动。 从左到右依次考虑，每次都扩展一个相同权值的区间，然后用右端点更小的区间里的雕像去匹配右端点更大的区间里的雕像。 这样子我们的需求都是在必须满足的时候满足的，并且已经考虑到了所有的情况。合理使用 STL 即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define mp make_pair#define mt make_tuple#define pb push_back#define pii pair&lt;int, int&gt;#define tii tuple&lt;int, int, int&gt;#define N 500007int p[N], ansb[N], anss[N];tii b[N], s[N];set&lt;pii&gt; B, S;int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) p[i] = rd(); for (int i = 1; i &lt;= n; ++i) b[i] = mt(p[i], rd(), i); sort(b + 1, b + 1 + n); for (int i = 1; i &lt;= n; ++i) p[i] = rd(); for (int i = 1; i &lt;= n; ++i) s[i] = mt(p[i], rd(), i); sort(s + 1, s + 1 + n); int tot = 0; for (int ptrs = 0, ptrb = 0; ptrs &lt; n || ptrb &lt; n;) &#123; if (ptrs &gt; ptrb) &#123; ++ptrb; B.insert(mp(get&lt;1&gt;(b[ptrb]), get&lt;2&gt;(b[ptrb]))); while (ptrb &lt; n &amp;&amp; get&lt;0&gt;(b[ptrb]) == get&lt;0&gt;(b[ptrb + 1])) &#123; ++ptrb; B.insert(mp(get&lt;1&gt;(b[ptrb]), get&lt;2&gt;(b[ptrb]))); &#125; &#125; else if (ptrs &lt; ptrb) &#123; ++ptrs; S.insert(mp(get&lt;1&gt;(s[ptrs]), get&lt;2&gt;(s[ptrs]))); while (ptrs &lt; n &amp;&amp; get&lt;0&gt;(s[ptrs]) == get&lt;0&gt;(s[ptrs + 1])) &#123; ++ptrs; S.insert(mp(get&lt;1&gt;(s[ptrs]), get&lt;2&gt;(s[ptrs]))); &#125; &#125; else &#123; ++ptrb; B.insert(mp(get&lt;1&gt;(b[ptrb]), get&lt;2&gt;(b[ptrb]))); while (ptrb &lt; n &amp;&amp; get&lt;0&gt;(b[ptrb]) == get&lt;0&gt;(b[ptrb + 1])) &#123; ++ptrb; B.insert(mp(get&lt;1&gt;(b[ptrb]), get&lt;2&gt;(b[ptrb]))); &#125; ++ptrs; S.insert(mp(get&lt;1&gt;(s[ptrs]), get&lt;2&gt;(s[ptrs]))); while (ptrs &lt; n &amp;&amp; get&lt;0&gt;(s[ptrs]) == get&lt;0&gt;(s[ptrs + 1])) &#123; ++ptrs; S.insert(mp(get&lt;1&gt;(s[ptrs]), get&lt;2&gt;(s[ptrs]))); &#125; &#125; if (ptrs &lt;= ptrb) &#123; for (auto [h, id] : S) &#123; if (h &gt;= (*--B.end()).first) &#123;puts(&quot;impossible&quot;); return 0;&#125; anss[++tot] = id; ansb[tot] = (*B.upper_bound(mp(h, 1e9))).second; B.erase(B.upper_bound(mp(h, 1e9))); &#125; S.clear(); &#125; else &#123; for (auto [h, id] : B) &#123; if (h &lt;= (*S.begin()).first) &#123;puts(&quot;impossible&quot;); return 0;&#125; ansb[++tot] = id; anss[tot] = (*--S.lower_bound(mp(h, 0))).second; S.erase(--S.lower_bound(mp(h, 0))); &#125; B.clear(); &#125; &#125; for (int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, ansb[i]); puts(&quot;&quot;); for (int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, anss[i]); return 0;&#125; *B - Beautiful Bridges 题面太麻烦了不再赘述，要求折线不能与上半圆外有交，最小化代价。 数据范围是允许 \\(\\mathcal{O}(n^2)\\) 做的，因此设 \\(f[i]\\) 表示前 \\(i\\) 个，且 \\(i\\) 放了桥墩的最小代价，转移很直接。 问题就是如何判断可以转移，即：判断区间内的点是否在上半圆外。 我们考虑枚举左端点 \\(i\\) ，然后再枚举被更新的所有右端点 \\(j\\) ，那么可以注意到圆心的轨迹是 \\((x_i+r,H-r),r\\ge 0\\) 。 考虑一个点到圆心的距离，其实就是从无穷远变成点到直线距离再变到无穷远，因此一个点的合法范围一定是一个区间。 考虑一个点 \\((x_j,y_j)\\) 带来的约束，临界值显然取在 \\((x_j-(x_i+r))^2+(y_j-(H-r))^2=r^2\\) 处： 如果 \\((x_j,y_j)\\) 加入时处于圆心上方（ \\(y_j\\ge H-\\frac{x_j-x_i}{2}\\) ），那么约束就是 \\(r\\in\\) 方程两根之间的区间。 否则，只会对 \\(r\\) 产生一个上界的约束（因为另一个约束不合法的原因是与下半圆冲突了，实际没关系）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 10007ll x[N], y[N], f[N];inline double sqr(double x) &#123;return x * x;&#125;int main() &#123; memset(f, 0x3f, sizeof(f)); ll n = rd(), H = rd(), alpha = rd(), beta = rd(); for (int i = 1; i &lt;= n; ++i) &#123;x[i] = rd(); y[i] = rd();&#125; f[1] = alpha * (H - y[1]); ll inf = f[n]; for (int i = 1; i &lt;= n; ++i) &#123; double l = 0, r = H - y[i]; for (int j = i + 1; j &lt;= n; ++j) &#123; double b = 2 * (x[i] + y[j] - x[j] - H); double c = sqr(x[j] - x[i]) + sqr(y[j] - H); double dlt = sqrt(b * b - 4 * c); double L = (-b - dlt) / 2, R = (-b + dlt) / 2; r = min(r, R); if (1.0 * y[j] &gt;= H - 1.0 * (x[j] - x[i]) / 2.0) l = max(l, L); double nwpos = 1.0 * (x[j] - x[i]) / 2.0; if (nwpos &gt;= l - 1e-8 &amp;&amp; nwpos &lt;= r + 1e-8) f[j] = min(f[j], f[i] + alpha * (H - y[j]) + beta * (x[j] - x[i]) * (x[j] - x[i])); &#125; &#125; if (f[n] == inf) &#123;puts(&quot;impossible&quot;); return 0;&#125; printf(&quot;%lld\\n&quot;, f[n]); return 0;&#125; D - Circular DNA 给定一个环状括号序列，有 \\(n\\) 类括号分别记做 \\((_i\\) 和 \\()_i\\) ，每类左括号只能与同一类右括号匹配。 找一个断开的位置变成一个序列，最大化合法的括号类数，如果有多个位置找下标最小的。 定义一类括号合法，当且仅当仅考虑该类括号，当前序列是一个合法的括号序列。 对每类分开考虑，合法的位置一定是若干个区间，然后线段树支持区间加求最值即可。 一个比较好写的方法：假设开始的位置是 \\(0\\) ，左括号 \\(-1\\) ，右括号 \\(+1\\) ，记录前缀和。 那么合法区间的左端点一定是前缀和最小的那些位置，右端点就是对应的下一个位置。 upd on 2022/11/4 : 因为只需要在最后查最值点，差分即可，并不需要线段树。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first #define sc second#define mp make_pair#define mt make_tuple#define pb push_back#define pii pair&lt;int, int&gt;#define tii tuple&lt;int, int, int&gt;#define N 1000007vector&lt;pii&gt; s[N];#define ls (rt &lt;&lt; 1)#define rs (rt &lt;&lt; 1 | 1)#define mid ((l + r) &gt;&gt; 1)int n, tag[N &lt;&lt; 2];pii mx[N &lt;&lt; 2];void pushdown(int rt) &#123; if (tag[rt]) &#123; mx[ls].fr += tag[rt]; tag[ls] += tag[rt]; mx[rs].fr += tag[rt]; tag[rs] += tag[rt]; tag[rt] = 0; &#125;&#125;void pushup(int rt) &#123; if (mx[ls].fr &gt; mx[rs].fr) mx[rt] = mx[ls]; else if (mx[ls].fr &lt; mx[rs].fr) mx[rt] = mx[rs]; else &#123;mx[rt].fr = mx[ls].fr; mx[rt].sc = min(mx[ls].sc, mx[rs].sc);&#125;&#125;void build(int rt, int l, int r) &#123; mx[rt].sc = l; if (l == r) return; build(ls, l, mid); build(rs, mid + 1, r);&#125;void upd(int rt, int l, int r, int L, int R) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; ++mx[rt].fr; ++tag[rt]; return; &#125; pushdown(rt); if (L &lt;= mid) upd(ls, l, mid, L, R); if (R &gt; mid) upd(rs, mid + 1, r, L, R); pushup(rt);&#125;void add(int l, int r) &#123; if (l &lt;= r) upd(1, 1, n, l, r); else &#123; upd(1, 1, n, 1, r); if (l &lt;= n) upd(1, 1, n, l, n); &#125;&#125;int tmp[N], pos[N];inline void work(int x) &#123; tmp[0] = 0; int tot = 0, mn = 0; for (auto [v, p] : s[x]) &#123; ++tot; tmp[tot] = tmp[tot - 1] + v; mn = min(mn, tmp[tot]); pos[tot] = p; &#125; if (tmp[tot] != 0) return; for (int i = 1; i &lt; tot; ++i) if (tmp[i] == mn) add(pos[i] + 1, pos[i + 1]); if (tmp[tot] == mn) add(pos[tot] + 1, pos[1]);&#125;int main() &#123; n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; char c = getchar(); while (!isalpha(c)) c = getchar(); int x = rd(); s[x].pb(mp((c == &#x27;s&#x27; ? 1 : -1), i)); &#125; build(1, 1, n); for (int i = 1; i &lt;= 1000000; ++i) if (!s[i].empty()) work(i); printf(&quot;%d %d\\n&quot;, mx[1].sc, mx[1].fr); return 0;&#125; *E - Dead-End Detector 给定无向图，定义 \\(E_i=(u_i,v_i)\\) 在 \\(u_i\\) 端要放死路牌：从 \\(u_i\\) 经过 \\(E_i\\) 之后，如果想回 \\(u_i\\) 一定要在某个顶点原路返回。 但如果存在 \\(x\\) 经过 \\(E_i\\) 之后可以到达 \\(y\\) 再经过 \\(E_j\\) ，并且 \\(E_i\\) 在 \\(x\\) 端有死路牌、\\(E_j\\) 在 \\(y\\) 端有死路牌，那么后者可以省去。 构造最小放置死路牌数方案。 对每个连通块考虑。 如果是一棵树，每条边都是死路。发现只需要在所有的叶子端放置即可，其他路径必定可以反着找到一条从叶子出发的边。 如果是其他情况，一定存在回路。考虑先拎出来一棵生成树，每加一条边，原树上对应这两个端点之间的路径都不是死路。 我们称这些被覆盖的点为标记点。可以注意到，两个标记点之间的路径也不会是死路，因为一定会走到一个环上。 此外同理，剩下的边里指向标记点的路径都不是死路。只有从标记点走出来的路径，并且不能到另一个标记点的是死路。 根据题目的省略要求，发现只要把所有标记点的最小连通块找出来就可以了，考场上写的虚树，实际上按叶子拓扑即可。 要放置死路牌的位置就是从拓扑中未删除点指向被删除点的那些方向。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first #define sc second#define mp make_pair#define mt make_tuple#define pb push_back#define pii pair&lt;int, int&gt;#define tii tuple&lt;int, int, int&gt;#define all(x) (x).begin(), (x).end()#define N 500007bool tree[N], circ[N], not_tree[N];vector&lt;int&gt; s[N];int tot, hd[N], f[N], deg[N];struct edge&#123;int to, nxt;&#125; e[N &lt;&lt; 1];inline void add(int u, int v) &#123; e[++tot].to = v; e[tot].nxt = hd[u]; hd[u] = tot; ++deg[u]; e[++tot].to = u; e[tot].nxt = hd[v]; hd[v] = tot; ++deg[v];&#125;int find(int x) &#123;return x == f[x] ? x : f[x] = find(f[x]);&#125;inline void merge(int x, int y) &#123; x = find(x); y = find(y); f[x] = y; not_tree[y] |= not_tree[x];&#125;vector&lt;pii&gt; ans;queue&lt;int&gt; q;void topo(int x) &#123; for (auto u : s[x]) if (deg[u] == 1 &amp;&amp; !circ[u]) &#123;tree[u] = true; q.push(u);&#125; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = hd[u], v; i; i = e[i].nxt) &#123; --deg[v = e[i].to]; if (deg[v] &lt;= 1 &amp;&amp; !circ[v] &amp;&amp; !tree[v]) &#123; q.push(v); tree[v] = true; &#125; &#125; &#125; for (auto u : s[x]) if (tree[u]) for (int i = hd[u], v; i; i = e[i].nxt) if (!tree[v = e[i].to]) ans.pb(mp(v, u));&#125;int main() &#123; int n = rd(), m = rd(); for (int i = 1; i &lt;= n; ++i) f[i] = i; for (int i = 1, u, v; i &lt;= m; ++i) &#123; u = rd(); v = rd(); if (find(u) == find(v)) not_tree[find(u)] = circ[u] = circ[v] = true; else &#123;merge(u, v); add(u, v);&#125; &#125; for (int i = 1; i &lt;= n; ++i) s[find(i)].pb(i); for (int i = 1; i &lt;= n; ++i) if (f[i] == i) &#123; if (not_tree[i]) topo(i); else for (auto u : s[i]) if (deg[u] == 1) ans.pb(mp(u, e[hd[u]].to)); &#125; sort(all(ans)); printf(&quot;%d\\n&quot;, (int)ans.size()); for (auto [u, v] : ans) printf(&quot;%d %d\\n&quot;, u, v); return 0;&#125; G - First of Her Name 一棵树，每个点上有一个字符，定义一个节点的串就是从他到根路径上的字符依次接起来。 每次询问一个串 \\(s\\) ，问有多少个节点的串以 \\(s\\) 为前缀。 把询问串翻转一下，节点的串顺序也改为从根到它的路径，相当于询问有多少个串以 \\(s\\) 为后缀。广义 SAM。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;cstdio&gt;#include&lt;cctype&gt;using namespace std;const int maxn=1000000,maxt=maxn&lt;&lt;1,maxi=26;int n,Q,p[maxn+5],cnt[maxt+5];int E,lnk[maxt+5],nxt[maxt+5],to[maxt+5];int pl,ro,son[maxt+5][maxi],fai[maxt+5],MAX[maxt+5];char s[maxn+5];#define EOLN(x) ((x)==10 || (x)==13 || (x)==EOF)inline char readc()&#123; static char buf[1&lt;&lt;16],*l=buf,*r=buf; return l==r &amp;&amp; (r=(l=buf)+fread(buf,1,1&lt;&lt;16,stdin),l==r)?EOF:*l++;&#125;template&lt;typename T&gt; int readi(T &amp;x)&#123; T tot=0;char ch=readc(),lst=&#x27;+&#x27;; while (!isdigit(ch)) &#123;if (ch==EOF) return EOF;lst=ch;ch=readc();&#125; while (isdigit(ch)) tot=(tot&lt;&lt;3)+(tot&lt;&lt;1)+(ch^48),ch=readc(); lst==&#x27;-&#x27;?x=-tot:x=tot;return EOLN(ch);&#125;char getupr() &#123;char ch=readc();while (!isupper(ch)) ch=readc();return ch;&#125;int reads(char *s)&#123; int len=0;char ch=getupr(); while (isupper(ch)) s[++len]=ch,ch=readc(); return len;&#125;struct fastO&#123; int si;char buf[1&lt;&lt;16]; void putc(char ch)&#123; if (si==(1&lt;&lt;16)) fwrite(buf,1,si,stdout),si=0; buf[si++]=ch; &#125; ~fastO() &#123;fwrite(buf,1,si,stdout);&#125;&#125;fo;template&lt;typename T&gt; void writei(T x,char ch=&#x27;\\n&#x27;)&#123; static int len=0,buf[100]; if (x&lt;0) fo.putc(&#x27;-&#x27;),x=-x; do buf[len++]=x%10,x/=10; while (x); while (len) fo.putc(buf[--len]+48); if (ch) fo.putc(ch);&#125;inline void Add(int x,int y) &#123;to[++E]=y;nxt[E]=lnk[x];lnk[x]=E;&#125;inline int newnode() &#123;pl++;return pl;&#125;int Extend(int p,int c)&#123; if (son[p][c])&#123; int q=son[p][c];if (MAX[p]+1==MAX[q]) return q; int nq=newnode();MAX[nq]=MAX[p]+1; for (int i=0;i&lt;maxi;i++) son[nq][i]=son[q][i]; fai[nq]=fai[q];fai[q]=nq; while (p &amp;&amp; son[p][c]==q) son[p][c]=nq,p=fai[p]; return nq; &#125; else &#123; int np=newnode();MAX[np]=MAX[p]+1; while (p &amp;&amp; !son[p][c]) son[p][c]=np,p=fai[p]; if (!p) &#123;fai[np]=ro;return np;&#125; int q=son[p][c];if (MAX[p]+1==MAX[q]) &#123;fai[np]=q;return np;&#125; int nq=newnode();MAX[nq]=MAX[p]+1; for (int i=0;i&lt;maxi;i++) son[nq][i]=son[q][i]; fai[nq]=fai[q];fai[q]=fai[np]=nq; while (p &amp;&amp; son[p][c]==q) son[p][c]=nq,p=fai[p]; return np; &#125;&#125;void DFS(int x) &#123;for (int j=lnk[x];j;j=nxt[j]) DFS(to[j]),cnt[x]+=cnt[to[j]];&#125;int main()&#123; readi(n);readi(Q); ro=newnode();p[0]=ro; for (int i=1,w,x;i&lt;=n;i++)&#123; w=getupr()-&#x27;A&#x27;;readi(x); p[i]=Extend(p[x],w);cnt[p[i]]++; &#125; for (int i=2;i&lt;=pl;i++) Add(fai[i],i); DFS(ro); for (int t=1;t&lt;=Q;t++)&#123; int len=reads(s),p=ro; for (int i=len;i;i--) p=son[p][s[i]-&#x27;A&#x27;]; writei(cnt[p]); &#125; return 0;&#125; *H - Hobsons' trains 给一个内向基环树森林，对于每个点，问有多少个点沿着出边走 \\(k\\) 步之内可以到达他。 如果是树，就可以树上差分，对每个点 \\(+1\\) ，再对其 \\(k\\) 级祖先 \\(-1\\) ，最后求子树和就是答案。 考虑对每棵树做完这个操作之后，再考虑每个点对环的贡献，发现一定是环上连续的一段，因此环上差分再单独做一遍即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define rep(i, x, y) for (int (i) = (x); (i) &lt;= (y); ++(i))#define per(i, x, y) for (int (i) = (x); (i) &gt;= (y); --(i))#define N 500007int n, m, k, tot, d[N], f[N], hd[N];struct edge&#123;int to, nxt;&#125; e[N &lt;&lt; 1];inline void add(int u, int v) &#123; e[++tot].to = v; e[tot].nxt = hd[u]; hd[u] = tot;&#125;int find(int x) &#123;return x == f[x] ? x : f[x] = find(f[x]);&#125;int vis[N], circ[N], pref[N], ans[N], stk[N], top;void dfs(int u, int id) &#123; stk[++top] = u; ++ans[u]; if (top - k &gt; 1) --ans[stk[top - k - 1]]; else &#123; --ans[stk[1]]; int len = k - top + 2; if (len &gt;= m) ++pref[1]; else &#123; int l = id, r = id + len - 1; ++pref[l]; if (r &gt; m) &#123;r -= m; ++pref[1];&#125; if (r &lt; m) --pref[r + 1]; &#125; &#125; for (int i = hd[u], v; i; i = e[i].nxt) if (vis[v = e[i].to] != 2) &#123;dfs(v, id); ans[u] += ans[v];&#125; --top;&#125;inline void work(int u) &#123; m = 0; int t = u; for (; !vis[t]; t = d[t]) vis[t] = 1; for (; vis[t] != 2; t = d[t]) &#123;vis[t] = 2; circ[++m] = t;&#125; rep(i, 1, m) dfs(circ[i], i); rep(i, 1, m) &#123;pref[i] += pref[i - 1]; ans[circ[i]] += pref[i];&#125; rep(i, 1, m) pref[i] = 0;&#125;int main() &#123; n = rd(); k = rd(); rep(i, 1, n) f[i] = i; rep(i, 1, n) &#123;d[i] = rd(); add(d[i], i); f[i] = find(d[i]);&#125; rep(i, 1, n) if (f[i] == i) work(i); rep(i, 1, n) printf(&quot;%d\\n&quot;, ans[i]); return 0;&#125;","categories":[{"name":"Official Contests","slug":"Official-Contests","permalink":"http://blog.gyx.me/categories/Official-Contests/"}],"tags":[{"name":"Geometry","slug":"Geometry","permalink":"http://blog.gyx.me/tags/Geometry/"},{"name":"Graphs","slug":"Graphs","permalink":"http://blog.gyx.me/tags/Graphs/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"},{"name":"Greedy","slug":"Greedy","permalink":"http://blog.gyx.me/tags/Greedy/"},{"name":"Segment Tree","slug":"Segment-Tree","permalink":"http://blog.gyx.me/tags/Segment-Tree/"},{"name":"String Suffix Structures","slug":"String-Suffix-Structures","permalink":"http://blog.gyx.me/tags/String-Suffix-Structures/"},{"name":"Difference and Prefix Sum","slug":"Difference-and-Prefix-Sum","permalink":"http://blog.gyx.me/tags/Difference-and-Prefix-Sum/"}]},{"title":"2018 CCPC Finals","slug":"official/ccpc/18-finals","date":"2022-10-18T16:00:00.000Z","updated":"2023-03-20T16:34:52.874Z","comments":true,"path":"official/ccpc/18-finals/","link":"","permalink":"http://blog.gyx.me/official/ccpc/18-finals/","excerpt":"","text":"比赛地址 ：Codeforces Gym 102055 A - Mischievous Problem Setter 签到，排序之后扫一扫。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first #define sc second #define N 100007int testcase;pair&lt;int, int&gt; a[N];inline void work() &#123; printf(&quot;Case %d: &quot;, ++testcase); int n = rd(), m = rd(); for (int i = 1; i &lt;= n; ++i) a[i].fr = rd(); for (int i = 1; i &lt;= n; ++i) a[i].sc = rd(); sort(a + 1, a + 1 + n); for (int i = 1; i &lt;= n; ++i) &#123; if (a[i].sc &gt; m) &#123;printf(&quot;%d\\n&quot;, i - 1); return;&#125; m -= a[i].sc; &#125; printf(&quot;%d\\n&quot;, n);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; *B - Balance of the Force 有 \\(n\\) 位骑士，现在要分裂成两个阵营，第 \\(i\\) 位骑士加入光明阵营武力值为 \\(L_i\\) ，加入黑暗阵营武力值为 \\(D_i\\) 。 此外有 \\(m\\) 对仇敌关系 \\((x_i,y_i)\\) ，表示要求第 \\(x_i\\) 位骑士不能和第 \\(y_i\\) 位骑士加入同一阵营。 问是否存在合法划分方案。若存在，假设第 \\(i\\) 位骑士最终的武力值为 \\(w_i\\) ，最小化 \\(\\max w_i-\\min w_i\\) 。 按照冲突关系连边，如果不是二分图就无解。 否则二分图染色，那么对于一个连通块只有两种染色方案，武力值区间对应着两个不同的 \\([l,r]\\) 。 不妨设两个区间分别是 \\([l_1,r_1]\\) 和 \\([l_2,r_2]\\) 且 \\(r_1&lt;r_2\\) ，我们先让每个区间取 \\([l_1,r_1]\\) 。 然后从小到大枚举 \\(\\min w_i\\) ，然后将不合法的区间变成另一个即可，维护过程中最小差值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first #define sc second #define pb push_back#define mp make_pair#define pii pair&lt;int, int&gt;#define N 200007int testcase, col[N], a[N], b[N];vector&lt;int&gt; e[N], s[3];bool dfs(int u) &#123; s[col[u]].pb(u); for (auto v : e[u]) if (!col[v]) &#123; col[v] = 3 - col[u]; if (dfs(v)) return true; &#125; else if (col[u] == col[v]) return true; return false;&#125;int l1[N], r1[N], l2[N], r2[N], tot;priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; q;inline void work() &#123; tot = 0; while(!q.empty()) q.pop(); printf(&quot;Case %d: &quot;, ++testcase); int n = rd(), m = rd(); for (int i = 1; i &lt;= n; ++i) &#123;e[i].clear(); col[i] = 0;&#125; for (int i = 1; i &lt;= m; ++i) &#123; int a = rd(), b = rd(); e[a].pb(b); e[b].pb(a); &#125; for (int i = 1; i &lt;= n; ++i) &#123;a[i] = rd(); b[i] = rd();&#125; int nwr = 0; for (int i = 1; i &lt;= n; ++i) if (!col[i]) &#123; s[1].clear(); s[2].clear(); col[i] = 1; if (dfs(i)) &#123;puts(&quot;IMPOSSIBLE&quot;); return;&#125; ++tot; l1[tot] = l2[tot] = 2e9; r1[tot] = r2[tot] = 0; for (auto u : s[1]) &#123; l1[tot] = min(l1[tot], a[u]); l2[tot] = min(l2[tot], b[u]); r1[tot] = max(r1[tot], a[u]); r2[tot] = max(r2[tot], b[u]); &#125; for (auto u : s[2]) &#123; l1[tot] = min(l1[tot], b[u]); l2[tot] = min(l2[tot], a[u]); r1[tot] = max(r1[tot], b[u]); r2[tot] = max(r2[tot], a[u]); &#125; if (r1[tot] &gt; r2[tot]) &#123; swap(r1[tot], r2[tot]); swap(l1[tot], l2[tot]); &#125; nwr = max(nwr, r1[tot]); q.push(mp(l1[tot], tot)); &#125; int ans = 2e9; while (!q.empty()) &#123; auto [nwl, p] = q.top(); q.pop(); ans = min(ans, nwr - nwl); if (l2[p] == nwl) break; q.push(mp(l2[p], p)); nwr = max(nwr, r2[p]); &#125; printf(&quot;%d\\n&quot;, ans);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; **C - GCD Land 对于 \\(1\\dots n\\) ，构造一个不超过 \\(10^n\\) 的非负整数，使得 \\(x+1,x+2,\\dots x+n\\) 连通。 定义 \\(u,v\\) 直接连通当且仅当 \\(gcd(u,v)&gt;1\\) ，定义 \\(u,v\\) 连通当且仅当 \\(u,v\\) 直接连通或存在 \\(w\\) 使得 \\(u,w\\) 连通、\\(w,v\\) 连通。 如果令 \\(x=\\prod_{p\\ is\\ prime,p\\le n} p - 1\\) ，那么数列相当于变成了 \\(0,1,\\dots,n-1\\) ，除了 \\(1\\) 其他人都和 \\(0\\) 连通。 那么现在就需要找一个合数沟通 \\(1\\) 和其他，随便构造一下就好了。注意到素数只有 \\(\\mathcal{O}(\\frac{n}{\\ln n})\\) 个，数位并不会超。 柴老师的构造在 \\(n&gt;34\\) 的时候都有解，所以 \\([1,34]\\) 就打下表。求很多个数字的乘积用分治 + FFT即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;typedef vector&lt;int&gt; PN;const int maxn=100000,maxt=1&lt;&lt;18,MOD=998244353;int te,n,P[maxn+5];int p[maxn+5];bool pri[maxn+5];int wn[maxt+5],temA[maxt+5],temB[maxt+5];int m;PN f[maxn+5],F,G,H,res;void Make(int n)&#123; for (int i=2;i&lt;=n;i++)&#123; if (!pri[i]) p[++p[0]]=i; for (int j=1,t;j&lt;=p[0] &amp;&amp; (t=i*p[j])&lt;=n;j++) &#123;pri[t]=true;if (!(i%p[j])) break;&#125; &#125;&#125;inline int ADD(int x,int y) &#123;return x+y&gt;=MOD?x+y-MOD:x+y;&#125;inline int MUL(int x,int y) &#123;return (LL)x*y%MOD;&#125;inline int MUL(int x,int y,int MOD) &#123;return (LL)x*y%MOD;&#125;int Pow(int w,int b) &#123;int s;for (s=1;b;b&gt;&gt;=1,w=MUL(w,w)) if (b&amp;1) s=MUL(s,w);return s;&#125;int Pow(int w,int b,int MOD) &#123;int s;for (s=1;b;b&gt;&gt;=1,w=MUL(w,w,MOD)) if (b&amp;1) s=MUL(s,w,MOD);return s;&#125;void NTTPre()&#123; int x=Pow(3,(MOD-1)/maxt); wn[maxt&gt;&gt;1]=1; for (int i=(maxt&gt;&gt;1)+1;i&lt;maxt;i++) wn[i]=MUL(wn[i-1],x); for (int i=(maxt&gt;&gt;1)-1;i;i--) wn[i]=wn[i&lt;&lt;1];&#125;void NTT(int *a,int n,int f)&#123; if (f&gt;0)&#123; for (int k=n&gt;&gt;1;k;k&gt;&gt;=1) for (int i=0;i&lt;n;i+=k&lt;&lt;1) for (int j=0;j&lt;k;j++)&#123; int x=a[i+j],y=a[i+j+k]; a[i+j+k]=MUL(x+MOD-y,wn[k+j]); a[i+j]=ADD(x,y); &#125; &#125; else &#123; for (int k=1;k&lt;n;k&lt;&lt;=1) for (int i=0;i&lt;n;i+=k&lt;&lt;1) for (int j=0;j&lt;k;j++)&#123; int x=a[i+j],y=MUL(a[i+j+k],wn[k+j]); a[i+j+k]=ADD(x,MOD-y); a[i+j]=ADD(x,y); &#125; for (int i=0,INV=MOD-(MOD-1)/n;i&lt;n;i++) a[i]=MUL(a[i],INV); reverse(a+1,a+n); &#125;&#125;void Print(const PN &amp;a)&#123; int si=a.size(); for (int i=si-1;i&gt;=0;i--) putchar(a[i]+48); puts(&quot;&quot;);&#125;PN operator * (const PN &amp;a,const PN &amp;b)&#123; static PN c; int n=a.size(),m=b.size(),t; for (t=1;t&lt;n+m-1;t&lt;&lt;=1); for (int i=0;i&lt;n;i++) temA[i]=a[i];for (int i=n;i&lt;=t;i++) temA[i]=0; for (int i=0;i&lt;m;i++) temB[i]=b[i];for (int i=m;i&lt;=t;i++) temB[i]=0; NTT(temA,t,1);NTT(temB,t,1); for (int i=0;i&lt;t;i++) temA[i]=MUL(temA[i],temB[i]); NTT(temA,t,-1); for (int i=0;i&lt;n+m-1;i++) temA[i+1]+=temA[i]/10,temA[i]%=10; int si=n+m-1; while (si&gt;1 &amp;&amp; !temA[si]) si--; c.resize(si+1); for (int i=0;i&lt;=si;i++) c[i]=temA[i]; return c;&#125;PN operator * (const PN &amp;a,const int &amp;x)&#123; static PN c; int si=a.size(); for (int i=0;i&lt;si;i++) temA[i]=a[i]*x; for (int i=si;i&lt;=si+10;i++) temA[i]=0; for (int i=0;i&lt;si+10;i++) temA[i+1]+=temA[i]/10,temA[i]%=10; si+=10;while (si&gt;1 &amp;&amp; !temA[si]) si--; c.resize(si+1); for (int i=0;i&lt;=si;i++) c[i]=temA[i]; return c;&#125;PN operator + (const PN &amp;a,const PN &amp;b)&#123; static PN c; int n=a.size(),m=b.size(),si=max(n,m); for (int i=0;i&lt;n;i++) temA[i]=a[i]; for (int i=0;i&lt;m;i++) temB[i]=b[i]; for (int i=n;i&lt;=si;i++) temA[i]=0; for (int i=m;i&lt;=si;i++) temB[i]=0; for (int i=0;i&lt;si;i++) temA[i]+=temB[i]; for (int i=0;i&lt;si;i++) temA[i+1]+=temA[i]/10,temA[i]%=10; while (si&gt;1 &amp;&amp; !temA[si]) si--; c.resize(si+1); for (int i=0;i&lt;=si;i++) c[i]=temA[i]; return c;&#125;void Fix(PN &amp;a,int x)&#123; a.clear(); do a.push_back(x%10),x/=10; while (x);&#125;PN Solve(int L,int R)&#123; if (L==R) return f[L]; int mid=L+(R-L&gt;&gt;1); return Solve(L,mid)*Solve(mid+1,R);&#125;int main()&#123; NTTPre();Make(maxn); for (int i=1,j=1,k=1;i&lt;=maxn;i++)&#123; while (j*j&lt;i) j++; while (k&lt;=p[0] &amp;&amp; p[k]&lt;j) k++; for (int t=k;t&lt;=p[0];t++) if (3*p[t]+1&lt;i &amp;&amp; !pri[2*p[t]+1]) &#123;P[i]=p[t];break;&#125; &#125; scanf(&quot;%d&quot;,&amp;te); for (int t=1;t&lt;=te;t++)&#123; printf(&quot;Case %d: &quot;,t); scanf(&quot;%d&quot;,&amp;n);m=0; if (n&lt;=34)&#123; if (n==1) &#123;puts(&quot;0&quot;);continue;&#125; if (n==17) &#123;puts(&quot;2183&quot;);continue;&#125; if (n==18) &#123;puts(&quot;27828&quot;);continue;&#125; if (n==19) &#123;puts(&quot;27827&quot;);continue;&#125; if (n==20) &#123;puts(&quot;87889&quot;);continue;&#125; if (n==21) &#123;puts(&quot;87889&quot;);continue;&#125; if (n==22) &#123;puts(&quot;171053&quot;);continue;&#125; if (n==23) &#123;puts(&quot;171053&quot;);continue;&#125; if (n==24) &#123;puts(&quot;325309&quot;);continue;&#125; if (n==25) &#123;puts(&quot;127373&quot;);continue;&#125; if (n==26) &#123;puts(&quot;323509&quot;);continue;&#125; if (n==27) &#123;puts(&quot;151061&quot;);continue;&#125; if (n==28) &#123;puts(&quot;151061&quot;);continue;&#125; if (n==29) &#123;puts(&quot;151061&quot;);continue;&#125; if (n==30) &#123;puts(&quot;151060&quot;);continue;&#125; if (n==31) &#123;puts(&quot;151059&quot;);continue;&#125; if (n==32) &#123;puts(&quot;151058&quot;);continue;&#125; if (n==33) &#123;puts(&quot;151057&quot;);continue;&#125; if (n==34) &#123;puts(&quot;7106717&quot;);continue;&#125; puts(&quot;-1&quot;);continue; &#125; int A=2*P[n]+1,B=P[n]; for (int i=1;i&lt;=p[0] &amp;&amp; p[i]&lt;=n;i++) if (p[i]!=P[n] &amp;&amp; p[i]!=(2*P[n]+1))&#123; A=MUL(A,p[i],P[n]);B=MUL(B,p[i],2*P[n]+1); m++;Fix(f[m],p[i]); &#125; F=Solve(1,m); A=Pow(A,P[n]-2,P[n]); B=Pow(B,2*P[n]-1,2*P[n]+1); G=F*A;G=G*(P[n]-1);G=G*(2*P[n]+1); H=F*B;H=H*P[n];H=H*(P[n]+1); res=G+H; res[0]--; for (int i=0;res[i]&lt;0;i++) res[i]+=10,res[i+1]--; while (res.size()&gt;1 &amp;&amp; !res.back()) res.pop_back(); Print(res); &#125; return 0;&#125; G - Pastoral Life in Stardew Valley 对于一个 \\(n\\times m\\) 的矩形，求和：对于每一个子矩形，选择其严格包含的（边界不重合）子矩形方案数。 暴力的做法：枚举子矩形宽度 \\(w\\) 和高度 \\(h\\) ，然后暴力求和，发现维护一个前缀和就行了。 \\[ ans = \\bigg(\\sum_{h=3}^n(n-h+1)\\sum_{l=1}^{h-2}(h-l+1)\\bigg)\\bigg(\\sum_{w=3}^m(m-w+1)\\sum_{r=1}^{w-2}(w-r+1)\\bigg) \\] 理性分析一下，显然这个题目可以变成两个一维问题答案的乘积。 如果子子矩形宽度是 \\(1\\) ，那么就要从 \\(n\\) 中选三个数，分别代表左边界，右边界，子子矩形位置，方案数为 \\({n\\choose 3}\\) 。 如果子子矩形宽度是 \\(2\\) ，那么就要从 \\(n\\) 中选四个数，方案数为 \\({n\\choose 4}\\) 。 因此最终答案是 \\(({n\\choose 3} + {n\\choose 4})({m\\choose 3} + {m\\choose 4})\\) 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;#define all(s) (s).begin(), (s).end()#define lowbit(x) ((x) &amp; -(x))#define N 100007#define mod 1000000007namespace Comb &#123; int fac[N], ifac[N]; inline int fpow(int x, int t) &#123; int res = 1; for (; t; t &gt;&gt;= 1, x = 1ll * x * x % mod) if (t &amp; 1) res = 1ll * res * x % mod; return res; &#125; inline void init() &#123; fac[0] = ifac[0] = 1; for (int i = 1; i &lt; N; ++i) fac[i] = 1ll * fac[i - 1] * i % mod; ifac[N - 1] = fpow(fac[N - 1], mod - 2); for (int i = N - 2; i; --i) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % mod; &#125; inline int C(int n, int m) &#123; if (n &lt; m) return 0; return 1ll * fac[n] * ifac[m] % mod * ifac[n - m] % mod; &#125;&#125;inline int calc(int x) &#123; return (Comb::C(x, 3) + Comb::C(x, 4)) % mod;&#125;int main() &#123; Comb::init(); for (int t = rd(), i = 1; i &lt;= t; ++i) printf(&quot;Case %d: %lld\\n&quot;, i, 1ll * calc(rd()) * calc(rd()) % mod); return 0;&#125; I - Cockroaches 二维平面上 \\(n\\) 个给定点，选一个位置可以把 \\(x\\) 或 \\(y\\) 相同的所有点都打上标记。 对于一次操作：（1）求最多标记多少个点。（2）在保证标记点数最多的前提下，有多少个可能的不同的被标记点集。 离散化，记录 \\(x\\) 相同的最多点数 \\(mxx\\) ，\\(y\\) 相同的最多点数 \\(mxy\\) ， \\(cnt[x]+cnt[y]=mxx+mxy\\) 的给定点数 \\(tot\\) ，讨论： 如果 \\(tot &lt; mxx\\times mxy\\) ，那么答案就是 \\((mxx+mxy, mxx\\times mxy-tot)\\) 。 否则（1）答案就要减一，（2）的答案要继续统计 \\(cnt[x]+cnt[y]=mxx+mxy-1\\) 的个数讨论。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first #define sc second #define pb push_back#define all(x) x.begin(), (x).end()#define N 100007int testcase, x[N], y[N], cntx[N], cnty[N];vector&lt;int&gt; X, Y;inline void work() &#123; printf(&quot;Case %d: &quot;, ++testcase); X.clear(); Y.clear(); int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; cntx[i] = cnty[i] = 0; x[i] = rd(); X.pb(x[i]); y[i] = rd(); Y.pb(y[i]); &#125; sort(all(X)); X.erase(unique(all(X)), X.end()); sort(all(Y)); Y.erase(unique(all(Y)), Y.end()); auto getx = [&amp;](int w) &#123;return lower_bound(all(X), w) - X.begin() + 1;&#125;; auto gety = [&amp;](int w) &#123;return lower_bound(all(Y), w) - Y.begin() + 1;&#125;; int mxx = 0, mxy = 0; for (int i = 1; i &lt;= n; ++i) &#123; x[i] = getx(x[i]); y[i] = gety(y[i]); ++cntx[x[i]]; mxx = max(mxx, cntx[x[i]]); ++cnty[y[i]]; mxy = max(mxy, cnty[y[i]]); &#125; int cntmxx = 0, cntmxy = 0, cntnxx = 0, cntnxy = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (cntx[i] == mxx) ++cntmxx; else if (cntx[i] == mxx - 1) ++cntnxx; if (cnty[i] == mxy) ++cntmxy; else if (cnty[i] == mxy - 1) ++cntnxy; &#125; int tot = 0, ans = mxx + mxy, totnx = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (cntx[x[i]] + cnty[y[i]] == ans) ++tot; else if (cntx[x[i]] + cnty[y[i]] == ans - 1) ++totnx; &#125; bool fl = true; if (tot == 1ll * cntmxx * cntmxy) &#123;--ans; fl = false;&#125; if (ans == 1) &#123;puts(&quot;1 1&quot;); return;&#125; if (ans == 2) &#123;printf(&quot;%d %lld\\n&quot;, 2, 1ll * n * (n - 1) / 2); return;&#125; if (fl) printf(&quot;%d %lld\\n&quot;, ans, 1ll * cntmxx * cntmxy - tot); else printf(&quot;%d %lld\\n&quot;, ans, tot + 1ll * cntmxx * cntnxy + 1ll * cntmxy * cntnxx - totnx);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; *K - Mr. Panda and Kakin 现在定义一个加密 FLAG 的算法（RSA）： 随机从 \\([10^5,10^9]\\) 中选取整数 \\(x\\) 。 令 \\(p\\) 为小于 \\(x\\) 的最大质数，\\(q\\) 为大于 \\(x\\) 的最小质数，\\(n=pq\\) 令 \\(c=\\text{FLAG}^{(2^{30}+3)}\\mod n\\) 现在给定 \\(c,n\\) ，求 FLAG 。 密码学讲过类似的破解思路但是考场上两个小时的时候才想起来。。。 首先 \\(n=pq\\) ，其中 \\(p,q\\) 为相邻素数，所以从 \\(\\sqrt n\\) 开始枚举复杂度不会错，根据唯一分解，第一次找到的因数就是对的。 然后就可以分成两个同余方程，最后用 CRT 合并一下。 破解思路：根据费马小定理有 \\(\\text{FLAG} = \\text{FLAG}^{(2^{30}+3)(2^{30}+3)^{-1}\\mod (p-1)}\\mod p\\) 然后暴力检验一下 \\(2^{30}+3\\) 是素数，所以可以用扩欧求模 \\(p-1\\) 下的逆元，然后还原回去就好了。 赛时一直 WA ，发现了胖胖的黑科技快速乘有 bug ，乘数不能超过模数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;typedef unsigned long long ULL;typedef long double DB;int te;LL n,C;inline ULL ADD(ULL x,ULL y,ULL MOD) &#123;return x+y&gt;=MOD?x+y-MOD:x+y;&#125;inline ULL MUL(ULL x,ULL y,ULL MOD)&#123; LL s=x*y-(ULL)((DB)1/MOD*x*y)*MOD; return s&lt;0?s+=MOD:(s&gt;=MOD?s-=MOD:s);&#125;LL Pow(LL w,LL b,LL MOD) &#123;LL s;for (s=1;b;b&gt;&gt;=1,w=MUL(w,w,MOD)) if (b&amp;1) s=MUL(s,w,MOD);return s;&#125;LL exgcd(LL a,LL b,LL &amp;x,LL &amp;y)&#123; if (!b) &#123;x=1;y=0;return a;&#125; LL r=exgcd(b,a%b,y,x);y-=a/b*x; return r;&#125;LL Inv(LL A,LL C)&#123; LL x,y;exgcd(A,C,x,y); return (x%C+C)%C;&#125;LL Solve(LL A,LL B,LL C)&#123; LL x,y,r=exgcd(A,C,x,y); C/=r;x=(x%C+C)%C;x=MUL(B/r%C,x,C); return x;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;te); for (int t=1;t&lt;=te;t++)&#123; printf(&quot;Case %d: &quot;,t); scanf(&quot;%lld%lld&quot;,&amp;n,&amp;C); LL S=sqrt(n) - 5; while ((n%S)) S++; LL Q=S,P=n/S; LL INV=Inv((1&lt;&lt;30)+3,P-1); LL A=Pow(C%P,INV,P); INV=Inv((1&lt;&lt;30)+3,Q-1); LL B=Pow(C%Q,INV,Q); LL now=Solve(Q,((A-B)%P+P)%P,P); A=ADD(MUL(now,Q,n),B,n); printf(&quot;%lld\\n&quot;,A); &#125; return 0;&#125; L - Ultra Weak Goldbach's Conjecture 给一个数字 \\(x\\) ，尝试分成六个素数的和。 偶数：\\(2,2,2,2,x,y\\) ，奇数：\\(2,2,2,3,x,y\\) ，剩下的事情交给哥德巴赫猜想。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define fr first#define sc second#define mp make_pairusing namespace std;typedef long long LL;typedef unsigned long long ULL;typedef long double DB;const int maxn=10000,prime[]=&#123;2,3,5,7,11,13,17,19,23,29,31,37&#125;;int te;LL n;int p[maxn+5];bool pri[maxn+5];bool f[6][maxn+5];pair&lt;int,int&gt; lst[6][maxn+5];inline ULL ADD(ULL x,ULL y,ULL MOD) &#123;return x+y&gt;=MOD?x+y-MOD:x+y;&#125;inline ULL MUL(ULL x,ULL y,ULL MOD)&#123; LL s=x*y-(ULL)((DB)1/MOD*x*y)*MOD; return s&lt;0?s+=MOD:(s&gt;=MOD?s-=MOD:s);&#125;LL Pow(LL w,LL b,LL MOD) &#123;LL s;for (s=1;b;b&gt;&gt;=1,w=MUL(w,w,MOD)) if (b&amp;1) s=MUL(s,w,MOD);return s;&#125;bool check(LL p,LL n)&#123; int k=0;LL d=n-1,x,s; while (d&amp;1^1) d&gt;&gt;=1,k++; x=Pow(p,d,n); for (;k;k--,x=s)&#123; s=MUL(x,x,n); if (s==1) return x==1 || x==n-1; &#125; return false;&#125;bool MR(LL n)&#123; if (n==1) return false; for (int t=0;t&lt;12;t++)&#123; if (n==prime[t]) return true; if (!(n%prime[t])) return false; if (!check(prime[t],n)) return false; &#125; return true;&#125;void Make(int n)&#123; for (int i=2;i&lt;=n;i++)&#123; if (!pri[i]) p[++p[0]]=i; for (int j=1,t;j&lt;=p[0] &amp;&amp; (t=i*p[j])&lt;=n;j++) &#123;pri[t]=true;if (!(i%p[j])) break;&#125; &#125;&#125;int main()&#123; Make(maxn); f[0][0]=true; for (int i=1;i&lt;=5;i++) for (int k=1;k&lt;=p[0];k++) for (int j=p[k];j&lt;=maxn;j++) if (f[i-1][j-p[k]]) f[i][j]=true,lst[i][j]=mp(i-1,j-p[k]); scanf(&quot;%d&quot;,&amp;te); for (int t=1;t&lt;=te;t++)&#123; scanf(&quot;%lld&quot;,&amp;n); printf(&quot;Case %d:&quot;,t); if (n&lt;=11) &#123;puts(&quot; IMPOSSIBLE&quot;);continue;&#125; LL x=n-10; for (;!MR(x) || !f[5][n-x];x--); int i=5,j=n-x; while (i || j)&#123; int x=lst[i][j].fr,y=lst[i][j].sc; printf(&quot; %d&quot;,j-y); i=x;j=y; &#125; printf(&quot; %lld\\n&quot;,x); &#125; return 0;&#125;","categories":[{"name":"Official Contests","slug":"Official-Contests","permalink":"http://blog.gyx.me/categories/Official-Contests/"}],"tags":[{"name":"Graphs","slug":"Graphs","permalink":"http://blog.gyx.me/tags/Graphs/"},{"name":"Number Theory","slug":"Number-Theory","permalink":"http://blog.gyx.me/tags/Number-Theory/"},{"name":"Counting","slug":"Counting","permalink":"http://blog.gyx.me/tags/Counting/"}]},{"title":"2019-2020 ICPC Latin American Regional","slug":"official/icpc/19-latin-american","date":"2022-10-16T16:00:00.000Z","updated":"2023-03-20T16:35:54.514Z","comments":true,"path":"official/icpc/19-latin-american/","link":"","permalink":"http://blog.gyx.me/official/icpc/19-latin-american/","excerpt":"","text":"比赛地址 ：Codeforces Gym 102428 A - Algorithm Teaching \\(n\\ (1\\le n\\le 10^3)\\) 个老师，第 \\(i\\) 个老师会 \\(m_i\\ (1\\le m_i\\le 10)\\) 个科目：\\(s_{i,1},s_{i,2},\\cdots,s_{i,m_i}\\)。 每个学生只可以从一个老师那里学会老师会的科目的一个子集，两个学生可以合作当且仅当会的集合互不包含。 问最多能找出来多少个学生，使得两两都可以合作。 求包含关系的最长反链，由 dilworth 定理就是求最小链覆盖。 每个老师对应 \\(2^{m_i}-1\\) 个集合，\\(3^{m_i}\\) 个包含关系。最多一共 \\(102300\\) 个不同的集合，\\(5904900\\) 条边。 包含关系天然的是传递闭包，因此直接跑最小路径覆盖复杂度 \\(\\mathcal{O}(m\\sqrt n)\\) 约 \\(10^9\\) ，Hopcroft 常数很小（只跑了217ms）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define fr first#define sc second#define pb push_back#define mp make_pair#define mt make_tuple#define pii pair&lt;int, int&gt;#define tiii tuple&lt;long, long, long&gt;#define all(s) (s).begin(), (s).end()#define lowbit(x) ((x) &amp; -(x))#define rep(i, x, y) for (int (i) = (x); (i) &lt;= (y); ++(i))#define per(i, x, y) for (int (i) = (x); (i) &gt;= (y); --(i))inline bool getmin(int &amp;a, int b) &#123;return (a &gt; b ? (a = b, true) : false);&#125;inline bool getmax(int &amp;a, int b) &#123;return (a &lt; b ? (a = b, true) : false);&#125;const int N = 110007;const int inf = 1000000000;namespace Hopcroft_Karp &#123; bool vis[N]; vector&lt;int&gt; e[N]; int nl, nr, ml[N], mr[N], dl[N], dr[N]; // m for match, d for distance inline bool bfs() &#123; static int q[N], hd, tl; hd = 1; tl = 0; memset(dl, -1, sizeof(int) * (nl + 1)); memset(dr, -1, sizeof(int) * (nr + 1)); for (int i = 1; i &lt;= nl; ++i) if (!ml[i]) &#123;dl[i] = 0; q[++tl] = i;&#125; int dT = inf; while (hd &lt;= tl) &#123; int u = q[hd++]; if (dl[u] &gt;= dT) break; for (auto v : e[u]) if (dr[v] == -1) &#123; dr[v] = dl[u] + 1; if (!mr[v]) getmin(dT, dr[v] + 1); else &#123;dl[mr[v]] = dr[v] + 1; q[++tl] = mr[v];&#125; &#125; &#125; return dT != inf; &#125; bool dfs(int u) &#123; for (auto v : e[u]) &#123; if (vis[v] || dl[u] + 1 != dr[v]) continue; vis[v] = true; if (!mr[v] || dfs(mr[v])) &#123;mr[v] = u; ml[u] = v; return true;&#125; &#125; return false; &#125; inline void add(int u, int v) &#123;e[u].push_back(v);&#125; inline int max_matching() &#123; int ans = 0; while(bfs()) &#123; memset(vis, 0, sizeof(bool) * (nr + 1)); for (int i = 1; i &lt;= nl; ++i) if (!ml[i]) ans += dfs(i); &#125; return ans; &#125;&#125;int tot, cnts;bool vis[N];unordered_map&lt;string, int&gt; tr;map&lt;vector&lt;int&gt;, int&gt; id;int main() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; int k; cin &gt;&gt; k; vector&lt;int&gt; course(k); for (int j = 0; j &lt; k; ++j) &#123; string str; cin &gt;&gt; str; if (!tr[str]) tr[str] = ++cnts; course[j] = tr[str]; &#125; sort(all(course)); vector&lt;int&gt; subset(1 &lt;&lt; k); for (int S = 1; S &lt; (1 &lt;&lt; k); ++S) &#123; vector&lt;int&gt; tmp(__builtin_popcount(S)); for (int j = 0, tmpcnt = 0; j &lt; k; ++j) if (S &amp; (1 &lt;&lt; j)) tmp[tmpcnt++] = course[j]; if (!id[tmp]) id[tmp] = ++tot; subset[S] = id[tmp]; &#125; for (int S = 1; S &lt; (1 &lt;&lt; k); ++S) &#123; int nwid = subset[S]; if (vis[nwid]) continue; vis[nwid] = true; for (int s = (S &amp; (S - 1)); s; s = (S &amp; (s - 1))) Hopcroft_Karp::add(nwid, subset[s]); &#125; &#125; Hopcroft_Karp::nl = Hopcroft_Karp::nr = tot; printf(&quot;%d\\n&quot;, tot - Hopcroft_Karp::max_matching()); return 0;&#125; *C - Cut Inequality Down 一共 \\(n\\ (1\\le n\\le 10^5)\\) 个月，第 \\(i\\) 个月的收入固定是 \\(a_i\\ (-10^6\\le a_i\\le 10^6)\\) 元。 限制钱数任何时刻都必须在 \\([L,R]\\) 内，如果一个月收入之后超过了边界就把钱数改为对应边界。 \\(Q\\ (1\\le Q\\le 10^5)\\) 次询问：如果从第 \\(a\\) 天开始的时候有 \\(w\\) 元钱，那么第 \\(b\\) 天的时候有多少钱？ 如果没有碰过边界，答案就是 \\(w+sum[b] - sum[a - 1]\\) 。 如果碰过边界，答案就是 最后一次碰的边界值 + 剩下的一段收入和 。 如何求最后一次碰的边界的位置呢？ 首先我们可以 \\(O(1)\\) 判断给定区间和初始钱数，区间内是否碰过边界： 预处理前缀和的区间 \\(\\max,\\min\\) 的 ST 表，查区间内收入最多/最低时刻，与边界比较即可。 那么可以用上述方法套一个二分 \\(\\mathcal{O}(\\log n)\\) 求出最近的触碰边界时刻。 就可以预处理倍增 nxt[i][t][0/1] 表示当前在 \\(i\\) ，当前钱数是上/下边界，往后 \\(2^t\\) 次触及边界的位置和对应是上/下边界。 每次询问先二分一次到边界，然后用倍增跳，最后一段直接用前缀和，总复杂度 \\(\\mathcal{O}(n\\log n+ Q\\log n)\\)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;#define all(s) (s).begin(), (s).end()#define lowbit(x) ((x) &amp; -(x))#define N 100007int n, L, R, a[N], lg[N];ll mx[N][18], mn[N][18], pre[N];inline ll qmx(int l, int r) &#123; int t = lg[r - l + 1]; return max(mx[l][t], mx[r - (1 &lt;&lt; t) + 1][t]);&#125;inline ll qmn(int l, int r) &#123; int t = lg[r - l + 1]; return min(mn[l][t], mn[r - (1 &lt;&lt; t) + 1][t]);&#125;pair&lt;int, bool&gt; nxt[N][18][2];pair&lt;int, bool&gt; getnxt(int nw, int w) &#123; auto check = [&amp;](int p) &#123; if (w + qmx(nw, p) - pre[nw - 1] &gt; R) return true; if (w + qmn(nw, p) - pre[nw - 1] &lt; L) return true; return false; &#125;; if (!check(n)) return mp(n + 1, 0); int l = nw, r = n; while (l &lt; r) &#123; int mid = (l + r) &gt;&gt; 1; check(mid) ? r = mid : l = mid + 1; &#125; return mp(l, w + qmx(nw, l) - pre[nw - 1] &gt; R);&#125;int main() &#123; for (int t = 0; (1 &lt;&lt; t) &lt; N; ++t) lg[1 &lt;&lt; t] = t; for (int i = 1; i &lt; N; ++i) if (!lg[i]) lg[i] = lg[i - 1]; n = rd(); L = rd(); R = rd(); for (int i = 1; i &lt;= n; ++i) &#123; a[i] = rd(); pre[i] = pre[i - 1] + a[i]; mx[i][0] = mn[i][0] = pre[i]; &#125; for (int t = 1; t &lt;= lg[n]; ++t) for (int i = 1; i &lt;= n - (1 &lt;&lt; t) + 1; ++i) &#123; mx[i][t] = max(mx[i][t - 1], mx[i + (1 &lt;&lt; (t - 1))][t - 1]); mn[i][t] = min(mn[i][t - 1], mn[i + (1 &lt;&lt; (t - 1))][t - 1]); &#125; memset(nxt, 0x3f, sizeof(nxt)); for (int i = 1; i &lt;= n; ++i) &#123; nxt[i][0][0] = getnxt(i, L); nxt[i][0][1] = getnxt(i, R); &#125; for (int t = 1; t &lt;= lg[n]; ++t) for (int i = 1; i &lt;= n; ++i) &#123; if (nxt[i][t - 1][0].fr &lt;= n) nxt[i][t][0] = nxt[nxt[i][t - 1][0].fr + 1][t - 1][nxt[i][t - 1][0].sc]; if (nxt[i][t - 1][1].fr &lt;= n) nxt[i][t][1] = nxt[nxt[i][t - 1][1].fr + 1][t - 1][nxt[i][t - 1][1].sc]; &#125; for (int q = rd(); q; --q) &#123; int l = rd(), r = rd(), w = rd(); auto [p, fl] = getnxt(l, w); if (p &gt; r) &#123; printf(&quot;%lld\\n&quot;, w + pre[r] - pre[l - 1]); continue; &#125; for (int i = lg[n]; ~i; --i) if (nxt[p][i][fl].fr &lt;= r) &#123; auto [nxp, nxfl] = nxt[p][i][fl]; p = nxp + 1; fl = nxfl; &#125; printf(&quot;%lld\\n&quot;, (fl ? R : L) + pre[r] - pre[p - 1]); &#125; return 0;&#125; D - Dazzling Stars 给定二维平面上 \\(n\\ (1\\le n\\le 10^3)\\) 个点的坐标 \\((x_i,y_i)\\) 和权值 \\(w_i\\) 。 问是否能将所有点整体旋转一个角度，使得：若 \\(w_A&gt;w_B\\) ，那么 \\(y_A\\ge y_B\\) 。 对于每一对不等关系，确定合法的角度区间，角度区间判交。 把角度区间控制在 \\([0,2\\pi]\\) 内，如果越过就拆成两段，然后扫描线，先 \\(+\\) 后 \\(-\\) ，判断是否有一个位置覆盖次数 \\(=\\) 区间个数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef long double ld;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;#define all(s) (s).begin(), (s).end()#define lowbit(x) ((x) &amp; -(x))const ld PI = 3.1415926535897932384;const ld a90 = atan(1) * 2;const ld a180 = a90 * 2, a270 = a90 * 3, a360 = a90 * 4;const ld dlt[2][2] = &#123;0, a180, a360, a180&#125;;#define N 1007int w[N];ld x[N], y[N];inline ld angle(ld x, ld y) &#123; if (fabs(x) &lt; 1e-15) return a90 * (1 + 2 * (y &lt; 0)); else return atan(y / x) + dlt[y &lt; 0][x &lt; 0];&#125;vector&lt;pair&lt;long double, bool&gt;&gt; s;int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; x[i] = rd(); y[i] = rd(); w[i] = rd(); &#125; int tot = 0, nw = 0; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) if (w[i] &gt; w[j]) &#123; ++tot; ld alpha = angle(x[i] - x[j], y[i] - y[j]); ld l = -alpha, r = PI - alpha; while (l &lt; 0) &#123;l += 2 * PI; r += 2 * PI;&#125; if (r &gt;= 2 * PI) r -= 2 * PI; s.pb(mp(l, false)); s.pb(mp(r, true)); if (l &gt; r) ++nw; &#125; sort(all(s)); if (tot == 0) &#123;puts(&quot;Y&quot;); return 0;&#125; for (auto [p, w] : s) &#123; nw += (w ? -1 : 1); if (nw == tot) &#123;puts(&quot;Y&quot;); return 0;&#125; &#125; puts(&quot;N&quot;); return 0;&#125; E - Eggfruit Cake 给一个 \\(01\\) 环，问有多少个环上的的区间符合长度不超过 \\(s\\) 并且至少有一个 \\(1\\) 。 枚举左端点，复制一遍预处理后面第一个 \\(1\\) 的位置，答案就是 \\(\\sum s-dis(pos[i]-i)\\) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;#define all(s) (s).begin(), (s).end()#define lowbit(x) ((x) &amp; -(x))string s;#define N 100007bool fl = false;int nxt[N &lt;&lt; 1];int main() &#123; cin &gt;&gt; s; for (auto x : s) if (x == &#x27;E&#x27;) &#123;fl = true; break;&#125; if (!fl) &#123;puts(&quot;0&quot;); return 0;&#125; int n = s.length(); s = &quot; &quot; + s + s; for (int i = (n &lt;&lt; 1), lst = n; i; --i) &#123; if (s[i] == &#x27;E&#x27;) lst = i; nxt[i] = lst; &#125; int mx; cin &gt;&gt; mx; ll ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; ans += max(0, mx - (nxt[i] - i)); &#125; printf(&quot;%lld\\n&quot;, ans); return 0;&#125; *F - Fabricating Sculptures 一些砖块堆起来，计数恰好用 \\(B\\) 块砖，最下面一层恰好 \\(S\\ (1\\le S\\le B\\le 10^3)\\) 块砖，并且不会积水的堆砌方案数。 需要横着想，一层一层放，约束变成：最下面一层 \\(S\\) 个，每一层不能比下一层多的方案数。 发现我们并不关心当前放了多少层，因此状态可以设计为 \\(f[x][j]\\) 表示已经用了 \\(x\\) 个，当前最上面一层放了 \\(j\\) 个的方案数。 转移：\\(f[x][j] = \\sum_{k=j}^Sf[x - j][k]\\times (k - j + 1) = \\sum_{k=j}^S f[x-j][k]\\times k - (j-1)\\sum_{k=j}^S f[x-j][k]\\) 维护 \\(f[\\ast][k]\\times k\\) 的后缀和、\\(f[\\ast][k]\\) 的后缀和即可实现 \\(\\mathcal{O}(1)\\) 转移。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;#define all(s) (s).begin(), (s).end()#define lowbit(x) ((x) &amp; -(x))#define N 5007#define mod 1000000007int f[N][N], sum[N][N], sumk[N][N];int main() &#123; int m = rd(), n = rd(); f[m][m] = 1; for (int j = m; j; --j) &#123; sum[m][j] = (sum[m][j + 1] + f[m][j]) % mod; sumk[m][j] = (sumk[m][j + 1] + 1ll * j * f[m][j]) % mod; &#125; for (int use = m + 1; use &lt;= n; ++use) &#123; for (int j = min(m, use); j; --j) &#123; f[use][j] = (sumk[use - j][j] + 1ll * sum[use - j][j] * (1 - j + mod)) % mod; sum[use][j] = (sum[use][j + 1] + f[use][j]) % mod; sumk[use][j] = (sumk[use][j + 1] + 1ll * j * f[use][j]) % mod; &#125; &#125; printf(&quot;%d\\n&quot;, sum[n][1]); return 0;&#125; G - Gluing Pictures 给定一个模版串，多次询问，把一个串最少拆成多少个模版串的子串拼接起来。 容易发现贪心拿更长的子串是正确的，所以直接在 SAM 上匹配就好了，失败就回到根，答案就是匹配次数。 123456789101112131415161718192021222324252627282930313233343536#include&lt;cstdio&gt;using namespace std;const int maxn=200000,maxt=maxn&lt;&lt;1,maxi=26;int n,te;char s[maxn+5],t[maxn+5];int pl,ro,son[maxt+5][maxi],fai[maxt+5],MAX[maxt+5];inline int newnode() &#123;pl++;return pl;&#125;int Extend(int p,int c)&#123; int np=newnode();MAX[np]=MAX[p]+1; while (p &amp;&amp; !son[p][c]) son[p][c]=np,p=fai[p]; if (!p) &#123;fai[np]=ro;return np;&#125; int q=son[p][c];if (MAX[p]+1==MAX[q]) &#123;fai[np]=q;return np;&#125; int nq=newnode();MAX[nq]=MAX[p]+1; for (int i=0;i&lt;maxi;i++) son[nq][i]=son[q][i]; fai[nq]=fai[q];fai[q]=fai[np]=nq; while (p &amp;&amp; son[p][c]==q) son[p][c]=nq,p=fai[p]; return np;&#125;int main()&#123; scanf(&quot;%s&quot;,s+1);ro=newnode(); for (int i=1,p=ro;s[i];i++) p=Extend(p,s[i]-&#x27;A&#x27;); for (scanf(&quot;%d&quot;,&amp;te);te;te--)&#123; scanf(&quot;%s&quot;,t+1); int ans=0; for (int i=1,p=ro;t[i];i++)&#123; p=son[p][t[i]-&#x27;A&#x27;]; if (!p)&#123; p=son[ro][t[i]-&#x27;A&#x27;];ans++; if (!p) &#123;ans=-2;break;&#125; &#125; &#125; printf(&quot;%d\\n&quot;,ans+1); &#125; return 0;&#125; I - Improve SPAM 注意题目保证是个DAG，BFS 去掉无用点，统计出正确点度，然后拓扑排序路径计数即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;#define all(s) (s).begin(), (s).end()#define lowbit(x) ((x) &amp; -(x))#define N 2007#define mod 1000000007int deg[N], f[N];vector&lt;int&gt; e[N];queue&lt;int&gt; q;int main() &#123; int n = rd(), m = rd(); for (int i = 1; i &lt;= m; ++i) for (int k = rd(); k; --k) e[i].pb(rd()); q.push(1); while (!q.empty()) &#123; int u = q.front(); q.pop(); for (auto v : e[u]) &#123; if (!deg[v]) q.push(v); ++deg[v]; &#125; &#125; int ans2 = 0; for (int i = m + 1; i &lt;= n; ++i) ans2 += (deg[i] &gt; 0); q.push(1); f[1] = 1; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (auto v : e[u]) &#123; f[v] = (f[v] + f[u]) % mod; --deg[v]; if (!deg[v]) q.push(v); &#125; &#125; int ans1 = 0; for (int i = m + 1; i &lt;= n; ++i) ans1 = (ans1 + f[i]) % mod; printf(&quot;%d %d\\n&quot;, ans1, ans2); return 0;&#125; **J - Jumping Grasshopper 给定长度为 \\(n\\) 的数列，规定一个起点和方向（左/右），每次会跳到该方向的第一个比当前高的位置，然后转向。 保证初始数列两两不同，支持 \\(m\\) 次 ：1. 把某个数改大（依旧两两不同）；2. 给定起始位置和方向，问最后停在的位置。 数据范围 ：\\(1\\le n,m\\le 2\\times 10^5,1\\le h_i\\le 10^9\\) 如果两侧都存在比当前位置大的，跳跃不会停止，最终会先跳到左右最大值较小的那个，然后再往对面跳一步 。 注意不是跳到最大的，因为最大值较小的一侧回头之后第一个比他大的，有可能不是那一侧最大的。 所以线段树维护区间 \\(\\max\\) + 线段树上二分找上一个/下一个比给定值大的位置，复杂度 \\(\\mathcal{O}(n\\log n)\\) 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;#define all(s) (s).begin(), (s).end()#define lowbit(x) ((x) &amp; -(x))#define N 200007#define ls (rt &lt;&lt; 1)#define rs (rt &lt;&lt; 1 | 1)#define mid ((l + r) &gt;&gt; 1)int n, m, h[N], mx[N &lt;&lt; 2];inline void pushup(int rt) &#123; mx[rt] = mx[ls] &gt; mx[rs] ? mx[ls] : mx[rs];&#125;void build(int rt, int l, int r) &#123; if (l == r) &#123;mx[rt] = h[l]; return;&#125; build(ls, l, mid); build(rs, mid + 1, r); pushup(rt);&#125;void upd(int rt, int l, int r, int p, int x) &#123; if (l == r) &#123;mx[rt] = x; return;&#125; p &lt;= mid ? upd(ls, l, mid, p, x) : upd(rs, mid + 1, r, p, x); pushup(rt);&#125;int qmax(int rt, int l, int r, int L, int R) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) return mx[rt]; int ans = 0; if (L &lt;= mid) ans = max(ans, qmax(ls, l, mid, L, R)); if (R &gt; mid) ans = max(ans, qmax(rs, mid + 1, r, L, R)); return ans;&#125;int nxtr(int rt, int l, int r, int L, int w) &#123; if (l == r) return l; if (L &lt;= mid &amp;&amp; mx[ls] &gt; w) &#123; int res = nxtr(ls, l, mid, L, w); if (res &gt; 0) return res; &#125; if (mx[rs] &lt;= w) return -1; return nxtr(rs, mid + 1, r, L, w);&#125;int nxtl(int rt, int l, int r, int L, int w) &#123; if (l == r) return l; if (L &gt; mid &amp;&amp; mx[rs] &gt; w) &#123; int res = nxtl(rs, mid + 1, r, L, w); if (res &gt; 0) return res; &#125; if (mx[ls] &lt;= w) return -1; return nxtl(ls, l, mid, L, w);&#125;unordered_map&lt;int, int&gt; pos;int main() &#123; int n = rd(), m = rd(), mxpos = 1; for (int i = 1; i &lt;= n; ++i) &#123; h[i] = rd(); pos[h[i]] = i; &#125; build(1, 1, n); for (int i = 1; i &lt;= m; ++i) &#123; char c = getchar(); while (!isalpha(c)) c = getchar(); if (c == &#x27;U&#x27;) &#123; int p = rd(); pos[h[p] = rd()] = p; upd(1, 1, n, p, h[p]); &#125; else &#123; int p = rd(); int lmx = qmax(1, 1, n, 1, p); if (c == &#x27;L&#x27; &amp;&amp; lmx == h[p]) &#123;printf(&quot;%d\\n&quot;, p); continue;&#125; int rmx = qmax(1, 1, n, p, n); if (c == &#x27;R&#x27; &amp;&amp; rmx == h[p]) &#123;printf(&quot;%d\\n&quot;, p); continue;&#125; if (lmx &lt; rmx) printf(&quot;%d\\n&quot;, nxtr(1, 1, n, pos[lmx], lmx)); else printf(&quot;%d\\n&quot;, nxtl(1, 1, n, pos[rmx], rmx)); &#125; &#125; return 0;&#125; K - Know your Aliens 构造多项式 \\(P\\) ，对于 \\(i=2,4,\\dots,2n\\) ，符合给定的条件 \\(P(i)&gt;0\\) 或 \\(P(i)&lt;0\\) 。 对于相邻的符号变化的位置，中位数一定是个奇数（并且是整数），可以假定他是多项式的根。 因此就是求 \\(\\prod (x-w_i)\\) 的各系数，然后根据第一个的正负调整一下符号即可。 有一个 \\(O(n^2)\\) 的递推方法求系数（直接多项式乘法复杂度也对）： 设 \\(f[i][j]\\) 表示前 \\(i\\) 个系数里所有的选 \\(j\\) 个的方案对应的乘积和，转移 \\(f[i][j] = f[i - 1][j] + f[i - 1][j - 1] * w_i\\) 。 （不过这个题题面里说保证存在系数不超过 \\(2^{63}\\) 的多项式符合要求，理解起来有点奇怪） 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;#define all(s) (s).begin(), (s).end()#define lowbit(x) ((x) &amp; -(x))#define N 10007char s[N];ll cnt, f[N][N], w[N];int main() &#123; scanf(&quot;%s&quot;, s + 1); int n = strlen(s + 1); for (int i = 1; i &lt; n; ++i) if (s[i] != s[i + 1]) w[++cnt] = - 2 * i - 1; f[0][0] = 1; for (int i = 1; i &lt;= cnt; ++i) &#123; f[i][0] = 1; for (int j = 1; j &lt;= i; ++j) f[i][j] = f[i - 1][j - 1] * w[i] + f[i - 1][j]; &#125; int fl = ((f[cnt][cnt] &gt; 0) == (s[1] == &#x27;H&#x27;) ? 1 : -1); printf(&quot;%lld\\n&quot;, cnt); for (int i = 0; i &lt;= cnt; ++i) printf(&quot;%lld &quot;, fl * f[cnt][i]); return 0;&#125; L - Leverage MDT 给一个 \\(01\\) 矩阵，对于每行你都可以选择全部 \\(01\\) 翻转/不翻转，然后求最大子正方形。 按列去看，枚举答案的右边界，对于每行约束就变成了向左找和当前位置相同的最长长度。 然后做一个单调栈就可以了，因为是正方形，更新答案使用当前的高度和宽度的较小值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;#define all(s) (s).begin(), (s).end()#define lowbit(x) ((x) &amp; -(x))#define N 1007bool a[N][N];int f[N][N];stack&lt;pii&gt; s;int main() &#123; int n = rd(), m = rd(); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) &#123; char c = getchar(); while (!isalpha(c)) c = getchar(); a[i][j] = (c == &#x27;G&#x27;); f[i][j] = (a[i][j] == a[i][j - 1] ? f[i][j - 1] + 1 : 1); &#125; int ans = 0; for (int j = 1; j &lt;= m; ++j) &#123; for (int i = 1; i &lt;= n; ++i) &#123; int len = 0; while (!s.empty() &amp;&amp; f[s.top().fr][j] &gt;= f[i][j]) &#123; len += s.top().sc; ans = max(ans, min(f[s.top().fr][j], len)); s.pop(); &#125; s.push(mp(i, len + 1)); &#125; int len = 0; while (!s.empty()) &#123; len += s.top().sc; ans = max(ans, min(f[s.top().fr][j], len)); s.pop(); &#125; &#125; printf(&quot;%d\\n&quot;, ans * ans); return 0;&#125; M - Mountain Ranges 给定数列，求最长的区间，区间内相邻的两个数差值不超过 \\(x\\) 。直接扫一遍。 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;#define all(s) (s).begin(), (s).end()#define lowbit(x) ((x) &amp; -(x))#define N 1007int a[N];int main() &#123; int n = rd(), k = rd(), ans = 0; for (int i = 1; i &lt;= n; ++i) a[i] = rd(); for (int i = n, cnt = 0; i; --i) &#123; if (a[i + 1] - a[i] &gt; k) cnt = 0; ++cnt; ans = max(ans, cnt); &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125;","categories":[{"name":"Official Contests","slug":"Official-Contests","permalink":"http://blog.gyx.me/categories/Official-Contests/"}],"tags":[{"name":"Graphs","slug":"Graphs","permalink":"http://blog.gyx.me/tags/Graphs/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"http://blog.gyx.me/tags/Binary-Search/"},{"name":"Segment Tree","slug":"Segment-Tree","permalink":"http://blog.gyx.me/tags/Segment-Tree/"},{"name":"Binary Lifting","slug":"Binary-Lifting","permalink":"http://blog.gyx.me/tags/Binary-Lifting/"},{"name":"Sparse Table","slug":"Sparse-Table","permalink":"http://blog.gyx.me/tags/Sparse-Table/"},{"name":"Stack","slug":"Stack","permalink":"http://blog.gyx.me/tags/Stack/"}]},{"title":"Prefix Function and Z Function","slug":"algorithms/z-function","date":"2022-10-14T06:29:18.000Z","updated":"2023-03-20T16:50:16.931Z","comments":true,"path":"algorithms/z-function/","link":"","permalink":"http://blog.gyx.me/algorithms/z-function/","excerpt":"","text":"Z Function Z-function - Algorithms for Competitive Programming Analysis 对于一个字符串 \\(S\\)（下标从 \\(1\\) 开始），定义 \\(z[i]\\) 表示 \\(S\\) 中从 \\(i\\) 开始的后缀与 \\(S\\) 的最长公共前缀（LCP）的长度。 直接求 \\(z\\) 数组是 \\(\\mathcal{O}(n^2)\\) 的，但是如果利用到以往的信息，就可以将暴力优化到 \\(\\mathcal{O}(n)\\) 。 Efficient Algorithm按照 \\(i=1,2,\\dots,|s|\\)的顺序依次求 \\(z\\)数组，同时维护当前匹配到最靠右的位置 \\(mxpos=\\arg \\max \\{i + z[i] - 1\\}\\)记 \\((mxpos,mxpos + z[mxpos] - 1)\\)为 \\((L,R)\\)，代表当前与前缀匹配的最靠右的区间。那么对于一个新扫描的位置 \\(i\\)，讨论：若 \\(i&gt;R\\)，那么曾经的信息都用不上了，暴力从 \\(i\\) 开始向后尝试匹配。如果 \\(i&lt;R\\)，我们尝试利用曾经计算过的信息：首先可以肯定 \\(S[i,R]=S[i-l+1,r-l+1]\\) ,尝试利用所以可以继承 \\(z[i-l+1]\\)的一部分。但如果对应位置超过 \\(R\\)就不能确定是否可以利用了，所以令 \\(z[i]=\\min(z[i-l+1],r - i + 1)\\)，然后再暴力向后匹配。123456int l = 0, r = 0;for (int i = 2; i &lt;= n; ++i) &#123; if (i &lt;= r) z[i] = min(z[i - l + 1], r - i + 1); while (i + z[i] &lt;= n &amp;&amp; t[z[i] + 1] == t[i + z[i]]) ++z[i]; if (i + z[i] - 1 &gt; r) &#123;l = i; r = i + z[i] - 1;&#125; &#125;Proof of Time Complexity首先算法正确性显然，空间复杂度显然是 \\(\\mathcal{O}(n)\\) ，就不多做分析了。证明思路：观察到两种情况下每次有效的暴力比较都会拓展右边界 \\(R\\) ，而右边界只会变化 \\(n\\) 次，故线性复杂度。 ARC 058 F - Iroha Loves Strings 给定 \\(n\\) 个串的序列 \\(s_1,s_2,\\dots,s_n\\) ，选择其中一些串，按照原序列顺序连接起来，使得得到的串长为 \\(k\\) 且字典序最小。 数据范围：\\(1\\le n\\le 2\\times 10^3,1\\le |s_i|\\le k\\le 10^4\\) 按顺序拿，先解决可不可以拿，倒序做一个 \\(O(nk)\\) 的 01 背包预处理 valid[i][j] 表示 \\(i\\) 及之后的串是否能组合出长度 \\(j\\) 。 接下来先考虑暴力：设 f[i][j] 表示前 \\(i\\) 个串，凑出长度为 \\(j\\) 的最小字典序字符串，转移为字符串比较复杂度，总 \\(\\mathcal{O}(nk^2)\\) 。 考虑优化，对于相同长度，最优解显然只有一个（转移时只从 f[i-1][x] 转移，已经使用）； 对于不同长度两个状态，假设较短的为 \\(a\\) ，较长的为 \\(b\\) ，若 \\(b\\) 长度为 \\(|a|\\) 的前缀和 \\(a\\) 不同，则 \\(a,b\\) 一定有一个没用。 因此当前所有最优解中，短的串必然是长的串的前缀，所有串都可以用最长的最优解 \\(S\\) 的前缀来表示。 现在考虑 dp 实际在做什么：将以往的某个最优解接上当前串，来替换以往的其他最优解。 即对于以往的两个最优解 \\(a,b\\) 满足 \\(|a|+|s_i|=|b|\\) ，如果 \\(s_i\\) 比 \\(S\\) 中 \\(|a|+1\\) 开始的后缀字典序要小，那么长度 \\(\\ge |a|\\) 的以往的最优解都没用了，因此我们可以枚举最靠前的这个位置进行插入（并删除以往多余的后缀）。 可以发现比较的永远是 \\(S\\) 的一个后缀和 \\(s_i\\) 的字典序，因此可以用 \\(s_i+\\#+S\\) 跑 Z 函数确定 LCP 后讨论。 这样复杂度就是 \\(\\mathcal{O}(nk)\\) 的了。实在是太细节了绷不住了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;#define N 2007#define K 10007char s[N][K], S[K], tmp[K &lt;&lt; 1];bool valid[N][K], pos[K];int len[N], z[K &lt;&lt; 1];void zfunc(int p) &#123; memset(z, 0, sizeof(z)); memset(tmp, 0, sizeof(tmp)); strcpy(tmp + 1, s[p] + 1); tmp[len[p] + 1] = &#x27;z&#x27; + 1; strcpy(tmp + len[p] + 2, S + 1); tmp[strlen(tmp + 1) + 1] = &#x27;z&#x27; + 2; int l = 0, r = 0; for (int i = 2, lim = strlen(tmp + 1); i &lt;= lim; ++i) &#123; if (i &lt;= r) z[i] = min(z[i - l + 1], r - i + 1); while (i + z[i] &lt;= lim &amp;&amp; tmp[z[i] + 1] == tmp[i + z[i]]) ++z[i]; if (i + z[i] - 1 &gt; r) &#123;l = i; r = i + z[i] - 1;&#125; &#125;&#125;int main() &#123; int n, k; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for (int i = 1; i &lt;= n; ++i) &#123; scanf(&quot;%s&quot;, s[i] + 1); len[i] = strlen(s[i] + 1); &#125; for (int i = 1; i &lt;= n + 1; ++i) valid[i][0] = true; for (int i = n; i; --i) for (int j = k; j; --j) &#123; valid[i][j] |= valid[i + 1][j]; if (j &gt;= len[i]) valid[i][j] |= valid[i + 1][j - len[i]]; &#125; for (int i = 1; i &lt;= n; ++i) &#123; zfunc(i); int len_S = strlen(S + 1); pos[len_S + 1] = true; for (int j = 1, lim = min(k + 1 - len[i], len_S + 1); j &lt;= lim; ++j) if (valid[i + 1][k - (j + len[i] - 1)] &amp;&amp; pos[j]) &#123; // update to S[j,j + len[i] - 1] int match = z[j + len[i] + 1]; if (match == len[i]) pos[j + len[i]] = true; else if (j + match - 1 == len_S) &#123; strcpy(S + j, s[i] + 1); pos[len_S + 1] = pos[j + len[i]] = true; &#125; else if (match &lt; len[i] &amp;&amp; tmp[match + 1] &lt; tmp[j + len[i] + 1 + match]) &#123; strcpy(S + j, s[i] + 1); for (int p = j + match + 1; p &lt;= k; ++p) pos[p] = false; break; &#125; &#125; &#125; puts(S + 1); return 0;&#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://blog.gyx.me/categories/Algorithms/"}],"tags":[{"name":"String","slug":"String","permalink":"http://blog.gyx.me/tags/String/"}]},{"title":"Dilworth's Theorem","slug":"algorithms/dilworth","date":"2022-09-23T05:57:39.000Z","updated":"2023-03-20T16:45:13.343Z","comments":true,"path":"algorithms/dilworth/","link":"","permalink":"http://blog.gyx.me/algorithms/dilworth/","excerpt":"","text":"Definition Partial order relation : a homogeneous relation that is transitive and antisymmetric. Non-strict (reflexive / weak) partial order \\(\\le\\) : Reflexivity, Antisymmetry, Transitivit. Strict (irreflexive / strong) partial order \\(&lt;\\) : Irreflexivity, Antisymmetry, Transitivit. Converse relation (Transpose) : the relation that occurs when the order of the elements is switched. the converse relation of \\(\\le\\) is \\(\\ge\\) , and the converse relation of \\(&lt;\\) is \\(&gt;\\) 。 For a partial ordered set \\((A, R)\\) ： Chain \\(A&#39;\\subseteq A\\) : a totally ordered set, i.e. \\(\\forall x,y\\in A&#39; (x\\ne y), xRy\\) or \\(yRx\\) holds. Antichain \\(A&#39;\\subseteq A\\) : a totally unordered set, i.e. \\(\\forall x,y\\in A&#39; (x\\ne y),\\) neither \\(xRy\\) nor \\(yRx\\) holds (incomparable). Chain Decomposition (Cover) : a partition of the elements of the order into disjoint chains. Theorem and Proof Dilworth's TheoremIn any finite partially ordered set, the largest antichain has the same size as the smallest chaindecomposition.The width of the partial order is defined as thecommon size of the antichain and chain decomposition.Dual (Mirsky's theorem)In any finite partially ordered set, the largest chain has the same size as the smallest antichain decomposition.The depth of the partial order is defined as thecommon size of the chain and antichain decomposition. The following proof by induction on the size of the partially ordered set \\((P,\\le)\\). Let \\(P\\) be a finite partially ordered set. The theorem holds trivially if \\(P\\) is empty. So, assume that \\(P\\) has at least one element, and let \\(a\\) be a maximal element of \\(P\\). By induction, we assume that for some integer \\(k\\) the partially ordered set \\(P^{\\prime}:=P \\backslash\\{a\\}\\) can be covered by \\(k\\) disjoint chains \\(C_1, \\ldots, C_k\\) and has at least one antichain \\(A_0\\) of size \\(k\\). Clearly, (since \\(A_0\\) is an antichain) , \\(A_0 \\cap C_i \\neq \\emptyset\\) for \\(i=1,2, \\ldots, k\\). For \\(i=1,2, \\ldots, k\\), let \\(x_i\\) be the maximal element in \\(C_i\\) that belongs to an antichain of size \\(k\\) in \\(P^{\\prime}\\) , and set \\(A:=\\left\\{x_1, x_2, \\ldots, x_k\\right\\}\\) . We claim that \\(A\\) is an antichain. Let \\(A_i\\) be an antichain of size \\(k\\) that contains \\(x_i\\) . Fix arbitrary distinct indices \\(i\\) and \\(j\\) . Then \\(A_i \\cap C_j \\neq \\emptyset\\) . Let \\(y \\in A_i \\cap C_j\\) . Then \\(y \\leq x_j\\) , by the definition of \\(x_j\\) . This implies that \\(x_i \\ne x_j\\) , since \\(x_i \\ne y\\) . By interchanging the roles of \\(i\\) and \\(j\\) in this argument we also have \\(x_j \\ne x_i\\). This verifies that \\(A\\) is an antichain. We now return to \\(P\\). Suppose first that \\(a \\geq x_i\\) for some \\(i \\in\\{1,2, \\ldots, k\\}\\). Let \\(K\\) be the chain \\(\\{a\\} \\cup\\left\\{z \\in C_i: z \\leq x_i\\right\\}\\) . Then by the choice of \\(x_i\\) , \\(P \\backslash K\\) does not have an antichain of size \\(k\\) . Induction then implies that \\(P \\backslash K\\) can be covered by \\(k-1\\) disjoint chains since \\(A \\backslash\\left\\{x_i\\right\\}\\) is an antichain of size \\(k-1\\) in \\(P \\backslash K\\) . Thus, \\(P\\) can be covered by \\(k\\) disjoint chains, as required. Next, if \\(a \\not\\ge x_i\\) for each \\(i \\in\\{1,2, \\ldots, k\\}\\), then \\(A \\cup\\{a\\}\\) is an antichain of size \\(k+1\\) in \\(P\\) (since \\(a\\) is maximal in \\(P\\) ). Now \\(P\\) can be covered by the \\(k+1\\) chains \\(\\{a\\}, C_1, C_2, \\ldots, C_k\\), completing the proof. Application 找二元关系并检验；2. 运用定理（及对偶定理）转化。 NOIP 1999 - 导弹拦截 给一个数列 \\(a_1,a_2,\\cdots,a_n\\) ，问最少划分为多少个严格不增子序列。 可以接到一个序列的关系为： \\(iRj=i&lt;j\\) 且 \\(a_i\\ge a_j\\) ，容易验证该二元关系是严格偏序。 那么反链的要求即 ( \\(i&lt;j\\) 且 \\(a_i&lt;a_j\\) ) 或 ( \\(i&gt;j\\) 且 \\(a_i&gt; a_j\\) ) ，即严格上升子序列，所以答案为最长上升子序列长度。 推论：一个数列总是存在下面二者之一：一个长度为 \\(\\sqrt n\\) 的上升子序列或一个长度为 \\(\\sqrt n\\) 的下降子序列。 因此可以构造，每 \\(\\sqrt n\\) 个一组，内部下降，整体上升，使得其 LIS 和 LDS 的 \\(\\max\\) 最小。 TJOI 2015 - 组合数学 给定一个网格图，每次从左上角出发，只能往右或往下走，最后到达右下角，每个格子有最低经过次数，问最少走几次？ 二元关系为向右向下走的可达性，且自己不可以到自己，是严格偏序。 求最小链覆盖，由 Dilworth 定理，等价于求最长反链，也就是两两都是严格的左下与右上的关系。 因此从左下角到右上角做最长反链的 dp 即可。设 \\(f[i][j]\\) 表示从左下角开始到 \\((i, j)\\) 的最长反链。 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 1007int a[N][N];ll f[N][N];inline void work() &#123; int n = rd(), m = rd(); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) &#123;f[i][j] = 0; a[i][j] = rd();&#125; for (int i = n; i; --i) for (int j = 1; j &lt;= m; ++j) f[i][j] = max(&#123;f[i + 1][j], f[i][j - 1], f[i + 1][j - 1] + a[i][j]&#125;); printf(&quot;%lld\\n&quot;, f[1][m]);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; Gym 102565 - Artifact 给一张有向图 \\((|V|\\le 3000, |E|\\le 20000)\\) ，问最多选出多少个点两两不可达。 可达关系 \\(iRj=\\) 可以从 \\(i\\) 走到 \\(j\\) ，发现并不满足反自反性，但 SCC 缩点之后是一个DAG \\((V&#39;,E&#39;)\\)，满足要求。 因此求最多的点数满足两两不可达，即两两不具有 \\(R\\) 关系，因此所求即为 \\((V&#39;,R)\\) 的最长反链。 由 Dilworth 定理求偏序关系 \\(R\\) 的最小链覆盖 ( 注意是原图的最小可重链覆盖 )，我们有一种通用的做法： 对于偏序关系 \\(R\\) ，用图结构表示一定是 DAG，且由传递性任意可达的两点之间距离一定为 \\(1\\) ； 因此对于本题中的原图，需用传递闭包求出 \\(R\\) ，得到偏序关系的图表示； 此时相当于求新图的最小不可重路径覆盖，即选最少的不重路径使得每个顶点恰好在一条路径中； 将每个点拆成入点和出点建立二分图，对于关系中存在的 \\(xRy\\ (x\\ne y)\\) 连边：\\((x_{出},y_{入})\\) 。 求最大匹配，证明优化目标的一致性：假设开始的时候每个点单独成链，一次匹配相当于将两个链连接起来。 所以结论为最小链覆盖 = 原图顶点数 \\(-\\) 构造的二分图最大匹配。 此题直接 floyd 传递闭包太慢，DAG 传递闭包可以用拓扑排序更新，再用 bitset 加速复杂度为 \\(O(\\frac{nm}{\\omega})\\) 。 匹配加速可以考虑使用 Hopcroft-Karp 或 Dinic，总复杂度为 \\(O(m(\\frac{n}{\\omega}+\\sqrt n))\\) 。一道类似的题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;inline bool getmin(int &amp;a, int b) &#123;return (a &gt; b ? (a = b, true) : false);&#125;inline bool getmax(int &amp;a, int b) &#123;return (a &lt; b ? (a = b, true) : false);&#125;#define fr first#define sc second#define pb push_back#define mp make_pair#define mt make_tuple#define pii pair&lt;int, int&gt;#define tiii tuple&lt;long, long, long&gt;#define all(s) (s).begin(), (s).end()#define lowbit(x) ((x) &amp; -(x))#define rep(i, x, y) for (int (i) = (x); (i) &lt;= (y); ++(i))#define per(i, x, y) for (int (i) = (x); (i) &gt;= (y); --(i))#define N 3007namespace SCC &#123; bool vis[N]; int scc, bl[N]; vector&lt;int&gt; e[N], re[N], nodes[N], order; void add(int u, int v) &#123;e[u].push_back(v); re[v].push_back(u);&#125; void dfs1(int u) &#123; vis[u] = 1; for (auto v : e[u]) if (!vis[v]) dfs1(v); order.push_back(u); &#125; void dfs2(int u) &#123; nodes[bl[u] = scc].push_back(u); for (auto v : re[u]) if (!bl[v]) dfs2(v); &#125; void kosaraju(int n) &#123; for (int u = 1; u &lt;= n; ++u) if (!vis[u]) dfs1(u); reverse(order.begin(), order.end()); for (auto u : order) if (!bl[u]) &#123;++scc; dfs2(u);&#125; &#125; int indeg[N], outdeg[N]; vector&lt;int&gt; source, sink; unordered_map&lt;ll, bool&gt; valid; inline bool has_edge(int u, int v) &#123; ll w = 1000000000ll * u + v; return valid[w] ? true : (valid[w] = true, 0); &#125; inline void shrink(int n) &#123; valid.clear(); for (int u = 1; u &lt;= n; ++u) e[u].clear(); for (int v = 1; v &lt;= n; ++v) for (auto u : re[v]) if (bl[u] != bl[v] &amp;&amp; !has_edge(bl[u], bl[v])) &#123; ++indeg[bl[v]]; ++outdeg[bl[u]]; e[bl[u]].push_back(bl[v]); &#125; for (int u = 1; u &lt;= scc; ++u) if (!indeg[u]) source.push_back(u); for (int u = 1; u &lt;= scc; ++u) if (!outdeg[u]) sink.push_back(u); for (int u = 1; u &lt;= n; ++u) re[u].clear(); for (int u = 1; u &lt;= scc; ++u) for (auto v : e[u]) re[v].push_back(u); &#125;&#125;namespace Hopcroft_Karp &#123; const int inf = 1000000000; bool vis[N]; vector&lt;int&gt; e[N]; int nl, nr, ml[N], mr[N], dl[N], dr[N]; // m for match, d for distance inline bool bfs() &#123; static int q[N], hd, tl; hd = 1; tl = 0; memset(dl, -1, sizeof(int) * (nl + 1)); memset(dr, -1, sizeof(int) * (nr + 1)); for (int i = 1; i &lt;= nl; ++i) if (!ml[i]) &#123;dl[i] = 0; q[++tl] = i;&#125; int dT = inf; while (hd &lt;= tl) &#123; int u = q[hd++]; if (dl[u] &gt;= dT) break; for (auto v : e[u]) if (dr[v] == -1) &#123; dr[v] = dl[u] + 1; if (!mr[v]) getmin(dT, dr[v] + 1); else &#123;dl[mr[v]] = dr[v] + 1; q[++tl] = mr[v];&#125; &#125; &#125; return dT != inf; &#125; bool dfs(int u) &#123; for (auto v : e[u]) &#123; if (vis[v] || dl[u] + 1 != dr[v]) continue; vis[v] = true; if (!mr[v] || dfs(mr[v])) &#123;mr[v] = u; ml[u] = v; return true;&#125; &#125; return false; &#125; inline void add(int u, int v) &#123;e[u].push_back(v);&#125; inline int max_matching() &#123; int ans = 0; while(bfs()) &#123; memset(vis, 0, sizeof(bool) * (nr + 1)); for (int i = 1; i &lt;= nl; ++i) if (!ml[i]) ans += dfs(i); &#125; return ans; &#125;&#125;bitset&lt;N&gt; edg[N];int main() &#123; int n = rd(), m = rd(); for (int i = 1; i &lt;= m; ++i) &#123; int u = rd(), v = rd(); SCC::add(u, v); &#125; SCC::kosaraju(n); SCC::shrink(n); n = SCC::scc; // Transitive Closure for (int i = n; i; --i) &#123; edg[i][i] = true; for (auto v : SCC::e[i]) edg[i] |= edg[v]; for (int j = i + 1; j &lt;= n; ++j) if (edg[i][j]) Hopcroft_Karp::add(i, j); &#125; Hopcroft_Karp::nl = Hopcroft_Karp::nr = n; printf(&quot;%d\\n&quot;, n - Hopcroft_Karp::max_matching()); return 0;&#125; CTSC 2008 - 祭祀 给一个 DAG ，问：(1) 最多选出多少个点两两不可达；(2) 输出一种方案；(3) 输出每个点是否可以在某个方案中出现。 DAG 直接bitset暴力传递闭包复杂度 \\(\\mathcal{O}(\\frac{n^3}{64})=\\mathcal{O}(\\frac{nm}{64})\\)，用 Hopcraft-Karp 复杂度 \\(\\mathcal{O}(m\\sqrt n)=\\mathcal{O}(n^{2.5})\\)。 求出最长反链：按照 Konig 定理构造最小点覆盖的时候复杂度是 \\(\\mathcal{O}(m)\\) 的，因为一个右侧点被打过标记之后，再经过他就不用管了。先找出来一个最小点覆盖，然后对于拆的点都不在最小点覆盖里的，加入最长反链。一个证明 枚举每个点，假设必选他，那么与他有偏序关系的所有点都不可以选，删掉这些之后求一下最长反链，看一下长度是否是原答案 \\(-1\\) 即可。 总复杂度 \\(\\mathcal{O}(\\frac{n^3}{64} + n^2 + n\\times n^{2.5})=\\mathcal{O}(n^{3.5})\\) ，对于 \\(n=100\\) 可过。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;inline bool getmin(int &amp;a, int b) &#123;return (a &gt; b ? (a = b, true) : false);&#125;inline bool getmax(int &amp;a, int b) &#123;return (a &lt; b ? (a = b, true) : false);&#125;template &lt;const int V, const int inf = 1000000000&gt;struct Hopcroft_Karp &#123; bool vis[V]; vector&lt;int&gt; e[V]; int nl, nr, ml[V], mr[V], dl[V], dr[V]; // m for match, d for distance void clear() &#123; for (int i = 1; i &lt;= nl; ++i) &#123;ml[i] = 0; e[i].clear();&#125; for (int i = 1; i &lt;= nr; ++i) &#123;mr[i] = 0; vis[i] = false;&#125; &#125; inline bool bfs() &#123; static int q[V], hd, tl; hd = 1; tl = 0; memset(dl, -1, sizeof(int) * (nl + 1)); memset(dr, -1, sizeof(int) * (nr + 1)); for (int i = 1; i &lt;= nl; ++i) if (!ml[i]) &#123;dl[i] = 0; q[++tl] = i;&#125; int dT = inf; while (hd &lt;= tl) &#123; int u = q[hd++]; if (dl[u] &gt;= dT) break; for (auto v : e[u]) if (dr[v] == -1) &#123; dr[v] = dl[u] + 1; if (!mr[v]) getmin(dT, dr[v] + 1); else &#123;dl[mr[v]] = dr[v] + 1; q[++tl] = mr[v];&#125; &#125; &#125; return dT != inf; &#125; bool dfs(int u) &#123; for (auto v : e[u]) &#123; if (vis[v] || dl[u] + 1 != dr[v]) continue; vis[v] = true; if (!mr[v] || dfs(mr[v])) &#123;mr[v] = u; ml[u] = v; return true;&#125; &#125; return false; &#125; inline void add(int u, int v) &#123;e[u].push_back(v);&#125; inline int max_matching() &#123; int ans = 0; while(bfs()) &#123; memset(vis, 0, sizeof(bool) * (nr + 1)); for (int i = 1; i &lt;= nl; ++i) if (!ml[i]) ans += dfs(i); &#125; return ans; &#125; bool visl[V], visr[V], anti[V]; void addtag(int u) &#123; visl[u] = true; for (auto v : e[u]) &#123; if (visr[v]) continue; visr[v] = true; addtag(mr[v]); &#125; &#125; inline void Antichain() &#123; for (int i = 1; i &lt;= nl; ++i) if (!ml[i]) addtag(i); // visl[i] = false or visr[i] = true : vertex cover // visl[i] = true or visr[i] = false : independent set for (int i = 1; i &lt;= nl; ++i) if (visl[i] &amp;&amp; !visr[i]) anti[i] = true; &#125;&#125;;#define N 101bool tag[N];Hopcroft_Karp&lt;N&gt; f;bitset&lt;N&gt; adj[N];int main() &#123; int n = rd(), m = rd(); for (int i = 1, u, v; i &lt;= m; ++i) &#123; u = rd(); v = rd(); adj[u][v] = true; &#125; for (int k = 1; k &lt;= n; ++k) for (int u = 1; u &lt;= n; ++u) if (adj[u][k]) adj[u] |= adj[k]; f.nl = f.nr = n; for (int u = 1; u &lt;= n; ++u) for (int v = 1; v &lt;= n; ++v) if (adj[u][v]) f.add(u, v); int ans = n - f.max_matching(); printf(&quot;%d\\n&quot;, ans); f.Antichain(); for (int i = 1; i &lt;= n; ++i) putchar(&#x27;0&#x27; + f.anti[i]); puts(&quot;&quot;); for (int i = 1; i &lt;= n; ++i) &#123; f.clear(); int tot = n; memset(tag, 0, sizeof(tag)); tag[i] = true; --tot; for (int u = 1; u &lt;= n; ++u) if (adj[u][i] || adj[i][u]) &#123;tag[u] = true; --tot;&#125; for (int u = 1; u &lt;= n; ++u) for (int v = 1; v &lt;= n; ++v) if (adj[u][v] &amp;&amp; !tag[u] &amp;&amp; !tag[v]) f.add(u, v); if (tot - f.max_matching() == ans - 1) putchar(&#x27;1&#x27;); else putchar(&#x27;0&#x27;); &#125; return 0;&#125; 一些结合其他套路的题目： SPOJ - DIVREL | ABC237Ex - hakata | CF590E - Birthday.","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://blog.gyx.me/categories/Algorithms/"}],"tags":[{"name":"Graphs","slug":"Graphs","permalink":"http://blog.gyx.me/tags/Graphs/"}]},{"title":"Matrix Multiplication","slug":"algorithms/matrix-multiplication","date":"2022-09-10T11:21:52.000Z","updated":"2023-03-20T16:50:11.924Z","comments":true,"path":"algorithms/matrix-multiplication/","link":"","permalink":"http://blog.gyx.me/algorithms/matrix-multiplication/","excerpt":"","text":"递推数列 路径计数 给定一张图，处理形如 “从 \\(u\\) 到 \\(v\\) 恰好经过 \\(k\\) 条边的路径条数” 的计数问题。 设 \\(f[u][v][k]\\) 表示从 \\(u\\) 到 \\(v\\) 恰好经过 \\(k\\) 条边的路径条数，设 \\(e[u][v]=1\\) 表示存在一条从 \\(u\\) 到 \\(v\\) 的边，有转移 \\[ f[u][v][k] = \\sum_{1\\le w\\le n} f[u][w][k-1]\\cdot e[w][v] \\] 这是一个典型的矩阵乘法，设 \\(F[k]\\) 表示 \\(k\\) 步的 \\(f\\) 数组，有 \\(F[k]=E^k (k\\ge 0)\\) 。 广义矩阵乘法 使用矩阵乘法来维护的要求有两个： 运算结果满足对应代数表达式； 满足结合律（用于快速幂加速）。 比较严谨的结论是：矩阵乘法可以处理的代数结构为半环 \\((A,+,\\cdot)\\) ，即满足： \\((A,+)\\) 为带有单位元 \\(0\\) 的交换幺半群（单位元，结合律，交换律）； \\((A,\\cdot\\ )\\) 为带有单位元 \\(1\\) 的幺半群（单位元，结合律）； 乘法对加法同时有左、右分配律； 加法单位元 \\(0\\) 抵消乘法。 In general, if the addition and multiplication satisfies the axioms of semi-ring, then the associativity of multiplication of matrices holds, enabling us to optimize DP with the matrix exponentiation like described above. A semi-ring is a set \\(A\\) equipped with two binary operations, addition \\(+\\) and multiplication \\(\\cdot\\) , such that all the following properties is satisfied: \\((A,+)\\) is an commutative monoid; i.e. it satisfies the following three conditions: The associativity of \\(+\\) holds. That is, for any \\(a, b, c \\in A\\), it holds that \\((a+b)+c=a+(b+c)\\). There exists an identity 0 of \\(+\\). That is, there exists \\(0 \\in A\\) such that \\(a+0=0+a=a\\). The commutativity of \\(+\\) holds. That is, for any \\(a, b \\in A\\), it holds that \\(a+b=b+a\\). \\((A, \\cdot)\\) is a monoid; i.e. it satisfies the following two conditions: The associativity of \\(\\cdot\\) holds. That is, for any \\(a,b,c\\in A\\), it holds that \\((a \\cdot b) \\cdot c=a \\cdot(b \\cdot c)\\) . There exists an identity 1 of \\(\\cdot\\). That is, there exists \\(1 \\in A\\) such that \\(a \\cdot 1=1 \\cdot a=a\\). \\(+\\) and \\(\\cdot\\) satisfies the following distributive property holds: For any \\(a, b, c \\in A\\), it holds that \\(a \\cdot(b+c)=a \\cdot b+a \\cdot c\\) . For any \\(a, b, c \\in A\\), it holds that \\((a+b) \\cdot c=a \\cdot c+b \\cdot c\\) . For all \\(a \\in A\\), it holds that \\(0 \\cdot a=a \\cdot 0=0\\). 一些例子 注意，使用广义矩阵乘法时，初始矩阵和单位矩阵对应的 \\(0\\) 和 \\(1\\) 自然的应当使用广义的 \\(0\\) 和 \\(1\\) 。 ID \\(A\\) \\(+\\) \\(0\\) \\(\\cdot\\) \\(1\\) 1 \\(\\mathbb{R}\\) \\(\\min\\) \\(+\\infty\\) \\(\\max\\) \\(-\\infty\\) 2 \\(\\mathbb{R}\\) \\(\\max\\) \\(-\\infty\\) \\(\\min\\) \\(+\\infty\\) 3 \\(\\mathbb{R}\\cup \\{-\\infty \\}\\) \\(\\max\\) \\(-\\infty\\) ordinary addition \\(+\\) \\(0\\) 4 \\(\\mathbb{R}\\cup \\{+\\infty \\}\\) \\(\\min\\) \\(+\\infty\\) ordinary addition \\(+\\) \\(0\\) 5 \\(\\forall n\\in \\mathbb{N^+},\\ [0,2^n)\\cap \\mathbb{N}\\) bitwise OR \\(0\\) bitwise AND \\(2^n-1\\) 6 \\(\\forall n\\in \\mathbb{N^+},\\ [0,2^n)\\cap \\mathbb{N}\\) bitwise AND \\(2^n-1\\) bitwise OR \\(0\\) 7 \\(\\forall n\\in \\mathbb{N^+},\\ [0,2^n)\\cap \\mathbb{N}\\) bitwise XOR \\(0\\) bitwise AND \\(2^n-1\\) ABC 236 G - Good Vertices 有一张无向图，开始没有边，第 \\(1\\sim m\\) 秒每秒加一条边 \\(u_i,v_i\\) 。 询问每个点 \\(u\\) ，询问最早的时刻，图中存在一条长度恰好为 \\(l\\) 的从 \\(1\\) 到 \\(u\\) 的路径。 将边加入的时间设为边权，即 \\(e[u_i][v_i]=i\\) ，问题改为长度为 \\(l\\) 的路径上最大边权最小是多少。 设 \\(f[u][v][k]\\) 表示恰好经过 \\(k\\) 条边从 \\(u\\) 到 \\(v\\) ，路径上的最大边权最小值。 枚举第 \\(k-1\\) 步（即 \\(v\\) 前一个）走到的点 \\(w\\) ，转移方程为：\\(f[u][v][k] = \\min_{1\\le w\\le n} \\big\\{ \\max (f[u][w][k-1], e[w][v])\\big\\}\\) 只看一步转移，发现这是一个加法为 \\(\\min\\) ，乘法为 \\(\\max\\) 的矩阵乘法，检验： 加法 \\(\\min\\) 的单位元为 \\(+\\infty\\) ，满足结合律交换律； 乘法 \\(\\max\\) 的单位元为 \\(-\\infty\\) ，满足结合律； 左分配律：\\(\\max(a,\\min(b,c)) = \\min(\\max(a,b),\\max(a,c))\\) ，由于 \\(\\max\\) 有交换律所以右分配律自然成立； 加法单位元抵消乘法： \\(\\max(+\\infty, x) = +\\infty\\) 所以可以用矩阵维护，对邻接矩阵做此时的矩阵快速幂即可，当然这个问题可以询问有向图以及任意点对。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 101int n, m, l;inline int min(const int &amp;a, const int &amp;b) &#123;return a &lt; b ? a : b;&#125;inline int max(const int &amp;a, const int &amp;b) &#123;return a &lt; b ? b : a;&#125;struct matrix &#123; int a[N][N]; matrix(bool id = 0) &#123; memset(a, 0x3f, sizeof(a)); if (id) for (int i = 0; i &lt; N; ++i) a[i][i] = -1e9; &#125; inline matrix operator * (const matrix &amp;obj) const &#123; matrix res; for (int k = 1; k &lt;= n; ++k) for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) res.a[i][j] = min(res.a[i][j], max(a[i][k], obj.a[k][j])); return res; &#125; inline matrix fpow(int t) const &#123; matrix res(1), x = *this; for (; t; t &gt;&gt;= 1, x = x * x) if (t &amp; 1) res = res * x; return res; &#125;&#125; A, res;int main() &#123; n = rd(); m = rd(); l = rd(); for (int i = 1; i &lt;= m; ++i) &#123; int u = rd(), v = rd(); A.a[u][v] = min(A.a[u][v], i); &#125; res = A.fpow(l); for (int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, res.a[1][i] &gt; m ? -1 : res.a[1][i]); return 0;&#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://blog.gyx.me/categories/Algorithms/"}],"tags":[{"name":"Matrix Theory","slug":"Matrix-Theory","permalink":"http://blog.gyx.me/tags/Matrix-Theory/"},{"name":"Algebra","slug":"Algebra","permalink":"http://blog.gyx.me/tags/Algebra/"}]},{"title":"DSU on Tree","slug":"algorithms/dsu-on-tree","date":"2022-08-31T00:13:35.000Z","updated":"2023-03-20T16:50:07.012Z","comments":true,"path":"algorithms/dsu-on-tree/","link":"","permalink":"http://blog.gyx.me/algorithms/dsu-on-tree/","excerpt":"","text":"Analysis DSU on Tree 在一些比较简单的子树问题时可以替代点分治，复杂度也是 \\(\\mathcal O(n\\log n)\\) 。 按子树 size 轻重链剖分，然后使用某个数据结构统计每个点的子树信息： 先让轻儿子统计子树信息，并撤销对数据结构的影响； 如果有重儿子，统计重儿子子树信息，保留对数据结构的影响（不撤销）； 向数据结构中添加轻儿子子树信息和当前点信息，统计当前点信息。 复杂度分析：每个点只会在到根路径上遇到轻边时被添加 /撤销，由轻重连剖分每个点到根的路径上至多 \\(\\log n\\) 条轻边。所以总复杂度是 \\(\\mathcal O(n \\log n)\\) ，由于明显跑不满所以常数会很小。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 100007#define pb push_backint sz[N], mxs[N];vector&lt;int&gt; e[N];void dfs(int u, int fa) &#123; sz[u] = 1; for (auto v : e[u]) if (v != fa) &#123; dfs(v, u); sz[u] += sz[v]; if (sz[v] &gt; sz[mxs[u]]) mxs[u] = v; &#125;&#125;inline void upd(int u) &#123; // adding information of u into data structures&#125;inline void del(int u) &#123; // deleting information of u from data structures&#125;void upd(int u, int fa) &#123; upd(u); for (auto v : e[u]) if (v != fa) upd(v, u);&#125;void del(int u, int fa) &#123; del(u); for (auto v : e[u]) if (v != fa) del(v, u);&#125;void dsu(int u, int fa) &#123; for (auto v : e[u]) if (v != fa &amp;&amp; v != mxs[u]) &#123;dsu(v, u); del(v, u);&#125; if (mxs[u]) dsu(mxs[u], u); for (auto v : e[u]) if (v != fa &amp;&amp; v != mxs[u]) upd(v, u); upd(u); &#125;int main() &#123; int n = rd(); for (int i = 1; i &lt; n; ++i) &#123; int u = rd(), v = rd(); e[u].pb(v); e[v].pb(u); &#125; dfs(1, 1); dsu(1, 1); return 0;&#125; CF 600 E. Lomsat gelral 一棵树每个点有一个颜色 \\(c_i\\) ，求每个点子树内出现次数最多的颜色的和。 对颜色维护 cnt 数组，由于 DSU 统计时只有加法，因此可以记录出现最多的次数 mx 和最多次数的颜色的和 res 。 每次 ++cnt[col[u]] 的时候讨论一下和 mx 的关系更新即可（见 upd 函数）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 100007#define pb push_backll ans[N], res;int cnt[N], col[N], mx;int sz[N], mxs[N];vector&lt;int&gt; e[N];void dfs(int u, int fa) &#123; sz[u] = 1; for (auto v : e[u]) if (v != fa) &#123; dfs(v, u); sz[u] += sz[v]; if (sz[v] &gt; sz[mxs[u]]) mxs[u] = v; &#125;&#125;inline void upd(int u) &#123; // adding information of u into data structures ++cnt[col[u]]; if (cnt[col[u]] &gt; mx) &#123;mx = cnt[col[u]]; res = col[u];&#125; else if (cnt[col[u]] == mx) res += col[u];&#125;inline void del(int u) &#123; // deleting information of u from data structures mx = 0; res = 0; cnt[col[u]] = 0;&#125;void upd(int u, int fa) &#123; upd(u); for (auto v : e[u]) if (v != fa) upd(v, u);&#125;void del(int u, int fa) &#123; del(u); for (auto v : e[u]) if (v != fa) del(v, u);&#125;void dsu(int u, int fa) &#123; for (auto v : e[u]) if (v != fa &amp;&amp; v != mxs[u]) &#123;dsu(v, u); del(v, u);&#125; if (mxs[u]) dsu(mxs[u], u); for (auto v : e[u]) if (v != fa &amp;&amp; v != mxs[u]) upd(v, u); upd(u); ans[u] = res;&#125;int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) col[i] = rd(); for (int i = 1; i &lt; n; ++i) &#123; int u = rd(), v = rd(); e[u].pb(v); e[v].pb(u); &#125; dfs(1, 1); dsu(1, 1); for (int i = 1; i &lt;= n; ++i) printf(&quot;%lld &quot;, ans[i]); return 0;&#125; CF 1009 F. Dominant Indices 给一棵树，对于每一个点求最小的 \\(k\\) ，使得子树内到他距离为 \\(k\\) 的点最多。 做法和上一题完全相同，每次更新的时候讨论，超过了 mx 直接覆盖 res ，等于 mx 和 res 取 \\(\\min\\) 。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;#define pic pair&lt;int, char&gt;#define lowbit(x) ((x) &amp; -(x))#define N 1000007int cnt[N], ans[N], mx, res;int sz[N], mxs[N], dep[N];vector&lt;int&gt; e[N];void dfs(int u, int fa) &#123; sz[u] = 1; dep[u] = dep[fa] + 1; for (auto v : e[u]) if (v != fa) &#123; dfs(v, u); sz[u] += sz[v]; if (sz[v] &gt; sz[mxs[u]]) mxs[u] = v; &#125;&#125;inline void upd(int u) &#123; // adding information of u into data structures ++cnt[dep[u]]; if (cnt[dep[u]] &gt; mx) &#123;mx = cnt[dep[u]]; res = dep[u];&#125; else if (cnt[dep[u]] == mx) res = min(res, dep[u]);&#125;inline void del(int u) &#123; // deleting information of u from data structures mx = 0; res = 0; cnt[dep[u]] = 0;&#125;void upd(int u, int fa) &#123; upd(u); for (auto v : e[u]) if (v != fa) upd(v, u);&#125;void del(int u, int fa) &#123; del(u); for (auto v : e[u]) if (v != fa) del(v, u);&#125;void dsu(int u, int fa) &#123; for (auto v : e[u]) if (v != fa &amp;&amp; v != mxs[u]) &#123;dsu(v, u); del(v, u);&#125; if (mxs[u]) dsu(mxs[u], u); for (auto v : e[u]) if (v != fa &amp;&amp; v != mxs[u]) upd(v, u); upd(u); ans[u] = res - dep[u];&#125;int main() &#123; int n = rd(); for (int i = 1; i &lt; n; ++i) &#123; int u = rd(), v = rd(); e[u].pb(v); e[v].pb(u); &#125; dfs(1, 1); dsu(1, 1); for (int i = 1; i &lt;= n; ++i) printf(&quot;%d\\n&quot;, ans[i]); return 0;&#125; CF 208 E. Blood Cousins 给一个森林，\\(q\\) 次问与 \\(u_i\\) 有共同的第 \\(k_i\\) 级祖先的点的个数。 询问其实与 \\(u_i\\) 关系不大，离线后是绑定在 \\(u_i\\) 的 \\(k_i\\) 级祖先上的，因此需要快速求 \\(k\\) 级祖先。 然后使用 DSU 求出 dep 的 cnt 数组即可，由于 DSU 本身也要用到轻重剖分，所以求祖先就也用树剖实现了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 100007#define fr first#define sc second#define pb push_back#define mp make_pair#define pii pair&lt;int, int&gt;int tot, dfn[N], seq[N], top[N], dep[N], ans[N], cnt[N], fa[N];int sz[N], mxs[N];vector&lt;int&gt; son[N];vector&lt;pii&gt; que[N];void dfs(int u) &#123; sz[u] = 1; for (auto v : son[u]) &#123; dfs(v); sz[u] += sz[v]; if (sz[v] &gt; sz[mxs[u]]) mxs[u] = v; &#125;&#125;void dfs2(int u, int t) &#123; top[u] = t; dfn[u] = ++tot; seq[tot] = u; if (mxs[u]) &#123;dep[mxs[u]] = dep[u] + 1; dfs2(mxs[u], t);&#125; for (auto v : son[u]) if (!dfn[v]) &#123;dep[v] = dep[u] + 1; dfs2(v, v);&#125;&#125;void upd(int u) &#123; ++cnt[dep[u]]; for (auto v : son[u]) upd(v);&#125;void del(int u) &#123; --cnt[dep[u]]; for (auto v : son[u]) del(v);&#125;void dsu(int u) &#123; for (auto v : son[u]) if (v != mxs[u]) &#123;dsu(v); del(v);&#125; if (mxs[u]) dsu(mxs[u]); for (auto v : son[u]) if (v != mxs[u]) upd(v); ++cnt[dep[u]]; for (auto q : que[u]) ans[q.sc] = cnt[dep[u] + q.fr] - 1;&#125;inline int anc(int u, int k) &#123; if (dep[u] &lt; k) return 0; int nw = u; while (dep[u] - dep[top[nw]] &lt; k) nw = fa[top[nw]]; return seq[dfn[nw] - (k - (dep[u] - dep[nw]))];&#125;int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) son[fa[i] = rd()].pb(i); for (auto u : son[0]) dfs(u); for (auto u : son[0]) dfs2(u, u); int q = rd(); for (int i = 1; i &lt;= q; ++i) &#123; int u = rd(), k = rd(); int w = anc(u, k); if (w == 0) continue; que[w].pb(mp(k, i)); &#125; for (auto u : son[0]) &#123;dsu(u); del(u);&#125; for (int i = 1; i &lt;= q; ++i) printf(&quot;%d &quot;, ans[i]); return 0;&#125; 另一种比较有意思的做法： 全部离线，DFS 时用栈记录从根到当前点的路径，得到 \\(k\\) 级祖先，复杂度 \\(\\mathcal O(n)\\) 。 将询问按深度分类，先将该深度的点加入数据结构，然后就相当于求 DFS 序上区间和。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;#define pic pair&lt;int, char&gt;#define lowbit(x) ((x) &amp; -(x))#define N 100007vector&lt;pii&gt; q[N], que[N];int tot, dfn[N], sz[N], ans[N], stk[N], c[N];vector&lt;int&gt; son[N], cur[N];inline void add(int p, int x) &#123; for (; p &lt; N; p += lowbit(p)) c[p] += x;&#125;inline int sum(int p) &#123; int res = 0; for (; p; p -= lowbit(p)) res += c[p]; return res;&#125;inline int sum(int l, int r) &#123; return sum(r) - sum(l - 1);&#125;void dfs(int u, int dep) &#123; sz[u] = 1; stk[dep] = u; cur[dep].pb(u); dfn[u] = ++tot; for (auto v : son[u]) &#123;dfs(v, dep + 1); sz[u] += sz[v];&#125; for (auto [k, id] : q[u]) if (dep &gt; k) que[dep].pb(mp(stk[dep - k], id));&#125;int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) son[rd()].pb(i); int m = rd(); for (int i = 1; i &lt;= m; ++i) &#123; int u = rd(), k = rd(); q[u].pb(mp(k, i)); &#125; for (auto u : son[0]) dfs(u, 1); for (int i = 1; i &lt;= n; ++i) &#123; for (auto u : cur[i]) add(dfn[u], 1); for (auto [u, id] : que[i]) ans[id] = sum(dfn[u], dfn[u] + sz[u] - 1) - 1; for (auto u : cur[i]) add(dfn[u], -1); &#125; for (int i = 1; i &lt;= m; ++i) printf(&quot;%d &quot;, ans[i]); return 0;&#125; CF 246 E. Blood Cousins Return 一棵树每个点上有一个字符串，多次询问 \\(u_i\\) 子树内深度为 \\(k\\) 的点对应的字符串集合中有多少个不同的。 还是上面那个问题，改成用一个 unordered_map 来计数每个深度的字符串即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 100007#define fr first#define sc second#define pb push_back#define mp make_pair#define pii pair&lt;int, int&gt;int dfn[N], top[N], dep[N], ans[N], tot, seq[N], fa[N];int sz[N], mxs[N];string nam[N];vector&lt;int&gt; son[N];vector&lt;pii&gt; que[N];unordered_map&lt;string, int&gt; cnt[N];void dfs(int u) &#123; sz[u] = 1; for (auto v : son[u]) &#123; dfs(v); sz[u] += sz[v]; if (sz[v] &gt; sz[mxs[u]]) mxs[u] = v; &#125;&#125;void dfs2(int u, int t) &#123; top[u] = t; dfn[u] = ++tot; seq[tot] = u; if (mxs[u]) &#123;dep[mxs[u]] = dep[u] + 1; dfs2(mxs[u], t);&#125; for (auto v : son[u]) if (!dfn[v]) &#123;dep[v] = dep[u] + 1; dfs2(v, v);&#125;&#125;inline void upd(int u) &#123; // adding information of u into data structures ++cnt[dep[u]][nam[u]];&#125;inline void del(int u) &#123; // deleting information of u from data structures --cnt[dep[u]][nam[u]]; if (!cnt[dep[u]][nam[u]]) cnt[dep[u]].erase(nam[u]);&#125;void upd(int u, int fa) &#123; upd(u); for (auto v : son[u]) upd(v, u);&#125;void del(int u, int fa) &#123; del(u); for (auto v : son[u]) del(v, u);&#125;void dsu(int u, int fa) &#123; for (auto v : son[u]) if (v != mxs[u]) &#123;dsu(v, u); del(v, u);&#125; if (mxs[u]) dsu(mxs[u], u); for (auto v : son[u]) if (v != mxs[u]) upd(v, u); upd(u); for (auto q : que[u]) &#123; int d = q.fr, id = q.sc; ans[id] = cnt[dep[u] + d].size(); &#125;&#125;int main() &#123; cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false); int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; nam[i] &gt;&gt; fa[i]; son[fa[i]].pb(i); &#125; for (auto u : son[0]) dfs(u); for (auto u : son[0]) dfs2(u, u); int q; cin &gt;&gt; q; for (int i = 1, u, k; i &lt;= q; ++i) &#123; cin &gt;&gt; u &gt;&gt; k; if (dep[u] + k &gt; n) continue; que[u].pb(mp(k, i)); &#125; for (auto u : son[0]) &#123;dsu(u, u); del(u, u);&#125; for (int i = 1; i &lt;= q; ++i) cout &lt;&lt; ans[i] &lt;&lt; endl; return 0;&#125; CF 570 D. Tree Requests 一棵树每个点上有一个字符，每次询问 \\(u_i\\) 子树内深度为 \\(k_i\\) 的所有点上的字符是否可以通过重排形成回文串。 形成回文串的条件是出现奇数次的字符至多一种。 用 DSU on Tree 维护 cnt[dep][c] 表示在 dep 这个深度上的点字符 c 的出现次数。 再用一个 odd[dep] 表示 cnt[dep][c] 是奇数的 c 的个数，询问 Yes 就是对应深度的 odd[dep] &lt;= 1 。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;#define pic pair&lt;int, char&gt;#define lowbit(x) ((x) &amp; -(x))#define N 500007bool ans[N];int cnt[N][26], ch[N], odd[N];int sz[N], mxs[N], dep[N];vector&lt;int&gt; son[N];vector&lt;pii&gt; que[N];void dfs(int u, int fa) &#123; sz[u] = 1; dep[u] = dep[fa] + 1; for (auto v : son[u]) &#123; dfs(v, u); sz[u] += sz[v]; if (sz[v] &gt; sz[mxs[u]]) mxs[u] = v; &#125;&#125;inline void upd(int u) &#123; // adding information of u into data structures ++cnt[dep[u]][ch[u]]; (cnt[dep[u]][ch[u]] &amp; 1) ? ++odd[dep[u]] : --odd[dep[u]];&#125;inline void del(int u) &#123; // deleting information of u from data structures cnt[dep[u]][ch[u]] = odd[dep[u]] = 0;&#125;void upd(int u, int fa) &#123; upd(u); for (auto v : son[u]) if (v != fa) upd(v, u);&#125;void del(int u, int fa) &#123; del(u); for (auto v : son[u]) if (v != fa) del(v, u);&#125;void dsu(int u, int fa) &#123; for (auto v : son[u]) if (v != fa &amp;&amp; v != mxs[u]) &#123;dsu(v, u); del(v, u);&#125; if (mxs[u]) dsu(mxs[u], u); for (auto v : son[u]) if (v != fa &amp;&amp; v != mxs[u]) upd(v, u); upd(u); for (auto [k, id] : que[u]) ans[id] = (odd[k] &lt;= 1);&#125;int main() &#123; int n = rd(), m = rd(); for (int i = 2; i &lt;= n; ++i) son[rd()].pb(i); char c = getchar(); while (!isalpha(c)) c = getchar(); for (int i = 1; i &lt;= n; ++i, c = getchar()) ch[i] = c - &#x27;a&#x27;; for (int i = 1; i &lt;= m; ++i) &#123; int u = rd(), k = rd(); que[u].pb(mp(k, i)); &#125; dfs(1, 1); dsu(1, 1); for (int i = 1; i &lt;= m; ++i) puts(ans[i] ? &quot;Yes&quot; : &quot;No&quot;); return 0;&#125; CF 375 D. Tree and Queries 一棵树每个点有一个颜色，每次询问 \\(u_i\\) 子树内出现次数超过 \\(k_i\\) 的颜色数。 DSU on Tree 求出来子树内颜色的出现次数 cnt 数组，再对 cnt 求出现次数 cnt' 数组，询问就是问 cnt' 的 \\(k_i\\) 后缀和。 因此很容易 \\(\\mathcal O(n\\log^2 n)\\) 做，额外再用一个树状数组维护 cnt' 就好了。 但实际上可以 \\(\\mathcal O(n\\log n)\\) 处理，我们实际在做：1. 对 cnt' 中某个位置 x 执行 --cnt'[x], ++cnt'[x+1]; 2. 求后缀和。 可以发现修改操作对后缀和数组的影响是 \\(\\mathcal O(1)\\) 的，所以我们可以直接在修改的同时维护每个位置的后缀和。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;#define pic pair&lt;int, char&gt;#define lowbit(x) ((x) &amp; -(x))#define N 100007int col[N], cnt[N], sum[N], ans[N];int sz[N], mxs[N], dep[N];vector&lt;int&gt; e[N];vector&lt;pii&gt; que[N];void dfs(int u, int fa) &#123; sz[u] = 1; dep[u] = dep[fa] + 1; for (auto v : e[u]) if (v != fa) &#123; dfs(v, u); sz[u] += sz[v]; if (sz[v] &gt; sz[mxs[u]]) mxs[u] = v; &#125;&#125;inline void upd(int u) &#123; // adding information of u into data structures ++sum[++cnt[col[u]]];&#125;inline void del(int u) &#123; // deleting information of u from data structures sum[cnt[col[u]]--]--;&#125;void upd(int u, int fa) &#123; upd(u); for (auto v : e[u]) if (v != fa) upd(v, u);&#125;void del(int u, int fa) &#123; del(u); for (auto v : e[u]) if (v != fa) del(v, u);&#125;void dsu(int u, int fa) &#123; for (auto v : e[u]) if (v != fa &amp;&amp; v != mxs[u]) &#123;dsu(v, u); del(v, u);&#125; if (mxs[u]) dsu(mxs[u], u); for (auto v : e[u]) if (v != fa &amp;&amp; v != mxs[u]) upd(v, u); upd(u); for (auto [k, id] : que[u]) ans[id] = sum[k];&#125;int main() &#123; int n = rd(), m = rd(); for (int i = 1; i &lt;= n; ++i) col[i] = rd(); for (int i = 1; i &lt; n; ++i) &#123; int u = rd(), v = rd(); e[u].pb(v); e[v].pb(u); &#125; for (int i = 1; i &lt;= m; ++i) &#123; int u = rd(), k = rd(); que[u].pb(mp(k, i)); &#125; dfs(1, 1); dsu(1, 1); for (int i = 1; i &lt;= m; ++i) printf(&quot;%d\\n&quot;, ans[i]); return 0;&#125; 2020 CCPC Changchun F. Strange Memory 给一棵树，每个点有一个权值 \\(a_i\\) ，求 \\(\\sum_{1\\le i&lt;j\\le n} [a_i\\oplus a_j=a_{lca(i,j)}] (i\\oplus j)\\) 直接 dsu on tree 会发现无法处理形如 \\(\\sum (w_i\\oplus x)\\) 的查询，因此可以按位统计（注意是节点编号的位数）。 每次将一个子树的答案先查出来再加入，因为 \\(a_i&gt;0\\) 所以不用考虑祖先后代关系的贡献。 总复杂度 \\(\\mathcal{O}(n\\log^2 n)\\) ，本题比较卡常，所以需要把所有轻儿子的子树点集预处理出来，省掉递归的常数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;#define pic pair&lt;int, char&gt;#define lowbit(x) ((x) &amp; -(x))#define N 1000007int cnt[N &lt;&lt; 1][2], mx, res;int sz[N], mxs[N], dep[N], a[N], b;ll ans;vector&lt;int&gt; e[N], subtree[N];void dfs(int u, int fa) &#123; sz[u] = 1; dep[u] = dep[fa] + 1; for (auto v : e[u]) if (v != fa) &#123; dfs(v, u); sz[u] += sz[v]; if (sz[v] &gt; sz[mxs[u]]) mxs[u] = v; &#125;&#125;void calc(int u, int fa, int w) &#123; for (auto v : e[u]) if (v != fa) calc(v, u, w);&#125;void dsu(int u, int fa) &#123; for (auto v : e[u]) if (v != fa &amp;&amp; v != mxs[u]) &#123; dsu(v, u); for (auto k : subtree[v]) cnt[a[k]][(k &gt;&gt; b) &amp; 1] = 0; &#125; if (mxs[u]) dsu(mxs[u], u); for (auto v : e[u]) if (v != fa &amp;&amp; v != mxs[u]) &#123; for (auto k : subtree[v]) ans += (1ll &lt;&lt; b) * cnt[a[k] ^ a[u]][((k &gt;&gt; b) &amp; 1) ^ 1]; for (auto k : subtree[v]) ++cnt[a[k]][(k &gt;&gt; b) &amp; 1]; &#125; ++cnt[a[u]][(u &gt;&gt; b) &amp; 1];&#125;void get_subtree(int u, int fa, int cur) &#123; subtree[cur].pb(u); for (auto v : e[u]) if (v != fa) get_subtree(v, u, cur);&#125;void dsu_tree(int u, int fa) &#123; for (auto v : e[u]) if (v != fa &amp;&amp; v != mxs[u]) get_subtree(v, u, v); for (auto v : e[u]) if (v != fa) dsu_tree(v, u);&#125;int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) a[i] = rd(); for (int i = 1; i &lt; n; ++i) &#123; int u = rd(), v = rd(); e[u].pb(v); e[v].pb(u); &#125; dfs(1, 1); dsu_tree(1, 1); for (b = 0; b &lt;= 16; ++b) &#123; dsu(1, 1); for (int u = 1; u &lt;= n; ++u) cnt[a[u]][0] = cnt[a[u]][1] = 0; &#125; printf(&quot;%lld\\n&quot;, ans); return 0;&#125; CF 741 D. Arpa’s letter-marked tree and Mehrdad’s Dokhtar-kosh paths 一棵树每条边上有一个字符 (a - v) ，每次询问 \\(u_i\\) 子树内最长的简单路径，满足其上的字符重排可形成回文串。 \\((u,v)\\) 路径信息 \\(=u\\) 到根信息 \\(+v\\) 到根信息 \\(-2*lca(u,v)\\) 到根信息。 字符集只有 \\(22\\) ，状压 \\(u\\) 到根每个字符的奇偶性 \\(s_u\\) ，路径信息即为 \\(s_u\\oplus s_v\\) （lca 信息因为异或两次消掉了） 考虑路径合并，每个点可能的配对方案只有 \\(23\\) 种（异或后为 \\(0\\) 或 \\(2\\) 的幂次，即最多允许一个字符出现奇数次） DSU on Tree，统计此前子树的信息，维护每个状压值的最深深度，保证 lca 是当前点需整个子树先查询后插入。 写挂的地方：1. 子树内最长要和儿子的 ans 取 \\(\\max\\) ；2.枚举配对的状态时，得保证存在再更新。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;#define pic pair&lt;int, char&gt;#define lowbit(x) ((x) &amp; -(x))#define N 500007int ch[N], sta[N], mxd[1 &lt;&lt; 22], ans[N], res;int sz[N], mxs[N], dep[N];vector&lt;int&gt; son[N];void dfs(int u, int fa, int S) &#123; sz[u] = 1; dep[u] = dep[fa] + 1; if (u != 1) S ^= (1 &lt;&lt; ch[u]); sta[u] = S; for (auto v : son[u]) &#123; dfs(v, u, S); sz[u] += sz[v]; if (sz[v] &gt; sz[mxs[u]]) mxs[u] = v; &#125;&#125;inline void upd(int u) &#123; // adding information of u into data structures mxd[sta[u]] = max(mxd[sta[u]], dep[u]);&#125;inline void del(int u) &#123; // deleting information of u from data structures mxd[sta[u]] = 0; res = 0;&#125;void upd(int u, int fa) &#123; upd(u); for (auto v : son[u]) if (v != fa) upd(v, u);&#125;void del(int u, int fa) &#123; del(u); for (auto v : son[u]) if (v != fa) del(v, u);&#125;void updans(int u, int del) &#123; // 枚举配对的状态需要保证存在！！！ if (mxd[sta[u]]) res = max(res, dep[u] + mxd[sta[u]] - 2 * del); for (int i = 0; i &lt; 22; ++i) if (mxd[sta[u] ^ (1 &lt;&lt; i)]) res = max(res, dep[u] + mxd[sta[u] ^ (1 &lt;&lt; i)] - 2 * del);&#125;void getans(int u, int del) &#123; updans(u, del); for (auto v : son[u]) getans(v, del);&#125;void dsu(int u, int fa) &#123; for (auto v : son[u]) if (v != fa &amp;&amp; v != mxs[u]) &#123;dsu(v, u); del(v, u);&#125; if (mxs[u]) dsu(mxs[u], u); updans(u, dep[u]); upd(u); for (auto v : son[u]) if (v != fa &amp;&amp; v != mxs[u]) &#123; getans(v, dep[u]); res = max(res, ans[v]); upd(v, u); &#125; ans[u] = res;&#125;int main() &#123; int n = rd(); for (int i = 2; i &lt;= n; ++i) &#123; son[rd()].pb(i); char c = getchar(); while (!isalpha(c)) c = getchar(); ch[i] = (c - &#x27;a&#x27;); &#125; dfs(1, 1, 0); dsu(1, 1); for (int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, ans[i]); return 0;&#125; HDU 7255 Expected Inversions 换根 + DSU on Tree 统计信息，见多校题解。","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://blog.gyx.me/categories/Algorithms/"}],"tags":[{"name":"DFS and Similar","slug":"DFS-and-Similar","permalink":"http://blog.gyx.me/tags/DFS-and-Similar/"}]},{"title":"AtCoder Beginner Contest 266","slug":"atcoder/abc266","date":"2022-08-30T13:58:14.000Z","updated":"2023-03-20T16:28:23.288Z","comments":true,"path":"atcoder/abc266/","link":"","permalink":"http://blog.gyx.me/atcoder/abc266/","excerpt":"","text":"ABCD 比较简单就不写了。 E. Throwing the Die 有 \\(k\\) 次掷骰子的机会，可以任意时刻喊停，得分就是停的时候骰子向上的数字，问最优策略期望得分。 期望要倒着算。设 \\(f[x]\\) 表示可以掷 \\(x\\) 次的最优期望得分，首先有 \\(f[1] = 3.5\\) 。 接下来考虑 \\(f[i]\\) 已知求 \\(f[i + 1]\\) ：枚举第 \\(i+1\\) 次的六种可能情况，如果本次得分比 \\(f[i]\\) 要大就不会再投了，否则会继续投。 因此方程为 \\(f[i + 1] =\\frac{1}{6}\\sum_{j=1}^6j\\times\\big[j &gt; f[i]\\big]+f[i]\\times \\big[j \\le f[i]\\big]\\) 。 12345678910111213int main() &#123; int n = rd(); double f[101] = &#123;0, 3.5&#125;; for (int i = 2; i &lt;= n; ++i) &#123; f[i] = 0; for (int j = 1; j &lt;= 6; ++j) &#123; if (1.0 * j &lt; f[i - 1]) f[i] += f[i - 1] / 6; else f[i] += j / 6.0; &#125; &#125; printf(&quot;%.10lf\\n&quot;, f[n]); return 0;&#125; F. Well-defined Path Queries on a Namori 给一棵无向基环树，\\(q\\) 次问 \\(u_i\\) 和 \\(v_i\\) 之间的简单路径是否唯一。 路径不经过环就唯一，因此拓扑把环找出来删掉，如果两个点在同一棵树内答案就是 Yes 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 200007#define pb push_backvector&lt;int&gt; e[N];bool vis[N];int deg[N];queue&lt;int&gt; q;int col[N], cnt;void dfs(int u, int c) &#123; for (auto v : e[u]) if (!col[v]) &#123; col[v] = c; dfs(v, c); &#125;&#125;int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; int u = rd(), v = rd(); e[u].pb(v); e[v].pb(u); ++deg[u]; ++deg[v]; &#125; for (int i = 1; i &lt;= n; ++i) if (deg[i] == 1) &#123;vis[i] = true; q.push(i);&#125; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (auto v : e[u]) if (!vis[v]) &#123; --deg[v]; if (deg[v] == 1) &#123; vis[v] = true; q.push(v); &#125; &#125; &#125; for (int i = 1; i &lt;= n; ++i) if (!vis[i]) col[i] = ++cnt; for (int i = 1; i &lt;= n; ++i) if (!vis[i]) dfs(i, col[i]); for (int q = rd(); q; --q) &#123; int u = rd(), v = rd(); puts(col[u] == col[v] ? &quot;Yes&quot; : &quot;No&quot;); &#125; return 0;&#125; G. Yet Another RGB Sequence 计数 \\(R\\) 个 r ，\\(G\\) 个 g ，\\(B\\) 个 b 的字符串，且其中rg 子串恰好 \\(k\\ (k\\le \\min(R,G))\\) 个。 先数出来 \\(k\\) 个 rg 、\\(G-k\\) 个 g 、\\(B\\) 个 b 的字符串个数是 \\(\\frac{(G+B)!}{k!(G-k)!B!}\\) （多重集的排列） 再将剩下的 \\(R-k\\) 个 r 插进去，因为不能插在 g 前面，所以只能插在 rg 或 b 的前面（及最后） 因此就是 \\(B+k\\) 个隔板和 \\(R-k\\) 个球的排列个数问题，方案数为 \\({R+B\\choose R-k}\\) ，两部分乘起来即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 2000007#define mod 998244353int fac[N], ifac[N];inline int fpow(int x, int t) &#123; int res = 1; for (; t; t &gt;&gt;= 1, x = 1ll * x * x % mod) if (t &amp; 1) res = 1ll * res * x % mod; return res;&#125; inline void init() &#123; fac[0] = ifac[0] = 1; for (int i = 1; i &lt; N; ++i) fac[i] = 1ll * fac[i - 1] * i % mod; ifac[N - 1] = fpow(fac[N - 1], mod - 2); for (int i = N - 2; i; --i) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % mod;&#125; inline int C(int n, int m) &#123; if (n &lt; m) return 0; return 1ll * fac[n] * ifac[m] % mod * ifac[n - m] % mod;&#125;int main() &#123; init(); int r = rd(), g = rd(), b = rd(), k = rd(); r -= k; g -= k; int ans = 1ll * fac[g + b + k] * ifac[g] % mod * ifac[b] % mod * ifac[k] % mod; b += k; printf(&quot;%lld\\n&quot;, 1ll * ans * C(r + b, r) % mod); return 0;&#125; Ex. Snuke Panic (2D) 二维平面上 \\(n\\ (n\\le 10^5)\\) 个点，位于 \\((x_i,y_i)\\) ，出现时间 \\(t_i\\) ，价值 \\(a_i\\) 。 开始你在 \\((0,0)\\) ，每秒四选一：\\(x\\) 方向 \\(+1/-1/y\\) 方向 \\(+1/\\) 不动。 恰好在 \\(t_i\\) 时刻到达 \\((x_i,y_i)\\) ，可以获得 \\(a_i\\) ，求能得到的最大价值。 直接设 \\(f[t][x][y]\\) 表示前 \\(t\\) 秒， \\(t\\) 时在 \\((x,y)\\) 能得到的最大价值；设 \\(val(t,x,y)\\) 表示 \\(t\\) 时刻 \\((x,y)\\) 的价值。 \\[ f[t][x][y]= \\max \\{f[t&#39;][x&#39;][y&#39;]\\ |\\ t&#39; \\le t, y&#39; \\le y, |x-x&#39;|+y-y&#39;\\le t - t&#39;\\} + val(t,x,y) \\] 由后两个限制条件有 \\(t-t\\ge y - y&#39;\\ge 0\\) 因此第一个条件可以丢掉，剩下的条件写为： \\[ \\left\\{ \\begin{array}{l} y&#39; \\le y\\\\ x - x&#39; + y - y&#39; \\le t - t&#39;\\\\ x&#39;-x + y - y&#39; \\le t - t&#39; \\end{array} \\right. \\ \\ \\Longrightarrow \\left\\{ \\begin{array}{l} y&#39; \\le y\\\\ t&#39; - x&#39; - y&#39; \\le t - x - y\\\\ t&#39; + x&#39; - y&#39; \\le t + x - y \\end{array} \\right. \\] 可以发现做个线性变换之后是个三维偏序，令 \\(a=t-x-y,b=t+x-y\\) ，有： \\[ f[a][b][y] = \\max\\{f[a&#39;][b&#39;][y&#39;]\\ |\\ a&#39;\\le a, b&#39;\\le b, y&#39;\\le y \\} + val(a,b,y) \\] 三维都从小到大排序后可以去掉一维，剩下两维用二维树状数组维护即可，答案显然只会在 \\(val(a,b,y)\\) 有值处统计到。 但是即使离散化的二维树状数组也开不下，需要将一维用 unordered_map 代替，时空复杂度均为 \\(\\mathcal O(n\\log^2n)\\) 。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define pb push_back#define lowbit(x) ((x) &amp; -(x))#define all(x) (x).begin(), (x).end()#define N 100007struct node &#123;int y, a, b, w;&#125; g[N];vector&lt;int&gt; A, B;int X, Y;unordered_map&lt;int, ll&gt; c[N];inline ll max(ll a, ll b) &#123;return a &gt; b ? a : b;&#125;inline void upd(int x, int y, ll w) &#123; for (int i = x; i &lt;= X; i += lowbit(i)) for (int j = y; j &lt;= Y; j += lowbit(j)) c[i][j] = max(c[i][j], w);&#125;inline ll qmax(int x, int y) &#123; ll res = 0; for (int i = x; i; i -= lowbit(i)) for (int j = y; j; j -= lowbit(j)) res = max(res, c[i][j]); return res;&#125;int main() &#123; int n = rd(), m = 0; for (int i = 1; i &lt;= n; ++i) &#123; int t = rd(), x = rd(), y = rd(), w = rd(); if (t - x - y &lt; 0 || t + x - y &lt; 0) continue; g[++m].y = y; g[m].w = w; g[m].a = t - x - y; A.pb(g[m].a); g[m].b = t + x - y; B.pb(g[m].b); &#125; n = m; auto cmp = [&amp;](node a, node b) &#123; if (a.y != b.y) return a.y &lt; b.y; if (a.a != b.a) return a.a &lt; b.a; return a.b &lt; b.b; &#125;; sort(g + 1, g + 1 + n, cmp); sort(all(A)); A.erase(unique(all(A)), A.end()); X = A.size(); sort(all(B)); B.erase(unique(all(B)), B.end()); Y = B.size(); ll ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; int a = lower_bound(all(A), g[i].a) - A.begin() + 1; int b = lower_bound(all(B), g[i].b) - B.begin() + 1; ll nw = qmax(a, b) + g[i].w; ans = max(ans, nw); upd(a, b, nw); &#125; printf(&quot;%lld\\n&quot;, ans); return 0;&#125;","categories":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://blog.gyx.me/categories/AtCoder/"},{"name":"AtCoder Beginner Contest","slug":"AtCoder/AtCoder-Beginner-Contest","permalink":"http://blog.gyx.me/categories/AtCoder/AtCoder-Beginner-Contest/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"},{"name":"Counting","slug":"Counting","permalink":"http://blog.gyx.me/tags/Counting/"},{"name":"Fenwick Tree","slug":"Fenwick-Tree","permalink":"http://blog.gyx.me/tags/Fenwick-Tree/"}]},{"title":"AtCoder Beginner Contest 259","slug":"atcoder/abc259","date":"2022-07-13T13:58:14.000Z","updated":"2023-03-20T16:28:18.055Z","comments":true,"path":"atcoder/abc259/","link":"","permalink":"http://blog.gyx.me/atcoder/abc259/","excerpt":"","text":"A - Growth Record 主人公 \\(N\\) 岁的时候身高是 \\(T\\) , 已知他 \\([1,X]\\) 期间每年长 \\(D\\) ，后面不长个子，问 \\(M\\) 岁的时候身高多少 \\(0\\) 岁的身高是 \\(T−X\\times D\\) ，然后分情况讨论。 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;int main() &#123; int n = rd(), m = rd(), x = rd(), t = rd(), d = rd(); int st = t - x * d; if (m &gt; x) printf(&quot;%d\\n&quot;, t); else printf(&quot;%d\\n&quot;, st + m * d); return 0;&#125; B - Counterclockwise Rotation 给定坐标 \\((x,y)\\) 问绕原点逆时针旋转 \\(d\\) 角度后的坐标。 坐标为 \\(x^{\\prime}=x * \\cos d-y * \\sin d, y^{\\prime}=x * \\sin d+y * \\cos d\\)，可以用各种方法(诱导公式/旋转矩阵)推。 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;using ld = long double;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;const ld PI = 3.1415926535;struct vec &#123; ld x, y; vec turn (ld ang) &#123; // 逆时针旋转 ang 角度 ld cosa = cos(ang), sina = sin(ang); return (vec)&#123;x * cosa - y * sina, x * sina + y * cosa&#125;; &#125;&#125;;int main() &#123; vec a; a.x = rd(); a.y = rd(); ld d = rd() / 180.0 * PI; a = a.turn(d); printf(&quot;%.10Lf %.10Lf\\n&quot;, a.x, a.y); return 0;&#125; C - XX to XXX 给定两个串 \\(S\\) 和 \\(T\\), 每次可以向 \\(S\\) 中相邻且相同的两个字符中间塞一个相同的字符。问若干次操作后 \\(S\\) 是否能变成 \\(T\\) 。 考虑双指针 \\(\\left(p t r_s, p t r_t\\right)\\), 从头对齐往后扫描，每次先不考虑扩张, 能不能匹配上。 如果不能匹配上，即 \\(S\\left[p t r_s\\right] \\neq T\\left[p t r_t\\right]\\), 那么 \\(T\\left[p t r_t\\right]\\) 只能往回看，尝试用 \\(S\\left[p t r_s-1\\right]\\) 和 \\(S\\left[p t r_s-2\\right]\\) 来扩张, 否则无解。 记得最后要判断一下两个串的指针是否都走到了结尾。 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;#define N 200007char s[N], t[N];int main() &#123; scanf(&quot;%s&quot;, s + 1); scanf(&quot;%s&quot;, t + 1); int n = strlen(s + 1); int m = strlen(t + 1); int ptr = 1; for (int i = 1; i &lt;= m; ++i) &#123; if (s[ptr] == t[i]) &#123;++ptr; continue;&#125; if (s[ptr - 1] != t[i]) &#123;puts(&quot;No&quot;); return 0;&#125; if (ptr &lt;= 1 || s[ptr - 1] != s[ptr - 2]) &#123; puts(&quot;No&quot;); return 0; &#125; &#125; puts(ptr == n + 1 ? &quot;Yes&quot; : &quot;No&quot;); return 0;&#125; D - Circumferences 给定二维平面上的 \\(n\\) 个圆, 以及某个圆上的起点和某个圆上的终点。 只能走圆的边界 (可以通 过两圆交点更换所在的圆），问能否从起点走到终点? 并查集判连通性, 数据范围只需要 \\(n^2\\) 暴力枚举判断是否有交点即可。 判断两圆有交点：不相离也不包含。 相离：圆心距大于两圆半径之和。 包含：圆心距小于两圆半径之差的绝对值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 3007ll x[N], y[N], r[N];int f[N];int find(int x) &#123; return x == f[x] ? x : (f[x] = find(f[x]));&#125;inline ll sqr(ll x) &#123;return x * x;&#125;int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) f[i] = i; int sx = rd(), sy = rd(); int tx = rd(), ty = rd(); for (int i = 1; i &lt;= n; ++i) &#123; x[i] = rd(); y[i] = rd(); r[i] = rd(); &#125; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) &#123; if (sqr(x[i] - x[j]) + sqr(y[i] - y[j]) &gt; sqr(r[i] + r[j])) continue; if (sqr(x[i] - x[j]) + sqr(y[i] - y[j]) &lt; sqr(r[i] - r[j])) continue; int u = find(i), v = find(j); f[u] = v; &#125; int px, py; for (int i = 1; i &lt;= n; ++i) &#123; if (sqr(sx - x[i]) + sqr(sy - y[i]) == sqr(r[i])) px = i; if (sqr(tx - x[i]) + sqr(ty - y[i]) == sqr(r[i])) py = i; &#125; puts(find(px) == find(py) ? &quot;Yes&quot; : &quot;No&quot;); return 0;&#125; E - LCM on Whiteboard 给定 \\(n\\) 个数字的标准分解, 将其中的某一个变成 \\(1\\) , 问操作后所有数字的最小公倍数有多少种不同的可能性? 结论是所有数字的最小公倍数等于 每个质因数的指数 取 所有数字对应质因数指数的 \\(\\max\\)。 一个数字变成 \\(1\\) 相当于对于 LCM 什么都不提供, 那么什么时候会导致 LCM 变化呢? 首先他的某一个质因数指数要和 LCM 对应的相同, 其次这个最大值在所有数字中是唯一的。 两个 unordered_map 实现： mx[i] 记录质因数 \\(i\\) 出现过的最大指数是多少, cnt[i] 记录有多少个数字对应这个最大指数。 那么一个数字有贡献也就对应于 e[i]==mx[i] &amp;&amp; cnt[i]==1 。 此外没有影响的所有数字总体会对答案产生一个贡献, 即原本所有数的 LCM 。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;using ld = long double;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 200007#define fr first#define sc second#define pb push_back#define mp make_pair#define pii pair&lt;int, int&gt;unordered_map&lt;int, int&gt; mx, cnt;vector&lt;pii&gt; s[N];int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; int m = rd(); for (int j = 1; j &lt;= m; ++j) &#123; int a = rd(), b = rd(); s[i].pb(mp(a, b)); if (mx[a] &lt; b) &#123;mx[a] = b; cnt[a] = 1;&#125; else if (mx[a] == b) ++cnt[a]; &#125; &#125; bool fl = 0; int ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; bool tag = 0; for (auto [a, b] : s[i]) &#123; if (mx[a] == b &amp;&amp; cnt[a] == 1) &#123;tag = 1; break;&#125; &#125; if (tag) ++ans; else fl = 1; &#125; ans += fl; printf(&quot;%d\\n&quot;, ans); return 0;&#125; F - Select Edges 给定一棵树, 每条边有一个边权 \\(w\\), 每个点有一个限制 \\(d_i\\) 。 选一个边集, 使得每个点相邻的边在这个集合里的个数不超过 \\(d_i\\), 并且最大化集合里边的 \\(\\sum w\\) 。 设 \\(f[i][0 / 1]\\) 表示节点 \\(i\\) 及其子树内, 是否要选 \\(i\\) 到父亲的边 \\((0/1)\\) ， 能得到的最大价值。 不选到父亲的边: 就是最多把 \\(d_i\\) 个儿子的贡献从 \\(f [son] [0]\\) 改为 \\(f[s o n] [1] +w[u][son]\\) ，挑能贡献最多的选（修改后较修改前差值最大的 \\(d_i\\) 个) 选到父亲的边： 就是最多把 \\(d_i-1\\) 个儿子的贡献从 \\(f [son] [0]\\) 改为 \\(f[s o n] [1] +w[u][son]\\) ; 特殊的如果 \\(d_i=0\\) 则 \\(f[i][1]=-\\mathrm{inf}\\) 直接 DP 就好了, 复杂度是 \\(O(n \\log n)\\) 的（因为涉及到儿子贡献的排序）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;using ld = long double;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 300007#define fr first#define sc second#define pb push_back#define mp make_pair#define pii pair&lt;int, int&gt;vector&lt;pii&gt; e[N];vector&lt;ll&gt; tmp;int d[N];ll f[N][2];void dfs(int u, int fa) &#123; ll sum = 0; for (auto [v, w] : e[u]) if (v != fa) dfs(v, u); tmp.clear(); for (auto [v, w] : e[u]) if (v != fa) &#123; sum += f[v][0]; tmp.push_back(f[v][1] + w - f[v][0]); &#125; sort(tmp.begin(), tmp.end()); reverse(tmp.begin(), tmp.end()); if (d[u] == 0) &#123; f[u][0] = sum; f[u][1] = -1e18; &#125; else &#123; f[u][0] = f[u][1] = sum; int len = tmp.size(); for (int i = 0; i &lt; len; ++i) &#123; if (tmp[i] &lt; 0) break; if (i &lt; d[u]) f[u][0] += tmp[i]; if (i &lt; d[u] - 1) f[u][1] += tmp[i]; &#125; &#125;&#125;int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) d[i] = rd(); for (int i = 1; i &lt; n; ++i) &#123; int u = rd(), v = rd(), w = max(0, rd()); e[u].pb(mp(v, w)); e[v].pb(mp(u, w)); &#125; dfs(1, 1); printf(&quot;%lld\\n&quot;, max(f[1][0], f[1][1])); return 0;&#125; G - Grid Card Game 给定一个数字矩阵 \\((1\\le H,W\\le 100)\\) ，选定一些行一些列，使得： 负数的位置所在行列不能同时选中。 定义一个位置被覆盖当且仅当所在行/列被覆盖，最大化被覆盖的位置权值和。 假设把所有非负数都选了，考虑最小割表示选择需要产生的代价，两排点左边表示行右边表示列。 假如选第 \\(i\\) 行，代价就是该行的负值的和 \\((S, R_i,-\\sum_j\\left[A_{i, j}&lt;0\\right] A_{i j})\\) 假如选第 \\(i\\) 列，代价就是该列的负值的和 \\((C_i, T,-\\sum_j\\left[A_{j, i}&lt;0\\right] A_{j i})\\) 接下来两排点之间的边表示对应格子的状态，割掉表示选择了对应行列都未选 若 \\(A_{x,y}\\ge 0\\) ，则行列都未选的代价就是扣掉这个位置的贡献 \\((R_i, C_j,A_{i j})\\) 若 \\(A_{x,y}&lt;0\\) ，则所在行列不能同时选，即不允许左右都被割掉，那么限制的方法就是强制中间的边被割，即 Ex - Yet Another Path Counting 给定一个矩阵 \\(A_{n \\times n}(1 \\leq n \\leq 400)\\), 从某个格子出发, 每次可以向右或向下走。问起点终点的数字相同的路径有多少条? 首先枚举数字是多少，然后考虑计算这个数字对应的所有点之间的贡献。根据每种数字出现次数讨论: 如果出现次数不超过 \\(n\\), 那么直接暴力枚举任意两个位置算贡献, 答案是 \\(\\left(\\begin{array}{c}\\Delta x+\\Delta y \\\\ \\Delta x\\end{array}\\right)\\) 。 复杂度是 \\(O\\left(\\sum_{\\sum c n t_i=n^2, c n t_i \\leq n} c n t_i^2\\right) \\leq O\\left(n \\times n^2\\right)=O\\left(n^3\\right)\\) ，用 \\(a^2+b^2 \\leq(a+b)^2\\) 放缩一下。 如果出现次数超过 \\(n\\), 那么种类数不会超过 \\(n\\) 个, 对每种颜色跑一个 \\(O\\left(n^2\\right)\\) 的 DP： 这个 DP 和 AGC001E 的方法是一样的，设 f[i][j] 表示所有可能的起点走到 \\((i,j)\\) 的总方案数。 f[i][j] = f[i - 1][j] + f[i][j - 1] ，此外如果这个点是我们要的颜色还要 f[i][j]++ 。 因此总复杂度也是 \\(O(n^3)\\) 的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;using ld = long double;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 1007#define NN 407#define M 160007#define mod 998244353#define pb push_back#define mp make_pair#define pii pair&lt;int, int&gt;int n, c[N][N], a[NN][NN], f[NN][NN], ans;vector&lt;pii&gt; pos[M];inline void calc(int col) &#123; memset(f, 0, sizeof(f)); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) &#123; f[i][j] = (f[i - 1][j] + f[i][j - 1]) % mod; if (a[i][j] == col) &#123; f[i][j] = (f[i][j] + 1) % mod; ans = (ans + f[i][j]) % mod; &#125; &#125;&#125;int main() &#123; c[0][0] = 1; for (int i = 1; i &lt; N; ++i) &#123; c[i][0] = 1; for (int j = 1; j &lt;= i; ++j) c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % mod; &#125; n = rd(); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) &#123; a[i][j] = rd(); pos[a[i][j]].push_back(mp(i, j)); &#125; for (int i = n * n; i; --i) &#123; if (pos[i].size() &gt; n) calc(i); else &#123; int sz = pos[i].size(); for (int j = 0; j &lt; sz; ++j) for (int k = 0; k &lt; sz; ++k) &#123; auto [sx, sy] = pos[i][j]; auto [tx, ty] = pos[i][k]; if (tx &lt; sx || ty &lt; sy) continue; ans = (ans + c[tx - sx + ty - sy][tx - sx]) % mod; &#125; &#125; &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125;","categories":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://blog.gyx.me/categories/AtCoder/"},{"name":"AtCoder Beginner Contest","slug":"AtCoder/AtCoder-Beginner-Contest","permalink":"http://blog.gyx.me/categories/AtCoder/AtCoder-Beginner-Contest/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"},{"name":"Number Theory","slug":"Number-Theory","permalink":"http://blog.gyx.me/tags/Number-Theory/"},{"name":"Threshold Optimization","slug":"Threshold-Optimization","permalink":"http://blog.gyx.me/tags/Threshold-Optimization/"},{"name":"Counting","slug":"Counting","permalink":"http://blog.gyx.me/tags/Counting/"}]},{"title":"Sophomore Year","slug":"summary/sophomore","date":"2022-07-05T14:14:43.000Z","updated":"2023-10-16T13:23:16.944Z","comments":true,"path":"summary/sophomore/","link":"","permalink":"http://blog.gyx.me/summary/sophomore/","excerpt":"","text":"今天是 2021 年 7 月 6 日，星期三。 两年前的今天，高考的前夜。担心感冒不敢开空调，燥热地躺在床上，辗转反侧。 碰巧昨晚又梦到了还在高中，困扰在时时刻刻的恐惧中，惊醒后久久才反应过来，已经上了两年大学了。 正好今天 22 级班助的聘用正式确定下来了，大二的生活算是尘埃落定，回顾一下这一年。 算法竞赛 首先谈竞赛，这一年算是经历了很多事情，打了一年的银，但是对竞赛的感情经历了很多变化。 大概从去年 7 月份的沈阳银首开始，自己进入了一个目标很不明确的时期。 暑假多校打的一般，除此外也没有进行太多的训练。队内排名基本稳定在第三名的位置（和前后都有一定距离）。 温水煮青蛙，没有紧张感，也没有什么太具体的目标。就这样浑浑噩噩的打了网络赛、CCPC 桂林银、ICPC 沈阳银。 寒假安排的很紧，除了算法竞赛还插了数模美赛集训、DL &amp; CV 的假期交流课程、兼职教小孩 C 语言。 但就最后的结果来看，寒假可以说碌碌无为。美赛拿了 S 奖，线上交流没学到太多，竞赛的刷题量只能说保持水平。 如何评价 2022 年 ICPC 昆明赛区？ 开学之后为了备战省赛和昆明，训练量加了不少，也是有点魔怔的一段时间。 3 月某天看到了一个人的 CodeForces 满屏绿色，有点受刺激，于是自己也离谱地连续打卡了近 50 天。 期间课几乎都没听，作业都尽量用最短的时间解决掉了，计组实验也和冯老师说全部都堆到比赛后验收。 于是到了浙江省赛和昆明。因为疫情各种延期，两个比赛在同一个周末的两天举办。 省赛打的很顺利，前两个小时几次榜一，最后因为做不动期望题 E 拿了第四，不过也算是不错的成绩。 昆明打之前觉得一切准备的都还不错，甚至还有 Eva 在做志愿者，应该会很踏实。 然而正赛开始之后就傻眼了。首先是大量的期望概率题目，签到想不出来；接下来比赛节奏完全没体验过，1h 过了一题，然后一直持续到 4h 才有过题。期间一直让自己冷静下来，安慰自己把有想法的题都过了就没问题，但是心里一直很慌。直到最后真的三题结束了，自己还没有反应过来发生了什么。 印象很深的是 Eva 走过来坐在我旁边，哭了出来，我问她为什么哭，她说真的替我很伤心。 反应过来之后，想想自己花了大半个学期训练，课程都快结束了，什么都没开始学；竞赛也没拿到想要的奖项，甚至差两名就要打铜；正逢当天是 2022 的多省联合省选。一切都让我回忆起了当年省选退役时那段黑暗的日子，无力挣扎，也很想哭。 当晚自然是又做了噩梦，时间线十分的混乱，又是刚退役回去学文化课，又是赛场上自己一个又一个错误的决定。 仿佛自己又要面对竞赛打的不好就会退役，退役就要回去面对那段整日担惊受怕、生活在高压和恐惧中的文化课生活。 昆明之后经历的生活也确实像高中退役后补欠下的债，上课听不懂，作业不会做，计算机组成原理四五个大实验一点还没开始写（甚至是还没学会）。最噩梦的是期末季也开始了，在大家都开始复习的时候，自己从头开始。 之后五月的某天，因为要宣传这个赛季的结果，集训队开了一次会，然后拍集体照。 开会的时候，刘老师谈到了暑假组队的事情：“原则上自由组队，大家敞开说，原有的队伍也可以重组，不要拿队伍磨合的好说事情，留给磨合的时间有很多。” 听完我突然有了重组的想法，虽然昆明爆炸的主要原因是我决策失误，但是这个赛季的队伍确实也有明显的问题。 之后也有两个比较巧合的事情让我真的开始思考这件事情。一个是在高级数据结构课上，刘老师突然问我，我们队要不要重组。另一个是恰好有一个实力比较强的队伍会拆散，其中一个队员的长处我认为比较互补。 但是提出换队友这个事情确实比较尴尬，首先打了一年银并不是某一个人的问题，其次确实这只是我自己的想法。自己根本不知道该如何开口商量这个事情，如果真的换了，我也不知道应该怎么面对被换出去的队友。 经历了很长一段的权衡后，我终于还是和刘老师商量了这个事情。第二天刘老师给我的答复是：如果所有人都同意，他可以同意。那天纠结了很久，最后一口气和相关的所有人都聊完了。中间聊天的过程真的很害怕，自己不知道怎么开口，也不好意思开口。但好在最后所有人都同意了，更换的队友也和另外两个很强的选手重新组了队伍。 真的很感谢涉及到这个艰难的过程的所有人，大家都因为我的选择或多或少受到了一些影响，尤其是被换出去的队友。到现在我还是很内疚，真的很感谢他能理解我的想法。 接下来的比赛只剩下了校赛，第 26 次 CSP 和蓝桥杯的国赛。这段时间几乎都在做期末大作业，偶尔做几道题保持水平。 但意外的是这几场比赛打的都还可以，杭电校赛靠手速拿到了一等奖，CSP - 26 靠卡常 AK 了。如何评价 CSP - 26？ 此外 5 月底的时候刘老师找到我，让我作为负责人组织一下今年广西省赛的出题，兴奋又有点紧张。 于是在期末前的几个星期，拉了出题团队，大家一起挤时间出题造题，还在考试周期间拉了几个集训队员验题。 期末最后一门考完当晚开始赶工题目的最后一部分，配置spj 到了半夜两点多，第二天早上修 pdf 版题面又发现了好多语法错误，改完反复读了好几遍之后终于在 ddl 前整理好了。 好在最后两天的比赛都很圆满，第一次做正式比赛的负责人，感觉收获很多（ 至少学会了用 PTA 和 Polygon ）。 把 Colin 和 Eva 的名字留在一场正式赛的题面里，以及给好多人讲题都是曾经的梦想啊。如何评价第五届GXCPC？ 总而言之，这一年的竞赛经历虽然比较曲折，但也确实让我认真地思考了自己到底想要什么。 下一个赛季大概率是最后一年参赛了，希望自己在想要摆烂的时候能从这一年的经历中汲取动力，加油。 课内学习 单从成绩上来看，和大一相比可能课程难度降低了，所以成绩比大一要好一些。 大二上意外地打出了历史最高绩点；大二下某门学分很重的课因为某些原因爆炸了，绩点没稳住，不过也过去了。 成绩撇开不谈，记录几门我觉得很收获很多或值得推荐的课程和老师，仅供参考。 形式语言与自动机（黄孝喜老师）：收获主要是此前对这个领域了解很少，上完能比较充分的了解到这个领域的一些基础模型，学编译的时候也能轻松些。课程中涉及到很多非常好玩的小算法，其中的构造思路也是比较有意义的。我最后期末考前还在沉迷构造图灵机无法自拔（虽然非常遗憾期末不考） 数字电路/计算机组成原理（冯建文老师）：作为一个对硬件十分反感的人来说真的很感谢冯老师硬逼着我把偏硬的这两门课学完了。作业和实验的任务量都比较大，但是冯老师真的非常负责，有什么问题基本都会不厌其烦的回答完。对我而言主要收获是学到了一个计算机系的学生应该知道的硬件相关内容。 概率论与数理统计（张安老师）：老师人超好，授课很清晰，要求很明确，作业量不大，治好了我的积分恐惧症。 密码学（胡耿然老师）：比较全面的介绍密码学的基础内容，上课也很轻松，对数论有一些要求（快速幂和逆元）。 影视音乐鉴赏（徐艳老师）：上课主要是看电影，很适合在繁忙的课程安排中放松一下。需要做的事情非常非常少，只要做完要求的事情就可以放心拿很好很好的成绩（不能再明说了，懂得都懂吧） 电子钢琴（盛晨老师）：这个课偏钢琴普及向，课程考核也主要根据每个人的基础决定，期末考试就是一首自选曲目。因为我和 Eva 都有一些底子，所以上课基本就是两个人弹想弹的曲子，一个学期弹了很多四手联弹非常开心，期末也选择了四手联弹的方式，选的《摇篮曲》。推荐的原因主要是很难有其他方式可以如此方便的摸到键盘，所以比较感兴趣的同学推荐试一试，没坑，但是如果在意成绩的话最好还是有一点钢琴基础。 体育舞蹈（董晓波老师）：每周都能和 Eva 去跳一次舞非常开心！上课比较轻松，老师教的很好，运动量即使是我也能撑得住，成绩对我来说也非常满意了。此外貌似有几组同学经过一个学期真的成了情侣，有需求的同学可以去试试桃花运（ 未来 大二这一年一直在考虑未来的发展，如果决定进企业的话，对我而言其实本科毕业直接上班可能比读研更有效。 借助一些契机和尝试，也让我明白自己还是有热爱的，所以决定试一试，本科毕业之后继续读书，先不去工作啦。 关于方向，还是决定离开机器学习这个领域了，非常感谢导师能够理解和支持我的想法。 毕竟还年轻，还有试错的机会，此时能比较轻松地放下对失败的顾虑，去追求自己的学术理想何尝不是一件大幸事。 我们 我们的爱情在这一年里有很多很感动的时刻，也有很多次吵架走到低谷。 时间长了不像刚开始谈恋爱那样激烈，但是日常平静生活中的一次次相互扶持，润物无声。 关于爱情，还是没有什么太多可以讲出来的，所以分享几个这一年中我觉得值得纪念的事情吧： 一起选修了电子钢琴，期末考核曲目选择了四手联弹《摇篮曲》 我通过大二上的体测，大二下一起选修了体育舞蹈，作为舞伴一起上课和考试 印象很深的是大二上体测的最后一项一千米，Eva 最后两圈全程陪我跑完，按照商量好的方案每 10 秒给我报一次时间。 最后的一段冲刺真的没有力气了，完全盯着终点线的 Eva 在跑。最后体测分数正好 60 分，0.1 都没多。 大二两次期末的突击复习，能一起承受住期末的压力，比较平稳的度过。 其实主要是帮我复习，因为有的课我考试前一天还啥都不会， Eva 经常因为压力太大会哭出来。 复习期间压力很大的环境下很容易发生争吵，真的很感动我们能一起挺过来那段时间，生气也能快速调整情绪。 教 Eva 学算法， Eva 能进杭电女队，参加下一个赛季的女生赛（Eva 进队的时候我真的很激动）。 一起去当下一届英才班的班助（大一刚谈恋爱的时候就聊起来过这个事情，发现我们都挺喜欢带学弟学妹的）。 最后很想分享一句话，在两个人的感情遇到问题的时候，我觉得这是一个很好的衡量自己做的是否正确的标准。","categories":[{"name":"Summary","slug":"Summary","permalink":"http://blog.gyx.me/categories/Summary/"}],"tags":[]},{"title":"AtCoder Regular Contest 061","slug":"atcoder/arc061","date":"2022-07-01T09:20:14.000Z","updated":"2023-03-20T16:28:47.966Z","comments":true,"path":"atcoder/arc061/","link":"","permalink":"http://blog.gyx.me/atcoder/arc061/","excerpt":"","text":"C - Many Formulas 给定一个数字串，可以在任意位置添加加号，问所有表达式结果的和是多少。 考虑一个前缀后面补一个新的数字： + 如果断开，那么前缀的贡献是前面的结果 + 如果不断开，那么前缀的贡献是前面除去最后一段 + 最后一段 \\(\\times 10\\) + 最后一个数字的贡献就是数值 \\(\\times 2^{len}\\) ，即可能的划分方案数 记 \\(f_i\\) 表示前缀 \\(i\\) 的答案，\\(g_i\\) 表示前缀 \\(i\\) 最后一段的答案，有： \\[ \\begin{array}{l} f_i &amp;= 2^i * digit_i + f_{i-1} + (f_{i-1} - g_{i-1}) + g_{i-1} \\times 10\\\\ g_i &amp;= 2^i * digit_i + g_{i-1} \\times 10 \\end{array} \\] 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt; using namespace std; using ll = long long; inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x; &#125; char s[11]; ll f[11], g[11]; int main() &#123; scanf(&quot;%s&quot;, s + 1); int len = strlen(s + 1); for (int i = 1, pw = 1; i &lt;= len; ++i, pw = pw * 2) &#123; f[i] = pw * (s[i] - &#x27;0&#x27;) + f[i - 1] * 2 + g[i - 1] * 9; g[i] = pw * (s[i] - &#x27;0&#x27;) + g[i - 1] * 10; &#125; printf(&quot;%lld\\n&quot;, f[len]); return 0; &#125; D - Snuke's Coloring 给定一个 \\(H\\times W\\) 的网格，初始所有位置都是白色，然后给定 \\(n\\) 个点染成黑色。 问所有的九宫格里，黑色点数为 \\(0\\dots 9\\) 的九宫格分别有多少个。 初始所有的九宫格都是白色，然后每次加入一个点模拟一下即可。 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt; using namespace std; using ll = long long; inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x; &#125; unordered_map&lt;ll, bool&gt; vis; inline ll pos(int x, int y) &#123;return 1ll * x * 1000000000 + y;&#125; ll ans[10]; int main() &#123; int h = rd(), w = rd(); ans[0] = 1ll * (h - 2) * (w - 2); for (int n = rd(); n; --n) &#123; int x = rd(), y = rd(); for (int a = max(1, x - 2); a &lt;= min(x, h - 2); ++a) for (int b = max(1, y - 2); b &lt;= min(y, w - 2); ++b) &#123; int cnt = 0; for (int dx = 0; dx &lt; 3; ++dx) for (int dy = 0; dy &lt; 3; ++dy) cnt += vis[pos(a + dx, b + dy)]; --ans[cnt]; ++ans[cnt + 1]; &#125; vis[pos(x, y)] = 1; &#125; for (int i = 0; i &lt; 10; ++i) printf(&quot;%lld\\n&quot;, ans[i]); return 0; &#125; E - Snuke's Subway Trip \\(n\\) 个点 \\(m\\) 条边的无向图，每个边有一个颜色。 一个路径的初始代价是 \\(1\\) ，每换一次颜色代价 \\(+1\\) ，求 \\(1\\) 到 \\(n\\) 的最短路。 考虑直接建分层图（每个点的实点建立 \\(m\\) 个虚点，虚点间连原图的边）。 真实的点向对应的虚点连边权为 \\(1\\) ，虚点之间连原图的边边权为 \\(0\\) ，最终答案除 \\(2\\) 即可。 可以发现有用的点其实只有 \\(\\mathcal{O}(n+m)\\) ，因此可以直接建图做（用一个 unordered_map ）。 然后在图上跑 01-BFS 即可，复杂度 \\(\\mathcal{O}(n+m)\\) 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt; using namespace std; using ll = long long; inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x; &#125; #define N 500007 #define M 2000007 unordered_map&lt;int, int&gt; id[N]; int tot, hd[N]; struct node&#123;int to, nxt; bool w;&#125; e[M]; inline void add(int u, int v, bool w) &#123; e[++tot].to = v; e[tot].w = w; e[tot].nxt = hd[u]; hd[u] = tot; e[++tot].to = u; e[tot].w = w; e[tot].nxt = hd[v]; hd[v] = tot; &#125; int dis[N]; bool vis[N]; deque&lt;int&gt; q; int main() &#123; int n = rd(), m = rd(); int totn = n; for (int i = 1; i &lt;= m; ++i) &#123; int u = rd(), v = rd(), c = rd(); if (!id[u][c]) &#123;id[u][c] = ++totn; add(u, totn, 1);&#125; if (!id[v][c]) &#123;id[v][c] = ++totn; add(v, totn, 1);&#125; add(id[u][c], id[v][c], 0); &#125; memset(dis, 0x3f, sizeof(dis)); dis[1] = 0; q.push_back(1); while (!q.empty()) &#123; int u = q.front(); q.pop_front(); if (vis[u]) continue; vis[u] = 1; for (int i = hd[u], v; i; i = e[i].nxt) &#123; if (dis[u] + e[i].w &lt; dis[v = e[i].to]) &#123; dis[v] = dis[u] + e[i].w; e[i].w ? q.push_back(v) : q.push_front(v); &#125; &#125; &#125; printf(&quot;%d\\n&quot;, dis[n] == dis[0] ? -1 : dis[n] / 2); return 0; &#125; F - Card Game for Three 三个人 A,B,C ，每个人分别有 \\(n,m,k\\) 张卡，每张卡的卡面都可能是 A/B/C 之一。 从 A 开始翻牌，每次翻到的牌子上写的是谁，下一个翻牌的就是谁。 轮到某个人时，如果他没有牌了就胜利，问总共 \\(3^{n+m+k}\\) 种方案中，A 胜利的方案数有多少。 这道题目的出发点完全想错了，不能将三个人分开想，因为有可能会有 A - B - C - A 循环。 考虑将整个操作序列连起来（长度 \\(n+m+k\\) ），每个操作序列一定对应于一种牌序。 那么也就是要求：某个前缀有 \\(n\\) 个 A ，且这段前缀内 B, C 的数量对应不超过 \\(m,k\\) 。 前一个条件避免数重，强制最后一个是 A 即可。 后一个条件考虑容斥做，由于长度限制容易发现两个反例只会出现一个： \\[ \\begin{array}{l} ans &amp;= \\displaystyle \\sum_{len=n}^{n+m+k} {len - 1\\choose n - 1}\\bigg({2^{len - n} - \\sum_{a = m+1}^{len - n}{len - n\\choose a}-\\sum_{b=k+1}^{len - n}{len - n\\choose b}}\\bigg)3^{n+m+k-len} \\end{array} \\] 设 \\(f_x=\\sum_{i=m}^x{x\\choose i}\\) ，然后用组合数定义优化这个东西： \\[ f_x = \\sum_{i=m}^x{x\\choose i} = \\sum_{i=m}^x \\bigg({x-1\\choose i}+{x-1\\choose i - 1}\\bigg) = 2f_{x-1} + {x - 1\\choose m - 1} \\] 就变成 \\(\\mathcal{O}(n+m+k)\\) 的了。。。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt; using namespace std; using ll = long long; inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x; &#125; #define N 1000007 #define mod 1000000007 namespace Comb &#123; int fac[N], ifac[N]; inline int fpow(int x, int t) &#123; int res = 1; for (; t; t &gt;&gt;= 1, x = 1ll * x * x % mod) if (t &amp; 1) res = 1ll * res * x % mod; return res; &#125; inline void init() &#123; fac[0] = ifac[0] = 1; for (int i = 1; i &lt; N; ++i) fac[i] = 1ll * fac[i - 1] * i % mod; ifac[N - 1] = fpow(fac[N - 1], mod - 2); for (int i = N - 2; i; --i) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % mod; &#125; inline ll C(int n, int m) &#123; if (n &lt; m) return 0; return 1ll * fac[n] * ifac[m] % mod * ifac[n - m] % mod; &#125; &#125; using namespace Comb; ll pw2[N] = &#123;1&#125;, pw3[N] = &#123;1&#125;, f1[N], f2[N]; int main() &#123; init(); ll ans = 0; int n = rd(), m = rd(), k = rd(); for (int i = 1; i &lt; N; ++i) &#123; pw2[i] = (pw2[i - 1] &lt;&lt; 1) % mod; pw3[i] = pw3[i - 1] * 3 % mod; f1[i] = (2 * f1[i - 1] + C(i - 1, m)) % mod; f2[i] = (2 * f2[i - 1] + C(i - 1, k)) % mod; &#125; for (int l = n; l &lt;= n + m + k; ++l) &#123; ll w = ((pw2[l - n] - f1[l - n] - f2[l - n]) % mod + mod) % mod; ans = (ans + C(l - 1, n - 1) * w % mod * pw3[n + m + k - l]) % mod; &#125; printf(&quot;%lld\\n&quot;, ans); return 0; &#125;","categories":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://blog.gyx.me/categories/AtCoder/"},{"name":"AtCoder Regular Contest","slug":"AtCoder/AtCoder-Regular-Contest","permalink":"http://blog.gyx.me/categories/AtCoder/AtCoder-Regular-Contest/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"},{"name":"STL","slug":"STL","permalink":"http://blog.gyx.me/tags/STL/"},{"name":"Combinatorics","slug":"Combinatorics","permalink":"http://blog.gyx.me/tags/Combinatorics/"},{"name":"01-BFS","slug":"01-BFS","permalink":"http://blog.gyx.me/tags/01-BFS/"}]},{"title":"Training Records - We Bare Bears!","slug":"summary/we-bare-bears","date":"2022-06-30T16:00:00.000Z","updated":"2023-11-06T03:34:48.544Z","comments":true,"path":"summary/we-bare-bears/","link":"","permalink":"http://blog.gyx.me/summary/we-bare-bears/","excerpt":"","text":"Season: 2022-2023 (the 47th ICPC &amp; the 8th CCPC) 杭电 2022 - 4 队训练记录。 个人题解点表格中比赛名称跳转。 熊熊一家已经退役啦，祝大家都有光明的未来～ Contests Date Contest Rank Solved Upsolved Award 2022/09/11 2022 CCPC Qualification Round 17 8 / 13 8 / 12 - 2022/09/17 2022 - 2023 ICPC Asia EC Regionals Online (I) 25 9 / 12 9 / 12 - 2022/11/06 2022 CCPC Weihai Site 12 8 / 13 10 / 13 Gold 2022/11/13 2022 CCPC Guangzhou Site 12 7 / 13 7 / 13 Gold 2022/11/20 2022 - 2023 ICPC Asia Hefei Regional 6 10 / 13 11 / 13 Gold 2022/12/18 2022 - 2023 ICPC Asia Nanjing Regional 13 7 / 13 8 / 13 Gold 2023/02/06 ICPC Training Camp powered by Huawei. Day 1 36 5 / 12 5 / 12 - 2023/02/07 ICPC Training Camp powered by Huawei. Day 2 15 7 / 11 7 / 11 - 2023/03/25 2022 - 2023 ICPC Asia East Continent Final 49 6 / 13 6 / 13 Silver 2023/04/15 2023 Zhejiang Provincial CPC 2 10 / 13 10 / 13 Gold Virt. Contests Date Contest Rank Solved Upsolved 2022/07/31 2021 CCPC Finals 20 7 / 12 7 / 12 2022/08/31 2021 - 2022 ICPC Latin American Regional 21 8 / 13 8 / 13 2022/09/07 2019 - 2020 ICPC Northwestern European Regional 44 9 / 11 9 / 11 2022/09/25 XXI Open Cup, Grand Prix of Wroclaw 87 7 / 13 7 / 13 2022/10/02 2020 - 2021 ICPC Xiaomi Invitational, Finals 8 6 / 13 6 / 13 2022/10/16 2019 - 2020 ICPC Latin American Regional 45 10 / 13 11 / 13 2022/10/18 2018 CCPC Finals 26 6 / 12 7 / 12 2022/10/19 2019 ICPC World Finals 46 5 / 11 6 / 11 2022/10/26 2019 CCPC Finals 24 4 / 12 5 / 12 2022/10/29 2019 - 2020 ICPC Asia Hong Kong Regional 4 5 / 11 10 / 11 2022/10/31 2022 CCPC Guilin Site 31 7 / 13 10 / 13 2022/11/03 2018-2019 ICPC Asia Nanjing Regional 6 9 / 13 11 / 13 2022/11/08 2020-2021 ICPC Asia Yinchuan Regional 25 6 / 13 9 / 13 2022/11/14 2022-2023 ICPC North Western Russia Regional 6 9 / 14 10 / 14 2022/12/3 2022-2023 ICPC Asia Jinan Regional 16 7 / 13 9 / 13 2022/12/12 2022-2023 ICPC Asia Hangzhou Regional 18 7 / 13 10 / 13 2022/12/14 2015 ICPC Asia EC-Finals 7 7 / 13 7 / 13 2023/03/08 2017 CCPC Finals 23 6 / 11 6 / 11 2023/03/20 2022-2023 ICPC Asia Hong Kong Regional 8 7 / 12 7 / 12 2023/03/21 2022 ICPC Southeastern Europe Regional 43 8 / 14 8 / 14 2023/04/02 2018 ICPC Asia Qingdao Regional 66 8 / 13 8 / 13 2023/04/05 2020-2021 ICPC NEERC Regional 30 10 / 14 10 / 14 Multi-University Training Date Contest Rank Solved Upsolved 2022/07/23 2022 Nowcoder Multi-University Training Contest 2 40 9 / 12 10 / 12 2022/07/25 2022 Nowcoder Multi-University Training Contest 3 16 6 / 10 8 / 10 2022/07/26 2022 HDU Multi-University Training Contest 3 45 7 / 12 9 / 12 2022/07/28 2022 HDU Multi-University Training Contest 4 79 8 / 11 8 / 11 2022/07/30 2022 Nowcoder Multi-University Training Contest 4 16 10 / 14 11 / 14 2022/08/01 2022 Nowcoder Multi-University Training Contest 5 - 9 / 11 10 / 11 2022/08/02 2022 HDU Multi-University Training Contest 5 81 6 / 12 7 / 12 2022/08/04 2022 HDU Multi-University Training Contest 6 73 7 / 12 7 / 12 2022/08/06 2022 Nowcoder Multi-University Training Contest 6 65 6 / 13 8 / 13 2022/8/08 2022 Nowcoder Multi-University Training Contest 7 11 7 / 12 8 / 12 2022/08/09 2022 HDU Multi-University Training Contest 7 79 6 / 11 9 / 11 2022/08/11 2022 HDU Multi-University Training Contest 8 29 9 / 13 9 / 13 2022/08/13 2022 Nowcoder Multi-University Training Contest 8 28 3 / 12 4 / 12 2022/08/15 2022 Nowcoder Multi-University Training Contest 9 24 8 / 11 8 / 11 2022/08/16 2022 HDU Multi-University Training Contest 9 60 6 / 11 6 / 11 2022/08/17 2022 Nowcoder Multi-University Training Contest 0 29 6 / 13 6 / 13 2022/08/18 2022 HDU Multi-University Training Contest 10 14 10 / 12 10 / 12 2022/08/20 2022 Nowcoder Multi-University Training Contest 10 37 5 / 11 5 / 11","categories":[{"name":"Summary","slug":"Summary","permalink":"http://blog.gyx.me/categories/Summary/"}],"tags":[]},{"title":"AtCoder Regular Contest 060","slug":"atcoder/arc060","date":"2022-06-30T09:20:14.000Z","updated":"2023-03-20T16:28:42.899Z","comments":true,"path":"atcoder/arc060/","link":"","permalink":"http://blog.gyx.me/atcoder/arc060/","excerpt":"","text":"C - Tak and Cards 给定 \\(n\\) 个有序数字，求有多少个下标集，对应的数字平均数是 \\(A\\) 数据范围很小，用背包计数就好了，注意枚举的上下界。 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 57#define M 5007#define B 2500ll f[N][M];int main() &#123; int n = rd(), A = rd(); f[0][B] = 1; for (int i = 1; i &lt;= n; ++i) &#123; int w = rd() - A; for (int v = max(-B, -B + w); v &lt;= min(B, B + w); ++v) f[i][v + B] = f[i - 1][v + B] + f[i - 1][v - w + B]; &#125; printf(&quot;%lld\\n&quot;, f[n][B] - 1); return 0;&#125; D - Digit Sum 给定两个数字 \\(n\\ (n\\le 10^{11})\\) 和 \\(s\\) ，求最小的进制 \\(b\\) ，使得 \\(n\\) 在 \\(b\\) 进制下的数位和等于 \\(s\\) 。 一道典型的根号讨论题目。 当 \\(b\\le \\sqrt{n}\\) 时，直接暴力验证。 当 \\(b\\ge \\sqrt{n}\\) 时，数字最多是两位数，可以写成 \\(n=pb+q,s=p+q\\) ，联立得 \\(n-s=p(b-1)\\) 注意后一种情况判断要求：\\(b\\ge \\sqrt{n},\\ 0\\le q&lt; b\\) 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt; using namespace std; using ll = long long; inline ll calc(ll n, ll b) &#123; ll ans = 0; for (; n; ans += n % b, n /= b); return ans; &#125; int main() &#123; ll n, s; cin &gt;&gt; n &gt;&gt; s; if (n &lt; s) &#123;puts(&quot;-1&quot;); return 0;&#125; if (n == s) &#123;printf(&quot;%lld\\n&quot;, n + 1); return 0;&#125; ll lim = sqrt(n); for (ll i = 2; i &lt;= lim; ++i) if (calc(n, i) == s) &#123;printf(&quot;%lld\\n&quot;, i); return 0;&#125; n -= s; ll ans = 1e18; for (ll i = sqrt(n); i &gt;= 1; --i) if (n % i == 0) &#123; if (i &gt;= lim &amp;&amp; s - n / i &lt; i + 1 &amp;&amp; s &gt;= n / i) ans = min(ans, i + 1); if (n / i &gt;= lim &amp;&amp; s - i &lt; n / i + 1 &amp;&amp; s &gt;= i) ans = min(ans, n / i + 1); &#125; printf(&quot;%lld\\n&quot;, ans == 1e18 ? -1 : ans); return 0; &#125; E - Tak and Hotels 给定数轴上的 \\(n\\) 个点，每次查询两个点 \\(a,b\\) ： 问从 \\(a\\) 到 \\(b\\) ，在给定的点之间跳跃，每次距离不超过 \\(L\\) ，最少多少次。 考虑倍增，设 \\(mx_{i,j}\\) 表示从 \\(i\\) 向右跳 \\(2^j\\) 步，最多能跳到哪里，组合的时候记得判一下最后一步即可。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt; using namespace std; using ll = long long; inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x; &#125; #define N 100007 int r[N][18], x[N]; int main() &#123; int n = rd(); int t = log2(n) + 1; for (int i = 1; i &lt;= n; ++i) x[i] = rd(); int l = rd(), q = rd(); for (int i = 1, rpos = 1; i &lt;= n; ++i) &#123; while (rpos &lt; n &amp;&amp; x[rpos + 1] - x[i] &lt;= l) ++rpos; r[i][0] = rpos; &#125; for (int i = 1; i &lt;= t; ++i) for (int l = 1; l &lt;= n; ++l) r[l][i] = r[r[l][i - 1]][i - 1]; for (; q; --q) &#123; int a = rd(), b = rd(); if (a &gt; b) swap(a, b); int ans = 0; for (int i = t; ~i; --i) if (r[a][i] &lt; b) &#123; ans += (1 &lt;&lt; i); a = r[a][i]; &#125; printf(&quot;%d\\n&quot;, ans + 1); &#125; return 0; &#125; F - Best Representation 定义无循环节（完整补齐）的字符串是好的。 定义将一个串划分为若干好的字符串，这个划分是好的。 定义一个划分是最优的，当且仅当划分是好的并且划分的子串数最少。 给定串 \\(S\\ (|S|\\le 5\\times 10^5)\\) 求最优划分所需的子串数和最优划分个数。 如果 \\(S\\) 自己本身无循环节，两个答案都是 \\(1\\) 如果 \\(S\\) 所有字母都相同，第一个答案是 \\(n\\) ，第二个是 \\(1\\) 如果 \\(S\\) 有循环节且所有字母都不同，第一个答案是 \\(2\\) （在任意循环节中间切开） 对于第三种情况枚举分割点计数，需要快速判断一个前缀/后缀有无循环节。 对正反两个串都做一下 kmp 就可以了，若 \\((n-nxt[n])\\ |\\ n\\) 则有循环节。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;#define N 500007char s[N];int nxt[N], nxtr[N];inline bool pre(int x) &#123; return (nxt[x] == 0) || (x % (x - nxt[x]) &gt; 0);&#125;inline bool suf(int x) &#123; return (nxtr[x] == 0) || (x % (x - nxtr[x]) &gt; 0);&#125;int main() &#123; scanf(&quot;%s&quot;, s + 1); int len = strlen(s + 1); bool fl = 0; for (int i = 2, pos; i &lt;= len; ++i) &#123; if (s[i] != s[i - 1]) fl = 1; pos = nxt[i - 1]; while (pos &amp;&amp; s[pos + 1] != s[i]) pos = nxt[pos]; if (pos != 0) nxt[i] = pos + 1; else nxt[i] = (s[1] == s[i]); &#125; if (!fl) &#123;printf(&quot;%d\\n1\\n&quot;, len); return 0;&#125; if (pre(len)) &#123;puts(&quot;1\\n1&quot;); return 0;&#125; puts(&quot;2&quot;); reverse(s + 1, s + 1 + len); for (int i = 2, pos; i &lt;= len; ++i) &#123; pos = nxtr[i - 1]; while (pos &amp;&amp; s[pos + 1] != s[i]) pos = nxtr[pos]; if (pos != 0) nxtr[i] = pos + 1; else nxtr[i] = (s[1] == s[i]); &#125; int ans = 0; for (int i = 1; i &lt; len; ++i) if (pre(i) &amp;&amp; suf(len - i)) ++ans; printf(&quot;%d\\n&quot;, ans); return 0;&#125;","categories":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://blog.gyx.me/categories/AtCoder/"},{"name":"AtCoder Regular Contest","slug":"AtCoder/AtCoder-Regular-Contest","permalink":"http://blog.gyx.me/categories/AtCoder/AtCoder-Regular-Contest/"}],"tags":[{"name":"String","slug":"String","permalink":"http://blog.gyx.me/tags/String/"},{"name":"Knapsack Problem","slug":"Knapsack-Problem","permalink":"http://blog.gyx.me/tags/Knapsack-Problem/"},{"name":"Greedy","slug":"Greedy","permalink":"http://blog.gyx.me/tags/Greedy/"},{"name":"Threshold Optimization","slug":"Threshold-Optimization","permalink":"http://blog.gyx.me/tags/Threshold-Optimization/"},{"name":"Binary Lifting","slug":"Binary-Lifting","permalink":"http://blog.gyx.me/tags/Binary-Lifting/"}]},{"title":"AtCoder Regular Contest 059","slug":"atcoder/arc059","date":"2022-06-29T09:20:14.000Z","updated":"2023-03-20T16:28:35.805Z","comments":true,"path":"atcoder/arc059/","link":"","permalink":"http://blog.gyx.me/atcoder/arc059/","excerpt":"","text":"C - Be Together 直接枚举最终结果是谁就行了，C 语言题。 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 107int n, a[N];inline int sqr(int x) &#123;return x * x;&#125;inline int calc(int x) &#123; int ans = 0; for (int i = 1; i &lt;= n; ++i) ans += sqr(a[i] - x); return ans;&#125;int main() &#123; n = rd(); for (int i = 1; i &lt;= n; ++i) a[i] = rd(); int ans = 2e9; for (int w = -100; w &lt;= 100; ++w) ans = min(ans, calc(w)); printf(&quot;%d\\n&quot;, ans); return 0;&#125; D - Unbalanced 给定一个字符串，找一个不平衡子串，子串中出现次数最多的字符次数超过长度的一半。 长度为 \\(2n\\) 的不平衡串，该字符一定出现了至少 \\(n+1\\) 次，因此一定有连续两个字符相同； 长度为 \\(2n+1\\) 的不平衡串，唯一特殊的情况是形如 abacada 这种，一定存在长度为 \\(3\\) 的不平衡子串； 综上，如果存在不平衡，那么最小的长度不会超过 \\(3\\) ，直接扫描即可。 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 100007char s[N];int main() &#123; scanf(&quot;%s&quot;, s + 1); int n = strlen(s + 1); if (s[n - 1] == s[n]) &#123;printf(&quot;%d %d\\n&quot;, n - 1, n); return 0;&#125; for (int i = 1; i &lt;= n - 2; ++i) &#123; if (s[i] == s[i + 1]) &#123;printf(&quot;%d %d\\n&quot;, i, i + 1); return 0;&#125; if (s[i] == s[i + 2]) &#123;printf(&quot;%d %d\\n&quot;, i, i + 2); return 0;&#125; &#125; puts(&quot;-1 -1&quot;); return 0;&#125; E - Children and Candies \\[ \\begin{array}{l} ans &amp;= \\displaystyle\\sum_{x_1 = a_1}^{b_1}\\sum_{x_2 = a_2}^{b_2}\\cdots\\sum_{x_n = a_n}^{b_n} \\sum_{\\substack{\\sum c_i=C\\\\c_i\\ge 0}}\\prod_{i=1}^n x_i^{c_i}\\\\ &amp;\\displaystyle= \\sum_{\\substack{\\sum c_i=C\\\\c_i\\ge 0}} \\sum_{x_1 = a_1}^{b_1} x_1^{c_1}\\sum_{x_2 = a_2}^{b_2}x_2^{c_2}\\cdots\\sum_{x_n = a_n}^{b_n} x_n^{c_n}\\\\ &amp;\\displaystyle= \\sum_{\\substack{\\sum c_i=C\\\\c_i\\ge 0}}\\prod_{i=1}^n\\bigg(\\sum_{x_i = a_i}^{b_i} x_i^{c_i}\\bigg)\\\\ \\end{array} \\] 我们可以预处理出 \\(pw_{i,k} =\\sum_{x_i=a_i}^{b_i} x_i^k\\) ，有 \\[ ans = \\sum_{\\substack{\\sum c_i=C\\\\c_i\\ge 0}}\\prod_{i=1}^n\\bigg(\\sum_{x_i = a_i}^{b_i} x_i^{c_i}\\bigg) =\\displaystyle\\sum_{c_1=0}^C pw_{1,c_1}\\sum_{\\substack{c_2+\\cdots + c_n=C-c_1\\\\c_i\\ge 0}}\\prod_{i=2}^n pw_{i,c_i} \\] 按照这个思路继续拆分 \\(c_2,\\cdots, c_n\\) ，本质上就是一个背包的动态规划。 设 \\(f_{i,j}\\) 表示考虑前 \\(i\\) 个变量，指数的和是 \\(j\\) ，对 \\(ans\\) 的贡献是多少。 枚举第 \\(i\\) 个指数占用了 \\(k\\ (k\\le j)\\) ，则转移方程： \\[ f_{i,j}\\leftarrow \\sum_{k=0}^j f_{i-1,j-k}\\times pw_{i,k} \\] 时间复杂度 \\(\\mathcal{O}(n^3)\\) ，空间复杂度 \\(\\mathcal{O}(n^2)\\) 。 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 407#define mod 1000000007int a[N], b[N], pw[N][N], f[N][N];int main() &#123; int n = rd(), c = rd(); for (int i = 1; i &lt;= n; ++i) a[i] = rd(); for (int i = 1; i &lt;= n; ++i) b[i] = rd(); for (int i = 1; i &lt;= n; ++i) for (int j = a[i]; j &lt;= b[i]; ++j) for (int t = 0, nw = 1; t &lt;= c; ++t, nw = 1ll * nw * j % mod) pw[i][t] = (pw[i][t] + nw) % mod; f[0][0] = 1; for (int i = 1; i &lt;= n; ++i) for (int j = 0; j &lt;= c; ++j) for (int k = 0; k &lt;= j; ++k) f[i][j] = (f[i][j] + 1ll * f[i - 1][j - k] * pw[i][k]) % mod; printf(&quot;%d\\n&quot;, f[n][c]); return 0;&#125; F - Unhappy Hacking 求 \\(n\\) 次操作生成一个给定串 \\(s\\) 的方案数： 每次操作三选一：结尾加 \\(0\\) ，结尾加 \\(1\\) ，删除结尾一个字符（若空就什么都不做） 冷静一下这个计数和串是什么没关系，因为所有长度相同的串生成的概率相同。 设 \\(f_{i,j}\\) 表示 \\(i\\) 次操作生成长度为 \\(j\\) 的串的方案数，有： + 删除：\\(f_{i,j} \\leftarrow f_{i-1,j+1}+[j == 0]f_{i-1,j}\\) + 添加：\\([j&gt;0] f_{i,j}\\leftarrow f_{i-1,j-1}\\times 2\\) 答案就是 \\(f_{n,|s|}\\times 2^{-|s|}\\) ，复杂度为 \\(\\mathcal{O}(n^2)\\) ，感觉可能还能优化。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt; using namespace std; using ll = long long; #define N 5007 #define mod 1000000007 inline int fpow(int x, int t) &#123; int res = 1; for (; t; t &gt;&gt;= 1, x = 1ll * x * x % mod) if (t &amp; 1) res = 1ll * res * x % mod; return res; &#125; char s[N]; int f[N][N], pw[N] = &#123;1&#125;; inline void add(int &amp;a, int b) &#123;a = (a + b) % mod;&#125; int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); scanf(&quot;%s&quot;, s + 1); f[0][0] = 1; for (int i = 1; i &lt;= n; ++i) pw[i] = (pw[i - 1] &lt;&lt; 1) % mod; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 0; j &lt;= n; ++j) &#123; add(f[i][j], f[i - 1][j + 1]); if (!j) add(f[i][j], f[i - 1][j]); else add(f[i][j], (f[i - 1][j - 1] &lt;&lt; 1) % mod); &#125; &#125; int m = strlen(s + 1); int ans = 1ll * f[n][m] * fpow(pw[m], mod - 2) % mod; printf(&quot;%d\\n&quot;, ans); return 0; &#125;","categories":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://blog.gyx.me/categories/AtCoder/"},{"name":"AtCoder Regular Contest","slug":"AtCoder/AtCoder-Regular-Contest","permalink":"http://blog.gyx.me/categories/AtCoder/AtCoder-Regular-Contest/"}],"tags":[{"name":"Knapsack Problem","slug":"Knapsack-Problem","permalink":"http://blog.gyx.me/tags/Knapsack-Problem/"},{"name":"Counting","slug":"Counting","permalink":"http://blog.gyx.me/tags/Counting/"},{"name":"Combinatorics","slug":"Combinatorics","permalink":"http://blog.gyx.me/tags/Combinatorics/"}]},{"title":"AtCoder Beginner Contest 253","slug":"atcoder/abc253","date":"2022-05-29T00:38:14.000Z","updated":"2023-03-20T16:28:12.328Z","comments":true,"path":"atcoder/abc253/","link":"","permalink":"http://blog.gyx.me/atcoder/abc253/","excerpt":"","text":"A, B 比较简单就不写了。 我的代码 : All Submissions - SGColin C. Max - Min Query 维护一个 multiset ，支持插入一个 \\(x\\) ，删除 \\(\\min(c_i,s.count(x))\\) 个 \\(x\\) ，查询最大值-最小值。 开始想想直接模拟复杂度是对的就写了 multiset，没想到 multiset 的 lower_bound 太慢了 T 了几个点。 Upd : 经提醒应该是 count 函数太慢了，官网描述是 \"Logarithmic in size and linear in the number of matches\" ，也就是说复杂度是 \\(\\mathcal{O}(k+\\log n)\\) ，其中 \\(k\\) 是查询数字的出现次数，所以加入 \\(10^5\\) 个点之后，多查几次就超时了。 所以改为用 map 维护一个计数器，每次某个数字新出现/消失的时候再对 set 操作。 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;map&lt;int, int&gt; cnt;set&lt;int&gt; s;int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; int op = rd(); if (op == 1) &#123; int x = rd(); ++cnt[x]; if (cnt[x] == 1) s.insert(x); &#125; else if (op == 2) &#123; int x = rd(); int t = min(rd(), cnt[x]); cnt[x] -= t; if (cnt[x] == 0) s.erase(x); &#125; else printf(&quot;%d\\n&quot;, (*--s.end()) - (*s.begin())); &#125; return 0;&#125; D. FizzBuzz Sum Hard 给定 \\(n,a,b\\) 找出 \\([1,n]\\) 内不是 \\(a\\) 或 \\(b\\) 倍数的数字的和。 简单的容斥原理，扣掉 \\(a,b\\) 的倍数，加上 \\(\\text{lcm}(a,b)\\) 的倍数。 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;int gcd(int a, int b) &#123; return b ? gcd(b, a % b) : a;&#125;int main() &#123; int n = rd(), a = rd(), b = rd(); ll sum = 1ll * n * (n + 1) / 2; int ka = n / a; int kb = n / b; sum -= 1ll * a * ka * (ka + 1) / 2; sum -= 1ll * b * kb * (kb + 1) / 2; ll lcm = 1ll * a * b / gcd(a, b); ll kl = n / lcm; sum += 1ll * lcm * kl * (kl + 1) / 2; printf(&quot;%lld\\n&quot;, sum); return 0;&#125; E. Distance Sequence 计数长度为 \\(n\\) 的序列 \\(\\{a_i\\}\\) ：(1) \\(a_i\\in[1,m]\\) ; (2) \\(\\forall i\\in[2,n], |a_i-a_{i-1}|\\ge k\\) . 直接 DP ，设 \\(f_{i,j}\\) 表示长度为 \\(i\\) 的序列，结尾是 \\(j\\) 的方案数，有： \\[ f_{i,j}=\\sum_{w\\in[1,j-k]\\cup[j+k,m]} f_{i-1,w} \\] 用一个前缀和优化即可，注意下 \\(k=0\\) 时不要算重，复杂度 \\(O(nm)\\) 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 1007#define M 5007#define mod 998244353int f[N][M], sum[N][M];inline int fpow(int x, int t) &#123; int res = 1; for (; t; t &gt;&gt;= 1, x = 1ll * x * x % mod) if (t &amp; 1) res = 1ll * res * x % mod; return res;&#125;int main() &#123; int n = rd(), m = rd(), k = rd(); if (k == 0) &#123;printf(&quot;%d\\n&quot;, fpow(m, n)); return 0;&#125; for (int i = 1; i &lt;= m; ++i) &#123; f[1][i] = 1; sum[1][i] = i; &#125; for (int i = 2; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; int l = max(0, j - k); int r = min(m, j + k - 1); f[i][j] = (sum[i - 1][m] - sum[i - 1][r] + mod) % mod; f[i][j] = (f[i][j] + sum[i - 1][l]) % mod; &#125; for (int j = 1; j &lt;= m; ++j) sum[i][j] = (sum[i][j - 1] + f[i][j]) % mod; &#125; printf(&quot;%d\\n&quot;, sum[n][m]); return 0;&#125; F. Operations on a Matrix 维护一个初始是全 \\(0\\) 的 \\(n\\times m\\ (n,m\\le 2\\ast 10^5)\\) 的矩阵，支持： 对 \\([l_i,r_i]\\) 这些列的每一个元素加 \\(x\\) 将第 \\(i\\) 行全部赋值为 \\(x\\) 查询矩阵中 \\((x_i,y_i)\\) 的值 记录每行最后一次被赋值的时间戳 \\(lst_i\\) 和赋值 \\(x_i\\) ，则答案为 \\(x_i\\) + \\([lst,now]\\) 这段操作里对 \\(y_i\\) 加的值。 在线的做法就是写一个主席树 + 标记持久化； 离线的做法就是把后面的贡献写做前缀和差分，然后两个时刻维护一下。 学到了简老师的主席树写法 OwO 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define mid ((l + r) &gt;&gt; 1)#define N 200007int tot, rttot;struct node &#123; int ls, rs; ll sum;&#125; c[N &lt;&lt; 6];int rot[N], lst[N];ll x[N];int copy(int rt) &#123; c[++tot] = c[rt]; return tot;&#125;void upd(int &amp;rt, int l, int r, int L, int R, int x) &#123; rt = copy(rt); if (L &lt;= l &amp;&amp; r &lt;= R) &#123; c[rt].sum += x; return; &#125; if (L &lt;= mid) upd(c[rt].ls, l, mid, L, R, x); if (R &gt; mid) upd(c[rt].rs, mid + 1, r, L, R, x);&#125;ll query(int rtl, int rtr, int l, int r, int p) &#123; ll res = c[rtr].sum - c[rtl].sum; if (l == r) return res; if (p &lt;= mid) res += query(c[rtl].ls, c[rtr].ls, l, mid, p); else res += query(c[rtl].rs, c[rtr].rs, mid + 1, r, p); return res;&#125;int main() &#123; int n = rd(), m = rd(), q = rd(); for (int i = 1; i &lt;= q; ++i) &#123; int op = rd(); if (op == 1) &#123; ++rttot; rot[rttot] = rot[rttot - 1]; int l = rd(), r = rd(), v = rd(); upd(rot[rttot], 1, m, l, r, v); &#125; else if (op == 2) &#123; int p = rd(); x[p] = rd(); lst[p] = rttot; &#125; else &#123; int row = rd(), col = rd(); printf(&quot;%lld\\n&quot;, x[row] + query(rot[lst[row]], rot[rttot], 1, m, col)); &#125; &#125; return 0;&#125; G. Swap Many Times 对于 \\(n\\) ，初始化一个序列 \\(a_1,\\cdots,a_n\\) ，满足 \\(a_i=i\\) 。 对于 \\(n\\) ，有 \\(\\frac{n(n+1)}{2}\\) 个形如 \\((x,y)\\) 的满足 \\(1\\le x&lt;y\\le n\\) 的数对，按照 pair 的规则排序。 给定 \\(L,R\\) ，对于这个 pair 序列的第 \\(L\\) 个到第 \\(R\\) 个，依次操作：交换 \\(a_x\\) 和 \\(a_y\\) 求最终的序列。 观察这个序列， \\(x\\) 相同的 pair 是连续出现的，考虑对于同一个 \\(x\\) 把所有操作都做掉。 假设以 \\(x\\) 为 first 的在 \\([L,R]\\) 内的操作为 \\((x,y_a),(x,y_a+1),\\cdots,(x,y_b)\\) 那么实际操作的结果就是把序列中 \\(x,y_a,y_a+1,\\cdots,y_b\\) 这些位置整体向右 shift 一个位置。 枚举 \\(x\\) ，然后只需要一个支持某个位置插入删除的数据结构就可以了。 然后昨天趁机学了一下 rope ，内核是块状链表，理论复杂度 \\(\\mathcal{O}(n\\sqrt{n})\\) ，实际表现速度很快。 只能说非常好用，可惜 Clang 编译不了，是在 Custom Test 手动调试的。 p.s. 题解的做法貌似不需要数据结构，好像很精妙 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;#include &lt;ext/rope&gt;using namespace std;using namespace __gnu_cxx;typedef long long ll;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;rope&lt;int&gt; s;int main() &#123; int n = rd(); ll L = rd(), R = rd(); ll l = 0, r = 0; for (int i = 0; i &lt;= n; ++i) s.push_back(i); for (int i = 1; i &lt;= n; ++i) &#123; l = r + 1; r = l + n - i - 1; if (L &lt;= r &amp;&amp; R &gt;= l) &#123; int ll = max(l, L), rr = min(r, R); int pl = i + 1 + ll - l; int pr = i + 1 + rr - l; int x = s[pr]; s.erase(pr, 1); s.insert(pl, s[i]); s.erase(i, 1); s.insert(i, x); &#125; &#125; for (int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, s[i]); return 0;&#125;","categories":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://blog.gyx.me/categories/AtCoder/"},{"name":"AtCoder Beginner Contest","slug":"AtCoder/AtCoder-Beginner-Contest","permalink":"http://blog.gyx.me/categories/AtCoder/AtCoder-Beginner-Contest/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"},{"name":"STL","slug":"STL","permalink":"http://blog.gyx.me/tags/STL/"},{"name":"Persistent Data Structure","slug":"Persistent-Data-Structure","permalink":"http://blog.gyx.me/tags/Persistent-Data-Structure/"}]},{"title":"Two Identical Machines Scheduling with Agreement Graphs","slug":"paper-notes/machine-scheduling-with-agreement-graph","date":"2022-05-25T14:03:18.000Z","updated":"2023-10-16T13:15:48.053Z","comments":true,"path":"paper-notes/machine-scheduling-with-agreement-graph/","link":"","permalink":"http://blog.gyx.me/paper-notes/machine-scheduling-with-agreement-graph/","excerpt":"","text":"New results in two identical machines scheduling with agreement graphs 收录于 TCS 2019 的一篇文章，基于许可图的独立双机流水安排问题的一些新进展。 问题模型 有 \\(n\\) 个任务，第 \\(i\\) 个任务需要的时间是 \\(p_i\\) 。 一共有两台机器，每个任务都需要被连续地安排到某一个机器上完成。 将任务抽象成点，给定一个许可图，两个任务有边则可以分别在两个机器上同时执行。 求一个安排方案，最小化最后一个被做完的任务完成时间。 现有结论： 许可图是树的情况下，此问题是 NP-Hard 的 许可图是毛毛虫的情况下，存在 \\(\\mathcal{O}(n)\\) 求最优解的方法 毛毛虫 毛毛虫是一种特殊的树，由一个核心路径和若干到路径距离为 \\(1\\) 的点构成。 Notation Meaning Notation Processing time \\(p\\) Maximum weighted independent set of the agreement graph \\(G\\) \\(I_p(G)\\) Weight of \\(I_p(G)\\) (a lower bound on the optimal makespan) \\(\\overline{I_p}(G) =\\sum_{j\\in I_p(G)} p_j\\) Set of neighbors of a job \\(j\\) (generalized for a subset \\(J&#39;\\)) \\(N(j)/N(J&#39;)\\) Set of leaves connected to job \\(j\\) \\(Lv(j)\\) Starting time of a job \\(j\\) \\(t_j\\) Minimum starting time of a subset \\(J&#39;\\) \\(t_j(J&#39;)=\\min_{k\\in J&#39;}\\{t_k\\}\\) Algorithm 见原文 [4.2] Caterpillar scheduling algorithm。 Polynomiality and Optimality Proof 为了简单描述，我们称在 MWIS 里的点为黑点，其余点为白点。 可以发现断掉白点之间的所有边后，这个新的图的性质是所有的边都是黑-白边。 Claim 1. 对于每个新的连通块 \\(CAT_i\\) ，其内的黑点集 \\(S_i^*\\) 仍然是 \\(CAT_i\\) 的 MWIS 假设存在其他的 MWIS \\(I_p(CAT_i)\\) 使得 \\(\\overline{I_p}(CAT_i) &gt; \\sum_{j\\in S_i^*} p_j\\) ，那么我们考虑将 \\(CAT_i\\) 这一部分的 MWIS 换成这个新的集合，其他部分的 MWIS 不变，那么还原回仍是原图的一个 IS，而这个新的 IS 比原来的 MWIS 权值还大，所以矛盾了。 \\[ \\sum_{j \\in S^{\\prime}} p_{j}=\\overline{I_{p}}(C A T)-\\sum_{j \\in S_{i}^{*}} p_{j}+\\overline{I_{p}}\\left(C A T_{i}\\right)&gt;\\overline{I_{p}}(C A T) \\] Claim 2. 对于每个新的连通块 \\(CAT_i\\) 的点集 \\(J_i\\) ，其内任何一个白点子集的点权和不会超过其邻居黑点的点权和 假设存在这样的一个白点集 \\(W\\) 满足 \\(\\sum_{j \\in W} p_{j} &gt; \\sum_{j \\in N(W)} p_{j}\\) ，那么考虑将 \\(S_i^*\\) 换成 \\(S&#39;= (S_i^*\\setminus N(W))\\cup W\\) ，易证\\(S&#39;\\) 也是一个独立集，且比 \\(S_i^*\\) 权值和还要大，矛盾。 \\[ \\sum_{j \\in S^{\\prime}} p_{j}=\\sum_{j \\in S_{i}^{*}} p_{j}-\\sum_{j \\in N(W)} p_{j}+\\sum_{j \\in W} p_{j}&gt;\\sum_{j \\in S_{i}^{*}} p_{j} \\] Claim 3. 对于任意白点 \\(\\beta\\) ，其邻居黑点都会被连续地安排在第一个机器上 分类讨论一下，如果是叶子显然；如果不是叶子，假设链上的顺序是 \\(\\alpha-\\beta-\\gamma\\) ，那么黑点顺序显然是 \\(\\alpha-(\\beta\\) 的叶子 \\()-\\gamma\\) Claim 4. 对于任意两个白点 \\(\\alpha,\\beta\\) ，如果他们被连续地安排在了某一个机器上，那么他们一定有公共邻居。 同样分类讨论 \\(\\alpha\\) 和 \\(\\beta\\) 的位置关系（分别是主干/叶子）即可。 Claim 5. 对于任意连续安排的白点集，其邻居一定是被连续安排在一个区间内的 前两条的自然结果，当然也需要第二条辅助理解一下，证明黑色一定是连续的。 Lemma 1. 每一个白点都会被安排在邻居对应的区间里 反证法，不符合的就两种情况： \\(t_\\beta &lt; t(N(\\beta ))\\) ：这种情况不存在，因为算法中每个黑点是连续安排的，如果出现该情况，这个白点会与非邻接的黑点重合，与许可图的要求相冲突。 \\(t_\\beta+p_\\beta &gt; t(N(\\beta )) + \\sum_{j\\in N(\\beta)} p_j\\) ：这种情况不存在，考虑从 \\(\\beta\\) 往前的第一个满足 \\(t_\\alpha=t_{N(\\alpha)}\\) 的任务 \\(\\alpha\\) ，那么从 \\(\\alpha\\) 到 \\(\\beta\\) 这一段是连续安排的，由事实 \\(5\\) ，连续安排的白点集，其邻居一定是被连续安排在一个区间内的，因此白点的区间就是 \\([t_\\alpha,t_\\alpha+\\sum_{j\\in[\\alpha,\\beta]} p_j]\\) ，黑点的区间就是 \\([t(N([\\alpha,\\beta])),t(N([\\alpha,\\beta])) + \\sum_{j\\in N([\\alpha,\\beta])} p_j]\\) ; 又由事实 \\(2\\) ，对于 \\(J_i\\) 内任何一个白点子集，其点权和不会超过其邻居黑点的点权和，因此有 \\(t_\\alpha+\\sum_{j\\in[\\alpha,\\beta]} p_j \\le \\sum_{j\\in N([\\alpha,\\beta])} p_j\\) ，因此 \\([\\alpha, \\beta]\\) 这一段的白点终止时间不超过黑点，因此作为最后一个完成的白点 \\(\\beta\\) ，有 \\(t_\\beta+p_\\beta \\le t(N(\\beta )) + \\sum_{j\\in N(\\beta)} p_j\\) Theorithm 2. 本算法求出的安排方案为最优解。 由引理 \\(1\\) ，每个 \\(\\sigma_i\\) 所需要的时间就是其中黑点所需的时间，即 \\(\\overline{I_p}(CAT_i)\\) ，因此总方案 \\(\\sigma\\) 所需的时间 \\(\\sum_{i} \\overline{I_p}(CAT_i) = \\overline{I_p}(CAT)\\) ，即答案下界。 总结 最后放一个 pdf 版的总结：","categories":[{"name":"Paper Notes","slug":"Paper-Notes","permalink":"http://blog.gyx.me/categories/Paper-Notes/"}],"tags":[{"name":"Graphs","slug":"Graphs","permalink":"http://blog.gyx.me/tags/Graphs/"},{"name":"Greedy","slug":"Greedy","permalink":"http://blog.gyx.me/tags/Greedy/"},{"name":"Scheduling","slug":"Scheduling","permalink":"http://blog.gyx.me/tags/Scheduling/"}]},{"title":"Codeforces Round #787 (Div. 3)","slug":"codeforces/1675","date":"2022-05-06T12:01:00.000Z","updated":"2023-03-20T16:26:03.759Z","comments":true,"path":"codeforces/1675/","link":"","permalink":"http://blog.gyx.me/codeforces/1675/","excerpt":"","text":"A. Food for Animals \\(a\\) 个狗粮，\\(b\\) 个猫粮，\\(c\\) 个通用粮（都能吃），能不能保证 \\(n\\) 个狗 \\(m\\) 个猫都有的吃？ 每个都先减掉专用的食物，剩下的看通用的够不够分即可。 12345inline void work() &#123; int a = rd(), b = rd(), c = rd(); int n = max(0, rd() - a), m = max(0, rd() - b); puts(n + m &gt; c ? &quot;NO&quot; : &quot;YES&quot;);&#125; B. Make It Increasing 给一个数列，每次操作把一个位置整除 \\(2\\) ，最少操作多少次使得数列严格递增？ 从后往前倒推，答案是固定的，一直做到符合要求即可。 1234567891011int a[57];inline void work() &#123; int n = rd(), ans = 0; for (int i = 1; i &lt;= n; ++i) a[i] = rd(); for (int i = n - 1; i; --i) if (a[i] &gt;= a[i + 1]) &#123; if (a[i + 1] == 0) &#123;puts(&quot;-1&quot;); return;&#125; while (a[i] &gt;= a[i + 1]) &#123;++ans; a[i] = a[i] / 2;&#125; &#125; printf(&quot;%d\\n&quot;, ans);&#125; C. Detective Task 有一幅画， \\(n\\) 个人看，中间某一时刻被某一个人偷走了。 问每个人他看的时候画还在不在，答案可能是有 (1) / 无 (0) / 忘记了 (?)。 好人会说实话/忘记了，偷走的人会随机选一个答案，求有多少个嫌疑人。 最后一个说有（1）的人，前面的人都不会是嫌疑人：如果前面的人是嫌疑人，那么他进去的时候应该已经被偷了，他就说谎了。 第一个说无（0）的人，后面的人都不会是嫌疑人：如果后面的人是嫌疑人，那么他进去的时候还没被偷，他就说谎了 因此答案是从最后一个说有的人到第一个说无的人这一段的人数。 1234567891011string s;inline void work() &#123; cin &gt;&gt; s; int n = s.length(); int l = 0, r = n - 1; for (int i = 0; i &lt; n; ++i) if (s[i] == &#x27;1&#x27;) l = i; for (int i = l; i &lt; n; ++i) if (s[i] == &#x27;0&#x27;) &#123;r = i; break;&#125; printf(&quot;%d\\n&quot;, r - l + 1);&#125; D. Vertical Paths 给一棵树，问最少分成多少个从上到下的链，并输出方案。 显然每个叶子都需要一个链，每个非叶子挑一个叶子挂上就行了，纯考实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 200007bool vis[N];int n, rt, f[N], cnt;vector&lt;int&gt; res[N], son[N];void dfs(int u, int bel) &#123; res[bel].push_back(u); if (son[u].empty()) &#123;++cnt; return;&#125; dfs(son[u][0], bel); for (int i = 1; i &lt; son[u].size(); ++i) dfs(son[u][i], son[u][i]);&#125;inline void work() &#123; n = rd(); cnt = 0; for (int i = 1; i &lt;= n; ++i) &#123;res[i].clear(); son[i].clear();&#125; for (int i = 1; i &lt;= n; ++i) &#123; f[i] = rd(); if (f[i] == i) rt = i; else son[f[i]].push_back(i); &#125; dfs(rt, rt); printf(&quot;%d\\n&quot;, cnt); for (int i = 1; i &lt;= n; ++i) if (!res[i].empty()) &#123; printf(&quot;%d\\n&quot;, (int)res[i].size()); for (auto j : res[i]) printf(&quot;%d &quot;, j); puts(&quot;&quot;); &#125; &#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; E. Replace With the Previous, Minimize 给一个字符串，每次操作你可以选定一个字符，并把串中的所有这个字符换成字典序前一个（a 变成 z ） 问 \\(k\\) 次操作内，字符串可能的字典序最小的结果是什么？ 首先如果 \\(k&gt;25\\) ，那么我从 z 到 b 都操作一遍就都变成 aaaaaaa 这样子了。 否则也一定不会对 a 操作，因为次数不够变回来了，因此操作是单向的，没有循环的。 因此按照字典序贪心就完事了，维护一个 \\(\\Sigma\\to \\Sigma\\) 的转移表，每次可以的话往前移动一下。 需要注意的是利用此前的结果，也就是每次做完之后记得把前缀覆盖一下。 12345678910111213141516string s;unordered_map&lt;char, char&gt; tr;inline void work() &#123; int n = rd(), k = rd(); cin &gt;&gt; s; for (char i = &#x27;a&#x27;; i &lt;= &#x27;z&#x27;; ++i) tr[i] = i; for (auto i : s) &#123; while (k &amp;&amp; tr[i] &gt; &#x27;a&#x27;) &#123; --tr[i]; --k; tr[i] = tr[tr[i]]; &#125; for (char j = i; j &gt;= tr[i]; --j) tr[j] = min(tr[j], tr[i]); if (k == 0) break; &#125; for (auto i : s) putchar(tr[i]); puts(&quot;&quot;);&#125; F. Vlad and Unfinished Business 给一棵树，树上的两个点 \\(x, y\\) ，以及一系列点 \\(a_1, a_2, \\dots,a_k\\) 求一个最短路径，从 \\(x\\) 出发，以任意顺序遍历完 \\(a_1, a_2, \\dots,a_k\\) ，最后走到 \\(y\\) 首先一个常见的套路（虚树）是，树上遍历一个点集的最短回路，就是所有点按照dfs序一次性访问。 现在考虑让树以 \\(x\\) 为根，现在需要遍历 \\(a_1,a_2,\\dots,a_k\\) 这些点，最后再走到 \\(y\\) 。 其实可以看成回路遍历点集 \\(x, a_1, a_2,\\dots, a_k,y\\) ，最后再把 \\(x\\) 到 \\(y\\) 的距离（也就是 \\(y\\) 的深度）扣掉。 所以按照 dfs 序依次访问即可，可能比较难写。 另外一种简单的写法是暴力往根跳，跳到第一个访问到的点即可，往答案里累加新增的点数 * 2 。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 200007vector&lt;int&gt; e[N], seq;bool vis[N];int n, k, x, y, f[N], ans;void dfs(int u, int fa, int dep) &#123; f[u] = fa; if (u == y) ans = -dep; for (auto v : e[u]) if (v != fa) dfs(v, u, dep + 1);&#125;inline void work() &#123; seq.clear(); n = rd(); k = rd(); x = rd(); y = rd(); for (int i = 1; i &lt;= n; ++i) vis[i] = 0, e[i].clear(); for (int i = 1; i &lt;= k; ++i) seq.push_back(rd()); seq.push_back(y); for (int i = 1; i &lt; n; ++i) &#123; int u = rd(), v = rd(); e[u].push_back(v); e[v].push_back(u); &#125; dfs(x, x, 0); vis[x] = 1; for (auto i : seq) for (int u = i; !vis[u]; u = f[u]) vis[u] = 1, ans += 2; printf(&quot;%d\\n&quot;, ans);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; G. Sorting Pancakes 给你一个序列，每次操作可以选两个相邻的两个位置一个 \\(-1\\) 一个 \\(+1\\) ，问最小操作多少次是的序列单减。 看到这种问题一般都是 dp ，就是状态设计需要好好考虑一下。 设 \\(f_{i,j}\\) 表示考虑了前 \\(i\\) 位，前缀和是 \\(j\\) 的最小操作数，那么转移就是枚举序列最终下一个位置的数字 \\(k\\) 。 即 \\(f_{i+1,j+k}=\\min\\{f_{i+1,j+k}, f_{i,j} + cost (i + 1, j+k)\\}\\) 其中 \\(cost(x, w)\\) 表示前缀 \\(x\\) 在此前基础上变成总和 \\(w\\) 的最小代价。 考虑 \\(f_{i,j}\\) 里已经包含了让前缀 \\(i\\) 合法的代价，现在其实只需要考虑新一位是 \\(k\\) 的代价。 本质上我们只需要考虑第 \\(i+1\\) 位和后面的后缀交流的多少次，即 \\(cost(i+1,j+k)=|\\sum_{p=1}^{i+1}a_p-(j+k)|\\) 那么怎么保证序列单减呢？把枚举 \\(k\\) 的循环放到最外面，从大到小，这样转移是从大到小的，比较妙。 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 257int a[N], s[N], f[N][N];int main() &#123; int n = rd(), m = rd(); for (int i = 1; i &lt;= n; ++i) s[i] = s[i - 1] + (a[i] = rd()); memset(f, 0x3f, sizeof(f)); f[0][0] = 0; for (int k = m; ~k; --k) for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt;= m - k; ++j) f[i + 1][j + k] = min(f[i + 1][j + k], f[i][j] + abs(j + k - s[i + 1])); printf(&quot;%d\\n&quot;, f[n][m]); return 0;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://blog.gyx.me/categories/Codeforces/"},{"name":"Codeforces Round","slug":"Codeforces/Codeforces-Round","permalink":"http://blog.gyx.me/categories/Codeforces/Codeforces-Round/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"},{"name":"DFS and Similar","slug":"DFS-and-Similar","permalink":"http://blog.gyx.me/tags/DFS-and-Similar/"}]},{"title":"Dynamic Programming on Intervals","slug":"algorithms/dp-interval","date":"2022-04-26T00:13:35.000Z","updated":"2023-03-20T16:50:02.320Z","comments":true,"path":"algorithms/dp-interval/","link":"","permalink":"http://blog.gyx.me/algorithms/dp-interval/","excerpt":"","text":"Normal Problems 区间动态规划的一般形式：枚举长度（阶段），枚举左端点，需要的话再枚举分割点 Unlock the Padlock Source:Google Kick Start 2022 Round B一个滚轮密码锁由 \\(n\\)个滚轮组成，每个的范围都是 \\([0, D-1]\\)（循环），初始是 \\(a_i\\) 。每次操作选取一个区间 \\(1 \\le l_i \\le r_i\\le n\\) ，将区间内所有滚轮都向上或向下拨一个位置。要求 \\([l_i,r_i]\\subseteq[l_{i+1},r_{i+1}]\\) ，问最少多少次把所有位置都变成 \\(0\\) 。 区间只能扩张不能收缩，因此任意时刻拨动的区间内的数字一定要相同。 如果 \\(D\\) 很小，可以设 \\(f[l][r][k]\\) 表示区间 \\([l,r]\\) 都调成 \\(k\\) 的最小代价，直接 \\(\\mathcal O(n^2D^2)\\) 求解。 那么什么时候区间能真的扩张？当且仅当区间内的值和 \\(a_{l-1}\\) 或 \\(a_{r+1}\\) 一样，才能向左或向右扩展一位。 因此 任意时刻操作区间的值一定和某个端点相同 ，设 \\(f[l][r][0/1]\\) 表示把 \\([l,r]\\) 都调成左/右端点的最小操作次数。 直接每次区间长度扩展 \\(1\\) 转移即可，复杂度 \\(\\mathcal O(n^2)\\) 。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 407int testcase;ll n, d, f[N][N][2], a[N];inline ll dis(ll a, ll b) &#123; ll w = abs(a - b); return min(w, d - w);&#125;inline void getmin(ll &amp;a, ll b) &#123;a = (a &lt; b ? a : b);&#125;inline void work() &#123; n = rd(); d = rd(); memset(f, 0x3f, sizeof(f)); for (int i = 1; i &lt;= n; ++i) &#123; a[i] = rd(); f[i][i][0] = f[i][i][1] = 0; &#125; for (int len = 1; len &lt; n; ++len) &#123; for (int l = 1; l &lt;= n - len + 1; ++l) &#123; int r = l + len - 1; getmin(f[l - 1][r][0], f[l][r][0] + dis(a[l], a[l - 1])); getmin(f[l - 1][r][0], f[l][r][1] + dis(a[r], a[l - 1])); getmin(f[l][r + 1][1], f[l][r][0] + dis(a[l], a[r + 1])); getmin(f[l][r + 1][1], f[l][r][1] + dis(a[r], a[r + 1])); &#125; &#125; ll ans = min(f[1][n][0] + dis(a[1], 0), f[1][n][1] + dis(a[n], 0)); printf(&quot;Case #%d: %lld\\n&quot;, ++testcase, ans);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; Sue 的小球 Source: SDOI2008有 \\(n\\) 个球往下落，初始坐标是\\(x_i\\) ，高度是 \\(h_i\\) ，下落速度 \\(v_i\\) ，可以下落到正无穷。初始坐标在 \\(x_0\\)，每秒可以向左/向右移动 \\(1\\)，经过某个球的坐标时就把这个球拿走，获得当前高度的得分。问拿到所有球的前提下，最大得分是多少。 得分 \\(=\\sum h_i-\\sum\\) 下降的高度，考虑动态规划求 \\(\\min\\sum\\) 下降的高度。 问题变为第 \\(i\\) 个位置每秒会消耗 \\(v_i\\) ，到一个位置就会停止消耗，是 关路灯 这个模型。 考虑把坐标排序之后离散化，拿走的球一定是一个连续的区间，因此我们可以让状态停在某一个端点。 状态设计比较特殊：设 \\(f[l][r][0/1]\\) 表示把 \\([l,r]\\) 全部拿走，最后停在左/右端点，从开始到这个时刻的最小总消耗 那么考虑每次扩展一个位置，那么所耗的时间就是两点距离，每一秒的代价就是 \\(\\sum_{i\\notin [l,r]} v_i\\) （所有没接到的球） 需要注意把初始坐标离散化进去。枚举区间动态规划复杂度 \\(\\mathcal O(n^2)\\) 。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;typedef double db;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 1007#define fr first#define sc secondpair&lt;int, double&gt; p[N];db ans, sum[N], f[N][N][2];inline void getmin(db &amp;a, db b) &#123;a = (a &lt; b ? a : b);&#125;int main() &#123; int n = rd(), c = rd(); for (int i = 1; i &lt;= n; ++i) p[i].fr = rd(); for (int i = 1; i &lt;= n; ++i) ans += rd() / 1000.0; for (int i = 1; i &lt;= n; ++i) p[i].sc = rd() / 1000.0; p[++n] = make_pair(c, 0); sort(p + 1, p + 1 + n); for (int l = 1; l &lt;= n; ++l) for (int r = 1; r &lt;= n; ++r) for (int k = 0; k &lt; 2; ++k) f[l][r][k] = 1e18; for (int i = 1; i &lt;= n; ++i) &#123; sum[i] = sum[i - 1] + p[i].sc; if (p[i].fr == c) f[i][i][0] = f[i][i][1] = 0; &#125; for (int len = 1; len &lt; n; ++len) for (int l = 1; l &lt;= n - len + 1; ++l) &#123; int r = l + len - 1; db rsum = sum[n] - sum[r] + sum[l - 1]; getmin(f[l - 1][r][0], f[l][r][0] + (p[l].fr - p[l - 1].fr) * rsum); getmin(f[l - 1][r][0], f[l][r][1] + (p[r].fr - p[l - 1].fr) * rsum); getmin(f[l][r + 1][1], f[l][r][0] + (p[r + 1].fr - p[l].fr) * rsum); getmin(f[l][r + 1][1], f[l][r][1] + (p[r + 1].fr - p[r].fr) * rsum); &#125; printf(&quot;%.3lf\\n&quot;, ans - min(f[1][n][0], f[1][n][1])); return 0;&#125; Cities Source: The45th ICPC Asia Kunming Regional有 \\(n\\) 个点，第 \\(i\\) 个点的颜色是 \\(c_i\\) ，保证每种颜色最多出现 \\(15\\) 次。每次操作可以把一段连续且颜色相同的点都改成某个颜色，问最少操作多少次使得所有点颜色相同。 先把同样颜色且连续的缩成一段，这样相邻两两颜色都不同，假设有 \\(m\\) 段。 如果所有的颜色都不同的话，那么答案就是 \\(m-1\\) ，因为每次只能改颜色相同的。 但是序列中依旧有颜色相同的，因此需要动态规划求，设 \\(f[l][r]\\) 表示把 \\([l,r]\\) 变成相同的所需的最少次数。 转移考虑 \\(c_l\\) 有没有单独消耗一次合并： 如果单独消耗了一次就是 \\(f[l][r] = f[l + 1][r] + 1\\) 如果不消耗，那么枚举相同的另一个是 \\(k\\) ，那么 \\(f[l][r] = f[l + 1][k - 1] + f[k][r] + 1\\) 后面这个方程成立的原因是，我们发现操作总是可以等效到把区间变成和端点颜色相同。 需要缩点的原因是，后一种方程里的 \\(+1\\) 是为了把 \\([l + 1][k - 1]\\) 变成和 \\(c_l\\) 相同的，不缩会求错。 枚举区间，再枚举相同颜色，因为题目限制每种颜色最多出现 \\(15\\) 次，复杂度 \\(O(15n^2)\\) 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;typedef double db;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;inline void getmin(int &amp;a, int b) &#123;a = (a &lt; b ? a : b);&#125;#define N 5007int a[N], f[N][N], lst[N], nxt[N];inline void work() &#123; int n = rd(), tot = 0; for (int i = 1, x; i &lt;= n; ++i) &#123; x = rd(); if (!tot || x != a[tot]) a[++tot] = x; lst[i] = n + 1; &#125; n = tot; for (int i = n; i; --i) &#123; nxt[i] = lst[a[i]]; lst[a[i]] = i; &#125; for (int len = 2; len &lt;= n; ++len) for (int l = 1; l &lt;= n - len + 1; ++l) &#123; int r = l + len - 1; f[l][r] = f[l + 1][r] + 1; for (int j = nxt[l]; j &lt;= r; j = nxt[j]) getmin(f[l][r], f[l + 1][j - 1] + f[j][r] + 1); &#125; printf(&quot;%d\\n&quot;, f[1][n]);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; Dire Wolf Source:2014 ICPC Asia Beijing Regional有 \\(n\\) 个恐狼先锋排成一排，第\\(i\\) 个有 \\(a_i\\) 初始攻击力，并且会为两侧的恐狼临时增加 \\(b_i\\)攻击力（死了就没了）每次杀掉一个需要承受他当前攻击力的伤害，问杀掉所有的狼，承受最少伤害是多少。 设 \\(f[l][r]\\) 表示把 \\([l,r]\\) 这个区间的所有狼杀掉所需的最小代价。 枚举最后一只杀掉的狼 \\(k\\) ，考虑此时他两侧的狼是谁？ 答案是 \\(l-1\\) 和 \\(r+1\\) ，考虑区间 DP 的阶段性，我只需要杀死当前枚举的区间的狼，所以两侧的狼都没有死过。 所以最后一只狼的攻击力是 \\(a_k+b_{l-1}+b_{r + 1}\\) ，枚举 \\(k\\) 更新，复杂度是 \\(\\mathcal O(n^3)\\) 的。 \\[ f[l][r] = \\min_{l\\le k\\le r} \\bigg\\{f[l][k-1]+f[k+1][r]+a_k+b_{l-1}+b_{r+1}\\bigg\\} \\] 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 207int a[N], b[N], testcase;ll f[N][N];inline void work() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) a[i] = rd(); for (int i = 1; i &lt;= n; ++i) b[i] = rd(); b[n + 1] = 0; for (int len = 1; len &lt;= n; ++len) for (int l = 1; l &lt;= n - len + 1; ++l) &#123; int r = l + len - 1; f[l][r] = 1e18; for (int p = l; p &lt;= r; ++p) f[l][r] = min(f[l][r], f[l][p - 1] + f[p + 1][r] + a[p] + b[l - 1] + b[r + 1]); &#125; printf(&quot;Case #%d: %lld\\n&quot;, ++testcase, f[1][n]);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; You Are the One Source:2012 ICPC Asia Tianjin Regional Online\\(n\\)个人排成一队依次入栈，任意时刻都可以按栈序弹出栈内的任意人数。第 \\(i\\) 个人如果是第 \\(k\\) 个出场的，代价是 \\(D_i\\ast (k-1)\\)，求所有人代价和最小可能是多少。 设 \\(f[l][r]\\) 表示序列里只有 \\([l,r]\\) 这些人（假设区间前后的人不存在），最小代价是多少。 观察这些人的出入栈的顺序，发现序列会被第一个人何时出栈划分为两个阶段。 第一个人第一个入栈，假设第 \\(k\\) 个出栈（他出栈前只压入第 \\(2\\sim k\\) 个人）那么序列表现为： 第 \\(2\\sim k\\) 个人出入栈，这些人前面没有其他人，代价是 \\(f[l+1][l+k-1]\\) 第一个人出栈，前面有 \\(k-1\\) 个人，代价是 \\(D_l\\ast(k-1)\\) 第 \\(k+1\\sim n\\) 个人出入栈，这些人前面都增加 \\(k\\) 个人，代价是 \\(f[l+k][r]+\\sum_{i=l+k+1}^rD_i\\ast k\\) 枚举 \\(k\\) 更新，复杂度是 \\(\\mathcal O(n^3)\\) 的。 \\[ f[l][r] =\\min_{1\\le k\\le r-l+1} \\bigg\\\\{f[l + 1][l + k-1]+D_l\\ast(k-1)+f[l+k][r] + \\sum_{i=l+k}^r D_i\\ast k\\bigg\\\\} \\] 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 107int testcase;ll d[N], sum[N], f[N][N];inline void getmin(ll &amp;a, ll b) &#123;a = (a &lt; b ? a : b);&#125;inline void work() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; d[i] = rd(); sum[i] = sum[i - 1] + d[i]; &#125; for (int len = 2; len &lt;= n; ++len) for (int l = 1; l &lt;= n - len + 1; ++l) &#123; int r = l + len - 1; f[l][r] = 1e18; for (int k = 1; k &lt;= len; ++k) getmin(f[l][r], f[l + 1][l + k - 1] + d[l] * (k - 1) + f[l + k][r] + (sum[r] - sum[l + k - 1]) * k); &#125; printf(&quot;Case #%d: %lld\\n&quot;, ++testcase, f[1][n]);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; 二叉查找树 Source: NOI2009给定 \\(n\\) 个节点的key,value,times ，修改一个点的 value 代价是\\(K\\) ，修改后要保证两两value 不同。然后把这些点建出一个 Treap，定义访问代价 \\(\\sum_{i} depth_i\\ast times_{i}\\)，最小化修改代价 + 访问代价。 核心点是 key 不能修改，所以中序遍历是固定的，根左侧是左子树，根右侧是右子树。 考虑在中序遍历上做区间 DP ，枚举谁做根，那么根的 value 应当比左右子树的节点 value 要小。 所以状态里我们还要记一下当前子树的最小 value 是多少。 设 \\(f[l][r][k]\\) 表示中序遍历区间 \\([l,r]\\) 内的点建树，里面的点 value 权值 \\(\\ge k\\) ，的最小代价。 如果这个点的权值不需要改（前提 \\(value_{rt}\\ge k\\) ），那么子树里的权值要比他大 \\[ f[l][r][k] = \\min_{l\\le rt\\le r}\\bigg\\{f[l][rt - 1][value_{rt}]+f[rt + 1][r][value_{rt}] + \\sum_{i=l}^r times_i\\bigg\\} \\] 如果这个点权值需要改，那么子树的权值下界也是 \\(k\\) \\[ f[l][r][k] = \\min_{l\\le rt\\le r}\\bigg\\{f[l][rt - 1][k]+f[rt + 1][r][k] + \\sum_{i=l}^r times_i + K\\bigg\\} \\] 因为初始两两节点 value 就不同，而且可以调整成任意实数，所以方程中对子树权值的约束不用修改。 答案是 \\(\\min_k f[1][n][k]\\) ，把权值离散化一下，DP 复杂度是 \\(\\mathcal O(n^4)\\) 的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;vector&lt;int&gt; s;unordered_map&lt;int, int&gt; tr;#define N 73struct node &#123;int k, v, t;&#125; c[N];ll f[N][N][N], sumt[N];inline void getmin(ll &amp;a, ll b) &#123;a = (a &lt; b ? a : b);&#125;int main() &#123; int n = rd(), w = rd(); for (int i = 1; i &lt;= n; ++i) c[i].k = rd(); for (int i = 1; i &lt;= n; ++i) s.push_back(c[i].v = rd()); for (int i = 1; i &lt;= n; ++i) c[i].t = rd(); sort(s.begin(), s.end()); int cnt = 0; for (auto i : s) tr[i] = ++cnt; for (int i = 1; i &lt;= n; ++i) c[i].v = tr[c[i].v]; sort(c + 1, c + 1 + n, [](node x, node y)&#123;return x.k &lt; y.k;&#125;); for (int i = 1; i &lt;= n; ++i) sumt[i] = sumt[i - 1] + c[i].t; for (int len = 1; len &lt;= n; ++len) for (int l = 1; l &lt;= n - len + 1; ++l) &#123; int r = l + len - 1; for (int k = 0; k &lt;= n; ++k) &#123; f[l][r][k] = 1e18; for (int rt = l; rt &lt;= r; ++rt) &#123; if (c[rt].v &gt;= k) getmin(f[l][r][k], f[l][rt - 1][c[rt].v] + f[rt + 1][r][c[rt].v]); getmin(f[l][r][k], f[l][rt - 1][k] + f[rt + 1][r][k] + w); &#125; f[l][r][k] += sumt[r] - sumt[l - 1]; &#125; &#125; ll ans = 1e18; for (int k = 0; k &lt;= n; ++k) ans = min(ans, f[1][n][k]); printf(&quot;%lld\\n&quot;, ans); return 0;&#125; Pre-Order Source :AtCoder Beginner Contest 252 G定义 dfs序：从根开始，每次选择未访问过的最小儿子访问，每个点第一次被访问时记入序列尾。现给定 dfs 序，问有多少棵树符合。 \\(n\\le500\\) 考虑多叉树转二叉树（左儿子右兄弟，这是一个双射），那么要求就变为右儿子一定要小于父节点的编号。 设 \\(f_{l, r}\\) 表示 \\([l,r]\\) 这段区间，以 \\(l\\) 为根形成这样一棵二叉树的方案数。 枚举右儿子是 \\(k\\in[l + 1, r], a[k] &gt; a[l]\\) ，有转移 \\(f_{l, r} = \\sum_k f_{l,k - 1} \\times f_{k, r}\\) 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 507#define mod 998244353ll a[N], f[N][N];int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; a[i] = rd(); f[i][i] = 1; &#125; for (int len = 2; len &lt; n; ++len) &#123; for (int l = 2; l &lt;= n - len + 1; ++l) &#123; int r = l + len - 1; f[l][r] = f[l + 1][r]; for (int k = l + 1; k &lt;= r; ++k) if (a[k] &gt; a[l]) f[l][r] = (f[l][r] + 1ll * max(1ll, f[l + 1][k - 1]) * f[k][r]) % mod; &#125; &#125; printf(&quot;%lld\\n&quot;, f[2][n]); return 0;&#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://blog.gyx.me/categories/Algorithms/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"}]},{"title":"AtCoder Grand Contest 001","slug":"atcoder/agc001","date":"2022-04-12T02:08:12.000Z","updated":"2023-03-20T16:29:03.628Z","comments":true,"path":"atcoder/agc001/","link":"","permalink":"http://blog.gyx.me/atcoder/agc001/","excerpt":"","text":"官方题解：https://img.atcoder.jp/agc001/editorial.pdf 听说多做 AGC 可以提升智力，于是来尝试提升一下智力（虽然都是抄的题解）。 A - BBQ Easy \\(2n\\) 个数，最大化两两一组分组后，每组两个数取 \\(\\min\\) 的和。 从小到大排序之后，两两组合，答案是奇数位置的和。 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;vector&lt;int&gt; a;int main() &#123; int n = (rd() &lt;&lt; 1); for (int i = 1; i &lt;= n; ++i) a.push_back(rd()); sort(a.begin(), a.end()); int ans = 0; for (int i = 0; i &lt; n; i += 2) ans += a[i]; printf(&quot;%d\\n&quot;, ans); return 0;&#125; B - Mysterious Light 边长为 \\(n\\) 的正三角形 ABC 的边 AB 上 \\(x\\) 处平行 BC 射出一条激光。 碰到边界反射，碰到此前的光线也反射，求回到起点的路径长度。 没看懂官方题解的简单做法。 首先前两段光路长度和是 \\(n\\) ，会切掉两个角，变成一个平行四边形。 对于平行四边形（边长分别为 \\(a\\) 和 \\(b\\) ），光线从一个 \\(120^\\circ\\) 角出发，沿角平分线射出距离为 \\(f(a,b)\\) 有 \\(f(a,0)=-a, f(a,b) = 2 \\ast \\displaystyle\\lfloor \\frac{a}{b}\\rfloor \\ast b +f(b, a \\% b)\\) ，也就是每次都切短边直到长短边交换，减掉最后一次多算的。 答案就是 \\(n+f(x,n-x)\\) ，递归形式和 gcd 相同，所以复杂度是 \\(\\mathcal O(\\log n)\\) 。 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;inline ll f(ll a, ll b) &#123; return b ? 2 * (a / b) * b + f(b, a % b) : -a;&#125;int main() &#123; ll n = rd(), x = rd(); printf(&quot;%lld\\n&quot;, n + f(x, n - x)); return 0;&#125; C - Shorten Diameter 给一棵树，每次可以删掉一个叶子，问最少删多少次使得直径不超过 \\(k\\) 本来想贪心每次删一个直径的端点，但是不对，因为有可能这个点会被保留到最后。 因为 \\(n\\) 只有 \\(2000\\) ，所以可以 \\(\\mathcal{O}(n^2)\\) 暴力，那么枚举中心就好了。 如果 \\(k\\) 是奇数，枚举中心的边，把树分成两棵，根就是这条边的两个端点，每棵只保留深度小于 \\(\\lfloor k/2\\rfloor\\) 的点 如果 \\(k\\) 是偶数，枚举中心的点，以这个点为根，只保留深度小于 \\(\\lfloor k/2\\rfloor\\) 的点 找到上述情况里需要删除的点最少的情况即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 2007#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;vector&lt;pii&gt; r;vector&lt;int&gt; e[N];int dep[N];void dfs(int u) &#123; for (auto v : e[u]) if (dep[v] &lt; 0) &#123;dep[v] = dep[u] + 1; dfs(v);&#125;&#125;int main() &#123; int n = rd(), k = rd(); for (int i = 1, u, v; i &lt; n; ++i) &#123; u = rd(); v = rd(); e[u].pb(v); e[v].pb(u); if (k &amp; 1) r.pb(mp(u, v)); &#125; int ans = 0; if (k &amp; 1) &#123; for (auto [u, v] : r) &#123; memset(dep, -1, sizeof(dep)); dep[u] = 0; dep[v] = 0; dfs(u); dfs(v); int tmpans = 0; for (int j = 1; j &lt;= n; ++j) tmpans += (dep[j] &lt;= k / 2); ans = max(ans, tmpans); &#125; &#125; else &#123; for (int i = 1; i &lt;= n; ++i) &#123; memset(dep, -1, sizeof(dep)); dep[i] = 0; dfs(i); int tmpans = 0; for (int j = 1; j &lt;= n; ++j) tmpans += (dep[j] &lt;= k / 2); ans = max(ans, tmpans); &#125; &#125; printf(&quot;%d\\n&quot;, n - ans); return 0;&#125; D - Arrays and Palindrome 给定序列 \\(\\{A_i\\}\\) ，满足 \\(\\sum A_i=N\\) ，需要重排 \\(\\{A_i\\}\\) ，并且构造 \\(\\{B_i\\}\\) ，满足 \\(\\sum B_i=N\\) ，且满足： 如果一个长度为 \\(N\\) 的串 \\(S\\) 满足（ \\(S[l,r]\\) 表示 \\(S[l]S[l+1]\\dots S[r]\\) 这一段子串）： \\(\\forall i,\\ S[\\sum_{j=1}^{i-1}A_j+1, \\sum_{j=1}^i A_j]\\) 是回文的（也就是按照 \\(A_i\\) 分割成若干段子串，都是回文的） \\(\\forall i,\\ S[\\sum_{j=1}^{i-1}B_j+1, \\sum_{j=1}^i B_j]\\) 是回文的（也就是按照 \\(B_i\\) 分割成若干段子串，都是回文的） 那么 一定能推出 \\(S\\) 中全部字符都相同。 好有意思的题目啊！！建议先看官方题解。 假如我们确定了 \\(\\{A\\}\\) 的顺序，那么 \\(\\{A\\}\\) 把序列分成若干段，每段对称的位置字符要相同。 我们如果把 \\(N\\) 个位置看作 \\(N\\) 个点，那么可以把 \\(A\\) 的所有要求对称的位置连一条边。 现在 \\(B\\) 相当于是要补一些边，使得所有点都连通。 假设所有的 \\(A_i\\) 均为偶数，那么令\\(|\\{B\\}|=|\\{A\\}|\\) ，先让 \\(B_i=A_i\\) ，然后 $B_1 B_1-1,B_{|{B}|}B_{|{B}|}+1 $那么（除第一段外）每一段的最后一个都和前一段的最后一个连边，连通了两段；此外每一段内的连边都是奇偶位置错开的，所以整个图是连通的。 然后考虑 \\(A_i\\) 有奇数，可以证明最多允许有两段奇数，把这两段放在两边，还是不影响答案的。 如果奇数长度段超过两个，一定无解，具体证明看官方题解，大概方法就是证明了边数凑不到 \\(n-1\\) 。 感觉这个构造真的很 useful 啊（ 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define ppb pop_back#define psb push_back#define ppf pop_front#define psf push_frontdeque&lt;int&gt; s, odd;int main() &#123; int m = rd(), n = rd(); for (int i = 1, x; i &lt;= n; ++i) &#123; x = rd(); (x &amp; 1) ? odd.psb(x) : s.psb(x); &#125; if (odd.size() &gt; 2) &#123;puts(&quot;Impossible&quot;); return 0;&#125; if (odd.size() &gt; 0) s.psf(odd[0]); if (odd.size() &gt; 1) s.psb(odd[1]); for (auto x : s) printf(&quot;%d &quot;, x); puts(&quot;&quot;); //需要注意只有一个元素和第一个元素是1的情况 if (s.size() == 1) s.psb(0); --s.front(); ++s.back(); if (s.front() == 0) s.ppf(); printf(&quot;%d\\n&quot;, s.size()); for(auto x : s) printf(&quot;%d &quot;, x); return 0;&#125; E - BBQ Hard 给定 \\(N\\) 个 \\((A_i,B_i)\\) ，求： \\[ \\sum_{i=1}^{n-1}\\sum_{j=i+1}^n {A_i+A_j+B_i+B_j\\choose A_i+A_j} \\mod 10^9+7 \\] 数据范围 \\(2\\le n\\le 2\\times 10^5,1\\le a_i,b_i\\le 2000\\) 只能往右和往上走，计数从 \\((x_0,y_0)\\) 到 \\((x_1,y_1)\\)的路径方案数，考虑哪些步是横向走，是 \\(\\displaystyle{ {x_1-x_0+y_1-y_0} \\choose {x_1-x_0}}\\) 。当然也可以用一个二维递推，令 f[x0][y0]=1 ，每次f[i][j] = f[i - 1][j] + f[i][j - 1] ，答案f[x1][y1] 。 把式中 \\(\\displaystyle{A_i+A_j+B_i+B_j\\choose A_i+A_j}\\) 变形为 \\(\\displaystyle {A_i-(-A_j)+B_i-(-B_j)\\choose A_i-(-A_j)}\\) ，可解读为从 \\((-A_j,-B_j)\\) 到 \\((A_i,B_i)\\) 的路径数。 那么把求和改一下形式，两个循环都改成从 \\(1\\) 到 \\(n\\) ，然后扣掉自己到自己的贡献，再除 \\(2\\) 就是答案。 \\[ ans = \\frac{\\sum_{i=1}^{N} \\sum_{j=1}^{N} \\displaystyle{A_{i} +B_{i}+A_{j}+B_{j} \\choose A_{i}+B_{i}}-\\sum_{i=1}^{N} {2\\ast A_{i}+2\\ast B_{i} \\choose 2 \\ast A_{i}}}{2} \\mod 10^9+7 \\] 前一半考虑用上面提到的递推方法整体一起求（加个偏移量把坐标调成正的）： 先给所有的 f[-a[i]][-b[i]] += 1 ，然后递推完查所有的 f[a[i]][b[i]] 即可。 后一半用组合数直接算就好了。总复杂度 \\(\\mathcal{O}(n+4\\ast \\max a_i\\ast \\max b_i)\\) 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define A 4007#define G 2001#define M 8007#define N 200007#define mod 1000000007#define inv2 500000004int f[A][A], fac[M], ifac[M], x[N], y[N];inline int fpow(int x, int t = mod - 2) &#123; int res = 1; for (; t; t &gt;&gt;= 1, x = 1ll * x * x % mod) if (t &amp; 1) res = 1ll * res * x % mod; return res;&#125;inline int mo(int x) &#123; for (; x &lt; 0; x += mod); for (; x &gt;= mod; x -= mod); return x;&#125;inline int C(int n, int m) &#123; if (n &lt; m) return 0; return 1ll * fac[n] * ifac[m] % mod * ifac[n - m] % mod;&#125;int main() &#123; fac[0] = ifac[0] = 1; for (int i = 1; i &lt; M; ++i) fac[i] = 1ll * fac[i - 1] * i % mod; ifac[M - 1] = fpow(fac[M - 1]); for (int i = M - 2; i; --i) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % mod; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; x[i] = rd(); y[i] = rd(); ++f[-x[i] + G][-y[i] + G]; &#125; for (int i = 1; i &lt; A; ++i) for (int j = 1; j &lt; A; ++j) f[i][j] = mo(f[i][j] + f[i - 1][j] + f[i][j - 1]); int ans = 0; for (int i = 1; i &lt;= n; ++i) ans = mo(ans + f[x[i] + G][y[i] + G] - C(2 * (x[i] + y[i]), 2 * x[i])); printf(&quot;%lld\\n&quot;, 1ll * ans * inv2 % mod); return 0;&#125; F - Wide Swap 给定一个 \\(\\{1,2,\\dots,n\\}\\) 的排列 \\(\\{P\\}\\) ，每次操作： 选取两个距离至少为 \\(k\\) 的位置 \\(i,j\\) 且 \\(|P_i-P_j|=1\\) ，交换 \\(i,j\\) 两个位置上的数。 你可以任意次数操作，问可能得到的最小字典序排列是什么。 排列求个逆（即 \\(Q_{P_i}=i\\) ），\\(Q_i\\) 的含义就是数字 \\(i\\) 的位置。 问题转化为：相邻并且差值至少为 \\(k\\) 的两个 \\(Q\\) 可以交换，\\(Q\\) 可能最小字典序是什么（小的数字位置靠前）。 如果 \\(|Q_i-Q_j|&lt;k\\) ，那么 \\(Q_i\\) 和 \\(Q_j\\)在序列里的相对顺序永远都不能改变（换到相邻就不能操作了）。反之如果两个位置差值 \\(\\ge k\\)，只要能换到相邻，就一定可以交换，如果换不到相邻，一定是上面的约束导致的。所以如果 \\(|Q_i-Q_j|\\ge k\\) ，那么\\(Q_i\\) 和 \\(Q_j\\) 在序列里的顺序没有任何要求。 只有 \" \\(a\\) 一定要在 \\(b\\) 前\" 这种约束的最小字典序排列显然可以用优先队列的拓扑排序求。 但是边的级别是 \\(\\mathcal{O}(n^2)\\) 的： \\(Q_i\\) 会向 \\(\\forall j&gt;i,Q_j\\in[Q_i-k + 1,Q_i + k-1]\\) 的所有 \\(Q_j\\) 连边。 考虑去掉一些没有意义的边：假设 \\((x,y),(y,z),(x,z)\\) 都存在，那么 \\((x,z)\\) 显然是没必要存的。 把区间拆成两块 \\([Q_i-k+1,Q_i],[Q_i,Q_i+k-1]\\) ，这两个区间内部有约束的肯定会两两连边（单向）。 因此 \\(Q_i\\) 并不需要向这里面的全部点连边，完全可以继承区间里最靠前的位置的所有边，然后让自己指向这个位置即可。 形式化的说，对于某个区间，找到 \\(pos = \\min_{Q_j\\in [\\text{interval}]} j\\) ，那么只需要连 \\(Q_i\\to Q_{pos}\\) ，其余边都间接继承 \\(Q_{pos}\\) 的。 这样边的级别（也就是拓扑排序复杂度）就是 \\(\\mathcal{O}(n)\\) 的，找 \\(pos\\) 需要单点更新查区间 \\(\\min\\) ，用线段树复杂度 \\(\\mathcal{O}(n\\log n)\\) 。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 500007#define ls (rt &lt;&lt; 1)#define rs (rt &lt;&lt; 1 | 1)#define mid ((l + r) &gt;&gt; 1)int mn[N &lt;&lt; 2];void pushup(int rt) &#123; mn[rt] = min(mn[ls], mn[rs]);&#125;void upd(int rt, int l, int r, int k, int v) &#123; if (l == r) &#123; mn[rt] = v; return; &#125; if (k &lt;= mid) upd(ls, l, mid, k, v); else upd(rs, mid + 1, r, k, v); pushup(rt);&#125;int qmn(int rt, int l, int r, int L, int R) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) return mn[rt]; int ans = 1e9; if (L &lt;= mid) ans = min(ans, qmn(ls, l, mid, L, R)); if (R &gt; mid) ans = min(ans, qmn(rs, mid + 1, r, L, R)); return ans;&#125;int p[N], q[N], deg[N];vector&lt;int&gt; e[N];#define pb push_backpriority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;que;int main() &#123; int n = rd(), k = rd(); memset(mn, 0x3f, sizeof(mn)); for (int i = 1; i &lt;= n; ++i) q[p[i] = rd()] = i; for (int i = n; i; --i) &#123; int j = qmn(1, 1, n, q[i], min(n, q[i] + k - 1)); if (j &lt;= n) &#123;e[q[i]].pb(q[j]); ++deg[q[j]];&#125; j = qmn(1, 1, n, max(1, q[i] - k + 1), q[i]); if (j &lt;= n) &#123;e[q[i]].pb(q[j]); ++deg[q[j]];&#125; upd(1, 1, n, q[i], i); &#125; for (int i = 1; i &lt;= n; ++i) if (!deg[i]) que.push(i); for (int i = 1; i &lt;= n; ++i) &#123; int u = q[i] = que.top(); que.pop(); for (auto v : e[u]) if (!(--deg[v])) que.push(v); &#125; for (int i = 1; i &lt;= n; ++i) p[q[i]] = i; for (int i = 1; i &lt;= n; ++i) printf(&quot;%d\\n&quot;, p[i]); return 0;&#125;","categories":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://blog.gyx.me/categories/AtCoder/"},{"name":"AtCoder Grand Contest","slug":"AtCoder/AtCoder-Grand-Contest","permalink":"http://blog.gyx.me/categories/AtCoder/AtCoder-Grand-Contest/"}],"tags":[{"name":"Constructive Algorithm","slug":"Constructive-Algorithm","permalink":"http://blog.gyx.me/tags/Constructive-Algorithm/"}]},{"title":"AtCoder Beginner Contest 244","slug":"atcoder/abc224","date":"2022-03-29T07:46:14.000Z","updated":"2023-03-20T16:28:01.907Z","comments":true,"path":"atcoder/abc224/","link":"","permalink":"http://blog.gyx.me/atcoder/abc224/","excerpt":"","text":"A, B, C 比较简单就不写了。 我的代码 : All Submissions - SGColin D. Swap Hats 给定两个 \"RGB\" 这个字符串的排列 \\(A,B\\) ，每次操作可以交换两个位置。 问能否正好操作 \\(10^{18}\\) 把 \\(A\\) 变成 \\(B\\) 。 假设 R=1,G=2,B=3 ，我们可以通过逆序数奇/偶把所有排列分两类。 因为只有三个位置，可以发现转换关系的连边是个完全二分图。 所以根据 \\(A\\) 和 \\(B\\) 不同的位数 \\(cnt\\) 即可判定是哪种情况。 \\(cnt=0\\) 完全相同，一直交换某两位即可。 \\(cnt=2\\) 逆序数相同，但排列不同，不可能通过偶数次交换得到。 \\(cnt=3\\) 逆序数不同，因为是完全二分图，一定可以通过两次操作把 \\(A\\) 变成 \\(B\\) ，后面参考 \\(cnt=0\\) 操作即可。 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;char a[3], b[3];inline char gc() &#123; char c = getchar(); while (!isalpha(c)) c = getchar(); return c;&#125;int main() &#123; for (int i = 0; i &lt; 3; ++i) a[i] = gc(); for (int i = 0; i &lt; 3; ++i) b[i] = gc(); int cnt = 0; for (int i = 0; i &lt; 3; ++i) cnt += (a[i] != b[i]); puts((cnt == 0 || cnt == 3) ? &quot;Yes&quot; : &quot;No&quot;); return 0;&#125; E. King Bombee 定义无向图 \\(G=(V,E)\\) 的一个长度为 \\(K\\) 的路径序列 \\(\\{A\\}\\) ： 由 \\(K+1\\) 个点编号 \\(A_0,\\dots,A_K\\in V\\) 构成，\\(A_0\\) 是起点，\\(A_K\\) 是终点，且 \\(\\forall 0\\le i &lt; K, (A_i, A_{i+1})\\in E\\) 给定无向图 \\(G\\ (|V|\\le 2000,|E|\\le 2000)\\) 求有多少个长度为 \\(K\\ (K\\le 2000)\\) 的路径序列，满足： 起点为 \\(S\\) ，终点为 \\(T\\) ，且点 \\(X\\) 在序列中出现偶数次（可以为 \\(0\\) ) 。 感觉最近 ABC 每场都会有一道比较暴力的 DP，就看敢不敢写（ 设 f[i][u][0/1] 表示当前考虑长度为 \\(i\\) 的路径，起点是 \\(S\\) ，终点是 \\(u\\) ，当前节点 \\(X\\) 在其中出现偶数/奇数次的方案数。 初始状态 f[0][S][S==X] = 1 ，答案 f[K][T][0] 。 转移暴力做就可以了，枚举下一步走哪里（ \\(u\\to v\\) ） ：f[i+1][v][k^(v == X)] += f[i][u][k] 。 这个题的核心在复杂度计算，外层枚举 \\(i\\) 是 \\(\\mathcal O(n)\\) 的，内层枚举 \\(u\\) 是 \\(\\mathcal O(n)\\) 的，枚举 \\(v\\) 复杂度怎么算？ 把后两个的复杂度放到一起考虑，就是 \\(\\sum_{u=1}^n deg(u) = \\mathcal O(m)\\) 所以总复杂度是 \\(\\mathcal O(nm)\\) 的。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 2007#define mod 998244353#define add(a, b) (a) = ((a) + (b)) % modvector&lt;int&gt; e[N];int f[N][N][2];int main() &#123; int n = rd(), m = rd(); int k = rd(), s = rd(), t = rd(), x = rd(); for (int i = 1; i &lt;= m; ++i) &#123; int u = rd(), v = rd(); e[u].push_back(v); e[v].push_back(u); &#125; f[0][s][x == s] = 1; for (int i = 0; i &lt; k; ++i) for (int u = 1; u &lt;= n; ++u) for (int k = 0; k &lt;= 1; ++k) &#123; if (!f[i][u][k]) continue; for (auto v : e[u]) &#123; int tar = (k ^ (v == x)); add(f[i + 1][v][tar], f[i][u][k]); &#125; &#125; printf(&quot;%d\\n&quot;, f[k][t][0]); return 0;&#125; F. Shortest Good Path 题意比较复杂，我简单描述一下。 定义无向图 \\(G=(V,E)\\) 的一个长度为 \\(K+1\\) 的路径序列 \\(\\{A\\}\\) ： 由 \\(K+1\\) 个点编号 \\(A_0,\\dots,A_K\\in V\\) 构成，\\(A_0\\) 是起点，\\(A_K\\) 是终点，且 \\(\\forall 0\\le i &lt; K, (A_i, A_{i+1})\\in E\\) 定义路径序列 \\(\\{A\\}\\) 符合要求序列 \\(S\\ (|S| = n, S_i = 0/1)\\) ，当且仅当： 若 \\(S_u = 0\\) ，则 \\(u\\) 在 \\(\\{A\\}\\) 中出现了偶数次（可以为 \\(0\\) ） 若 \\(S_u = 1\\) ，则 \\(u\\) 在 \\(\\{A\\}\\) 中出现了奇数次 那么对于所有的 \\(S=0,\\cdots,2^n-1\\) ，都会存在一个路径序列满足 \\(S\\) 的要求。 记满足 \\(S\\) 要求的路径序列最短为 \\(f(S)\\) ，求 \\(\\sum_{S=0}^{2^n-1}f(S)\\) 看到 ABC 出 \\(n\\le 17\\) 就是状压或者超级暴力了。 考虑路径之间互相更新转移，那么状态之间需要区分的，除了当前每个点出现奇数/偶数次以外，还有最后一个点的编号。 定义符合序列 \\(S\\) 且最后一个点是 \\(u\\) 的状态集编号为 sta[S][u] 。 那么对于每一个 \\(u\\to v\\) ，对所有的 \\(S\\) 连边 sta[S][u] -&gt; sta[S ^ (1 &lt;&lt; v)][v] 最后补上初始状态的连边 source -&gt; sta[1 &lt;&lt; u][u] 那么跑 BFS 就可以求出来每个状态所需的最小长度了（从 source 出发的距离） 那么 \\(f(S) = \\min_{u} dis[sta[S][u]]\\) 即可，复杂度即状态数乘转移数 \\(\\mathcal O(n^2\\ast 2^n)\\) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 17#define M 5000007#define pb push_backint id[1 &lt;&lt; N][N], cnt, dis[M];vector&lt;int&gt; e[M];queue&lt;int&gt; q;int main() &#123; int n = rd(), m = rd(); int S = (1 &lt;&lt; n) - 1; for (int s = 0; s &lt;= S; ++s) for (int u = 0; u &lt; n; ++u) id[s][u] = ++cnt; for (int i = 1; i &lt;= m; ++i) &#123; int u = rd() - 1, v = rd() - 1; for (int s = 0; s &lt;= S; ++s) &#123; e[id[s][u]].pb(id[s ^ (1 &lt;&lt; v)][v]); e[id[s][v]].pb(id[s ^ (1 &lt;&lt; u)][u]); &#125; &#125; for (int i = 0; i &lt; n; ++i) e[0].pb(id[1 &lt;&lt; i][i]); memset(dis, 0x3f, sizeof(dis)); dis[0] = 0; q.push(0); while (!q.empty()) &#123; int u = q.front(); q.pop(); for (auto v : e[u]) if (dis[v] &gt; dis[u] + 1) &#123;dis[v] = dis[u] + 1; q.push(v);&#125; &#125; ll ans = 0; for (int s = 1, tmp; s &lt;= S; ++s) &#123; tmp = 1e9; for (int u = 0; u &lt; n; ++u) &#123; tmp = min(tmp, dis[id[s][u]]); &#125; ans += tmp; &#125; printf(&quot;%lld\\n&quot;, ans); return 0;&#125; G. Construct Good Path 定义无向图 \\(G=(V,E)\\) 的一个长度为 \\(K+1\\) 的路径序列 \\(\\{A\\}\\) ： 由 \\(K+1\\) 个点编号 \\(A_0,\\dots,A_K\\in V\\) 构成，\\(A_0\\) 是起点，\\(A_K\\) 是终点，且 \\(\\forall 0\\le i &lt; K, (A_i, A_{i+1})\\in E\\) 定义路径序列 \\(\\{A\\}\\) 符合要求序列 \\(S\\ (|S| = n, S_i = 0/1)\\) ，当且仅当： 若 \\(S_u = 0\\) ，则 \\(u\\) 在 \\(\\{A\\}\\) 中出现了偶数次（可以为 \\(0\\) ） 若 \\(S_u = 1\\) ，则 \\(u\\) 在 \\(\\{A\\}\\) 中出现了奇数次 给定连通无向图 \\(G\\) 和要求序列 \\(S\\) ，构造一个长度不超过 \\(4\\ast |V|\\) 的序列符合 \\(S\\) 图只有连通的性质，那么可以考虑树怎么解决，其他情况找一棵生成树就可以了。 设 \\(A_u\\) 为 \\(u\\) 子树的合法序列：满足 \\(u\\) 子树内，除了 \\(u\\) 以外其他点都符合要求的一个序列。 强制叶子 \\(v\\) 对应的 \\(A_v=(v)\\) 。 其他情况如果令 \\(A_u=(u)+A_{son1}+(u)+A_{son2}+\\cdots+(u)\\) ，那么只有 \\(son\\) 这些节点会不合法。 那么对于每个导致不合法的 \\(son\\) ，给序列最后接上一个 \\((son,u)\\) 就可以保证 \\(son\\) 合法。 用数学归纳法做正确性证明：\\(|A_u|\\le 4 \\astsize_u-3\\) ，其中 \\(size_u\\) 为\\(u\\) 子树大小。对于叶子，\\(|A_u|=1=4\\ast1-3\\)假设对于一个点 \\(u\\)，所有儿子节点 \\(son\\)都符合，那么这个点的序列：必须添加 \\(cntson + 1\\) 个 \\((u)\\) ，还有所有的 \\(A_{son}\\)，其余的每个补充会增加两个点。\\[\\begin{array}{ll}|A_u| &amp; \\le \\sum_{son} A_{son} + cntson + 1 + 2 \\ast cntson\\\\\\\\\\ &amp; \\le \\sum_{son} (4 \\ast size_{son} - 3) + 3\\ast cntson +1\\\\\\\\\\ &amp; = 4 \\ast \\sum_{son} size_{son} - 3\\ast cntson + 3\\ast cntson+ 1\\\\\\\\\\ &amp; = 4 \\ast (size_u - 1) + 1\\\\\\\\\\ &amp; = 4 \\ast size_u - 3\\end{array}\\] 这样就证明了，最后根的序列大小不超过 \\(4N - 3\\) 。 最后序列中如果根节点奇偶性不对，那么随便找一个根节点的儿子 \\(son\\) ，补一个 \\((son,u,son)\\) 即可修正。 这样子序列长度的上限刚好是 \\(4N\\) ，复杂度 \\(\\mathcal{O}(n)\\)。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;inline bool gn() &#123; char c = getchar(); for (; !isdigit(c); c = getchar()); return c - &#x27;0&#x27;;&#125;#define N 100007#define pb push_backvector&lt;int&gt; e[N], res;bool vis[N], s[N];void add(int x) &#123; s[x] ^= 1; res.pb(x);&#125;void dfs(int u) &#123; vis[u] = 1; add(u); for (auto v : e[u]) if (!vis[v]) &#123; //当前点没在树里出现过 dfs(v); add(u); if (s[v]) &#123;add(v); add(u);&#125; &#125;&#125;int main() &#123; int n = rd(), m = rd(); for (int i = 1; i &lt;= m; ++i) &#123; int u = rd(), v = rd(); e[u].pb(v); e[v].pb(u); &#125; for (int i = 1; i &lt;= n; ++i) s[i] = gn(); dfs(1); if (s[1]) &#123; int son = e[1][0]; add(son); add(1); add(son); &#125; printf(&quot;%d\\n&quot;, (int)res.size()); for (auto x : res) printf(&quot;%d &quot;, x); return 0;&#125; Ex. Linear Maximization 维护一个二维向量集，支持： 插入一个二维向量 \\((x, y)\\) 查询集合中和给定向量 \\((u, v)\\) 点积的最大值 [SDOI2014]向量集 弱化版，线段树维护凸包即可。","categories":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://blog.gyx.me/categories/AtCoder/"},{"name":"AtCoder Beginner Contest","slug":"AtCoder/AtCoder-Beginner-Contest","permalink":"http://blog.gyx.me/categories/AtCoder/AtCoder-Beginner-Contest/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"},{"name":"Constructive Algorithm","slug":"Constructive-Algorithm","permalink":"http://blog.gyx.me/tags/Constructive-Algorithm/"},{"name":"Bitmask","slug":"Bitmask","permalink":"http://blog.gyx.me/tags/Bitmask/"}]},{"title":"Codeforces Round #777 (Div. 2)","slug":"codeforces/1647","date":"2022-03-18T16:00:00.000Z","updated":"2023-03-20T16:25:56.818Z","comments":true,"path":"codeforces/1647/","link":"","permalink":"http://blog.gyx.me/codeforces/1647/","excerpt":"","text":"A 和 B 比较简单就不写了。 C. Madoka and Childish Pranks 一个初始是全白的矩阵，每次可以选一个子矩阵染成棋盘（左上角是白色） 构造一个不超过 \\(n*m\\) 次的方法把矩阵染成目标样子，或输出无解。 Key ：每次染一个 \\(1\\ast 2\\) 的，可以把右侧的变黑，\\(2\\ast 1\\) 的可以把下侧的变黑。 因此对于每一行，我又可以从右往左依次染 \\(1\\ast 2\\) ，除第一列任何位置都可以染黑。 对于第一列从下往上依次染 \\(2\\ast 1\\) ，除 \\((1,1)\\) 位置外都可以染黑。 所以只要 \\((1,1)\\) 不是黑色的就都有解。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;inline int gn() &#123; char c = getchar(); for (; !isdigit(c); c = getchar()); return c - &#x27;0&#x27;;&#125;#define N 107#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;int a[N][N];vector&lt;pair&lt;pii,pii&gt;&gt; s;inline void work() &#123; s.clear(); int n = rd(), m = rd(); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) a[i][j] = gn(); if (a[1][1]) &#123;puts(&quot;-1&quot;); return;&#125; for (int i = 1; i &lt;= n; ++i) for (int j = m; j &gt; 1; --j) if (a[i][j]) s.pb(mp(mp(i,j - 1), mp(i, j))); for (int i = n; i &gt; 1; --i) if (a[i][1]) s.pb(mp(mp(i - 1, 1), mp(i, 1))); printf(&quot;%d\\n&quot;, (int)s.size()); for (auto x : s) printf(&quot;%d %d %d %d\\n&quot;, x.fr.fr, x.fr.sc, x.sc.fr, x.sc.sc);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; D. Madoka and the Best School in Russia 定义一个数字 \\(x\\) 是好的，当且仅当 \\(x\\) 是 \\(d\\) 的倍数。 定义一个数字 \\(x\\) 是漂亮的，当且仅当他不能被拆分成两个好的数的乘积（也就是只含有一个 \\(d\\) ） 给你一个好的数 \\(x\\) ，问你是否有至少两种不同的方法，把 \\(x\\) 拆成若干个漂亮的数的乘积。 方法不同即拆分得到的数集不同。 因为每个漂亮数有且仅有一个 \\(d\\) ，因此 \\(x\\) 里有几个 \\(d\\) ，就至多要拆成几个漂亮数。 先考虑把 \\(x\\) 里的 \\(d\\) 都去掉，剩下的数是 \\(y\\) ，我们至少得到一种方案是 \\(d,d,\\dots,d,d\\ast y\\) 如果 \\(y\\) 可以拆分（不是素数），那么就肯定有解； 如果 \\(y\\) 不可拆分： 如果 \\(d\\) 不可拆分，肯定无解（没有可拆的了） 如果 \\(x\\) 里只有两个 \\(d\\) ，肯定无解（没有可拆的了） 如果 \\(x\\) 里有超过三个 \\(d\\) ，肯定有解（把 \\(y\\) 和 \\(d\\) 拆分得到的三个数，分配给另外三个 \\(d\\) ） 如果 \\(x\\) 里正好有三个 \\(d\\) ，需要检验一下把 \\(d\\) 拆出来的两部分某一部分分给 \\(y\\) 会不会形成新的 \\(d\\) 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 107inline void work() &#123; int x = rd(), d = rd(); if (x % d != 0) &#123;puts(&quot;NO&quot;); return;&#125; if (x / d % d != 0) &#123;puts(&quot;NO&quot;); return;&#125; int cnt = 0; for (; x % d == 0; x /= d, ++cnt); int lim = sqrt(x); for (int i = 2; i &lt;= lim; ++i) if (x % i == 0) &#123;puts(&quot;YES&quot;); return;&#125; if (cnt == 2) &#123;puts(&quot;NO&quot;); return;&#125; lim = sqrt(d); for (int i = 2; i &lt;= lim; ++i) if (d % i == 0) &#123; if (cnt &gt; 3) &#123;puts(&quot;YES&quot;); return;&#125; if (1ll * i * x % d != 0 || 1ll * d / i * x % d != 0) &#123;puts(&quot;YES&quot;); return;&#125; &#125; puts(&quot;NO&quot;);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; E. Madoka and the Sixth-graders 题意太复杂，我简单说一下，不清楚的看原题。 给定一个共 \\(n\\) 个点的内向基环树森林，开始每个点上有一个数（是 \\(n\\) 的排列）。 每一个时刻所有点按照所在边移动一次，如果某一时刻某个点上有很多数，只保留最小的。 如果某一时刻某个点上没数了（叶子），那么按照节点编号从小到大依次往里面塞 \\(n+1,n+2,\\dots\\) 现在给出森林的形态，和经过若干时刻后每个点上的数字 \\(a_1,\\dots,a_n\\) 。 请你还原出来一个字典序最小的初始状态，保证有解。 Key 1 ：假设已知经过的时间是 \\(t\\) ，那么每个点按照边移动 \\(t\\) 步以后的位置上的数字一定是不超过 \\(n\\) 的。 证明：如果是树的部分，那么 \\(n\\) 以后的数字永远追不上；如果是环的部分，因为 \\(n\\) 以后的数字比 \\(n\\) 大，所以都会被舍弃。 Key 2 ：两个点如果在某一步之后同时移动到了同一个点，那么后面的路径都相同（因为每个点只有一个出边）。 找出经过的时间 \\(t\\) ：假设叶子个数是 \\(cnt\\) ，序列里最大是 \\(mx\\) ，那么 \\(t=\\frac{mx - n}{cnt}\\) （每一次移动会引进 \\(cnt\\) 个数）。 每个位置可能会放哪个数？ 根据前面提到的 Key，假设 \\(u\\) 走 \\(t\\) 步之后到达的点是 \\(v\\) ，那么 \\(u\\) 上开始的数字要么是 \\(a_v\\) ，要么比 \\(a_v\\) 大，在移动的过程中某一步被挤掉了。 也就是说，如果一个点集 \\(S\\) 里所有点走 \\(t\\) 步以后到达的点都是 \\(v\\) ，那么这些点初始状态里有一个必定是 \\(a_v\\) ，其他都比 \\(a_v\\) 大。 怎么找 \\(v\\) ：因为每个点都只有一条出边，因此可以直接倍增找 怎么贪心？ 我们先令结果序列 \\(b_u=a_v\\) ，也就是假设每个点的初始状态就是走 \\(t\\) 步以后的位置上的值。 设 \\(S_x=\\\\{u|b_u=x\\\\}\\) ，考虑从小到大放数字 \\(x\\) ： 如果 \\(S_x\\ne \\emptyset\\) ，那么就把 \\(x\\) 放到 \\(S_x\\) 中位置最靠前的 如果 \\(S_x=\\emptyset\\) ，那么就把 \\(x\\) 放到 \\(S_1\\cup S_2\\cup\\dots\\cup S_{x-1}\\) 中未使用的最靠前的位置里。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 100007int f[N][40], a[N], res[N];bool vis[N];queue&lt;int&gt; s[N];set&lt;int&gt; S;inline void work() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; f[i][0] = rd(); vis[f[i][0]] = 1; &#125; for (int j = 1; j &lt; 40; ++j) for (int i = 1; i &lt;= n; ++i) f[i][j] = f[f[i][j - 1]][j - 1]; int mx = 0, cnt = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (!vis[i]) ++cnt; a[i] = rd(); mx = max(mx, a[i]); &#125; cnt = (mx - n) / cnt; memset(vis, 0, sizeof(vis)); for (int i = 1; i &lt;= n; ++i) &#123; int u = i; for (int k = 30; k &gt;= 0; --k) if (cnt &amp; (1 &lt;&lt; k)) u = f[u][k]; res[i] = a[u]; s[res[i]].push(i); vis[res[i]] = 1; //Sx不空 &#125; for (int i = 1; i &lt;= n; ++i) if (vis[i]) s[i].pop(); //把i放到Si最靠前的位置 int nw = 0; for (int i = 1; i &lt;= n; ++i) if (!vis[i]) &#123; while (nw &lt;= i) &#123; while (s[nw].size()) &#123; S.insert(s[nw].front()); s[nw].pop(); &#125; ++nw; &#125; res[*S.begin()] = i; S.erase(S.begin()); &#125; for (int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, res[i]);&#125;int main() &#123; for (int t = 1; t; --t) work(); return 0;&#125; F. Madoka and Laziness 给定一个没有重复数值的数列 \\(\\{a_i\\}\\) ，问有多少种方式将数列划分为两个峰序列（严格单增再单减）。 两种划分不同，当且仅当至少某一个峰序列的峰值不同（认为 &lt;a,b&gt; 和 &lt;b,a&gt; 相同）。 Key ：最大值一定是其中一个峰的峰值。 这个观察有什么用呢？因为一个峰值固定，我们可以得到答案是 O(n) 的。 也就是说，我们只需要去检验，其他的每一个值是否有可能成为峰值即可。 怎么检验呢？只需要判断是否存在一种拆分方式，使得到每个位置之前是升的，过了这个位置之后是降的，并且没给这个序列的元素扔给最大值所在的序列都合法。 我们可以假设另一个峰值（峰值B）在最大值（峰值A）的右侧，然后把序列翻过来再做一遍即可。 这样就有三个阶段： 到峰值A前：两个序列都上升 这一阶段序列A里只要单调递增，放多大的都可以。 我们为了后面序列B还要增的考虑，应该尽量减少序列B在这一部分的最大值。 设 \\(f_i\\) 为考虑前缀 \\(i\\) ，则 \\(a_i\\) 必定为某一个序列结尾，则另一个序列结尾最小值是多少。 转移很简单，接在 \\(a_{i-1}\\) 后，或接在 \\(f_{i-1}\\) 后。 12if (a[i] &gt; a[i - 1]) f[i] = min(f[i], f[i - 1]);if (a[i] &gt; f[i - 1]) f[i] = min(f[i], a[i - 1]); 峰值A后，峰值B前：序列A下降，序列B上升 这一阶段因为两个序列单调性不同，所以贪心策略也不同。 设 \\(g_{i,0}\\) 表示第 \\(i\\) 个元素放到序列A里，另一个序列（正在上升的序列B）末尾最小是多少。 设 \\(g_{i,1}\\) 表示第 \\(i\\) 个元素放到序列B里，另一个序列（正在下降的序列A）末尾最大是多少。 转移也很简单，讨论一下接在谁后面就好了。 1234if (a[i] &lt; a[i - 1]) g[i][0] = min(g[i][0], g[i - 1][0]);if (a[i] &lt; g[i - 1][1]) g[i][0] = min(g[i][0], a[i - 1]);if (a[i] &gt; a[i - 1]) g[i][1] = max(g[i][1], g[i - 1][1]);if (a[i] &gt; g[i - 1][0]) g[i][1] = max(g[i][1], a[i - 1]); 峰值B后：两个序列都下降 倒着考虑，变成单增的，那么在保证峰值B跟着的序列合法的前提下，另一个序列（留给峰值A的）的最大值要尽可能小。 因此处理方法同第一个阶段（设为 \\(h\\) 数组）。 那么怎么判断是否合法嘞？把 \\(a_i\\) 放到序列B里，另一个序列合法（ 也就是满足 g[i][1] &gt; h[i] ） 就可以啦～ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 500007#define inf 1e9 + 7int n, a[N], f[N], g[N][2];inline int calc() &#123; int p = 0; //maxpos for (int i = 1; i &lt;= n; ++i) &#123; f[i] = g[i][0] = inf; g[i][1] = -1; if (a[i] &gt; a[p]) p = i; &#125; for (int i = 1; i &lt;= p; ++i) &#123; if (a[i] &gt; a[i - 1]) f[i] = min(f[i], f[i - 1]); if (a[i] &gt; f[i - 1]) f[i] = min(f[i], a[i - 1]); &#125; g[p][0] = f[p]; //承接第一阶段的最宽松约束 for (int i = p + 1; i &lt;= n; ++i) &#123; if (a[i] &lt; a[i - 1]) g[i][0] = min(g[i][0], g[i - 1][0]); if (a[i] &lt; g[i - 1][1]) g[i][0] = min(g[i][0], a[i - 1]); if (a[i] &gt; a[i - 1]) g[i][1] = max(g[i][1], g[i - 1][1]); if (a[i] &gt; g[i - 1][0]) g[i][1] = max(g[i][1], a[i - 1]); &#125; int ans = 0; for (int i = n; i &gt; p; --i) &#123; if (a[i] &gt; a[i + 1]) f[i] = min(f[i], f[i + 1]); if (a[i] &gt; f[i + 1]) f[i] = min(f[i], a[i + 1]); if (g[i][1] &gt; f[i]) ++ans; &#125; return ans;&#125;int main() &#123; n = rd(); for (int i = 1; i &lt;= n; ++i) a[i] = rd(); int ans = calc(); reverse(a + 1, a + 1 + n); printf(&quot;%d\\n&quot;, ans + calc()); return 0;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://blog.gyx.me/categories/Codeforces/"},{"name":"Codeforces Round","slug":"Codeforces/Codeforces-Round","permalink":"http://blog.gyx.me/categories/Codeforces/Codeforces-Round/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"},{"name":"Constructive Algorithm","slug":"Constructive-Algorithm","permalink":"http://blog.gyx.me/tags/Constructive-Algorithm/"}]},{"title":"AtCoder Beginner Contest 237","slug":"atcoder/abc237","date":"2022-01-31T00:38:14.000Z","updated":"2023-03-20T16:28:06.899Z","comments":true,"path":"atcoder/abc237/","link":"","permalink":"http://blog.gyx.me/atcoder/abc237/","excerpt":"","text":"感觉这场质量还不错。 C - kasaka 给定一个字符串 \\(S\\) ，问是否可以在开头添加若干个 a 使得串变为回文串。 如果字符串开头 a 的个数比末尾 a 的个数多肯定无解。 否则问题等价于去掉开头和结尾的所有的 a ，然后判断是否是回文串。 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 1000007char s[N];int main() &#123; scanf(&quot;%s&quot;, s + 1); int n = strlen(s + 1); int x = 0, y = 0; for (int i = 1; i &lt;= n; ++i, ++x) if (s[i] != &#x27;a&#x27;) break; for (int i = n; i; --i, ++y) if (s[i] != &#x27;a&#x27;) break; if (x &gt; y) &#123;puts(&quot;No&quot;); return 0;&#125; int L = x + 1, R = n - y; for (int i = L; i &lt;= R; ++i) if (s[i] != s[R - (i - L)]) &#123;puts(&quot;No&quot;); return 0;&#125; puts(&quot;Yes&quot;); return 0;&#125; D - LR insertion 一个数列，开始只有 \\(0\\) ，对 \\(i=1,2,\\cdots,n\\) 依次执行： 若 op[i] = L ，将 \\(i\\) 插入到 \\(i-1\\) 的左侧。 若 op[i] = R ，将 \\(i\\) 插入到 \\(i-1\\) 的右侧。 求最终的数列。 考虑按照 \\(i\\) 从大到小执行，容易发现操作等价于每次在开头或结尾添加数字。 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 200007#define pb push_back#define pf push_frontstring s;deque&lt;int&gt; res;int main() &#123; cin.tie(nullptr) -&gt; sync_with_stdio(false); int n; cin &gt;&gt; n; res.pb(n); cin &gt;&gt; s; for (int i = n - 1; i &gt;= 0; --i) s[i] == &#x27;L&#x27; ? res.pb(i) : res.pf(i); for (auto x : res) printf(&quot;%d &quot;, x); return 0;&#125; E - Skiing \\(n\\) 个点每个点有一个点权 \\(h_i\\) ，以及 \\(M\\) 条有向边 \\((u,v)\\) : 若 \\(h_u&gt;h_v\\) ，边权为 \\(-(h_u-h_v)\\) ；否则，边权为 \\(2(h_u-h_v)\\) 。 求 \\(1\\) 号点到所有点的最短路。 负权图不可以跑 Dijkstra ；又很容易构造出网格图卡掉 SPFA 。 一个把负权图变成正权图的方法： 给每个点分配一个势能 \\(d_i\\) ，对于一条边 \\(u\\to v\\) ，边权增加 \\(d_u-d_v\\) ，把所有边都变成非负权值。 \\(s\\) 到 \\(x\\) 的最短路即 \\(dis_x+d_x-d_s\\) 。 本题中 \\(h_i\\) 恰好符合势能的要求，因此修改边权后运行 Dijkstra 即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 200007int n, m, tot, hd[N];struct edge &#123;int to, nxt, w;&#125; e[N &lt;&lt; 1];inline void add(int u, int v, int w) &#123; e[++tot].to = v; e[tot].w = w; e[tot].nxt = hd[u]; hd[u] = tot;&#125;ll dis[N], h[N];bool vis[N];priority_queue&lt;pair&lt;ll, int&gt; &gt; q;inline void dij(int u) &#123; memset(dis, 0x3f, sizeof(dis)); dis[u] = 0; q.push(make_pair(0, u)); while (!q.empty()) &#123; u = q.top().second; q.pop(); if (vis[u]) continue; vis[u] = 1; for (int i = hd[u], v; i; i = e[i].nxt) if (dis[v = e[i].to] &gt; dis[u] + e[i].w) &#123; dis[v] = dis[u] + e[i].w; q.push(make_pair(-dis[v], v)); &#125; &#125;&#125;int main() &#123; n = rd(); m = rd(); for (int i = 1; i &lt;= n; ++i) h[i] = rd(); for (int i = 1, u, v, w; i &lt;= m; ++i) &#123; u = rd(); v = rd(); if (h[u] &lt; h[v]) swap(u, v); add(u, v, 0); add(v, u, h[u] - h[v]); &#125; dij(1); ll ans = 0; for (int u = 1; u &lt;= n; ++u) ans = max(ans, -(dis[u] + h[u] - h[1])); printf(&quot;%lld\\n&quot;, ans); return 0;&#125; F - |LIS| = 3 计数长度为 \\(n\\ (n\\le 1000)\\) ，每个位置是 \\([1,m]\\ (m\\le 10)\\) 中整数的数列个数，满足 LIS 长度不超过 \\(3\\) 。 比较经典的状态机 DP ，设 \\(f[i][x][y][z]\\) 表示长度为 \\(i\\) 的数列，长度为 \\(1\\) 的 LIS 结尾最小是 \\(x\\) ，长度为 \\(2\\) 的 LIS 结尾最小是 \\(y\\) ，长度为 \\(3\\) 的 LIS 结尾最小是 \\(z\\) 时的数列个数。 转移直接枚举第 \\(i\\) 个位置的数字即可，注意不能超过 \\(z\\) 。复杂度 \\(\\mathcal{O}(nm^4)\\) 。 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 1007#define mod 998244353int n, m, f[N][12][12][13];#define min(x, y) ((x) &gt; (y) ? (y) : (x))int main() &#123; cin.tie(nullptr) -&gt; sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; ++i) f[1][i][11][12] = 1; for (int i = 1; i &lt; n; ++i) for (int a = 1; a &lt;= m; ++a) for (int b = a + 1; b &lt;= 11; ++b) for (int c = b + 1; c &lt;= 12; ++c) for (int j = 1; j &lt;= min(c, m); ++j) &#123; int tara = min(a, j); int tarb = (j &gt; a ? min(b, j) : b); int tarc = (j &gt; b ? min(c, j) : c); f[i + 1][tara][tarb][tarc] = (f[i + 1][tara][tarb][tarc] + f[i][a][b][c]) % mod; &#125; int ans = 0; for (int i = 1; i &lt;= m; ++i) for (int j = i + 1; j &lt;= m; ++j) for (int k = j + 1; k &lt;= m; ++k) ans = (ans + f[n][i][j][k]) % mod; cout &lt;&lt; ans; return 0;&#125; G - Range Sort Query 一个 \\(n\\) 的排列，\\(q\\) 次操作，每次对一个区间升序或降序排序。问 \\(x\\) 最终的位置。 因为只关心 \\(x\\) 的位置，所以将小于 \\(x\\) 的认为是 \\(0\\) ，大于 \\(x\\) 的认为是 \\(2\\) ，将 \\(x\\) 改为 \\(1\\) 。 区间排序就变成统计区间 \\(0,1,2\\) 的个数，然后进行至多三段的区间赋值，线段树即可。 另解 set 维护区间复杂度正确，每次操作最多带来 \\(3\\) 个区间，每个区间被遍历后一定会删除（除了两侧至多留下 \\(2\\) 个）。 注意维护 set 的时候不能查 \\(l_i\\ge L\\) 的区间（第一段有可能找不到），所以要按 \\(r_i\\) 为第一关键字排序。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;#define mt make_tuple#define lb lower_bound#define tri tuple&lt;int, int, int&gt;#define R get&lt;0&gt;#define L get&lt;1&gt;#define V get&lt;2&gt;set&lt;tri&gt; s;int main() &#123; cin.tie(nullptr) -&gt; sync_with_stdio(false); int n, q, k; cin &gt;&gt; n &gt;&gt; q &gt;&gt; k; for (int i = 1, x; i &lt;= n; ++i) &#123; cin &gt;&gt; x; s.insert(mt(i, i, (x == k) + (x &gt; k) * 2)); &#125; for (int i = 1, ty, l, r; i &lt;= q; ++i) &#123; cin &gt;&gt; ty &gt;&gt; l &gt;&gt; r; auto x = mt(l, 0, 0); int cnt[3] = &#123;0, 0, 0&#125;; for (auto nw = s.lb(x); nw != s.end(); nw = s.lb(x)) &#123; auto y = *nw; if (L(y) &gt; r) break; cnt[V(y)] += min(r, R(y)) - max(l, L(y)) + 1; if (L(y) &lt; l) s.insert(mt(l - 1, L(y), V(y))); if (R(y) &gt; r) s.insert(mt(R(y), r + 1, V(y))); s.erase(nw); &#125; if (ty == 1) &#123; for (int v = 0; v &lt;= 2; l += cnt[v], ++v) if (cnt[v]) s.insert(mt(l + cnt[v] - 1, l, v)); &#125; else &#123; for (int v = 2; v &gt;= 0; l += cnt[v], --v) if (cnt[v]) s.insert(mt(l + cnt[v] - 1, l, v)); &#125; &#125; for (auto x : s) if (V(x) == 1) &#123;printf(&quot;%d\\n&quot;, R(x)); break;&#125; return 0;&#125; Ex - Hakata 给一个字符串 \\(S\\ (|S|\\le 200)\\)，问最多能选出多少个回文子串，使得相互不包含。 首先有一个结论是：长度为 \\(n\\) 的串本质不同的回文子串不超过 \\(n\\) 个。 接下来回文子串之间的包含关系是一个偏序，根据 Dilworth 定理解最大反链即可。 定理细节和使用方法详见 Dilworth's Theorem - Colin's Blog 。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 207#define pb push_backstring str, a[N];set&lt;string&gt; s;inline bool substr(int u, int v) &#123; for (int i = 0; i + a[v].length() &lt;= a[u].length(); ++i) &#123; bool fl = true; for (int j = 0; j &lt; a[v].length(); ++j) if (a[u][i + j] != a[v][j]) &#123;fl = false; break;&#125; if (fl) return true; &#125; return false;&#125;vector&lt;int&gt; e[N];int match[N], vis[N];bool dfs(int u, int t) &#123; for (auto v : e[u]) if (vis[v] != t) &#123; vis[v] = t; if (!match[v] || dfs(match[v], t)) &#123;match[v] = u; return true;&#125; &#125; return false;&#125;int main() &#123; cin &gt;&gt; str; int n = str.length(); for (int l = 0; l &lt; n; ++l) for (int r = l; r &lt; n; ++r) &#123; bool fl = true; int len = r - l + 1; for (int i = 1; i &lt;= len; ++i) if (str[l + i - 1] != str[r - i + 1]) fl = false; if (fl) s.insert(str.substr(l, len)); &#125; int m = 0; for (auto x : s) a[++m] = x; for (int i = 1; i &lt;= m; ++i) for (int j = 1; j &lt;= m; ++j) if (i != j &amp;&amp; substr(j, i)) e[i].pb(j); int ans = m; for (int i = 1; i &lt;= m; ++i) ans -= dfs(i, i); printf(&quot;%d\\n&quot;, ans); return 0;&#125;","categories":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://blog.gyx.me/categories/AtCoder/"},{"name":"AtCoder Beginner Contest","slug":"AtCoder/AtCoder-Beginner-Contest","permalink":"http://blog.gyx.me/categories/AtCoder/AtCoder-Beginner-Contest/"}],"tags":[{"name":"Graphs","slug":"Graphs","permalink":"http://blog.gyx.me/tags/Graphs/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"},{"name":"STL","slug":"STL","permalink":"http://blog.gyx.me/tags/STL/"},{"name":"Shortest Path","slug":"Shortest-Path","permalink":"http://blog.gyx.me/tags/Shortest-Path/"}]},{"title":"2021-2022 ICPC Asia Shenyang Regional","slug":"official/icpc/21-shenyang","date":"2021-11-22T09:21:07.000Z","updated":"2023-03-20T16:36:09.976Z","comments":true,"path":"official/icpc/21-shenyang/","link":"","permalink":"http://blog.gyx.me/official/icpc/21-shenyang/","excerpt":"","text":"Summary 比赛地址 ：Codeforces Gym 103427 还没补完：ACGKLM 难度：BEFJ - HIL - DM - ACG - K 热身赛 D - Closest Pair of Segments 原题是 HDU 6697 。 二分答案之后考虑将线段扩张成 “香肠”，检查是否有一对“香肠”相交。 考虑对 \\(x\\) 扫描线，用 set 维护这些香肠关于 \\(y\\) 的顺序，那么总是只需要检查相邻的两个香肠是否相交。亦即，对于一个插入事件，检查新的香肠是否和上下相邻的两个香肠相交，对于一个删除事件，删除香肠之后检查上下两个相邻的香肠是否相交。如果判定到相交说明答案偏大，否则答案偏小。 由于在判定到相交之前的扫描过程中，香肠都是互不相交的凸图形，可以简单地用一条连接香肠最左点和最右点的线段来描述香肠在扫描线上的相对顺序，判定香肠相交直接计算扩张前的两个线段的距离即可。 复杂度是 \\(O(n\\log n\\log (1/\\epsilon))\\) 。 B - Bitwise Exclusive-OR Sequence 构造 \\(n\\) 个数 \\(a_1,\\dots,a_n\\)，满足 \\(m\\) 个约束条件，形如 \\(a_{p_i}\\oplus a_{q_i} = w_i\\) ，且 \\(\\sum a_i\\) 最小。 按位考虑，那么按照每一位都可以建出来一张图，边权为 \\(0/1\\) 表示两个数在这一位相同/不同 。 图存在矛盾的边则无解，有解时可以将每一个连通分图的点划分为两组，让个数少的那一组这一位取 \\(1\\) 即可最小化。 复杂度 \\(O(n\\log \\max a_i)\\) 。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;#define N 200007using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;int n, m;struct node &#123;int a, b, w;&#125; c[N];ll ans = 0;int tot, cnt[2], hd[N], col[N];struct edge &#123;int to, nxt, w;&#125;e[N &lt;&lt; 1];inline void add(int u, int v, int w) &#123; e[++tot].to = u; e[tot].w = w; e[tot].nxt = hd[v]; hd[v] = tot; e[++tot].to = v; e[tot].w = w; e[tot].nxt = hd[u]; hd[u] = tot;&#125;bool fl = 0;void dfs(int u) &#123; ++cnt[col[u]]; for (int i = hd[u], v; i; i = e[i].nxt) &#123; v = e[i].to; if (col[v] != -1) &#123; if (col[v] != (col[u] ^ e[i].w)) &#123;fl = 1; return;&#125; continue; &#125; col[v] = (col[u] ^ e[i].w); dfs(v); if(fl) return; &#125;&#125; inline bool work(int p) &#123; tot = 0; for (int i = 1; i &lt;= n; ++i) hd[i] = 0, col[i] = -1; for (int i = 1; i &lt;= m; ++i) add(c[i].a, c[i].b, ((c[i].w &amp; (1 &lt;&lt; p)) &gt; 0)); for (int i = 1; i &lt;= n; ++i) if (col[i] == -1) &#123; cnt[0] = 0; cnt[1] = 0; col[i] = 0; dfs(i); if (fl) return 1; ans += 1ll * (1 &lt;&lt; p) * min(cnt[0], cnt[1]); &#125; return 0;&#125;int main() &#123; n = rd(); m = rd(); for (int i = 1; i &lt;= m; ++i) &#123; c[i].a = rd(); c[i].b = rd(); c[i].w = rd(); &#125; for (int i = 30; i &gt;= 0; --i) if (work(i)) &#123;puts(&quot;-1&quot;); return 0;&#125; printf(&quot;%lld\\n&quot;, ans); return 0;&#125; D - Cross the Maze E - Edward Gaming, the Champion 给定一个串，数串里有多少个 edgnb 1234567891011121314#include&lt;bits/stdc++.h&gt;#define N 200007using namespace std;int ans;char s[N];int main()&#123; scanf(&quot;%s&quot;, s); for (int i = 0; s[i]; ++i) if (!strncmp(s + i, &quot;edgnb&quot;, 5)) ++ans; printf(&quot;%d\\n&quot;, ans); return 0;&#125; F - Encoded Strings I 设从后往前看，字符 \\(c\\) 第一次出现之前出现过 \\(k\\) 个不同的字母，则映射 f(c)='a'+k 定义一个串 \\(s\\) 的 Encoded String \\(s&#39;\\) ：对 \\(\\forall i\\le |s|, s&#39;[i] = f(s[i])\\) 求给定串所有前缀对应的 Encoded String 中，字典序最大的那个。 暴力求，然后按字典序排序。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;#define N 1007using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;char S[N];map&lt;char, int&gt; f;struct node &#123; int len; char a[N];&#125;s[N];inline bool cmp(node a, node b) &#123; int tot = min(a.len, b.len); for (int i = 1; i &lt;= tot; ++i) if (a.a[i] != b.a[i]) return a.a[i] &lt; b.a[i]; return a.len &lt; b.len;&#125;inline void work(int p) &#123; int cnt = 0; f.clear(); s[p].len = p; for (int i = p; i; --i) &#123; if (!f[S[i]]) f[S[i]] = ++cnt; s[p].a[i] =&#x27;a&#x27; - 1 + f[S[i]]; &#125;&#125;int main() &#123; int n = rd(); scanf(&quot;%s&quot;, S + 1); for (int i = 1; i &lt;= n; ++i) work(i); sort(s + 1, s + 1 + n, cmp); for (int i = 1; i &lt;= s[n].len; ++i) putchar(s[n].a[i]); puts(&quot;&quot;); return 0;&#125; H - Line Graph Matching 给定一个带权图，求对应线图的最大权匹配。 按照线图的最大匹配算法，每个连通块中，如果边数是偶数就可以完美匹配，否则只需要扔掉一条边。 可以扔掉的条件是删除后形成的新连通块边数都是偶数，即删掉非割边或两侧边数都是偶数的割边。复杂度 \\(O(n)\\) 。 I - Linear Fractional Transformation 定义复数函数 \\(f(z)=\\frac{az+b}{cz+d}\\ (a,b,c,d\\in \\mathbb{C},ad-bc\\not=0)\\)，给定 \\(f(z_1)=w_1,f(z_2)=w_2,f(z_3)=w_3\\) ，求 \\(f(z_0)\\) 。 数据保证 \\(z_1,z_2,z_3,w_1,w_2,w_3\\) 两两不同。 若 \\(c=0\\) ，则 \\(f(z)=kz+b\\) ，直接用两个方程把 \\(k,b\\) 求出后，判断第三个方程是否正确，然后代入即可。 若 \\(c\\not = 0\\) ，则 \\(zf(z)+k_3f(z)=k_1z+k_2\\) ，手动消元一下得： \\[ k_3=\\displaystyle\\frac{(w_2z_2 - w_1z_1) - \\displaystyle\\frac{z_2-z_1}{z_3-z_1} * (w_3z_3 - w_1z_1)}{\\displaystyle\\frac{z_2-z_1}{z_3-z_1} * (w_3 - w_1) - (w_2 - w_1)} \\] 比赛的时候本来想用自带的 complex&lt;double&gt; 类，但是发现 real 和 imag 不能直接赋值，就不会用了遂手写... 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;#define N 200007using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;inline double sqr(double x) &#123; return x * x;&#125;struct cp &#123; double a, b; inline cp operator + (const cp &amp;obj) const&#123; return (cp)&#123;a + obj.a, b + obj.b&#125;; &#125; inline cp operator - (const cp &amp;obj) const&#123; return (cp)&#123;a - obj.a, b - obj.b&#125;; &#125; inline cp operator * (const cp &amp;obj) const&#123; return (cp)&#123;a * obj.a - b * obj.b, a * obj.b + b * obj.a&#125;; &#125; inline cp operator / (const double x) const &#123; return (cp)&#123;a / x, b / x&#125;; &#125; inline cp operator / (const cp &amp;obj) const&#123; return (cp)&#123;a * obj.a + b * obj.b, b * obj.a - a * obj.b&#125; / (sqr(obj.a) + sqr(obj.b)); &#125; inline bool operator == (const cp &amp;obj) const&#123; return (fabs(a - obj.a) &lt;= 1e-6 &amp;&amp; fabs(b - obj.b) &lt;= 1e-6); &#125;&#125;;inline void work() &#123; cp z0, z1, z2, z3, w1, w2, w3; z1.a = rd(); z1.b = rd(); w1.a = rd(); w1.b = rd(); z2.a = rd(); z2.b = rd(); w2.a = rd(); w2.b = rd(); z3.a = rd(); z3.b = rd(); w3.a = rd(); w3.b = rd(); z0.a = rd(); z0.b = rd(); cp k = (w2 - w1) / (z2 - z1); cp b = w1 - k * z1; if (w3 == k * z3 + b) &#123; cp res = k * z0 + b; printf(&quot;%.10lf %.10lf\\n&quot;, res.a, res.b); return; &#125; cp g1, g2, g3; g1 = z1 * w1; g2 = z2 * w2; g3 = z3 * w3; cp kk = (z2 - z1) / (z3 - z1); cp k3 = ((g2 - g1) - kk * (g3 - g1)) / (kk * (w3 - w1) - (w2 - w1)); cp k1 = ((g2 - g1) + k3 * (w2 - w1)) / (z2 - z1); cp k2 = z1 * w1 + k3 * w1 - k1 * z1; cp res = (k1 * z0 + k2) / (z0 + k3); printf(&quot;%.10lf %.10lf\\n&quot;, res.a, res.b);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; 题解提供的做法比较神仙，分式线性变换保交换比，有： \\[ \\frac{w_0-w_1}{w_0-w_2}\\bigg/\\frac{w_3-w_1}{w_3-w_2}=\\frac{z_0-z_1}{z_0-z_2}\\bigg/\\frac{z_3-z_1}{z_3-z_2} \\] 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;typedef complex&lt;double&gt; C;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;inline C rdc() &#123; int x = rd(), y = rd(); return C(x, y);&#125;inline void work() &#123; C z1 = rdc(), w1 = rdc(), z2 = rdc(), w2 = rdc(), z3 = rdc(), w3 = rdc(), z0 = rdc(); C res = ((z0 - z1) / (z0 - z2)) / ((z3 - z1) / (z3 - z2)) * ((w3 - w1) / (w3 - w2)); res = w2 + (w2 - w1) / (res - C(1, 0)); printf(&quot;%.12lf %.12lf\\n&quot;, res.real(), res.imag());&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; J - Luggage Lock 一个四位锁，每次可以把一个区间往上或往下拨动 \\(1\\) ，多次询问： 从 \\(a_1a_2a_3a_4\\) 状态拨到 \\(b_1b_2b_3b_4\\) 状态最少需要拨动的次数。 容易发现答案只和对应位的差有关，问题变为 \\(0000\\) 拨到 \\(x_1x_2x_3x_4\\) 所需的最少次数，bfs 求最短路。计算量 \\(10^4\\times 10\\times 4\\) 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;inline bool getmin(int &amp;a, int b) &#123;return (a &gt; b ? (a = b, true) : false);&#125;inline bool getmax(int &amp;a, int b) &#123;return (a &lt; b ? (a = b, true) : false);&#125;#define N 10000queue&lt;int&gt; q;int dis[N];int main() &#123; memset(dis, 0x3f, sizeof(dis)); q.push(0); dis[0] = 0; while(!q.empty()) &#123; int u = q.front(); q.pop(); int a[4] = &#123;u / 1000, u % 1000 / 100, u % 100 / 10, u % 10&#125;; for (int x = 1; x &lt;= 4; ++x) &#123; for (int l = 0; l &lt;= 4 - x; ++l) &#123; // up int v = 0; for (int i = 0; i &lt; 4; ++i) if (i &gt;= l &amp;&amp; i &lt; l + x) v = v * 10 + (a[i] + 1) % 10; else v = v * 10 + a[i]; if (dis[v] &gt; dis[u] + 1) &#123;dis[v] = dis[u] + 1; q.push(v);&#125; v = 0; for (int i = 0; i &lt; 4; ++i) if (i &gt;= l &amp;&amp; i &lt; l + x) v = v * 10 + (a[i] + 9) % 10; else v = v * 10 + a[i]; if (dis[v] &gt; dis[u] + 1) &#123;dis[v] = dis[u] + 1; q.push(v);&#125; &#125; &#125; &#125; for (int t = rd(); t; --t) &#123; int u = rd(), v = rd(); int a[4] = &#123;u / 1000, u % 1000 / 100, u % 100 / 10, u % 10&#125;; int b[4] = &#123;v / 1000, v % 1000 / 100, v % 100 / 10, v % 10&#125;; int dlt = 0; for (int i = 0; i &lt; 4; ++i) dlt = dlt * 10 + (b[i] - a[i] + 10) % 10; printf(&quot;%d\\n&quot;, dis[dlt]); &#125; return 0;&#125;","categories":[{"name":"Official Contests","slug":"Official-Contests","permalink":"http://blog.gyx.me/categories/Official-Contests/"}],"tags":[{"name":"Graphs","slug":"Graphs","permalink":"http://blog.gyx.me/tags/Graphs/"},{"name":"Connectivity","slug":"Connectivity","permalink":"http://blog.gyx.me/tags/Connectivity/"}]},{"title":"AtCoder Beginner Contest 216","slug":"atcoder/abc216","date":"2021-08-29T13:37:14.000Z","updated":"2023-03-20T16:27:55.948Z","comments":true,"path":"atcoder/abc216/","link":"","permalink":"http://blog.gyx.me/atcoder/abc216/","excerpt":"","text":"E. Amusement Park 给定 \\(n\\) 个数，最多 \\(k\\) 次操作，每次可以拿走某个数 \\(a_i\\) 加入得分，然后把 \\(a_i-1\\) 放回，问得分最大值，\\(k,a_i\\le 2\\times 10^9\\) 二分最后剩下的所有数里的最大值为 \\(x\\) ，答案是把所有数都拿到 \\(x\\) 的得分，然后加上剩下次数个 \\(x\\) 的得分。 需要注意二分上界 \\(r = 2\\times 10^9\\) ，所以二分 mid = (l + r) / 2 的时候可能会爆 int 。坑死我了 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;#define N 200007using namespace std;typedef long long ll;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for(; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for(; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;ll n, k, a[N];inline bool valid(ll x) &#123; ll cnt = 0; for (int i = 1; i &lt;= n; ++i) if (a[i] &gt; x) cnt += a[i] - x; return cnt &lt;= k;&#125;inline ll sum(ll l, ll r) &#123; return (l + r) * (r - l + 1) / 2;&#125;int main() &#123; n = rd(); k = rd(); for (int i = 1; i &lt;= n; ++i) a[i] = rd(); ll l = 0, r = 2e9; while (l &lt; r) &#123; ll mid = (l + r) / 2; valid(mid) ? r = mid : l = mid + 1; &#125; ll ans = 0; for (int i = 1; i &lt;= n; ++i) if (a[i] &gt; l) &#123; ans += sum(l + 1, a[i]); k -= a[i] - l; &#125; ans += k * l; printf(&quot;%lld\\n&quot;, ans); return 0;&#125; F. Max Sum Counting 有 \\(n\\) 个数对 \\((A_i, B_i)\\)构成一个集合，问有多少个子集，满足子集内 \\(A\\) 的最大值大于 \\(B\\) 的和。 考虑枚举最大的 \\(A\\) 是谁，将所有数对按照 \\(A\\) 从小到大排序，问题转化为选哪些 \\(B\\) 。 假设现在考虑排序后第 \\(i\\) 个数对，则 \\(B_i\\) 必选，相当于计数 \\(B_1,\\cdots,B_{i-1}\\) 中选出若干，且总和不超过 \\(A_i-B_i\\) 的方案数。 因为 \\(A\\) 的值域很小，搞一个 01 背包计数即可，复杂度 \\(O(n\\times \\max A_i)\\) 。 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;#define N 5007#define mod 998244353using namespace std;typedef long long ll;int n, f[N] = &#123;1&#125;;struct node &#123;int a, b;&#125; c[N];inline bool operator &lt; (const node &amp;a, const node &amp;b) &#123; return a.a == b.a ? a.b &lt; b.b : a.a &lt; b.a;&#125;int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;c[i].a); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;c[i].b); sort(c + 1, c + 1 + n); int ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; for (int v = 0; v &lt;= c[i].a - c[i].b; ++v) ans = (ans + f[v]) % mod; for (int v = N - 1; v &gt;= c[i].b; --v) f[v] = (f[v] + f[v - c[i].b]) % mod; &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125; G. 01Sequence 构造长度为 \\(n\\) 的 \\(01\\) 序列，满足 \\(k\\) 个形如 “ \\([l_i,r_i]\\) 内至少有 \\(x_i\\) 个 \\(1\\) ” 的条件，且 \\(1\\) 的个数最少。 将约束条件按照右端点从小到大排序，考虑每个条件当前还未满足的个数。 则对于每个 \\(1\\) ，在可行的范围内往右放的贡献不低于往左放，因此从右边界依次放过来即可。 查询未满足的个数需要维护一个树状数组，复杂度 \\(O(n\\log n)\\) 。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;#define N 200007using namespace std;typedef long long ll;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for(; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for(; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;int cur[N], vis[N];#define lowbit(x) (x &amp; -x)inline void add(int x) &#123; for (; x &lt; N; x += lowbit(x)) ++cur[x];&#125;inline int calc(int x) &#123; int res = 0; for (; x; x -= lowbit(x)) res += cur[x]; return res;&#125;struct node &#123;int l, r, k;&#125; c[N];inline bool operator &lt; (const node &amp;a, const node &amp;b) &#123;return a.r &lt; b.r;&#125;int main() &#123; int n = rd(); int m = rd(); for (int i = 1; i &lt;= m; ++i) &#123; c[i].l = rd(); c[i].r = rd(); c[i].k = rd(); &#125; sort(c + 1, c + 1 + m); for (int i = 1; i &lt;= m; ++i) &#123; int nw = calc(c[i].r) - calc(c[i].l - 1); for (int ptr = c[i].r; nw &lt; c[i].k; --ptr) if (!vis[ptr]) &#123; add(ptr); ++nw; vis[ptr] = 1; &#125; &#125; for (int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, vis[i]); return 0;&#125; H. Random Robots","categories":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://blog.gyx.me/categories/AtCoder/"},{"name":"AtCoder Beginner Contest","slug":"AtCoder/AtCoder-Beginner-Contest","permalink":"http://blog.gyx.me/categories/AtCoder/AtCoder-Beginner-Contest/"}],"tags":[{"name":"Binary Search","slug":"Binary-Search","permalink":"http://blog.gyx.me/tags/Binary-Search/"},{"name":"Knapsack Problem","slug":"Knapsack-Problem","permalink":"http://blog.gyx.me/tags/Knapsack-Problem/"},{"name":"Greedy","slug":"Greedy","permalink":"http://blog.gyx.me/tags/Greedy/"}]},{"title":"Codeforces Round #738 (Div. 2)","slug":"codeforces/1559","date":"2021-08-17T16:00:00.000Z","updated":"2023-03-20T16:25:51.090Z","comments":true,"path":"codeforces/1559/","link":"","permalink":"http://blog.gyx.me/codeforces/1559/","excerpt":"","text":"A - Mocha and Math 签到。显然可以构造出来所有的与。 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;inline void work() &#123; int n = rd(), ans = rd(); for (int i = 2; i &lt;= n; ++i) ans = (ans &amp; rd()); printf(&quot;%d\\n&quot;, ans);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; B - Mocha and Red and Blue 两侧的问号显然可以处理成无相邻重复，中间的问号都依照左侧交替放就行。显然没有相邻重复更少的构造。 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 1007char s[N];inline void work() &#123; int n = rd(); scanf(&quot;%s&quot;, s + 1); int l = 1, r = n; while (s[l] == &#x27;?&#x27; &amp;&amp; l &lt;= n) ++l; if (l == n + 1) &#123; for (int i = 1; i &lt;= n; ++i) putchar((i &amp; 1) ? &#x27;B&#x27; : &#x27;R&#x27;); puts(&quot;&quot;); return; &#125; for (int i = l - 1; i; --i) s[i] = (s[i + 1] == &#x27;R&#x27; ? &#x27;B&#x27; : &#x27;R&#x27;); while (s[r] == &#x27;?&#x27; &amp;&amp; r) --r; for (int i = r + 1; i &lt;= n; ++i) s[i] = (s[i - 1] == &#x27;R&#x27; ? &#x27;B&#x27; : &#x27;R&#x27;); for (int i = l; i &lt;= r; ++i) if (s[i] == &#x27;?&#x27;) s[i] = (s[i - 1] == &#x27;R&#x27; ? &#x27;B&#x27; : &#x27;R&#x27;); puts(s + 1);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; C - Mocha and Hiking 如果 \\(a[1]=1\\) 有 \\(n+1\\to 1\\to 2\\to \\cdots\\to n\\) 。 如果 \\(a[n]=0\\) 有 \\(1\\to 2\\to \\cdots\\to n\\to n+1\\) 。 否则 \\(a[1] = 0,a[n] = 1\\) ，一定有一个位置 \\(a[i] = 0, a[i + 1] = 1\\) ，有 \\(1\\to \\cdots \\to i\\to n+1\\to i+1\\to \\cdots\\to n\\) 。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 10007int a[N];inline void work() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) a[i] = rd(); if (a[1] == 1) &#123; printf(&quot;%d &quot;, n + 1); for (int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, i); puts(&quot;&quot;); return; &#125; if (a[n] == 0) &#123; for (int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, i); printf(&quot;%d\\n&quot;, n + 1); return; &#125; for (int i = 1; i &lt;= n; ++i) if (a[i] == 0 &amp;&amp; a[i + 1] == 1) &#123; for (int j = 1; j &lt;= i; ++j) printf(&quot;%d &quot;, j); printf(&quot;%d &quot;, n + 1); for (int j = i + 1; j &lt;= n; ++j) printf(&quot;%d &quot;, j); puts(&quot;&quot;); return; &#125;&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; D - Mocha and Diana 给定两个森林 \\(A,B\\) ，节点标号都是 \\(1\\sim n\\) 。 一次操作选择一个 \\((u,v)\\) ，使得边 \\((u,v)\\) 加入两幅图后，两幅图依旧都是森林。 问最多能操作多少次，并输出方案。 容易发现每次成功的操作之后，\\(A,B\\) 的连通块数都 \\(-1\\) 。 如果不能操作了，且 \\(A\\)连通块数不唯一，那么考虑：\\(\\forall 1\\le i,j\\le n\\) ， \\(i\\) 和 \\(j\\) 在 \\(A\\) 中不连通，则 \\(i\\) 和 \\(j\\) 在 \\(B\\) 中连通。\\(\\forall 1\\le i,j\\le n\\) ， \\(i\\) 和 \\(j\\) 在 \\(A\\) 中连通，则 \\(\\exists 1\\le k\\le n\\) ，\\(k\\) 在 \\(A\\) 中与 \\(i\\) 和 \\(j\\) 均不连通。结合两条可以得到所有点在 \\(B\\)中均连通，即 \\(B\\) 是一棵树。 所以最多操作次数是 \\(\\min (n-1-|E_A|,n-1-|E_B|)\\) ，且每次随便找一个可操作的操作都是对的。 那么现在问题是怎么快速找出可供选择的点对，方法很多，记录一个比较有意思的构造性方法： 先尝试操作 \\(1\\) 号点和所有点的组合（即能和 \\(1\\) 连通的都连通）。 令 \\(A,B\\) 中与 \\(1\\) 号点不连通的集合分别为 \\(S_A,S_B\\) ，由定义 \\(S_A\\cap S_B=\\emptyset\\) （否则一定可以操作 \\(1\\) 和交中的点）。 每次从 \\(S_A,S_B\\) 中各找出一个点，操作这两个点（由上结论两个图中两点一定不连通），按定义更新 \\(S_A,S_B\\) 。 首先 \\(S_A, S_B\\) 显然是可操作的最大范围了，所以正确性没问题。 考虑实现方法，其实懒惰删除法就好了，每次取点的时候判断下是否合法即可。并查集实现复杂度 \\(O(n\\alpha(n))\\) 。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 100007struct DSU &#123; int f[N]; inline void reset(int n) &#123;for (int i = 1; i &lt;= n; ++i) f[i] = i;&#125; int find(int x) &#123;return x == f[x] ? x : f[x] = find(f[x]);&#125; inline bool merge(int x, int y) &#123; x = find(x); y = find(y); return x == y ? false : (f[x] = y, true); &#125;&#125; A, B;vector&lt;int&gt; sA, sB;vector&lt;pii&gt; res;int main() &#123; int n = rd(), m1 = rd(), m2 = rd(); A.reset(n); B.reset(n); while (m1--) A.merge(rd(), rd()); while (m2--) B.merge(rd(), rd()); for (int j = 1; j &lt;= n; ++j) if (A.find(1) != A.find(j) &amp;&amp; B.find(1) != B.find(j)) &#123; res.push_back(make_pair(1, j)); A.merge(1, j); B.merge(1, j); &#125; for (int i = 1; i &lt;= n; ++i) &#123; if (A.find(1) != A.find(i)) sA.push_back(i); if (B.find(1) != B.find(i)) sB.push_back(i); &#125; while (!sA.empty() &amp;&amp; !sB.empty()) &#123; int u = sA.back(), v = sB.back(); sA.pop_back(); sB.pop_back(); res.push_back(make_pair(u, v)); A.merge(u, v); B.merge(u, v); while (!sA.empty() &amp;&amp; A.find(1) == A.find(sA.back())) sA.pop_back(); while (!sB.empty() &amp;&amp; B.find(1) == B.find(sB.back())) sB.pop_back(); &#125; printf(&quot;%d\\n&quot;, (int)res.size()); for (auto [u, v] : res) printf(&quot;%d %d\\n&quot;, u, v); return 0;&#125; E - Mocha and Stars 给定 \\(n\\le 50,m\\le 10^5\\) ，计数 \\((a_1,a_2,\\cdots,a_n)\\) 的个数，满足： \\(\\forall 1\\le i\\le n, a_i\\in \\left[l_i, r_i\\right]\\cap \\mathbb{Z}\\) \\(\\sum_{i=1}^n a_i \\leq m\\) \\(\\operatorname{gcd}\\left(a_1, a_2, \\ldots, a_n\\right)=1\\) 法一：对 \\(\\text{gcd}\\) 容斥，设 \\(f(d)\\) 表示 \\(d|\\operatorname{gcd}\\left(a_1, a_2, \\ldots, a_n\\right)\\) 的方案数，\\(g(d)\\) 表示 \\(d=\\operatorname{gcd}\\left(a_1, a_2, \\ldots, a_n\\right)\\) 的方案数。 显然有 \\(g(d)=f(d)-\\sum_{k=2}^\\infty g(kd)\\) ，又由于 \\(\\operatorname{gcd}\\left(a_1, a_2, \\ldots, a_n\\right)\\) 最大取到 \\(\\lfloor\\frac{m}{n}\\rfloor\\) ，可以倒推。 求 \\(f(d)\\) 考虑要求每个数字都要是 \\(d\\) 的倍数，不妨设 \\(a_i=b_id\\) ，有： \\(l_i\\le a_i=b_id\\le r_i\\) ，有 \\(\\lceil\\frac{l_i}{d}\\rceil\\le b_i\\le \\lfloor\\frac{r_i}{d}\\rfloor\\) \\(\\sum a_i = \\sum b_id\\le m\\) ，有 \\(\\sum b_i\\le \\lfloor\\frac{m}{d}\\rfloor\\) 这样转化成了 \\((n,\\lfloor\\frac{m}{d}\\rfloor)\\) 规模的问题。 设 \\(cnt[i][j]\\) 表示前 \\(i\\) 个数字和是 \\(j\\) 的方案数，前缀和优化 dp 复杂度 \\(O(n\\lfloor\\frac{m}{d}\\rfloor)\\) ， \\(f(d)=\\sum_{k=0}^{\\lfloor\\frac{m}{d}\\rfloor} cnt[n][k]\\) 。 总复杂度为 \\(O(\\sum_{d=1}^{\\lfloor\\frac{m}{n}\\rfloor} n\\big\\lfloor\\frac{m}{d}\\rfloor)=O(nm\\ln m)\\)。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 51#define M 100007#define mod 998244353int l[N], r[N], f[N][M], sum[N][M], ans[M];int main() &#123; int n = rd(), m = rd(); for (int i = 1; i &lt;= n; ++i) &#123;l[i] = rd(); r[i] = rd();&#125; for (int j = 0; j &lt;= m; ++j) sum[0][j] = 1; auto mo = [&amp;](int x) &#123;return x &gt;= mod ? x - mod : x;&#125;; auto dp = [&amp;](int t, int d) &#123; for (int i = 1; i &lt;= n; ++i) &#123; int L = (l[i] + d - 1) / d, R = r[i] / d; for (int j = 1; j &lt;= t; ++j) f[i][j] = 0; for (int j = L; j &lt;= t; ++j) f[i][j] = mo(mod + sum[i - 1][j - L] - (j - R - 1 &gt;= 0 ? sum[i - 1][j - R - 1] : 0)); for (int j = 1; j &lt;= t; ++j) sum[i][j] = mo(sum[i][j - 1] + f[i][j]); &#125; return sum[n][t]; &#125;; int lim = m / n; for (int d = lim; d; --d) &#123; ans[d] = dp(m / d, d); for (int i = d * 2; i &lt;= lim; i += d) ans[d] = mo(ans[d] + mod - ans[i]); &#125; printf(&quot;%d\\n&quot;, ans[1]); return 0;&#125; 法二：直接莫比乌斯反演求容斥的系数，定义 \\(\\operatorname{valid}(a_1,a_2,\\dots,a_n)\\) 表示这个方案是否符合前两个要求。 \\[ \\begin{aligned} &amp;\\ \\ \\ \\ \\ \\sum_{a_1=l_1}^{r_1} \\sum_{a_2=l_2}^{r_2} \\ldots \\sum_{a_n=l_n}^{r_n}\\operatorname{valid}\\left(a_1, a_2, \\ldots, a_n\\right)\\left[\\operatorname{gcd}\\left(a_1, a_2, \\ldots, a_n\\right)=1\\right] \\\\ &amp;=\\sum_{a_1=l_1}^{r_1} \\sum_{a_2=l_2}^{r_2} \\ldots \\sum_{a_n=l_n}^{r_n} \\operatorname{valid}\\left(a_1, a_2, \\ldots, a_n\\right) \\sum_{d \\mid \\operatorname{gcd}\\left(a_1, a_2, \\ldots, a_n\\right)} \\mu(d) \\\\ &amp;=\\sum_{a 1}^{r_1} \\sum_{a_2=l_2}^{r_2} \\cdots \\sum_{a_n=l_n}^{r_n} \\operatorname{valid}\\left(a_1, a_2, \\ldots, a_n\\right) \\sum_{d\\left|a_1, d\\right| a_2, \\ldots, d \\mid a_n} \\mu(d) \\\\ &amp;=\\sum_{d=1}^m \\mu(d) \\sum_{a_1=\\left\\lceil\\frac{l_1}{d}\\right\\rceil}^{\\left\\lfloor\\frac{r_1}{d}\\right\\rfloor} \\sum_{a_2=\\left\\lceil\\frac{l_2}{d}\\right\\rceil}^{\\left\\lfloor\\frac{r_2}{d}\\right\\rfloor} \\cdots \\sum_{a_n=\\left\\lceil\\frac{l_n}{d}\\right\\rceil}^{\\left\\lfloor\\frac{r_n}{d}\\right\\rfloor} \\operatorname{valid}\\left(a_1 d, a_2 d, \\ldots, a_n d\\right) \\\\ \\end{aligned} \\] 考虑最后一行 \\(\\mu(d)\\) 后面的部分，可以用法一同样的 \\(dp\\) 计数，因此复杂度 \\(O(m+\\sum_{d=1}^m n\\big\\lfloor\\frac{m}{d}\\rfloor)=O(nm\\ln m)\\)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 51#define M 100007#define mod 998244353int l[N], r[N], f[N][M], sum[N][M];int prm[M], mnd[M], mu[M] = &#123;0, 1&#125;;int main() &#123; int n = rd(), m = rd(); for (int i = 1; i &lt;= n; ++i) &#123;l[i] = rd(); r[i] = rd();&#125; for (int i = 2; i &lt;= m; ++i) &#123; if (!mnd[i]) &#123;prm[++prm[0]] = mnd[i] = i; mu[i] = mod - 1;&#125; for (int j = 1, p = prm[1], prod; j &lt;= prm[0]; p = prm[++j]) &#123; if ((prod = i * p) &gt; m) break; mnd[prod] = p; if (p == mnd[i]) &#123;mu[prod] = 0; break;&#125; mu[prod] = 1ll * mu[i] * mu[p] % mod; &#125; &#125; for (int j = 0; j &lt;= m; ++j) sum[0][j] = 1; auto mo = [&amp;](int x) &#123;return x &gt;= mod ? x - mod : x;&#125;; auto dp = [&amp;](int t, int d) &#123; for (int i = 1; i &lt;= n; ++i) &#123; int L = (l[i] + d - 1) / d, R = r[i] / d; for (int j = 1; j &lt;= t; ++j) f[i][j] = 0; for (int j = L; j &lt;= t; ++j) f[i][j] = mo(mod + sum[i - 1][j - L] - (j - R - 1 &gt;= 0 ? sum[i - 1][j - R - 1] : 0)); for (int j = 1; j &lt;= t; ++j) sum[i][j] = mo(sum[i][j - 1] + f[i][j]); &#125; return sum[n][t]; &#125;; int ans = 0; for (int d = 1; d &lt;= m / n; ++d) ans = (ans + 1ll * mu[d] * dp(m / d, d)) % mod; printf(&quot;%d\\n&quot;, ans); return 0;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://blog.gyx.me/categories/Codeforces/"},{"name":"Codeforces Round","slug":"Codeforces/Codeforces-Round","permalink":"http://blog.gyx.me/categories/Codeforces/Codeforces-Round/"}],"tags":[{"name":"Constructive Algorithm","slug":"Constructive-Algorithm","permalink":"http://blog.gyx.me/tags/Constructive-Algorithm/"},{"name":"Number Theory","slug":"Number-Theory","permalink":"http://blog.gyx.me/tags/Number-Theory/"},{"name":"Counting","slug":"Counting","permalink":"http://blog.gyx.me/tags/Counting/"}]},{"title":"AtCoder Beginner Contest 214","slug":"atcoder/abc214","date":"2021-08-14T13:58:14.000Z","updated":"2023-03-20T16:27:49.505Z","comments":true,"path":"atcoder/abc214/","link":"","permalink":"http://blog.gyx.me/atcoder/abc214/","excerpt":"","text":"D. Sum of Maximum Weights 给定一棵树，边有边权。计算所有点对路径上最大边权的权值和，范围 \\(n\\le 10^5\\) 考虑类似 Kruskal 的过程添加树边，则每一条边加入时，对于连通的两个集合间的点对，最大边即为当前边。 因此在维护并查集的同时维护集合大小即可，贡献为 w \\(\\times\\) Size(u) \\(\\times\\) Size(v) ，复杂度 \\(O(n\\log n)\\) E. Packing Under Range Regulations 有 \\(10^9\\) 个盒子，每个盒子只能放一个球。有 \\(n\\) 个球，第 \\(i\\) 个要放在 \\([l_i,r_i]\\) 的某一个盒子中，问是否有解，范围 \\(n\\le 2\\times 10^5\\) 比较经典的贪心，考虑从左往右放，最紧急的需求肯定是右端点最小的。 按照右端点排序，依次考虑每个需求，尽量往左放，相当于区间查询最靠左的未覆盖位置，然后修改这个位置的覆盖状态。 实现可以选择动态开点线段树+线段树上区间内二分，我是用的是并查集维护下一个未覆盖的位置（疯狂的馒头）。 因为序列有 \\(10^9\\) 长，使用 unordered_map 维护并查集数组，具体实现见代码，复杂度 \\(O(n\\log n)\\) 。 1234567891011121314151617181920212223242526struct node &#123;int l, r;&#125; c[N];inline bool operator &lt; (const node &amp;a, const node &amp;b) &#123; return a.r == b.r ? a.l &lt; b.l : a.r &lt; b.r;&#125;unordered_map&lt;int, int&gt; nxt;int find(int x) &#123; return nxt[x] ? nxt[x] = find(nxt[x]) : x;&#125;void work() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123;c[i].l = rd(); c[i].r = rd();&#125; sort(c + 1, c + 1 + n); for (int i = 1, pos; i &lt;= n; ++i) &#123; if (!nxt[c[i].l]) &#123; nxt[c[i].l] = c[i].l + 1; continue; &#125; pos = find(c[i].l); if (pos &gt; c[i].r) &#123;puts(&quot;No&quot;); return;&#125; nxt[pos] = pos + 1; &#125; puts(&quot;Yes&quot;);&#125;","categories":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://blog.gyx.me/categories/AtCoder/"},{"name":"AtCoder Beginner Contest","slug":"AtCoder/AtCoder-Beginner-Contest","permalink":"http://blog.gyx.me/categories/AtCoder/AtCoder-Beginner-Contest/"}],"tags":[{"name":"Union-Find Set","slug":"Union-Find-Set","permalink":"http://blog.gyx.me/tags/Union-Find-Set/"}]},{"title":"AtCoder Regular Contest 124","slug":"atcoder/arc124","date":"2021-07-26T14:53:11.000Z","updated":"2023-03-20T16:28:52.911Z","comments":true,"path":"atcoder/arc124/","link":"","permalink":"http://blog.gyx.me/atcoder/arc124/","excerpt":"","text":"A. LR Constraints 给一个数列赋值，值域 \\([1,k]\\)，对于每个 \\(k\\)，约束第一次出现的位置或最后一次出现的位置，求方案数 维护一下对于每个位置，当前有多少种方案，复杂度 \\(O(n)\\) B. XOR Matching 2 给定两个长度相同的数列 \\(A,B\\)，求有哪些 \\(x\\) ，使得将 \\(B\\) 重排后，任意位置 \\(A_i\\ \\text{xor}\\ B_i = x\\) 重排后有 \\(\\forall 1\\le i,j\\le n,\\ A_i\\ \\text{xor}\\ B_i=A_j\\ \\text{xor}\\ B_j\\Rightarrow A_i\\ \\text{xor}\\ A_j=B_i\\ \\text{xor}\\ B_j\\)​​​​ 也就是说，要满足重排后, （\\(A_i\\)​​ 与所有其他 \\(A\\)​​ 的异或值）与（\\(B_i\\)​​ 与所有其他 \\(B\\)​​​​ 的异或值）一一对应 约束条件很强，我们只需要处理 \\(A_1\\)​ 与其他 \\(A\\) 的异或值，然后找可能对应的 \\(B\\) 即可，复杂度 \\(O(n^2\\log n)\\)​​ C. LCM of GCDs 给定 \\(n\\) 个 pair，每个 pair中的数一个放入 \\(A\\) 集，另一个放入\\(B\\)​ 集，最大化 \\(lcm[\\ gcd(A),\\ gcd(B)\\ ]\\) 集合的最大公约数一定是每个数的因子，将第一个 pair 里的两个数求出所有的约数，枚举答案。 如果存在一种方案使得答案为 \\([x,y]\\)​​ 的倍数，那么对于每个 pair \\((a,b)\\)​​ ，有 \\(x|a,\\ y|b\\)​ 或者 \\(x|b,\\ y|a\\)​ ​​ 暴力检验即可，复杂度 \\(O\\big(div(A_{1a})div(A_{1b})n\\big)\\)​ D. Yet Another Sorting Problem 一个 \\(n+m\\)​ 的排列，每次选择前\\(n\\)​ 个中一个和后 \\(m\\)​个中一个交换，问交换成单位置换所需最少次数 如果没有位置选择的限制，还原一个 \\(n\\)​​ 的排列所需最少交换次数为 \\(n\\ -\\) 排列所对应的环数。 将排列 \\(p\\)​​视作置换，将位置视为点，每个数由当前位置指向目标位置，即建边 \\(i\\to p_i\\)​​ 得到若干个环。我们的目标是让所有的 \\(i\\)​ 满足\\(i \\to i\\)​ ，即 \\(\\forall i, p_i = i\\)​ ​变为单位置换。因此对于某次交换，操作都会形如将 \\(p_i\\)​ 和 \\(p_{p_i}\\)​​ 进行交换，也就是将第 \\(i\\) 位的数和第 \\(p_i\\) 位的数交换。那么对于原来所在环中的结构 \\(i\\to p_i, p_i\\to p_{p_i}\\)​ ，变换后第 \\(i\\)​个位置上变为 \\(p_{p_i}\\)​ ，而第 \\(p_i\\) 位上的数变为 \\(p_i\\)​​​也就是说，对于每个环，每次交换相当于将环上的一个 \\(a\\to b\\to c\\) 结构变为 \\(a\\to c，b\\to b\\)​​​​​目标是形成 \\(n\\)​个自环，因此每个环需要环长 \\(-\\ 1\\)​次移动才能将环内归位，而不同的环之间还原过程无关。 考虑位置选择的限制条件，我们将前 \\(n\\) 个点染成黑色，后 \\(m\\) 个点染成白色。 可以发现，每次可以操作的约束条件等价于每次删掉的边要满足连接的两个点颜色不同。 对于一个由若干段白黑交替连接的环，我们一定可以通过白点吃指向的黑色的点，将整个环变成只剩下一个黑色，然后用这个黑色删掉所有其他白色，总次数为环长 \\(-1\\)​ 对于一个只有某一种颜色的环，我们需要考虑“引入”另一种颜色，需要花费一步的代价进行一次交换引入，然后分析如上，此时环长因为引入 \\(+1\\)​​ ，因此总次数为原来环长 \\(+1\\)​​ 考虑都有“引入”需求，但颜色不同的两个单色环，此时某一个环引入对方的某个元素，相当于帮助了对方引入，因此两个环之需要一次“引入” ，并且两个环共享的引入的长度 ，总次数为第一个环长+第二个环长 综上，对于双色环，我们所需次数为环长 \\(-1\\) ，单色环先默认代价为环长 \\(+1\\) ，每匹配上一对总代价 \\(-2\\) 。 此外本题无需考虑太过复杂，首先同色单色环之间融合没有意义（可比较前后代价），其次不需要考虑单色环和双色环的融合，这种情况可以看作先将双色环归位，再取某一个长度为 \\(1\\)​​​​​​ 的自环与单色环进行融合。 处理过程中只涉及 dfs 找环，总复杂度 \\(O(n)\\) 123456789int cntl = 0, cntr = 0;for (int i = 1; i &lt;= n + m; ++i) if (!bl[i] &amp;&amp; i != p[i]) &#123; ++tot; dfs(i); ans += len[tot]; if (l[tot] &amp;&amp; r[tot]) --ans; else &#123;l[tot] ? ++cntl : ++cntr; ++ans;&#125; &#125;printf(&quot;%d\\n&quot;, ans - min(cntl, cntr) * 2);","categories":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://blog.gyx.me/categories/AtCoder/"},{"name":"AtCoder Regular Contest","slug":"AtCoder/AtCoder-Regular-Contest","permalink":"http://blog.gyx.me/categories/AtCoder/AtCoder-Regular-Contest/"}],"tags":[{"name":"Constructive Algorithm","slug":"Constructive-Algorithm","permalink":"http://blog.gyx.me/tags/Constructive-Algorithm/"},{"name":"Number Theory","slug":"Number-Theory","permalink":"http://blog.gyx.me/tags/Number-Theory/"}]},{"title":"Freshman Year","slug":"summary/freshman","date":"2021-07-08T02:27:14.000Z","updated":"2021-07-15T02:27:14.000Z","comments":true,"path":"summary/freshman/","link":"","permalink":"http://blog.gyx.me/summary/freshman/","excerpt":"","text":"今天是 2021 年 7 月 8 日，星期四。 一年前的今天，高考最后一门刚刚考完。走出考场，回到自己的教室，拿手机，搬行李，告别。 离开学校的时候，碰到了还在梳理交通的竞赛教练，问我考的怎么样，然后约了后天要给高一的学弟们上课。 直到昨晚，暑假回本部给又一届的学弟们上完最后一天课。从二中本部的校门里走出来，回头看看。 来杭电之前 高考完就跟爸爸妈妈说我不复读，当晚就对答案，大概 645。报了南科大综评，拿到了还算不错的校考分。 然后在南校区给高一的同学讲了比较入门的概率，也是那些在一年前的暑假认识的，刚踏入二中大门学弟。 结束的时候在空空的学校里溜达，想想他们上课时候那种纯粹的热情，一代又一代，多少有一点感慨。 走之前拍了张照片，想起来一句自认为很应景的话：“雨过天青云破处，者般颜色做将来” 连着下了两三天的小雨，只剩下竞赛生的二中 出分的晚上比较坦然，提前几分钟查到了分数，比估计的低 9 分，都扣在语文上，115 / 134 / 136 / 251。 之后的几天比较迷茫，听了几个学校的招生宣讲都不尽如人意。南科大那边几度有希望，后来终究是落空。 在我想起来杭电这所学校的时候，突然感觉就是要去这里了。 可能是高二去学军培训喜欢上了杭州这个城市，也可能是对竞赛生涯结束的不甘吧。 先自己偷偷找 Claris 要到了教练的联系方式，问了读研和专业的事情，刘老师的热情的杭州话让人很舒服。 然后就是小心翼翼地和父母交流，说我自己的想法和考虑，直到最后心里十分踏实地填上了第一志愿。 录取的结果是数学系，高考分数达到了卓越学院二次选拔的报名分数线，报了卓越学院的招生考试。 之后的假期写了几个板子，打了几场 CF 恢复一点水平，参加了 HDU 的几场内部训练，搬了一套题恰烂钱。 开学之前和岳老师吃了个饭（竟然还赶上了他生日）， 让我重心不要全部放到竞赛上，要给自己留个后路。 初到杭电 有一说一假期还是过的比较随意，虽然报名了卓越学院，但是一点没准备，9 月份忐忑地就来到杭电啦。 考试之前自己很没有底气，当时觉得能进计科班就不错了。考完觉得考的还行，因为竞赛里接触过一点高数线代的知识，觉得自己英语阅读也比较会蒙。然后晚上大概九点的时候出成绩了，震惊自己竟然过了英才班的线。 晚上给爸爸妈妈很激动地打了个电话，有点担心 11 进 9 被刷掉，一直到十二点多才睡着。 第二天面试的时候其实自己比较轻松，感觉面试向来都比较稳 比较会吹 ，面试单独面，五个老师。 面试比较自然，老师们的问题基本是跟着我的自我介绍思路走，不过还是有几个问题血压拉满。 我努力地强调自己的竞赛水平，然后冯老师问：“现在让你去打区域赛能拿到什么奖项？” 我介绍了一下高中学校和班级的情况，然后另一个老师问：“你觉得二中和衡一哪个更好？” 周老师（也是现在的导师）问：“你也不能打一辈子竞赛啊。以后有什么进一步的打算？” 我说会读研，以后可能会去当大学老师。导师笑笑说要想当教授，后面得去好点的大学读书。 面试完出来觉得自己还挺稳的，但是也不敢确定，忐忑到了晚上十点多出了结果。终于还是去学计算机了。 之后的生活很顺利，见面会，正常上课，班委选举（当了学委）。 上课的时候强迫自己去提问，回答问题，意识到自己可以做一些 由自己决定的 想做什么就做什么 的事。 遇到了自己喜欢的老师，有能够舒适相处，真心相待的一帮同学，慢慢地从高三痛苦自闭的状态走出来了。 竞赛 这段话也想写给每个学竞赛过程中感到无力的同行者。 算法竞赛的魅力在于，通过努力积累或灵机一动，你能够做出越来越难的题目，是一种对自我能力的认可。 算法竞赛的危险亦在于，你学会的东西越多，认识的厉害的人越多，面对不可计数的强者，很容易陷入自我否定。 想到杭电之前，很长一段时间都觉得，大学不会再打竞赛了。 学竞赛的过程中经历的打击，不仅是比赛和上课中受到一众神仙居高临下的压迫感，更多的其实是周围人不经意的否定和安慰。对我来说，这是一种对信心很大的打击，会想要证明自己，亦或是心里感到无力而故作轻松。 在面临是否买 D 的抉择时，我放弃了。不是担心取得不了什么结果，而是觉得压力太大了。 在选学校的时候，突然想到杭电的那一刻，有种死灰复燃的感觉。 记起来 NOIP 2018 结束的时候，在存真楼下，孙校长和我们几个刚从秦皇岛回来的学生说的几句话： “学别的竞赛的，最终的发展和竞赛不一定有关系，但是算法竞赛的学生，最终往往都会选择计算机行业。” 算法竞赛会在心里埋下一颗种子。 我不是那种一帆风顺的天才，在受到打击的时候，我会感到无力。 但当我抛开名利、和他人比较、证明自己这些功利的意义之后，我发现自己还剩下些东西，还能看到初心。 是对算法的欣赏和热爱，是理解每一个算法、做出每一个题目的瞬间，精神上的享受，这就够了。 至少在我看来，从我开始接触竞赛，到做出很多重要的选择，我决策的初心从来都不是名利，因为对算法还爱着。决定最终没有买 D 类，最大的原因还是在那个时刻，竞赛带来的痛苦超过了学习的享受，被一次次的排名裹挟，被各种机会所吸引，我越来越像一个没有自我的机器，越来越被成功学牢牢锁死。而在我选择大学的时候，竞赛对我的意义不再是未来的全部了。我能够静下来，问问自己对算法还有没有那种近乎痴迷的喜爱，能够将它作为一种兴趣去发展，不需要考虑付出和回报，至少在大学，我还是有自由支配自己的权利。 我还是那个深深爱着算法的小孩，对几十行代码背后的智慧如痴如醉。 Gold Medal (30th Place) : The 45th ICPC Asia Jinan Regional Contest, 2020 Gold Medal ( 15th Place) : The 18th Zhejiang Provincial Collegiate Programming Contest, 2021 Silver Medal (28th Place) : The 45th ICPC Asia Shenyang Regional Contest, 2021 课内学习 第一个学期不会选课，修了系统默认的 25.25 个学分， 第二个学期修了 32.25 个学分。 通识选修只完成了科技发展与科学精神，大二上应该会把剩下的指标修完。 数理基础 数分 （6 * 3.5 + 5 * 4.2）、高代（3 * 5 + 2 * 5）、离散（4 * 5）、大物1（3 * 5） CS专业课 计导（2 * 5）、程设基础（5 * 5）、数据结构（4 * 4.5）、C++ 面向对象（3 * 5） 通识教育 思修法基（3 * 5）、心理健康（1 * 4.3）、大军（2 * 4.8）、ACM（2 * 5） 外语类 英语精读 A（2 * 4.4 + 2 * 4.6）、英语听说 A（1 * 4.3 + 1 * 4.7）、实用翻译（2 * 4.6） 其他 大学启示录（1 * 4）、形式与政策（0.5 * 5）、科研实践（1 * 5）、体育（1 * 2.1 + 1 * 1.8） 很幸运的是遇到的老师都很认真负责，老师们对课程内容非常了解，自己遇到问题也都能很好沟通。 很多课程都觉得自己做的没那么好，对给出的成绩也常常受之有愧。 数学分析和高等代数两门数学基础课的表现截然相反，让我更清楚地意识到很大程度上我是个兴趣驱动的人。 对数分的知识体系自己本身可能就不太感兴趣，加上数分课是真的提不起来精神，两个学期的数学分析成绩都不太看的过去，数分上可能要在大三重修了。老师确实想要认真教会我，可是自己确实提不起兴趣去学。经历了数分上的洗礼，数分下还是逼着自己学了学，最后的结果算是马马虎虎吧，确实对不起老师对不起自己。 很喜欢高代老师的课，很大程度驱动我去花相对比较多的时间在这门课上。两个学期最后的结果都比较好，在自己喜欢的科目上能够看到自己做了些事情，也是让自己很开心的一件事。唯一遗憾的是期末错在了最后一节课老师强调过的一个小点上（证明正定阵需先说明对称）。大二下预定了老师的近世代数。 也很喜欢 Cathy 上的英语精读，也算是第一次能让我主动提起来学英语的兴趣。 Cathy 的课有一种很轻松的气氛，不会按照课本一板一眼的去上，讲的很多东西很受用。 感谢程设和OOP（C++）的老师对我的包容，自己在这两门课上确实有过很幼稚的行为。很佩服将近退休的老师能精确把控很多细节，随手写的代码能一遍过编译什么错都没有。 离散数学和数据结构 给了我很深刻的教训。两门都是自认为了解比较多的，数据结构甚至申请了免听。考前复习的都不是很充分，等上了考场发现要开始脑补一堆一堆的概念。期末离散卷子简单，没暴露出来什么问题。数据结构觉得自己看看书就够了，最后的成绩却不尽如人意，原因只是不知道排序里的一个既定细节，只能悔不当初。 大学物理和思想道德修养与法律基础 两门课结果意外的好，其实自己认真去学一学还是可以有效果的。中学阶段一直头疼的政治在闭卷的期末考试也写了个差不多。学不会电磁在考场上也做出来了绝大多数题。考试遇到不会的题也不能太着急，多想一会没准就通了。 体育 从中考的 \\(18\\) 分保底，到大一上的体测 \\(36\\) 分，痛失两个学期的奖学金，终究还是没逃过身体素质不行这个问题。还是感谢环境逼着我去直面体育，按着体能班的要求大一下结结实实把 40 次阳光长跑跑完了，也确实让我看到耐力可以有提升，从操场跑一圈就喘不上气，到体测的时候人生第一次把 1000 米全跑下来，确实是很激动的。也终于在锻炼身体上有了动力，首先是大二下想要和 qyy 同学一起学体育舞，其次是想要恰奖学金。 我的她 只想说爱情的体验是一种很纯粹的幸福。 愿意为她牺牲自己的一切，无时无刻都会想起她的事情，找不到她会坐如针毡，什么都做不下去。 她所高兴的事情比她还高兴，她难受的时候会跟着一起哭出来，在爱情中两个人都学会了如何照顾对方。 两个人在一起呆着常常心有灵犀，做事情反应如出一辙，很多事情不用言语。 两个人在一起呆着就是最快乐的事情，能够一起学习，散步，她在我的身边就能感受到无比的踏实。 会走到一起的人终究不会分开。心里对未来有着期盼，静下心来踏踏实实做事，继续加油。","categories":[{"name":"Summary","slug":"Summary","permalink":"http://blog.gyx.me/categories/Summary/"}],"tags":[]},{"title":"Codeforces Round #723 (Div. 2)","slug":"codeforces/1526","date":"2021-03-28T16:00:00.000Z","updated":"2023-03-20T16:25:45.387Z","comments":true,"path":"codeforces/1526/","link":"","permalink":"http://blog.gyx.me/codeforces/1526/","excerpt":"","text":"A. Mean Inequality 将 \\(2n\\) 个不同的数字排成一个循环，使得任意位置的数不是相邻两个数的平均值。 从小到大排序之后，前 \\(n\\) 个和后 \\(n\\) 个交替放。 因为数字两两不同，大的数字不可能是两个小的数字的平均数，小的同理。 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125; int a[51];inline void work() &#123; int n = rd(); int m = 2 * n; for (int i = 1; i &lt;= m; ++i) a[i] = rd(); sort(a + 1, a + 1 + m); for (int i = 1; i &lt;= n; ++i) printf(&quot;%d %d &quot;, a[i], a[i + n]); puts(&quot;&quot;);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; B. I Hate 1111 询问一个正整数 \\(x\\) 是否可以拆分成若干个 \\(11,111,1111,\\dots\\) 的和 根据 麦乐鸡定理 ，\\(11\\) 和 \\(111\\) 可以组成大于 \\(11*111-111-11=1099\\) 的任何数。 所以后面的数字都没用了， \\(x\\le 1099\\) 的部分做一下 \\(11\\) 和 \\(111\\) 的完全背包，其他情况都是 YES 。 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125; #define N 1100bool f[N];inline void work() &#123; int x = rd(); puts(x &gt;= N ? &quot;YES&quot; : (f[x] ? &quot;YES&quot; : &quot;NO&quot;));&#125;int main() &#123; f[0] = 1; for (int i = 11; i &lt; N; ++i) f[i] |= f[i - 11]; for (int i = 111; i &lt; N; ++i) f[i] |= f[i - 111]; for (int t = rd(); t; --t) work(); return 0;&#125; C. Potions 给一个数列，求一个最长的子序列，使得子序列任意前缀和都 \\(\\ge 0\\) 经典的带反悔贪心，用一个小根堆维护拿了的数字。 每次先把当前的拿了，如果当前的和是负的，就一直去掉堆顶直到合法即可。 这样子在每次结束的时候都是正的，并且去掉了最少的数。 等效的贪心是每次放进来如果变成负数就看一下能不能替换堆顶。 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125; priority_queue&lt;int&gt; q;int main() &#123; int n = rd(); int ans = 0; ll nw = 0; for (int i = 1, a; i &lt;= n; ++i) &#123; a = rd(); ++ans; nw += a; q.push(-a); while (nw &lt; 0) &#123; nw += q.top(); q.pop(); --ans; &#125; &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125; D. Kill Anton 给定一个字符集只有 'A','D','O','T' 的串，将其重排使得恢复成原来的所需操作次数最大。 操作一次可以交换两个字符的位置。 猜一下操作次数只和逆序数相关（我一直不太会这种的证明），所以一定可以把同一类字符放到一起。 记 inv[i][j] 表示字符 i 前字符j 的顺序对数，即如果结果串中字符 i 在字符 j 前，增加的逆序数。 因此枚举 \\(4!\\) 种排列，计算一下哪一种逆序数最大即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const char tc[4] = &#123;&#x27;A&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;T&#x27;&#125;;ll cnt[4], inv[4][4];inline int tr(char c) &#123; if (c == &#x27;A&#x27;) return 0; if (c == &#x27;N&#x27;) return 1; return (c == &#x27;O&#x27; ? 2 : 3);&#125;string s;inline void work() &#123; cin &gt;&gt; s; for (int i = 0; i &lt; 4; ++i) &#123; cnt[i] = 0; for (int j = 0; j &lt; 4; ++j) inv[i][j] = 0; &#125; for (auto c : s) &#123; int i = tr(c); for (int j = 0; j &lt; 4; ++j) if (j != i) inv[i][j] += cnt[j]; ++cnt[i]; &#125; ll ans = -1; int p[4] = &#123;0, 1, 2, 3&#125;, res[4]; do &#123; ll tmpans = 0; for (int i = 0; i &lt; 4; ++i) for (int j = i + 1; j &lt; 4; ++j) tmpans += inv[p[i]][p[j]]; if (tmpans &gt; ans) &#123; ans = tmpans; for (int i = 0; i &lt; 4; ++i) res[i] = p[i]; &#125; &#125; while(next_permutation(p, p + 4)); for (int i = 0; i &lt; 4; ++i) for (int j = 1; j &lt;= cnt[res[i]]; ++j) putchar(tc[res[i]]); puts(&quot;&quot;);&#125;int main() &#123; int t; for (cin &gt;&gt; t; t; --t) work(); return 0;&#125; E. Oolimry and Suffix Array 给定后缀数组，求有多少个串长为 \\(n\\) ，字符集大小为 \\(k\\) 的字符串 \\(S\\) 符合这个后缀数组 后缀数组 \\(sa_i\\) 记录的是排名第 \\(i\\) 位的后缀的开始下标。 根据字典序要求，\\(S_{sa_i}\\) 和 \\(S_{sa_{i+1}}\\) 只有两种关系：\\(S_{sa_i}&lt;S_{sa_{i+1}}\\) 或 \\(S_{sa_i}=S_{sa_{i+1}}\\) 小于一定是可以的，等于的充要条件是 \\(rank_{sa_i+1}&lt;rank_{sa_{i+1}+1}\\) ，即去掉第一个字符字典序不变。 因此我们得到了含有 \\(n-1\\) 个不等号的不等式链，假设其中有 \\(a\\) 个是 \\(\\le\\) 。 我们枚举有 \\(i\\) 个 \\(\\le\\) 实际上是 \\(&lt;\\) ，那么实际字符集大小是 \\(n-i\\) ，方案数就是 \\[ \\sum_{i=0}^a{a\\choose i}{k\\choose n-i}={a+k\\choose n} \\] 等式从组合含义理解，从 \\(a+k\\) 个里选 \\(n\\) 个，定价于枚举从前 \\(a\\) 个里选 \\(i\\) 个，剩余的从后 \\(k\\) 个里选。 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 200007#define mod 998244353inline int fpow(int x, int t = mod - 2) &#123; int res = 1; for (; t; t &gt;&gt;= 1, x = 1ll * x * x % mod) if (t &amp; 1) res = 1ll * res * x % mod; return res;&#125;int rk[N], pos[N], fac[N &lt;&lt; 1] = &#123;1&#125;;int main() &#123; int n = rd(), k = rd(); for (int i = 1; i &lt;= n; ++i) rk[pos[i] = rd()] = i; for (int i = 1; i &lt; n; ++i) k += (rk[pos[i] + 1] &lt; rk[pos[i + 1] + 1]); if (k &lt; n) &#123;puts(&quot;0&quot;); return 0;&#125; for (int i = 1; i &lt;= k; ++i) fac[i] = 1ll * fac[i - 1] * i % mod; printf(&quot;%lld\\n&quot;, 1ll * fac[k] * fpow(fac[n]) % mod * fpow(fac[k - n]) % mod); return 0;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://blog.gyx.me/categories/Codeforces/"},{"name":"Codeforces Round","slug":"Codeforces/Codeforces-Round","permalink":"http://blog.gyx.me/categories/Codeforces/Codeforces-Round/"}],"tags":[{"name":"Greedy","slug":"Greedy","permalink":"http://blog.gyx.me/tags/Greedy/"},{"name":"Constructive Algorithm","slug":"Constructive-Algorithm","permalink":"http://blog.gyx.me/tags/Constructive-Algorithm/"},{"name":"Number Theory","slug":"Number-Theory","permalink":"http://blog.gyx.me/tags/Number-Theory/"},{"name":"Counting","slug":"Counting","permalink":"http://blog.gyx.me/tags/Counting/"}]},{"title":"Render Math Equations in Hexo","slug":"misc/mathjax","date":"2019-05-31T16:00:00.000Z","updated":"2021-05-31T16:00:00.000Z","comments":true,"path":"misc/mathjax/","link":"","permalink":"http://blog.gyx.me/misc/mathjax/","excerpt":"","text":"\\[ f(a) = \\frac{1}{2\\pi i}\\oint_{\\gamma}\\frac{f(z)}{z-a}dz \\] Beautiful and accessible math in all browsers - MathJax This post is used to check out whether the mathjax plugin (hexo-math) still works. Inline Formula Consider the sequence of \\(n\\) distinct positive integers: \\(c_1, c_2, \\cdots, c_n\\). The child calls a vertex-weighted rooted binary tree good if and only if for every vertex \\(v\\), the weight of \\(v\\) is in the set \\(\\{c_1, c_2, \\cdots, c_n\\}\\) . Also our child thinks that the weight of a vertex-weighted tree is the sum of all vertices' weights. Given an integer \\(m\\), can you for all $s (1 s ≤ m) $ calculate the number of good vertex-weighted rooted binary trees with weight \\(s\\) ? Please, check the samples for better understanding what trees are considered different. We only want to know the answer modulo \\(998244353\\) ( \\(7 × 17 × 2^{23} + 1\\) , a prime number). Block Formula \\[ \\int \\frac{dx}{cos^2x}=\\int sec^2xdx=tan x+C\\ \\] \\[ \\int \\frac{dx}{sin^2x}=\\int csc^2xdx=-cot x+C\\ \\] \\[ \\sum\\limits_{i = 0}^{E} w[i]{M \\choose i} {N \\choose iS} \\frac{(iS)!}{(S!)^{i}} \\sum\\limits_{j = 0}^{E - i} (-1)^{j} {M - i \\choose j} {N - iS \\choose jS} \\frac{(jS)!}{(S!)^{j}} (M - i - j)^{N - iS - jS} \\] \\[ = \\sum\\limits_{i = 0}^{E} w[i]{M \\choose i} {N \\choose iS} \\frac{(iS)!}{(S!)^{i}} \\sum\\limits_{j = i}^{E} (-1)^{j - i} {M - i \\choose j - i} {N - iS \\choose jS - iS} \\frac{(jS - iS)!}{(S!)^{j - i}} (M - j)^{N - jS} \\] Matrix \\[ \\begin{bmatrix} (\\omega_n^0)^0 &amp; (\\omega_n^0)^1 &amp; \\cdots &amp; (\\omega_n^0)^{n-1}\\\\\\\\ (\\omega_n^1)^0 &amp; (\\omega_n^1)^1 &amp; \\cdots &amp; (\\omega_n^1)^{n-1}\\\\\\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\\\\\ (\\omega_n^{n-1})^0 &amp; (\\omega_n^{n-1})^1 &amp; \\cdots &amp; (\\omega_n^{n-1})^{n-1} \\end{bmatrix} \\begin{bmatrix} a_0 \\\\\\\\ a_1 \\\\\\\\ \\vdots \\\\\\\\ a_{n-1} \\end{bmatrix} = \\begin{bmatrix} A(\\omega_n^0) \\\\\\\\ A(\\omega_n^1) \\\\\\\\ \\vdots \\\\\\\\ A(\\omega_n^{n-1}) \\end{bmatrix} \\] \\[ \\begin{bmatrix} a_0 \\\\\\\\ a_1 \\\\\\\\ \\vdots \\\\\\\\ a_{n-1} \\end{bmatrix} = \\frac{1}{n} \\begin{bmatrix} (\\omega_n^{-0})^0 &amp; (\\omega_n^{-0})^1 &amp; \\cdots &amp; (\\omega_n^{-0})^{n-1} \\\\\\\\ (\\omega_n^{-1})^0 &amp; (\\omega_n^{-1})^1 &amp; \\cdots &amp; (\\omega_n^{-1})^{n-1} \\\\\\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\\\\\ (\\omega_n^{-(n-1)})^0 &amp; (\\omega_n^{-(n-1)})^1 &amp; \\cdots &amp; (\\omega_n^{-(n-1)})^{n-1} \\end{bmatrix} \\begin{bmatrix} A(\\omega_n^0) \\\\\\\\ A(\\omega_n^1) \\\\\\\\ \\vdots \\\\\\\\ A(\\omega_n^{n-1}) \\end{bmatrix} \\] To prevent escaping, you need to use \\\\\\\\ to make a new line rather than \\\\ . For more about the Mathjax symbols, refer to ：The Comprehensive LaTeX Symbol List .","categories":[],"tags":[]},{"title":"Hello World","slug":"misc/hello-world","date":"2018-11-28T16:00:00.000Z","updated":"2018-11-28T16:00:00.000Z","comments":true,"path":"misc/hello-world/","link":"","permalink":"http://blog.gyx.me/misc/hello-world/","excerpt":"","text":"「 Hello, the lovely world. 」 「 Stay hungry, Stay foolish. 」 12345678910111213141516171819202122&gt;&gt;&gt; import thisThe Zen of Python, by Tim PetersBeautiful is better than ugly.Explicit is better than implicit.Simple is better than complex.Complex is better than complicated.Flat is better than nested.Sparse is better than dense.Readability counts.Special cases aren&#x27;t special enough to break the rules.Although practicality beats purity.Errors should never pass silently.Unless explicitly silenced.In the face of ambiguity, refuse the temptation to guess.There should be one-- and preferably only one --obvious way to do it.Although that way may not be obvious at first unless you&#x27;re Dutch.Now is better than never.Although never is often better than *right* now.If the implementation is hard to explain, it&#x27;s a bad idea.If the implementation is easy to explain, it may be a good idea.Namespaces are one honking great idea -- let&#x27;s do more of those!","categories":[],"tags":[]}],"categories":[{"name":"Official Contests","slug":"Official-Contests","permalink":"http://blog.gyx.me/categories/Official-Contests/"},{"name":"Summary","slug":"Summary","permalink":"http://blog.gyx.me/categories/Summary/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://blog.gyx.me/categories/Codeforces/"},{"name":"Codeforces Round","slug":"Codeforces/Codeforces-Round","permalink":"http://blog.gyx.me/categories/Codeforces/Codeforces-Round/"},{"name":"AtCoder","slug":"AtCoder","permalink":"http://blog.gyx.me/categories/AtCoder/"},{"name":"AtCoder Beginner Contest","slug":"AtCoder/AtCoder-Beginner-Contest","permalink":"http://blog.gyx.me/categories/AtCoder/AtCoder-Beginner-Contest/"},{"name":"Educational Codeforces Round","slug":"Codeforces/Educational-Codeforces-Round","permalink":"http://blog.gyx.me/categories/Codeforces/Educational-Codeforces-Round/"},{"name":"AtCoder Regular Contest","slug":"AtCoder/AtCoder-Regular-Contest","permalink":"http://blog.gyx.me/categories/AtCoder/AtCoder-Regular-Contest/"},{"name":"Algorithms","slug":"Algorithms","permalink":"http://blog.gyx.me/categories/Algorithms/"},{"name":"Paper Notes","slug":"Paper-Notes","permalink":"http://blog.gyx.me/categories/Paper-Notes/"},{"name":"AtCoder Grand Contest","slug":"AtCoder/AtCoder-Grand-Contest","permalink":"http://blog.gyx.me/categories/AtCoder/AtCoder-Grand-Contest/"}],"tags":[{"name":"Algebra","slug":"Algebra","permalink":"http://blog.gyx.me/tags/Algebra/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"},{"name":"DFS and Similar","slug":"DFS-and-Similar","permalink":"http://blog.gyx.me/tags/DFS-and-Similar/"},{"name":"Markov Chains","slug":"Markov-Chains","permalink":"http://blog.gyx.me/tags/Markov-Chains/"},{"name":"Linear Basis","slug":"Linear-Basis","permalink":"http://blog.gyx.me/tags/Linear-Basis/"},{"name":"STL","slug":"STL","permalink":"http://blog.gyx.me/tags/STL/"},{"name":"Shortest Path","slug":"Shortest-Path","permalink":"http://blog.gyx.me/tags/Shortest-Path/"},{"name":"Counting","slug":"Counting","permalink":"http://blog.gyx.me/tags/Counting/"},{"name":"Segment Tree","slug":"Segment-Tree","permalink":"http://blog.gyx.me/tags/Segment-Tree/"},{"name":"Geometry","slug":"Geometry","permalink":"http://blog.gyx.me/tags/Geometry/"},{"name":"Graphs","slug":"Graphs","permalink":"http://blog.gyx.me/tags/Graphs/"},{"name":"Number Theory","slug":"Number-Theory","permalink":"http://blog.gyx.me/tags/Number-Theory/"},{"name":"Constructive Algorithm","slug":"Constructive-Algorithm","permalink":"http://blog.gyx.me/tags/Constructive-Algorithm/"},{"name":"Knapsack Problem","slug":"Knapsack-Problem","permalink":"http://blog.gyx.me/tags/Knapsack-Problem/"},{"name":"String Suffix Structures","slug":"String-Suffix-Structures","permalink":"http://blog.gyx.me/tags/String-Suffix-Structures/"},{"name":"Greedy","slug":"Greedy","permalink":"http://blog.gyx.me/tags/Greedy/"},{"name":"Tricks","slug":"Tricks","permalink":"http://blog.gyx.me/tags/Tricks/"},{"name":"Flows","slug":"Flows","permalink":"http://blog.gyx.me/tags/Flows/"},{"name":"Probabilities","slug":"Probabilities","permalink":"http://blog.gyx.me/tags/Probabilities/"},{"name":"Trie","slug":"Trie","permalink":"http://blog.gyx.me/tags/Trie/"},{"name":"Minkowski Sum","slug":"Minkowski-Sum","permalink":"http://blog.gyx.me/tags/Minkowski-Sum/"},{"name":"String","slug":"String","permalink":"http://blog.gyx.me/tags/String/"},{"name":"Divide and Conquer","slug":"Divide-and-Conquer","permalink":"http://blog.gyx.me/tags/Divide-and-Conquer/"},{"name":"Difference and Prefix Sum","slug":"Difference-and-Prefix-Sum","permalink":"http://blog.gyx.me/tags/Difference-and-Prefix-Sum/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"http://blog.gyx.me/tags/Binary-Search/"},{"name":"Binary Lifting","slug":"Binary-Lifting","permalink":"http://blog.gyx.me/tags/Binary-Lifting/"},{"name":"Sparse Table","slug":"Sparse-Table","permalink":"http://blog.gyx.me/tags/Sparse-Table/"},{"name":"Stack","slug":"Stack","permalink":"http://blog.gyx.me/tags/Stack/"},{"name":"Matrix Theory","slug":"Matrix-Theory","permalink":"http://blog.gyx.me/tags/Matrix-Theory/"},{"name":"Fenwick Tree","slug":"Fenwick-Tree","permalink":"http://blog.gyx.me/tags/Fenwick-Tree/"},{"name":"Threshold Optimization","slug":"Threshold-Optimization","permalink":"http://blog.gyx.me/tags/Threshold-Optimization/"},{"name":"Combinatorics","slug":"Combinatorics","permalink":"http://blog.gyx.me/tags/Combinatorics/"},{"name":"01-BFS","slug":"01-BFS","permalink":"http://blog.gyx.me/tags/01-BFS/"},{"name":"Persistent Data Structure","slug":"Persistent-Data-Structure","permalink":"http://blog.gyx.me/tags/Persistent-Data-Structure/"},{"name":"Scheduling","slug":"Scheduling","permalink":"http://blog.gyx.me/tags/Scheduling/"},{"name":"Bitmask","slug":"Bitmask","permalink":"http://blog.gyx.me/tags/Bitmask/"},{"name":"Connectivity","slug":"Connectivity","permalink":"http://blog.gyx.me/tags/Connectivity/"},{"name":"Union-Find Set","slug":"Union-Find-Set","permalink":"http://blog.gyx.me/tags/Union-Find-Set/"}]}