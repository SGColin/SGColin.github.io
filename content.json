{"pages":[{"title":"About","text":"Hello, I’m Colin from HDU. Welcome to my blog &amp; Have a nice day ! Friends ID &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ID ZH_comld ZZH - EZS / HDU ZigZagK ZZK - HDU ACM wjh15101051 WJH - EZS / BUAA Dinosaurcj CJ - HDU CTF - PWN Kingsann CZY - SJZEZ / THU wenzhuan WZ - HDU ACM / CTF ErkkiErkko GSH - SDFZ / THU","link":"/about/index.html"},{"title":"Training Records","text":"You can find my editorial by the following links. Hope you enjoy it! Codeforces Codeforces Round #735 (Div. 2) [Upsolved - 4/5] Codeforces Round #701 (Div. 2) [Done - 2021.02.13] Codeforces Round #699 (Div. 2) [Done - 2021.02.06] Codeforces Round #532 (Div. 2) [Done - 2019.01.14] Codeforces Round #528 (Div. 2) [Done - 2018.12.24] Codeforces Round #525 (Div. 2) [Done - 2018.12.10] Codeforces Round #524 (Div. 2) [Done - 2018.11.30] Codeforces Round #514 (Div. 2) [Done - 2019.01.16] Educational Codeforces Round 112 (Rated for Div. 2) [Upsolved - 5 / 6] Educational Codeforces Round 58 (Rated for Div. 2) [Done - 2019.02.09] Educational Codeforces Round 55 (Rated for Div. 2) [Done - 2019.01.22] AtCoder AtCoder Regular Contest 124 [Done - 2021.07.26] AtCoder Beginner Contest 203 [Done - 2021.03.31] AtCoder Beginner Contest 179 [Done - 2020.09.20] AtCoder Beginner Contest 178 [Done - 2020.09.14] AtCoder Beginner Contest 175 [Done - 2020.08.16] CodeChef July Lunchtime 2021 [Upsolved - 2/5] July Cook-Off 2021 [Done - 2021.7.29]","link":"/training/index.html"},{"title":"To Do","text":"Contests Start Time Name Remark July 14th 22:35 Educational Codeforces Round 111 Upsolved 4 / 6 July 17th 22:35 Codeforces Round #733 Wating July 22th 22:35 Harbour.Space Scholarship Contest 2021-2022 Upsolved 4 / 9 July 24th 20:00 AtCoder Beginner Contest 211 Wating July 25th 20:00 AtCoder Regular Contest 124 Upsolved 4 / 6 July 25th 22:35 Codeforces Global Round 15 Wating July 26th 12:00 Best Coder - Test Round Wating July 29th 22:35 Codeforces Round #735 Wating July 31th 14:00 Best Coder Round 1A Wating Contests (Team Training) Date Name Remark July 17th Nowcoder Multi-University Training Contest 1 Upsolved 8 / 11 July 19th Nowcoder Multi-University Training Contest 2 Wating July 20th HDU Multi-University Training Contest 1 Upsolved 7 / 11 July 22th HDU Multi-University Training Contest 2 Upsolved 7 / 11 July 24th Nowcoder Multi-University Training Contest 3 Upsolved 5 / 10 July 26th Nowcoder Multi-University Training Contest 4 Upsolved 6 / 10 July 27th HDU Multi-University Training Contest 3 Upsolved 6 / 12 July 29th HDU Multi-University Training Contest 4 Wating July 31th Nowcoder Multi-University Training Contest 5 Wating","link":"/todo/index.html"},{"title":"Comments","text":"","link":"/comments/index.html"},{"title":"AtCoder Beginner Contest 175","text":"官方题解链接： AtCoder Beginner Contest 175 Editorial A - Rainy SeasonABC 175 A 求一个字符串中最长连续字符 'R' 的长度， $|S| = 3$ 。 Solution暴力扫描。 B - Making TriangleABC 175 B 给定 $n$ 个数的数组 $L$ , 求三元组 $(i,j,k)$ 的个数 $(1\\le i&lt;j&lt;k\\le n)$ ，满足： $L_i,L_j,L_k$ 各不相同 $L_i,L_j,L_k$ 可构成三角形 满足 $n\\le 100$ ，$L_i \\le 10^9$ Solution$\\mathcal O(n^3)$ 暴力扫描统计。 C - Walking TakahashiABC 175 C 一个人在整数轴坐标 $x$ 处，进行 $k$ 次移动。 每次可以向左或向右移动 $d$ 个单位，求最后坐标 绝对值最小值 。 满足 $-10^{15}\\le x\\le 10^{15}$ ， $1\\le k,d\\le 10^{15}$ Solution如果回不到零点附近就朝着零点方向一直走。 如果回到零点附近就在零点两侧来回走。 123ll cnt = (x + d - 1) / d;if (cnt &gt; k) printf(\"%lld\\n\", x - k * d);else printf(\"%lld\\n\", abs(x - cnt * d + ((k - cnt) &amp; 1) * d)); D - Moving PieceABC 175 D （留坑） Solution1 E - Picking GoodsABC 175 E 在一个 $r$ 行 $c$ 列的矩阵上，有 $k$ 个 坐标互不相同 的宝物，在 $(r_i,c_i)$ 上的宝物价值 $v_i$。 开始在 $(1,1)$ 处，可以向右或向下走，即从 $(i,j)$ 移动到 $(i+1,j)$ 或 $(i,j+1)$ 。 到某个位置 可以不取 对应位置的宝物，每行最多取三个，问最后总价值最多多少。 满足 $1\\le r,c\\le 3000$ ， $1\\le v_i\\le 10^9$ Solution$f[i][j][0/1/2/3]$ 代表当前位置 $(i,j)$ ，当前行已经拿了 $0/1/2/3$ 个东西，$\\mathcal O(n^2)$ DP。 （F 留坑）","link":"/training/atcoder/abc/175.html"},{"title":"AtCoder Beginner Contest 178","text":"官方题解链接： AtCoder Beginner Contest 178 Editorial C - UbiquityABC 178 C 计数长度为 $n$ 的整数数列 $A$ 的个数，满足： $0\\le A_i\\le 9$ 保证数列中至少存在一个 $0$ 和一个 $9$ 满足 $n\\le 10^{6}$ ，答案对 $10^9 + 7$ 取模。 Solution容斥，不考虑条件 $2$ 的方案数有 $10^n$ ，不满足条件 $2$ 的方案数为 $2\\times 9^n - 8^n$ ，相减。 D - RedistributionABC 178 D 将整数 $S$ 划分成数列 $A$ ，长度不限，每项最少为 $3$，求方案数。 满足 $S\\le 2000$ Solution开始想着整数拆分的递推式，但是很难解决多重集的排列问题。 换个思路，设 $f[i]$ 表示当前已经划分走 $i$ 的方案数，则 $f[i]=\\sum_{j=3}^if[i - j]$ 。 123f[0] = 1;for (int i = 3; i &lt;= n; ++i) for (int j = 3; j &lt;= i; ++j) f[i] = (f[i] + f[i - j]) % mod; E - Dist MaxABC 178 E 求 $n$ 个点两两曼哈顿距离的最大值。 满足 $2\\le n \\le 2\\times 10^5$ ， $1\\le x_i,y_i\\le 10^9$ Solution分讨。 $x_1−x_2\\ge 0,y_1−y_2\\ge 0$ $|x_1−x_2|+|y_1−y_2|=x_1−x_2+y_1−y_2=(x_1+y_1)−(x_2+y_2)$ $x_1−x_2&lt;0,y_1−y_2\\ge 0$ $|x_1−x_2|+|y_1−y_2|=x_2−x_1+y_1−y_2=(x_2−y_2)−(x_1−y_1)$ $x_1−x_2\\ge 0,y_1−y_2&lt;0$ $|x_1−x_2|+|y_1−y_2|=x_1−x_2+y_2−y_1=(x_1−y_1)−(x_2−y_2)$ $x_1−x_2&lt;0,y_1−y_2&lt;0$ $|x_1−x_2|+|y_1−y_2|=x_2−x_1+y_2−y_1=(x_2+y_2)−(x_1+y_1)$ 所以答案 $\\max \\big{ \\max {x_i+y_i }− \\min {x_i+y_i }, \\max {x_i−y_i } − \\min {x_i −y_i} \\big}$ ，注意初始化。 F - ContrastABC 178 F 给定两个长度为 $n$ 的数列 $A,B$ ，保证两数列都是升序。 问是否能通过重排 $B$ ，使得不存在 $i\\in [1,n]$ ，有 $A_i = B_i$ ，输出方案。 满足 $2\\le n \\le 2\\times 10^5$ ， $1\\le A_i,B_i\\le n$ SolutionAt 的构造还是很有意思。 考虑把 $B$ 翻转，则 $A$ 升序， $B$ 降序 ，若有不合法位置，则相同的数字一定只有一个。 记相同的数字为 $x$ ，相同数字的区间为 $[l, r]$ 。 考虑 $B$ 中某一个换过来的位置 $i$ ，那么需要保证 $a[i] \\ne x$ 且 $b[i] \\ne x$ ，否则换后依然不合法。 记录 $A$ 和 $B$ (翻转后) 出现 $x$ 最靠左的位置 $L$ ，出现 $x$ 最靠右的位置 $R$ 。 则可以交换的位置 $i\\in [L,R]$ ，有 $L - 1 + n - R$ 个，若这个数 $&gt;r-l+1$ 则有解。 然后就和两侧交换就好了。 123456789101112131415reverse(b + 1, b + 1 + n);int x, l = 0, r, L, R;for (int i = 1; i &lt;= n; ++i) if (a[i] == b[i]) l ? ++r : l = r = i;x = a[l];if (!l) {print(); return 0;}for (int i = 1; i &lt;= n; ++i) if (a[i] == x || b[i] == x) {L = i; break;}for (int i = n; i; --i) if (a[i] == x || b[i] == x) {R = i; break;}if (L - 1 + n - R &lt; (r - l + 1)) {puts(\"No\"); return 0;}int lim = min(L - 1, r - l + 1);for (int i = 1; i &lt;= lim; ++i) swap(b[i], b[l + i - 1]);lim = r - l + 1 - lim;for (int i = 1; i &lt;= lim; ++i) swap(b[n - i + 1], b[r - i + 1]);","link":"/training/atcoder/abc/178.html"},{"title":"AtCoder Beginner Contest 179","text":"官方题解链接： AtCoder Beginner Contest 179 Editorial A - Plural FormABC 179 A 输出给定名词负数，结尾不是 's' 的加 's' ，否则加 'es' 。 B - Go to JailABC 179 B 两个长度为 $n$ 的数列 $A,B$ ，问是否存在 $i\\in[1,n-2]$，满足 $A_i = B_i,A_{i+1} = B_{i + 1},A_{i + 2} = B_{i + 2}$ 。 线性扫描一下。 C - A x B + CABC 179 C 给定 $n$ ，计数正整数三元组 $(A,B,C)$ 的个数，满足 $n=A\\times B+C$ 。满足 $n\\le 10^{6}$ 。 Solution $C$ 的含义就是做一个前缀和，所以只需要算对于 $i\\in[1,n]$，$i$ 的拆分有多少种。 $A$ 和 $B$ 确定一个另一个就确定了，所以考虑 $x\\in[1,n]$ 作为 $A$ 可贡献的位置，即他的倍数。 这样复杂度是调和级数 ，暴力跑一下大概是 $2\\times 10^8$ 级别，做法常数小可过。 123for (int i = 1; i &lt;= n; ++i) for (int j = i; j &lt;= n; j += i) ++cnt[j];for (int i = 2; i &lt;= n; ++i) cnt[i] += cnt[i - 1]; D - Leaping TakABC 179 D 一个长度为 $n$ 的路，开始在 $1$ 号位置，问移动到 $n$ 的方案数。 给出 $k$ 个不相交的区间 $(l_i,r_i)$ ，每次向右移动的距离 $x$ 应属于某个区间。 满足 $n\\le 2\\times 10^5, k\\le 10$ 。 Solution设 $f[i]$ 表示走到 $i$ 的方案数，则有$$f[i]=\\sum_{t=1}^k \\sum_{j=i-r_t-1}^{i-l_t}f[j]$$因此每个位置考虑贡献，相当于区间加，求单点值，树状数组维护。 标算做法好像高明很多，考虑在求 $f$ 的同时维护 $f$ 的前缀和 $s$。 因为只会从前面转移，所以每算完一个位置的 $f$ 就求一下这个位置的前缀和就好。 123456f[1] = s[1] = 1;for (int i = 2; i &lt;= n; ++i) { for (int j = 1; j &lt;= k; ++j) f[i] = (f[i] + s[max(0, i - l[j])] - s[max(0, i - r[j] - 1)] + mod) % mod; s[i] = (s[i - 1] + f[i]) % mod;} E - Sequence SumABC 179 E 给定 $n,x,m$，求$$\\sum_{i=0}^{n-1} x^{2^{i}}\\mod {m}$$满足 $n\\le 10^{10},x,m\\le 10^5$ Solution考虑扩展欧拉定理。$$a^c\\equiv\\begin{cases}a^{cmod\\varphi(m)} &amp;\\gcd(a,m)=1 \\a^c &amp;\\gcd(a,m)\\neq1\\landc&lt;\\varphi(m) \\ a^{cmod\\varphi(m)+\\varphi(m)} &amp;\\gcd(a,m)\\neq1\\landc\\geq\\varphi(m)\\end{cases}$$指数大于 $\\varphi(m)$ 时，相当于与只会在 $\\big [\\varphi(m),2\\varphi(m)\\big)$ 内。 而指数是 $2^i$ ，其中 $i$ 是连续的，也就是说指数会存在在 $\\varphi(m)$ 剩余系下的循环节，找循环节即可。 复杂度 $\\mathcal O(M)$，注意循环节可能会很小，因此指数的计数器要开 long long 。 F - Simplified ReversiABC 179 F 一个 $n\\times n$ 的矩阵，每个格子都可能被染成黑白两色。 初始中间的 $(n-2)\\times (n-2)$ 的格子被染成黑色，最右侧和最下侧的格子被染成白色，其他未染色。 执行 $q$ 次操作： 1 x 将 $(1,x)$ 染成白色，并向下找到第一个白色格子，把他们之间的格子染成白色。 2 x 将 $(x, 1)$ 染成白色，并向右找到第一个白色格子，把他们之间的格子染成白色。 问操作后黑色格子有多少个。 满足 $3\\le n \\le 2\\times 10^5$ 。 Solution","link":"/training/atcoder/abc/179.html"},{"title":"Atcode Beginner Contest 203","text":"Contest Link: AtCoder Beginner Contest 203 Official Editorial: Editorial - AtCoder Beginner Contest 203 Overview: 比平时的 ABC 难一些， F 题比较有意思。 D. Pond给定一个 $n\\times n$ 的矩阵，找到所有 $k\\times k$ 的子矩阵中，子矩阵内中位数的最小值。 考虑对于某个 $x$ ，将矩阵中小于等于 $x$ 的数标 $1$ ，其余标 $0$ 。 若某个 $k\\times k$ 的子矩阵内和为 $\\lfloor\\frac{k^2}{2} + 1\\rfloor$ ，则此时 $x$ 可以成为答案之一（ $x$ 为该子矩阵的中位数） 赛时的做法比较窒息，将所有数字排序后逐个插入，需要支持单点加，询问是否存在对应的子矩阵。 由于询问的矩阵大小相同，将子矩阵内的权值记录在左上角，转化成了子矩阵加加，维护矩阵内单点 $\\max$ 。 写了二维线段树复杂度 $O(n^2\\log^2n)$ ，TLE * 8，耻辱下播。 实际上二分答案+二维前缀和就好了，每次二分，把原矩阵中小于的标 $1$ 。 然后用二维容斥逐个检查是否存在 $k\\times k$ 的子矩阵内和 $&gt;\\lfloor\\frac{k^2}{2} + 1\\rfloor$ 即可，复杂度 $O(n^2\\log n)$ 。 E. White Pawn题意不再叙述，注意直着移动目标位置不能有黑点，斜着移动目标位置必须有黑点。 考虑维护起点到每一行末尾的连通性，那么一个黑点能影响的连通性，其实只有它所在的行。 具体的，如果某个黑点坐标在 $(x_0,y_0)$ ，起点可以到的 $x=x_0-1$ 的行的集合为 $S$ ，那么： ￼ 如果 $y_0+1\\in S$ 或 $y_0-1\\in S$ ，则 $x=x_0$ 时 $y_0$ 可达，将 $y_0$ 加入。 ￼ 否则 $x=x_0$ 时 $y_0$ 不可达，将 $y_0$ 删去。 因此只需要维护可达行的集合 $S$ ，按黑点 $x$ 从小到大修改 $S$ 即可，显然集合的大小与黑点的个数是线性关系。 维护的时候需要注意同一列上不同点可能会互相影响，可以把修改存下来，每一列处理完后统一做。 1234567891011121314151617181920set&lt;int&gt; S;map&lt;int, vector&lt;int&gt; &gt; a;vector&lt;int&gt; add, del;int main() { int n = rd(), m = rd(); for (int i = 1; i &lt;= m; ++i) a[rd()].push_back(rd()); S.insert(n); for (auto v : a) { add.clear(); del.clear(); for (auto y : v.second) if (S.count(y - 1) || S.count(y + 1)) add.push_back(y); else del.push_back(y); for (auto y : add) S.insert(y); for (auto y : del) S.erase(y); } printf(\"%d\\n\", S.size()); return 0;} F. Weed题意不再叙述，注意是双关键字最优。 赛时以为第一关键字最优的情况一定是推掉最大/最小的共 k 个，反例很好找（一段一段的分布） 性质：每次 2 操作集合里的最大值都会至少减半，最多删 $\\log\\{\\max a_i\\}$ 次一定会结束了，第一关键字最大为 $30$ 。 这个状态设计比较有意思（答案放到状态中）：首先将 $a[i]$ 从小到大排序，$f[i][j]$ 表示，只考虑 $a[1],\\cdots, a[i]$ ，即只考虑 $\\le a[i]$ 的元素时， 最少提前使用 2 操作删掉几个，使得剩余的只需要 $j$ 次 1 操作即可删干净。 转移分讨当前元素删/不删即可: $f[i][j] = \\min(f[i-1][j] + 1,f[pos - 1][j - 1])$ 其中 $pos$ 的含义为，最小的 $x\\ge 1$ ，满足 $a[x] &gt; \\frac{a[i]}2$ ，即使用一次操作 $a[i]$ 能带走的最靠前的位置。 123456789sort(a + 1, a + 1 + n);for (int i = 1, p = 1; i &lt;= n; i++) { for (; a[p] * 2 &lt;= a[i]; p++); f[i][0] = i; for (int j = 1; j &lt; K; j++) f[i][j] = min(f[i - 1][j] + 1, f[p - 1][j - 1]);}for (p = 0; f[n][p] &gt; k; p++);printf(\"%d %d\\n\", p, f[n][p]);","link":"/training/atcoder/abc/203.html"},{"title":"Atcode Regular Contest 124","text":"Contest Link: AtCoder Regular Contest 124 Official Editorial: Editorial - AtCoder Regular Contest 124 overview：不太会用很强的约束条件 A. LR Constraints 给一个数列赋值，值域 $[1,k]$​​ ，对于每个 $k$​​​​​ ，约束第一次出现的位置或最后一次出现的位置，求方案数 维护一下对于每个位置，当前有多少种方案，复杂度 $O(n)$​ B. XOR Matching 2 给定两个长度相同的数列 $A,B$​​ ，求有哪些 $x$​​ ，使得将 $B$​​ 重排后，任意位置 $A_i\\ \\text{xor}\\ B_i = x$​​​ 重排后有 $\\forall 1\\le i,j\\le n,\\ A_i\\ \\text{xor}\\ B_i=A_j\\ \\text{xor}\\ B_j\\Rightarrow A_i\\ \\text{xor}\\ A_j=B_i\\ \\text{xor}\\ B_j$​​​​ 也就是说，要满足重排后, （$A_i$​​ 与所有其他 $A$​​ 的异或值）与（$B_i$​​ 与所有其他 $B$​​​​ 的异或值）一一对应 约束条件很强，我们只需要处理 $A_1$​ 与其他 $A$ 的异或值，然后找可能对应的 $B$ 即可，复杂度 $O(n^2\\log n)$​​ C. LCM of GCDs 给定 $n$ 个 pair，每个 pair 中的数一个放入 $A$ 集，另一个放入 $B$​ 集，最大化 $lcm[\\ gcd(A),\\ gcd(B)\\ ]$​ 集合的最大公约数一定是每个数的因子，将第一个 pair 里的两个数求出所有的约数，枚举答案。 如果存在一种方案使得答案为 $[x,y]$​​ 的倍数，那么对于每个 pair $(a,b)$​​ ，有 $x|a,\\ y|b$​ 或者 $x|b,\\ y|a$​ ​​ 暴力检验即可，复杂度 $O\\big(div(A_{1a})div(A_{1b})n\\big)$​ D. Yet Another Sorting Problem 一个 $n+m$​ 的排列，每次选择前 $n$​ 个中一个和后 $m$​ 个中一个交换，问交换成单位置换所需最少次数 首先，如果没有位置选择的限制，还原一个 $n$​​ 的排列所需最少交换次数为 $n\\ -$ 排列所对应的环数。 将排列 $p$​​ 视作置换，将位置视为点，每个数由当前位置指向目标位置，即建边 $i\\to p_i$​​ 得到若干个环。 我们的目标是让所有的 $i$​ 满足 $i \\to i$​ ，即 $\\forall i, p_i = i$​ ​变为单位置换。 因此对于某次交换，操作都会形如将 $p_i$​ 和 $p_{p_i}$​​ 进行交换，也就是将第 $i$ 位的数和第 $p_i$ 位的数交换。 那么对于原来所在环中的结构 $i\\to p_i\\to p_{p_i}$​ ，变换后第 $i$​ 个位置上变为 $p_{p_i}$​ ，而第 $p_i$ 位上的数变为 $p_i$​​​ 也就是说，对于每个环，每次交换相当于将环上的一个 $a\\to b\\to c$ 结构变为 $a\\to c，b\\to b$​​​​​ 目标是形成 $n$​ 个自环，因此每个环需要环长 $-\\ 1$​ 次移动才能将环内归位，而不同的环之间还原过程无关。 考虑位置选择的限制条件，我们将前 $n$ 个点染成黑色，后 $m$ 个点染成白色。 可以发现，每次可以操作的约束条件等价于每次删掉的边要满足连接的两个点颜色不同。 对于一个由若干段白黑交替连接的环，我们一定可以通过白点吃指向的黑色的点，将整个环变成只剩下一个黑色，然后用这个黑色删掉所有其他白色，总次数为环长 $-1$​ 对于一个只有某一种颜色的环，我们需要考虑“引入”另一种颜色，需要花费一步的代价进行一次交换引入，然后分析如上，此时环长因为引入 $+1$​​ ，因此总次数为原来环长 $+1$​​ 考虑都有“引入”需求，但颜色不同的两个单色环，此时某一个环引入对方的某个元素，相当于帮助了对方引入，因此两个环之需要一次“引入” ，并且两个环共享的引入的长度 ，总次数为第一个环长+第二个环长 综上，对于双色环，我们所需次数为环长 $-1$ ，单色环先默认代价为环长 $+1$ ，每匹配上一对总代价 $-2$ 。 此外本题无需考虑太过复杂，首先同色单色环之间融合没有意义（可比较前后代价），其次不需要考虑单色环和双色环的融合，这种情况可以看作先将双色环归位，再取某一个长度为 $1$​​​​​​ 的自环与单色环进行融合。 处理过程中只涉及 dfs 找环，总复杂度 $O(n)$ 123456789int cntl = 0, cntr = 0;for (int i = 1; i &lt;= n + m; ++i) if (!bl[i] &amp;&amp; i != p[i]) { ++tot; dfs(i); ans += len[tot]; if (l[tot] &amp;&amp; r[tot]) --ans; else {l[tot] ? ++cntl : ++cntr; ++ans;} }printf(\"%d\\n\", ans - min(cntl, cntr) * 2); E. Pass to Next比赛没来得及看的题，回头做。 F. Chance Meeting比赛没来得及看的题，回头做。","link":"/training/atcoder/arc/124.html"},{"title":"Codeforces Round 699 (Div. 2)","text":"A. Space Navigation统计四个方向的移动分别有多少，只保留走向目标向量对应方向的移动，判断是否可达。 B. New Colony观察数据范围 $n,h_i\\le 100$ 最多扔 $10^4$ 个石头就结束了，模拟 $\\text O(n^2h)$ 即可。 C. Fence Painting首先如果最后一次涂色不在 $b_i$ 里，肯定无解。 然后如果所有涂色不能满足将所有 $a_i$ 和 $b_i$ 不一样的位置覆盖为 $b_i$ ，则无解。 剩下的情况必定有解，一种构造方法： 对每种颜色 $c$ 预处理出来所有 $a_i$ 和 $b_i$ 不同且 $b_i=c$ 的位置集合 $S_c$ 。 首先确定最后一次涂色的位置 $pos_m$ ： 若 $S_{c_m}$ 为空，则令 $pos_m$ 为任意一个 $b_i=c_m$ 的位置。 若 $S_{c_m}$ 不为空，则让 $pos_m$ 为 $S_{c_m}$ 中的任意一个，并将该位置移出 $S_{c_m}$ 。 然后时间倒序考虑，对于当前颜色 $c_j$ ： 若 $S_{c_j}$ 为空，那么让 $pos_j=pos_m$ ，因为第 $m$ 次操作是最后一次，所以肯定会覆盖。 若 $S_{c_j}$ 不为空，则让 $pos_j$ 为 $S_{c_j}$ 中任意一个位置，然后将该位置移除 $S_{c_j}$ 即可。 D. AB Graph首先奇数长度一定有解，在两个点之间来回跑就可以了。 考虑偶数长度，如果存在连接两个点的一组边类型相同，那么就一直在这两个点之间来回跑就可以了。 剩余的情况就是每一组边都是一条 $A$ 一条 $B$ ，那么对于 $n\\ge 3$ 时很容易证明： 存在一个点 $x$ ，满足存在另两个点 $y,z$ ，边 $x\\to y$ 和 $x\\to z$ 的类型不同。 反证法：假设对于任意的点，所有的出边类型相同，入边类型相同，且两种边类型不同。 不妨设点 $x$ 的所有出边类型均为 $A$ ，也就是说对于其他任意的点的入边类型均为 $A$ （由假设性质） 那么对于任意另外两个点 $y,z$ 之间的边的类型，存在矛盾： $z$ 的入边由上知类型为 $A$ ，则 $y\\to z$ 是 $z$ 的入边，类型必须为 $A$。 $y$ 的出边与入边类型相反，则 $y\\to z$ 是 $y$ 的出边，类型必须为 $B$ 。 因此只需要 $\\text O(n)$ 枚举 $x$ ，$\\text O(n)$ 扫描其他点，判断是否存在 $y,z$ 即可。 对于 $m = 4k$ 的情况，构造解形如 $x\\ y\\ x\\ y\\cdots x\\ y\\ x\\ z\\ x\\ \\cdots z\\ x\\ z\\ x$ 即可。 对于 $m = 4k+2$ 的情况，构造解形如 $y\\ x\\ y\\ x\\ y\\cdots x\\ y\\ x\\ z\\ x\\ \\cdots z\\ x\\ z\\ x\\ z$ 即可。 E. Sorting Books","link":"/training/codeforces/round/699.html"},{"title":"Codeforces Round 701 (Div. 2)","text":"A. Add and Divide首先最优解一定是 ++b 若干次（可能为 $0$ ），然后再一直做 a=a/b 直到符合条件。 考虑最差的情况：$a=10^9,b=1$ ，至多只需 $1+\\lceil \\log_2{10^9}\\rceil = 31$ 次，所以所有答案都 $\\le 31$。 因此枚举++b 的操作次数 $k\\ (0\\le k\\le 31)$ ，然后暴力计算答案即可，复杂度 $\\text O(t\\log^2 a)$ 。 B. Replace and Keep Sorted考虑 $b_i\\not =a_i$ ，那么考虑 $b_i$ 的取值范围： 对于 $i=l$ 的情况， $1\\le b_i&lt;a_{i+1}$ ，与 $a_i$ 不同的方案有 $a_{i + 1} - 2$ 个。 对于 $i=r$ 的情况， $a_{i-1}&lt;b_i\\le k$ ，与 $a_i$ 不同的方案有 $k - a_{i-1} - 1$ 个。 对于 $l&lt;i&lt;r$ 的情况， $a_{i-1}&lt;b_i&lt;a_{i+1}$ ，与 $a_i$ 不同的方案有 $a_{i+1}-a_{i-1}-2$ 个。 $i$ 不同的贡献是独立的，所以用前缀和优化一下第三部分的计算，各个位置的方案数求和即可。 C. Floor and Mod设 $\\lfloor a/b\\rfloor=a\\ \\text{mod}\\ b=k$ ，根据整除理论，有 $a=k *b+k$ ，且 $k &lt; b$ 。 考虑枚举 $k$ ，去数可行的 $b$ ，那么限制条件有：$1\\le b \\le y\\ ,\\ 1\\le k*b+b=a\\le x$ 移项，得 $1\\le b\\le \\min(y,\\ x / k - 1)$ ，即 $k$ 的贡献为 $\\min(y,\\ x/k - 1)$ 。 又由 $k\\le b$ 得 $k ^2 &lt; k * b+k = a\\le x$ ，得 $k\\le \\sqrt x$ ，因此 $O(t\\sqrt x)$ 枚举 $k$ 直接计算即可。 比赛时用的另一种做法，复杂度也是 $\\text O(t\\sqrt x)$ ： 考虑枚举 $b$ ，由上知可行的 $a = k *(b+1)$ 且 $1\\le k\\le b-1$ 。 考虑枚举 $b$ ，则贡献为 $\\min(b-1,\\lfloor x/(b + 1)\\rfloor)$ ，具体的： 当 $(b+1)(b-1)\\le x$ 时，即 $b \\le \\sqrt{x + 1}$ 时，贡献为 $b-1$ ，可以等差数列求和。 否则贡献取 $\\lfloor x /(b + 1)\\rfloor$ ，整除分块计算即可。 D. Multiples and Power Differences数据范围 $1\\le a_{i,j}\\le 16$ ，观察： $\\text{lcm}(1,2,\\cdots,16)=720720\\le 10^6 - 10^5$ $16^4 = 65536\\le 10^5$ 将矩阵黑白染色，黑色变为 $720720$ ， 白色变为 $720720+x^4$ 即可 （ $x$ 为原矩阵对应位置的数） E. Move and Swap设 $f[u]$ 表示红点在 $u$ 时，$u$ 及其子树的最大得分。 若红蓝不交换，假设红色在 $u$ ，则最优解本质上是 $u$ 儿子最大得分 + 同深度点与 $u$ 点权最大差值。 若红蓝交换，则本质是任选同深度节点 $v$ 的最优儿子，及 $v$ 与 $u$ 点权差值。 那么转移方程具体的（设 $d[u]$ 表示节点 $u$ 的深度）：$$f[u] = \\max \\bigg \\{ \\max_{s\\in son[u]} f[s] + \\max_{d[v] = d[u]} | a_u - a_v |\\ ,\\ \\max_{d[v]=d[u]}\\bigg(|a_u-a_v| + \\max_{s\\in son[v]} f[s]\\bigg)\\bigg \\}$$可以发现转移是从深到浅转移的。第一部分直接枚举儿子转移即可，第二部分维护： $$mxp[d] = \\max_{d[v]=d}\\bigg(a_v + \\max_{s\\in son[v]} f[s]\\bigg)\\ ,\\ mxm[d] = \\max_{d[v]=d}\\bigg(-a_v + \\max_{s\\in son[v]} f[s]\\bigg)$$ 则第二部分的转移就可以表示为 $f[u] = \\max\\{mxp[d[u]] - a[u],mxm[d[u]]+a[u]\\}$ 。 F. Copy or Prefix Sum假设当前处理到第 $i$ 位，前 $i-1$ 位的和为 $S$ ，那么 $a_i=b_i$ 或者 $a_i=b_i-S$ 都是可以的。 那么答案为什么不是 $2^n$ 呢？因为 $S=0$ 时会重复计数。 设 $f_{i,S}$ 表示前 $i$ 位填完，前缀和为 $S$ 的方案数，那么转移为： $a_i=b_i$ ： $\\forall S\\ ,\\ f_{i+1,S+b_i} += f_{i,S}$ $a_i = b_i -S$ ： $\\forall S\\ ,\\ f_{i+1,b_i}+=f_{i,S}$ ，即 $f_{i+1,b_i}=\\sum_{\\forall S} f_{i,S}$ $S=0$ 去重：$f_{i+1,b_i} -= f_{i,0}$ 综上，$i\\to i+1$ 转移的过程即为：所有的 $f$ 整体向右偏移 $b_i$ ，然后对 $f_{b_i}$ 单独赋值。 因此省略第一维，使用 map 维护第二维，用记录整体偏移量的方法优化。 记录 $tot=\\sum_{k=1}^ib_k\\ ,\\ ans=\\sum_{\\forall S} f_S$ ，递推即可，实现见 代码 。","link":"/training/codeforces/round/701.html"}],"posts":[{"title":"热爱生活","text":"今天是 2021 年 7 月 8 日，星期四。 一年前的今天，高考最后一门刚刚考完。走出考场，回到自己的教室，拿手机，搬行李，告别。 离开学校的时候，碰到了还在梳理交通的竞赛教练，问我考的怎么样，然后约了后天要给高一的学弟们上课。 直到昨晚，暑假回本部给又一届的学弟们上完最后一天课。从二中本部的校门里走出来，回头看看。 来杭电之前高考完就跟爸爸妈妈说我不复读，当晚就对答案，大概 645。报了南科大综评，拿到了还算不错的校考分。 然后在南校区给高一的同学讲了比较入门的概率，也是那些在一年前的暑假认识的，刚踏入二中大门学弟。 结束的时候在空空的学校里溜达，想想他们上课时候那种纯粹的热情，一代又一代，多少有一点感慨。 走之前拍了张照片，想起来一句自认为很应景的话：“雨过天青云破处，者般颜色做将来” 出分的晚上比较坦然，提前几分钟查到了分数，比估计的低 9 分，都扣在语文上，115 / 134 / 136 / 251。 之后的几天比较迷茫，听了几个学校的招生宣讲都不尽如人意。南科大那边几度有希望，后来终究是落空。 在我想起来杭电这所学校的时候，突然感觉就是要去这里了。 可能是高二去学军培训喜欢上了杭州这个城市，也可能是对竞赛生涯结束的不甘吧。 先自己偷偷找 Claris 要到了教练的联系方式，问了读研和专业的事情，刘老师的热情的杭州话让人很舒服。 然后就是小心翼翼地和父母交流，说我自己的想法和考虑，直到最后心里十分踏实地填上了第一志愿。 录取的结果是数学系，高考分数达到了卓越学院二次选拔的报名分数线，报了卓越学院的招生考试。 之后的假期写了几个板子，打了几场 CF 恢复一点水平，参加了 HDU 的几场内部训练，搬了一套题恰烂钱。 开学之前和岳老师吃了个饭（竟然还赶上了他生日）， 让我重心不要全部放到竞赛上，要给自己留个后路。 初到杭电有一说一假期还是过的比较随意，虽然报名了卓越学院，但是一点没准备，9 月份忐忑地就来到杭电啦。 考试之前自己很没有底气，当时觉得能进计科班就不错了。考完觉得考的还行，因为竞赛里接触过一点高数线代的知识，觉得自己英语阅读也比较会蒙。然后晚上大概九点的时候出成绩了，震惊自己竟然过了英才班的线。 晚上给爸爸妈妈很激动地打了个电话，有点担心 11 进 9 被刷掉，一直到十二点多才睡着。 第二天面试的时候其实自己比较轻松，感觉面试向来都比较稳 比较会吹 ，面试单独面，五个老师。 面试比较自然，老师们的问题基本是跟着我的自我介绍思路走，不过还是有几个问题血压拉满。 我努力地强调自己的竞赛水平，然后冯老师问：“现在让你去打区域赛能拿到什么奖项？” 我介绍了一下高中学校和班级的情况，然后另一个老师问：“你觉得二中和衡一哪个更好？” 周老师（也是现在的导师）问：“你也不能打一辈子竞赛啊。以后有什么进一步的打算？” 我说会读研，以后可能会去当大学老师。导师笑笑说要想当教授，后面得去好点的大学读书。 面试完出来觉得自己还挺稳的，但是也不敢确定，忐忑到了晚上十点多出了结果。终于还是去学计算机了。 之后的生活很顺利，见面会，正常上课，班委选举（当了学委）。 上课的时候强迫自己去提问，回答问题，意识到自己可以做一些 由自己决定的 想做什么就做什么 的事。 遇到了自己喜欢的老师，有能够舒适相处，真心相待的一帮同学，慢慢地从高三痛苦自闭的状态走出来了。 竞赛这段话也想写给每个学竞赛过程中感到无力的同行者。 算法竞赛的魅力在于，通过努力积累或灵机一动，你能够做出越来越难的题目，是一种对自我能力的认可。 算法竞赛的危险亦在于，你学会的东西越多，认识的厉害的人越多，面对不可计数的强者，很容易陷入自我否定。 想到杭电之前，很长一段时间都觉得，大学不会再打竞赛了。 学竞赛的过程中经历的打击，不仅是比赛和上课中受到一众神仙居高临下的压迫感，更多的其实是周围人不经意的否定和安慰。对我来说，这是一种对信心很大的打击，会想要证明自己，亦或是心里感到无力而故作轻松。 在面临是否买 D 的抉择时，我放弃了。不是担心取得不了什么结果，而是觉得压力太大了。 在选学校的时候，突然想到杭电的那一刻，有种死灰复燃的感觉。 记起来 NOIP 2018 结束的时候，在存真楼下，孙校长和我们几个刚从秦皇岛回来的学生说的几句话： “学别的竞赛的，最终的发展和竞赛不一定有关系，但是算法竞赛的学生，最终往往都会选择计算机行业。” 算法竞赛会在心里埋下一颗种子。 我不是那种一帆风顺的天才，在受到打击的时候，我会感到无力。 但当我抛开名利、和他人比较、证明自己这些功利的意义之后，我发现自己还剩下些东西，还能看到初心。 是对算法的欣赏和热爱，是理解每一个算法、做出每一个题目的瞬间，精神上的享受，这就够了。 至少在我看来，从我开始接触竞赛，到做出很多重要的选择，我决策的初心从来都不是名利，因为对算法还爱着。决定最终没有买 D 类，最大的原因还是在那个时刻，竞赛带来的痛苦超过了学习的享受，被一次次的排名裹挟，被各种机会所吸引，我越来越像一个没有自我的机器，越来越被成功学牢牢锁死。而在我选择大学的时候，竞赛对我的意义不再是未来的全部了。我能够静下来，问问自己对算法还有没有那种近乎痴迷的喜爱，能够将它作为一种兴趣去发展，不需要考虑付出和回报，至少在大学，我还是有自由支配自己的权利。 我还是那个深深爱着算法的小孩，对几十行代码背后的智慧如痴如醉。 Gold Medal (30th Place) : The 45th ICPC Asia Jinan Regional Contest, 2020 Gold Medal ( 15th Place) : The 18th Zhejiang Provincial Collegiate Programming Contest, 2021 Silver Medal (28th Place) : The 45th ICPC Asia Shenyang Regional Contest, 2021 课内学习第一个学期不会选课，修了系统默认的 25.25 个学分， 第二个学期修了 32.25​ 个学分。 通识选修只完成了科技发展与科学精神（2/2），大二上应该会把剩下的指标修完。 数理基础（23） 数分 （6 * 3.5 + 5 * 4.2）、高代（3 * 5 + 2 * 5）、离散（4 * 5）、大学物理1（3 * 5） CS专业课（14） 计导（2 * 5）、程设基础（5 * 5）、数据结构（4 * 4.5）、C++ 面向对象（3 * 5） 通识教育（8） 思修法基（3 * 5）、心理健康（1 * 4.3）、大军（2 * 4.8）、ACM（2 * 5） 外语类（8） 英语精读 A（2 * 4.4 + 2 * 4.6）、英语听说 A（1 * 4.3 + 1 * 4.7）、实用翻译（2 * 4.6） 其他（3.5） 大学启示录（1 * 4）、形式与政策（0.5 * 5）、科研实践（1 * 5）、体育（1 * 2.1 + 1 * 1.8） 很幸运的是遇到的老师都很认真负责，老师们对课程内容非常了解，自己遇到问题也都能很好沟通。 很多课程都觉得自己做的没那么好，对给出的成绩也常常受之有愧。 数学分析和高等代数两门数学基础课的表现截然相反，让我更清楚地意识到很大程度上我是个兴趣驱动的人。 对数分的知识体系自己本身可能就不太感兴趣，加上数分课是真的提不起来精神，两个学期的数学分析成绩都不太看的过去，数分上可能要在大三重修了。老师确实想要认真教会我，可是自己确实提不起兴趣去学。经历了数分上的洗礼，数分下还是逼着自己学了学，最后的结果算是马马虎虎吧，确实对不起老师对不起自己。 很喜欢高代老师的课，很大程度驱动我去花相对比较多的时间在这门课上。两个学期最后的结果都比较好，在自己喜欢的科目上能够看到自己做了些事情，也是让自己很开心的一件事。唯一遗憾的是期末错在了最后一节课老师强调过的一个小点上（证明正定阵需先说明对称）。大二下预定了老师的近世代数。 也很喜欢 Cathy 上的英语精读，也算是第一次能让我主动提起来学英语的兴趣。 Cathy 的课有一种很轻松的气氛，不会按照课本一板一眼的去上，讲的很多东西很受用。 感谢程设和OOP（C++）的老师对我的包容，自己在这两门课上确实有过很幼稚的行为。很佩服将近退休的老师能精确把控很多细节，随手写的代码能一遍过编译什么错都没有。 离散数学和数据结构 给了我很深刻的教训。两门都是自认为了解比较多的，数据结构甚至申请了免听。考前复习的都不是很充分，等上了考场发现要开始脑补一堆一堆的概念。期末离散卷子简单，没暴露出来什么问题。数据结构觉得自己看看书就够了，最后的成绩却不尽如人意，原因只是不知道排序里的一个既定细节，只能悔不当初。 大学物理和思想道德修养与法律基础 两门课结果意外的好，其实自己认真去学一学还是可以有效果的。中学阶段一直头疼的政治在闭卷的期末考试也写了个差不多。学不会电磁在考场上也做出来了绝大多数题。考试遇到不会的题也不能太着急，多想一会没准就通了。 体育 从中考的 $18$ 分保底，到大一上的体测 $36$ 分，痛失两个学期的奖学金，终究还是没逃过身体素质不行这个问题。还是感谢环境逼着我去直面体育，按着体能班的要求大一下结结实实把 40 次阳光长跑跑完了，也确实让我看到耐力可以有提升，从操场跑一圈就喘不上气，到体测的时候人生第一次把 1000 米全跑下来，确实是很激动的。也终于在锻炼身体上有了动力，首先是大二下想要和 qyy 同学一起学体育舞，其次是想要恰奖学金。 我的她只想说爱情的体验是一种很纯粹的幸福。 愿意为她牺牲自己的一切，无时无刻都会想起她的事情，找不到她会坐如针毡，什么都做不下去。 她所高兴的事情比她还高兴，她难受的时候会跟着一起哭出来，在爱情中两个人都学会了如何照顾对方。 两个人在一起呆着常常心有灵犀，做事情反应如出一辙，很多事情不用言语。 两个人在一起呆着就是最快乐的事情，能够一起学习，散步，她在我的身边就能感受到无比的踏实。 会走到一起的人终究不会分开。心里对未来有着期盼，静下心来踏踏实实做事，继续加油。","link":"/2021/07/08/freshman/"},{"title":"Hello World","text":"「 Hello, the lovely world. 」 「 Stay hungry, Stay foolish. 」 12345678910111213141516171819202122&gt;&gt;&gt; import thisThe Zen of Python, by Tim PetersBeautiful is better than ugly.Explicit is better than implicit.Simple is better than complex.Complex is better than complicated.Flat is better than nested.Sparse is better than dense.Readability counts.Special cases aren't special enough to break the rules.Although practicality beats purity.Errors should never pass silently.Unless explicitly silenced.In the face of ambiguity, refuse the temptation to guess.There should be one-- and preferably only one --obvious way to do it.Although that way may not be obvious at first unless you're Dutch.Now is better than never.Although never is often better than *right* now.If the implementation is hard to explain, it's a bad idea.If the implementation is easy to explain, it may be a good idea.Namespaces are one honking great idea -- let's do more of those!","link":"/2018/11/29/hello-world/"},{"title":"线性筛与积性函数","text":"线性筛是一种数论筛法，可以筛出一定范围内的质数或任意积性函数的值。 其中”线性“的含义为 每个数字只被其最小的质因数筛出 ，并非时间复杂度。 假设求积性函数 $f(x)$ 的质数幂 $f(p^k)$ 复杂度为 $t$，则最终复杂度为 $ \\mathcal O(n+\\frac{n}{\\ln n}\\times t)$ 。 数论函数定义域为正整数集 $\\mathbb N^+$，陪域为复数集 $\\mathbb C$ 的函数。 常见的数论函数可视为，定义域为正整数，值域为整数的函数。 积性函数对于一个数论函数 $f$ ， $\\forall\\ a\\ \\bot\\ b,\\ f(ab) = f(a)\\times f(b)$，则称 $f$ 为积性函数。 若 $n$ 的标准分解为 $n = p_1^{k_1}\\times p_2^{k_2}\\times …\\times p_m^{k_m}\\ (p_1&lt;p_2&lt;…&lt;p_m)$ ，则$$f(n)=\\prod_{i=1}^m f(p_i^{k_i})$$这也是线性筛的基础，即积性函数的基本性质之一就是可被线性筛。 完全积性函数对于一个数论函数 $f$ ， $\\forall\\ a,b\\in \\mathbb N^+ ,\\ f(ab) = f(a)\\times f(b)$，则称 $f$ 为完全积性函数。 线性筛求 $f(n)$ 的值时，考虑其标准分解 $$n = p_1^{k_1}\\times p_2^{k_2}\\times …\\times p_m^{k_m}\\ (p_1&lt;p_2&lt;…&lt;p_m)$$ 对标准分解的最小质因数的指数 $k_1$ 的情况讨论。 $n$ 是素数 $p_1$，即 $k_1=m=1$ $n=p_1\\times i$，其中 $i$ 是任意正整数，且 $k_1=1$，即 $p_1\\nmid i$ $n=p_1\\times i$，其中 $i$ 是任意正整数，且 $k_1&gt;1$，即 $p_1\\mid i$ 下面对三类情况分别进行处理： $n$ 是素数 $p_1$，即 $k_1=m=1$ 往往可以利用数论函数的定义快速求出。 $n=p_1\\times i$，其中 $i$ 是任意正整数，且 $k_1=1$，即 $p_1\\nmid i$ 利用积性函数的定义，由于 $p_1\\bot i$，有 $f(n) = f(p_1) \\times f(i)$ 由于 $p_1&lt;n,\\ i&lt;n$，$f(p_1)$ 和 $f(i)$ 在此前都已求出。 $n=p_1\\times i$，其中 $i$ 是任意正整数，且 $k_1&gt;1$，即 $p_1\\mid i$ 将 $n$ 重新表示为 $n=p_1^{k_1}\\times j$ 的形式，此时 $p_1^{k_1}\\bot j$，有$f(n)=f(p_1^{k_1})\\times f(j)$ 由于 $p_1^{k_1}&lt;n, j&lt;n$，$f(p_1^{k_1})$ 和 $f(j)$ 在此前都已求出。 现在只需要解决如何快速求出 $n$ 对应的 $p_1^{k_1}$ 和 $k_1$ 的值。 不妨设 $g(n)=p_1^{k_1},\\ k(n)=k_1$，这两个函数虽然不是积性的，但依然可以按照上述思路讨论。 $n$ 与 $p_1$ 关系 $g(n)$ $k(n)$ $n$ 是素数 $p_1$ $p_1$ $1$ $n=p_1\\times i$，且 $p_1\\nmid i$ $p$ $1$ $n=p_1\\times i$，且 $p_1\\mid i$ $g(i)\\times p_1$ $k(i)+1$ 因此我们可以在线性筛的同时求出 $g(n)$ 和 $k(n)$，复杂度不变。 应用下面展示一些积性函数的线性筛法。 对应函数的积性证明参考 这里 ，本篇不再证明。 下面提到的 $n,m,i,j,p,k$ 的定义与上述内容相同。 线性筛质数本质上是筛 最小质因数 $d_{min}(n)=p_1$，若 $d_{min}(n)=n$ 则这个数为质数。 这个函数也不是积性函数，但是对于由当前质数 $p_i$ 筛掉的任意合数 $n$，都有 $d_{min}(n)=p_i$ Sample-Code 1234567for (int i = 2; i &lt;= n; ++i) { if (!mindiv[i]) prime[++tot] = mindiv[i] = i; for (int j = 1; j &lt;= tot; ++j) { if (prime[j] &gt; mindiv[i] || prime[j] * i &gt; n) break; mindiv[prime[j] * i] = prime[j]; }} 线性筛 $\\mu$莫比乌斯函数 $\\mu$ 是积性函数，定义为$$\\mu(n)= \\begin{cases} 1 \\qquad &amp; n=1 \\ (-1)^k \\qquad &amp; n=\\Pi_{i=1}^{k} p_i \\ 0 \\qquad &amp; \\text{otherwise} \\end{cases}$$易得 $\\mu(p_i^k)=0(k&gt;1)$，直接按条件分讨就可以。 $n$ 与 $p_1$ 关系 $\\mu(n)$ $n$ 是素数 $p_1$ $-1$ $n=p_1\\times i$，且 $p_1\\nmid i$ $\\mu(p_1)\\times \\mu(i)=-\\mu(i)$ $n=p_1\\times i$，且 $p_1\\mid i$ $\\mu(p_1^{k_1})\\times\\mu(j)=0$ Sample-Code 123456789mu[1] = 1;for (int i = 2; i &lt;= n; ++i) { if (!mindiv[i]) prime[++tot] = mindiv[i] = i, mu[i] = -1; for (int j = 1; j &lt;= tot; ++j) { if (prime[j] &gt; mindiv[i] || prime[j] * i &gt; n) break; mindiv[prime[j] * i] = prime[j]; mu[prime[j] * i] = (i % prime[j]) ? -mu[i] : 0; }} 线性筛 $\\varphi$欧拉函数 $\\varphi$ 是积性函数，定义为 $$\\varphi(n)=\\sum_{i=1}^n[i\\bot n]$$ 同时有 $\\varphi$ 计算公式（证明见这里) $$\\varphi(n)=n\\prod_{i=1}^m \\frac{p_i-1}{p_i}$$ 由计算公式知，第三类情况 $$\\varphi(n)=\\varphi(p_1^k)\\times\\varphi(j)=(p_1-1)\\times p_1^{k-1}\\times \\varphi(j)\\\\varphi(i)=\\varphi(p_1^{k_1-1})\\times \\varphi(j)=(p_1-1)\\times p_1^{k_1-2}\\times \\varphi(j)$$ 因此有 $$\\varphi(n)=\\varphi(i)\\times p_1$$ $n$ 与 $p_1$ 关系 $\\varphi(n)$ $n$ 是素数 $p_1$ $n-1$ $n=p_1\\times i$，且 $p_1\\nmid i$ $\\varphi(p_1)\\times \\varphi(i)=(p_1-1)\\times \\varphi(i)$ $n=p_1\\times i$，且 $p_1\\mid i$ $\\varphi(p_1^k)\\times\\varphi(j)=p_1\\times \\varphi(i)$ Sample-Code 12345678phi[1] = 1;for (int i = 2; i &lt;= n; ++i) { if (!phi[i]) prime[++tot] = i, phi[i] = i - 1; for (int j = 1; j &lt;= tot; ++j) { if (prime[j] &gt; mindiv[i] || prime[j] * i &gt; n) break; phi[prime[j] * i] = phi[i] * ((i % prime[j]) ? prime[j] - 1 : prime[j]); }} 关于 $\\sigma_k$约束幂和函数 $\\sigma_k$ 是积性函数，定义为$$\\sigma_k(n)=\\sum_{d|n}d^k$$也就是说，$\\sigma_k$ 是一个函数族，代表 $n$ 的约数的 $k$ 次幂和。 下面我们从简到难介绍 $\\sigma_k$ 的求法。 线性筛 $\\tau$约数个数函数 $\\tau=\\sigma_0$ 是积性函数，即约束的 $0$ 次幂和，定义为$$\\tau(n)=\\sigma_0(n)=\\sum [d | n]$$利用多集合的计数思路，对于 $n$ 的标准分解，有$$\\tau(n)=\\sigma_0(n)=\\prod_{i=1}^m (k_i+1)$$ 同样直接分类讨论即可，但注意维护 $g(n)$ 和计算 $\\tau(p^k)$ 的位置。 $n$ 与 $p_1$ 关系 $\\tau(n)$ $n$ 是素数 $p_1$ $2$ $n=p_1\\times i$，且 $p_1\\nmid i$ $\\tau(p_1)\\times \\tau(i)=2\\tau(i)$ $n=p_1\\times i$，且 $p_1\\mid i$ $\\tau(p_1^k)\\times\\tau(j)$ Sample-Code 123456789101112131415161718192021g[1] = tau[1] = 1;for (int i = 2; i &lt;= n; ++i) { if (!mindiv[i]) { g[i] = i; tau[i] = 2; prime[++tot] = mindiv[i] = i; } for (int j = 1, temp; j &lt;= tot; ++j) { temp = prime[j] * i; if (prime[j] &gt; mindiv[i] || temp &gt; n) break; if (prime[j] == mindiv[i]) { g[temp] = g[i] * prime[j]; if (g[temp] == temp) tau[temp] = tau[g[i]] + 1; else tau[temp] = tau[g[temp]] * tau[i / g[i]]; continue; } g[temp] = prime[j]; mindiv[temp] = prime[j]; tau[temp] = 2 * tau[i]; }} 线性筛 $\\sigma$约数和函数 $\\sigma=\\sigma_1$ 是积性函数，即约束的 $1$ 次幂和，定义为$$\\sigma(n)=\\sigma_1(n)=\\sum_{d|n} d$$利用多集合的计数思路，对于 $n$ 的标准分解，有$$\\sigma(n)=\\sigma_1(n)=\\prod_{i=1}^m \\sum_{j=0}^{k_i} p_i^j$$ 同样直接分类讨论即可，注意维护 $g(n),k(n)$ 和计算 $\\sigma(p^k)$ 的位置 。 由于计算 $\\sigma(p^k)$ 单次复杂度为 $O(\\log k)$，总复杂度依然保持线性。 $n$ 与 $p_1$ 关系 $\\sigma(n)$ $n$ 是素数 $p_1$ $p_1+1$ $n=p_1\\times i$，且 $p_1\\nmid i$ $\\sigma(p_1)\\times \\sigma(i)=(p_1+1)\\times \\sigma(i)$ $n=p_1\\times i$，且 $p_1\\mid i$ $\\sigma(p_1^k)\\times\\sigma(j)$ Sample-Code 123456789101112131415161718192021222324g[1] = k[1] = sigma[1] = 1;for (int i = 2; i &lt;= n; ++i) { if (!mindiv[i]) { g[i] = i; k[i] = 1; sigma[i] = i + 1; prime[++tot] = mindiv[i] = i; } for (int j = 1, temp; j &lt;= tot; ++j) { temp = prime[j] * i; if (prime[j] &gt; mindiv[i] || temp &gt; n) break; if (prime[j] == mindiv[i]) { k[temp] = k[i] + 1; g[temp] = g[i] * prime[j]; if (g[temp] == temp) sigma[temp] = sigma[g[i]] + fpow(prime[j], k[i]); else sigma[temp] = sigma[g[temp]] * sigma[i / g[i]]; continue; } g[temp] = prime[j]; k[temp] = 1; mindiv[temp] = prime[j]; sigma[temp] = (prime[j] + 1) * sigma[i]; }} 线性筛 $\\sigma_k$约数幂和函数 $\\sigma_k$ 是积性函数，即约束的 $k$ 次幂和，定义为$$\\sigma_k(n)=\\sum_{d|n} d^k$$为避免重复，用大写 $K$ 表示所求幂次。 同样直接分类讨论即可，注意维护 $g(n),k(n)$ 和计算 $\\sigma_k(p^k)$ 的位置 。 此时计算 $\\sigma_k(p^k)$ 单次复杂度为 $\\mathcal O(\\log (k\\times K))$，总复杂度不再保持线性。 $n$ 与 $p_1$ 关系 $\\sigma_k(n)$ $n$ 是素数 $p_1$ $p_1^{K}+1$ $n=p_1\\times i$，且 $p_1\\nmid i$ $\\sigma(p_1)\\times \\sigma(i)$ $n=p_1\\times i$，且 $p_1\\mid i$ $\\sigma(p_1^k)\\times\\sigma(j)$ Sample-Code 123456789101112131415161718192021222324g[1] = k[1] = sigma[1] = 1;for (int i = 2; i &lt;= n; ++i) { if (!mindiv[i]) { g[i] = i; k[i] = 1; sigma[i] = fpow(i, K) + 1; prime[++tot] = mindiv[i] = i; } for (int j = 1, temp; j &lt;= tot; ++j) { temp = prime[j] * i; if (prime[j] &gt; mindiv[i] || temp &gt; n) break; if (prime[j] == mindiv[i]) { k[temp] = k[i] + 1; g[temp] = g[i] * prime[j]; if (g[temp] == temp) sigma[temp] = sigma[g[i]] + fpow(prime[j], k[i] * K); else sigma[temp] = sigma[g[temp]] * sigma[i / g[i]]; continue; } g[temp] = prime[j]; k[temp] = 1; mindiv[temp] = prime[j]; sigma[temp] = sigma[prime[j]] * sigma[i]; }} 优化当 $K$ 很大的时候显然会超时，例如计算 $n=K=10^7$ 时，可以考虑打表。 找到 $p_i,k_i$ 可能的最大值，得到 $p\\le 4\\times 10^3,k_i\\le 25$，直接记忆化省掉快速幂。 Sample-Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e7 + 10, p = 1000000007;// c[N] 即文中 k[N]int n, k, pri[N], tot, c[N], mn[N], g[N];bool vis[N];ll f[N], ans;int fpow(int a, ll b) { int r = 1; for( ; b ; b &gt;&gt;= 1, a = (ll) a * a % p) if(b &amp; 1) r = (ll) r * a % p; return r;}int val[4000][25];inline int F(int mn, int c) { if(val[mn][c] != -1) return val[mn][c]; int r = 0; for(int j = 0 ; j &lt;= c ; ++ j) r = ((ll) r + fpow(mn, (ll) j * k)) % p; return val[mn][c] = r;}int main() { memset(val, -1, sizeof val); scanf(\"%d%d\", &amp;n, &amp;k); ans = f[1] = 1; for(int i = 2 ; i &lt;= n ; ++ i) { if(!vis[i]) pri[++ tot] = i, f[i] = 1 + fpow(i, k), g[i] = i, c[i] = 1, mn[i] = i; for(int j = 1 ; j &lt;= tot &amp;&amp; (ll) i * pri[j] &lt;= n ; ++ j) { int x = i * pri[j]; vis[x] = 1; if(i % pri[j] == 0) { f[x] = f[i / g[i]] * F(mn[i], c[i] + 1) % p; g[x] = g[i] * pri[j]; c[x] = c[i] + 1; mn[x] = pri[j]; break; } else f[x] = f[i] * f[pri[j]] % p, g[x] = pri[j], c[x] = 1, mn[x] = pri[j]; } ans = (ans + f[i]) % p; } printf(\"%lld\\n\", ans);} 例题对于一些未定义积性函数，线性筛的应用。 [2018 南京网络预赛] Sum定义 $f(x)$ 为满足以下条件的有序二元组 $(a,b)$ 的方案数 $x = a\\times b$ $a$ 和 $b$ 均无平方因子 ( $\\mu(a)\\neq 0,\\mu(b)\\neq 0$ ) 求 $\\sum_{i=1}^n f(i)$，数据范围 $n\\le 2\\times 10^7$ Solution 显然 $f(x)=\\sum_{d|x} abs(\\mu(d)\\mu(\\frac nd))$，是积性函数（相当于是重定义让 $\\mu\\ge 0$， $\\mu*\\mu$ ）。 $n$ 与 $p_1$ 关系 $f(n)$ $n$ 是素数 $p_1$ $2$ $n=p_1\\times i$，且 $p_1\\nmid i$ $f(p_1)\\times f(i)=2f(i)$ 对于 $n=p_1\\times i$，且 $p_1\\mid i$ 的情况，讨论： 若 $p_1 | \\frac i{p_1}$ 即 $p_1 | \\frac{n}{p_1^2}$ 时， $n$ 中 $p_1$ 的指数至少为 $3$ ，无论如何划分 $(a,b)$，都有一个 $\\mu = 0$ ， $f(n) = 0$ 否则 $p_1$ 的指数为 $2$ ， 产生贡献必须把 $p_1$ 分给 $a$ 和 $b$ 各一个，即方案数 $f(n) = f(\\frac{n}{p_1^2})$ 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;#define N 20000007llusing namespace std;inline int rd() { int x = 0; char c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) { x = x * 10 + (c ^ 48); c = getchar(); } return x;}bool vis[N];int tot, f[N], prm[N];inline void init() { f[1] = 1; for (int i = 2; i &lt; N; ++i) { if (!vis[i]) prm[++tot] = i, f[i] = 2; for (int j = 1; j &lt;= tot; ++j) { if (1ll * i * prm[j] &gt;= N) break; vis[i * prm[j]] = 1; if (i % prm[j] == 0) { f[i * prm[j]] = ((i / prm[j]) % prm[j]) ? f[i / prm[j]] : 0; break; } f[i * prm[j]] = f[i] &lt;&lt; 1; } } for (int i = 1; i &lt; N; ++i) f[i] += f[i - 1];}int main() { init(); int t = rd(); while (t--) printf(\"%d\\n\", f[rd()]); return 0;} (还有一种做法即 $f=\\mu^2 *\\mu^2$ ，反演即可，查询单次 $\\mathcal O(\\sqrt n)$ ，参考这里)","link":"/2020/07/23/linear-sieve/"},{"title":"Render Math Equations in Hexo","text":"$$f(a) = \\frac{1}{2\\pi i}\\oint_{\\gamma}\\frac{f(z)}{z-a}dz$$ Beautiful and accessible math in all browsers - MathJax This post is used to check out whether the mathjax plugin (hexo-math) still works. Inline FormulaConsider the sequence of $n$ distinct positive integers: $c_1, c_2, \\cdots, c_n$. The child calls a vertex-weighted rooted binary tree good if and only if for every vertex $v$, the weight of $v$ is in the set ${c_1, c_2, \\cdots, c_n}$ . Also our child thinks that the weight of a vertex-weighted tree is the sum of all vertices’ weights. Given an integer $m$, can you for all $s (1 \\le s ≤ m) $ calculate the number of good vertex-weighted rooted binary trees with weight $s$ ? Please, check the samples for better understanding what trees are considered different. We only want to know the answer modulo $998244353$ ( $7 × 17 × 2^{23} + 1$ , a prime number). Block Formula$$\\int \\frac{dx}{cos^2x}=\\int sec^2xdx=tan x+C\\$$ $$\\int \\frac{dx}{sin^2x}=\\int csc^2xdx=-cot x+C\\$$ $$\\sum\\limits_{i = 0}^{E} w[i]{M \\choose i} {N \\choose iS} \\frac{(iS)!}{(S!)^{i}} \\sum\\limits_{j = 0}^{E - i} (-1)^{j} {M - i \\choose j} {N - iS \\choose jS} \\frac{(jS)!}{(S!)^{j}} (M - i - j)^{N - iS - jS}$$ $$= \\sum\\limits_{i = 0}^{E} w[i]{M \\choose i} {N \\choose iS} \\frac{(iS)!}{(S!)^{i}} \\sum\\limits_{j = i}^{E} (-1)^{j - i} {M - i \\choose j - i} {N - iS \\choose jS - iS} \\frac{(jS - iS)!}{(S!)^{j - i}} (M - j)^{N - jS}$$ Matrix$$\\begin{bmatrix}(\\omega_n^0)^0 &amp; (\\omega_n^0)^1 &amp; \\cdots &amp; (\\omega_n^0)^{n-1}\\\\ (\\omega_n^1)^0 &amp; (\\omega_n^1)^1 &amp; \\cdots &amp; (\\omega_n^1)^{n-1}\\\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\(\\omega_n^{n-1})^0 &amp; (\\omega_n^{n-1})^1 &amp; \\cdots &amp; (\\omega_n^{n-1})^{n-1}\\end{bmatrix}\\begin{bmatrix}a_0 \\\\a_1 \\\\\\vdots \\\\a_{n-1}\\end{bmatrix}=\\begin{bmatrix}A(\\omega_n^0) \\\\A(\\omega_n^1) \\\\\\vdots \\\\A(\\omega_n^{n-1})\\end{bmatrix}$$ $$\\begin{bmatrix}a_0 \\\\a_1 \\\\\\vdots \\\\a_{n-1}\\end{bmatrix}=\\frac{1}{n}\\begin{bmatrix}(\\omega_n^{-0})^0 &amp; (\\omega_n^{-0})^1 &amp; \\cdots &amp; (\\omega_n^{-0})^{n-1} \\\\(\\omega_n^{-1})^0 &amp; (\\omega_n^{-1})^1 &amp; \\cdots &amp; (\\omega_n^{-1})^{n-1} \\\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\(\\omega_n^{-(n-1)})^0 &amp; (\\omega_n^{-(n-1)})^1 &amp; \\cdots &amp; (\\omega_n^{-(n-1)})^{n-1}\\end{bmatrix}\\begin{bmatrix}A(\\omega_n^0) \\\\A(\\omega_n^1) \\\\\\vdots \\\\A(\\omega_n^{n-1})\\end{bmatrix}$$ To prevent escaping, you need to use \\\\\\\\ to make a new line rather than \\\\ . For more about the Mathjax symbols, refer to The Comprehensive LaTeX Symbol List .","link":"/2019/06/01/mathjax/"}],"tags":[{"name":"Blog","slug":"Blog","link":"/tags/Blog/"},{"name":"线性筛","slug":"线性筛","link":"/tags/%E7%BA%BF%E6%80%A7%E7%AD%9B/"}],"categories":[{"name":"life","slug":"life","link":"/categories/life/"},{"name":"Blog","slug":"Blog","link":"/categories/Blog/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"}]}