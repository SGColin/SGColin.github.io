{"meta":{"title":"Colin's Space","subtitle":"God helps those who help themselves.","description":null,"author":"Colin Gao","url":"http://blog.gyx.me","root":"/"},"pages":[{"title":"","date":"2022-04-13T03:56:52.822Z","updated":"2021-08-07T16:14:11.574Z","comments":false,"path":"about/index.html","permalink":"http://blog.gyx.me/about/index.html","excerpt":"","text":""}],"posts":[{"title":"AtCoder Regular Contest 061","slug":"ARC061","date":"2022-07-01T09:20:14.000Z","updated":"2022-07-01T11:21:28.584Z","comments":true,"path":"2022/07/01/ARC061/","link":"","permalink":"http://blog.gyx.me/2022/07/01/ARC061/","excerpt":"","text":"C - Many Formulas 给定一个数字串，可以在任意位置添加加号，问所有表达式结果的和是多少。 考虑一个前缀后面补一个新的数字： + 如果断开，那么前缀的贡献是前面的结果 + 如果不断开，那么前缀的贡献是前面除去最后一段 + 最后一段 \\(\\times 10\\) + 最后一个数字的贡献就是数值 \\(\\times 2^{len}\\) ，即可能的划分方案数 记 \\(f_i\\) 表示前缀 \\(i\\) 的答案，\\(g_i\\) 表示前缀 \\(i\\) 最后一段的答案，有： \\[ \\begin{array}{l} f_i &amp;= 2^i * digit_i + f_{i-1} + (f_{i-1} - g_{i-1}) + g_{i-1} \\times 10\\\\ g_i &amp;= 2^i * digit_i + g_{i-1} \\times 10 \\end{array} \\] 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt; using namespace std; using ll = long long; inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x; &#125; char s[11]; ll f[11], g[11]; int main() &#123; scanf(&quot;%s&quot;, s + 1); int len = strlen(s + 1); for (int i = 1, pw = 1; i &lt;= len; ++i, pw = pw * 2) &#123; f[i] = pw * (s[i] - &#x27;0&#x27;) + f[i - 1] * 2 + g[i - 1] * 9; g[i] = pw * (s[i] - &#x27;0&#x27;) + g[i - 1] * 10; &#125; printf(&quot;%lld\\n&quot;, f[len]); return 0; &#125; D - Snuke's Coloring 给定一个 \\(H\\times W\\) 的网格，初始所有位置都是白色，然后给定 \\(n\\) 个点染成黑色。 问所有的九宫格里，黑色点数为 \\(0\\dots 9\\) 的九宫格分别有多少个。 初始所有的九宫格都是白色，然后每次加入一个点模拟一下即可。 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt; using namespace std; using ll = long long; inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x; &#125; unordered_map&lt;ll, bool&gt; vis; inline ll pos(int x, int y) &#123;return 1ll * x * 1000000000 + y;&#125; ll ans[10]; int main() &#123; int h = rd(), w = rd(); ans[0] = 1ll * (h - 2) * (w - 2); for (int n = rd(); n; --n) &#123; int x = rd(), y = rd(); for (int a = max(1, x - 2); a &lt;= min(x, h - 2); ++a) for (int b = max(1, y - 2); b &lt;= min(y, w - 2); ++b) &#123; int cnt = 0; for (int dx = 0; dx &lt; 3; ++dx) for (int dy = 0; dy &lt; 3; ++dy) cnt += vis[pos(a + dx, b + dy)]; --ans[cnt]; ++ans[cnt + 1]; &#125; vis[pos(x, y)] = 1; &#125; for (int i = 0; i &lt; 10; ++i) printf(&quot;%lld\\n&quot;, ans[i]); return 0; &#125; E - Snuke's Subway Trip \\(n\\) 个点 \\(m\\) 条边的无向图，每个边有一个颜色。 一个路径的初始代价是 \\(1\\) ，每换一次颜色代价 \\(+1\\) ，求 \\(1\\) 到 \\(n\\) 的最短路。 考虑直接建分层图（每个点的实点建立 \\(m\\) 个虚点，虚点间连原图的边）。 真实的点向对应的虚点连边权为 \\(1\\) ，虚点之间连原图的边边权为 \\(0\\) ，最终答案除 \\(2\\) 即可。 可以发现有用的点其实只有 \\(\\mathcal{O}(n+m)\\) ，因此可以直接建图做（用一个 unordered_map ）。 然后在图上跑 01-BFS 即可，复杂度 \\(\\mathcal{O}(n+m)\\) 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt; using namespace std; using ll = long long; inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x; &#125; #define N 500007 #define M 2000007 unordered_map&lt;int, int&gt; id[N]; int tot, hd[N]; struct node&#123;int to, nxt; bool w;&#125; e[M]; inline void add(int u, int v, bool w) &#123; e[++tot].to = v; e[tot].w = w; e[tot].nxt = hd[u]; hd[u] = tot; e[++tot].to = u; e[tot].w = w; e[tot].nxt = hd[v]; hd[v] = tot; &#125; int dis[N]; bool vis[N]; deque&lt;int&gt; q; int main() &#123; int n = rd(), m = rd(); int totn = n; for (int i = 1; i &lt;= m; ++i) &#123; int u = rd(), v = rd(), c = rd(); if (!id[u][c]) &#123;id[u][c] = ++totn; add(u, totn, 1);&#125; if (!id[v][c]) &#123;id[v][c] = ++totn; add(v, totn, 1);&#125; add(id[u][c], id[v][c], 0); &#125; memset(dis, 0x3f, sizeof(dis)); dis[1] = 0; q.push_back(1); while (!q.empty()) &#123; int u = q.front(); q.pop_front(); if (vis[u]) continue; vis[u] = 1; for (int i = hd[u], v; i; i = e[i].nxt) &#123; if (dis[u] + e[i].w &lt; dis[v = e[i].to]) &#123; dis[v] = dis[u] + e[i].w; e[i].w ? q.push_back(v) : q.push_front(v); &#125; &#125; &#125; printf(&quot;%d\\n&quot;, dis[n] == dis[0] ? -1 : dis[n] / 2); return 0; &#125; F - Card Game for Three 三个人 A,B,C ，每个人分别有 \\(n,m,k\\) 张卡，每张卡的卡面都可能是 A/B/C 之一。 从 A 开始翻牌，每次翻到的牌子上写的是谁，下一个翻牌的就是谁。 轮到某个人时，如果他没有牌了就胜利，问总共 \\(3^{n+m+k}\\) 种方案中，A 胜利的方案数有多少。 这道题目的出发点完全想错了，不能将三个人分开想，因为有可能会有 A - B - C - A 循环。 考虑将整个操作序列连起来（长度 \\(n+m+k\\) ），每个操作序列一定对应于一种牌序。 那么也就是要求：某个前缀有 \\(n\\) 个 A ，且这段前缀内 B, C 的数量对应不超过 \\(m,k\\) 。 前一个条件避免数重，强制最后一个是 A 即可。 后一个条件考虑容斥做，由于长度限制容易发现两个反例只会出现一个： \\[ \\begin{array}{l} ans &amp;= \\displaystyle \\sum_{len=n}^{n+m+k} {len - 1\\choose n - 1}\\bigg({2^{len - n} - \\sum_{a = m+1}^{len - n}{len - n\\choose a}-\\sum_{b=k+1}^{len - n}{len - n\\choose b}}\\bigg)3^{n+m+k-len} \\end{array} \\] 设 \\(f_x=\\sum_{i=m}^x{x\\choose i}\\) ，然后用组合数定义优化这个东西： \\[ f_x = \\sum_{i=m}^x{x\\choose i} = \\sum_{i=m}^x \\bigg({x-1\\choose i}+{x-1\\choose i - 1}\\bigg) = 2f_{x-1} + {x - 1\\choose m - 1} \\] 就变成 \\(\\mathcal{O}(n+m+k)\\) 的了。。。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt; using namespace std; using ll = long long; inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x; &#125; #define N 1000007 #define mod 1000000007 namespace Comb &#123; int fac[N], ifac[N]; inline int fpow(int x, int t) &#123; int res = 1; for (; t; t &gt;&gt;= 1, x = 1ll * x * x % mod) if (t &amp; 1) res = 1ll * res * x % mod; return res; &#125; inline void init() &#123; fac[0] = ifac[0] = 1; for (int i = 1; i &lt; N; ++i) fac[i] = 1ll * fac[i - 1] * i % mod; ifac[N - 1] = fpow(fac[N - 1], mod - 2); for (int i = N - 2; i; --i) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % mod; &#125; inline ll C(int n, int m) &#123; if (n &lt; m) return 0; return 1ll * fac[n] * ifac[m] % mod * ifac[n - m] % mod; &#125; &#125; using namespace Comb; ll pw2[N] = &#123;1&#125;, pw3[N] = &#123;1&#125;, f1[N], f2[N]; int main() &#123; init(); ll ans = 0; int n = rd(), m = rd(), k = rd(); for (int i = 1; i &lt; N; ++i) &#123; pw2[i] = (pw2[i - 1] &lt;&lt; 1) % mod; pw3[i] = pw3[i - 1] * 3 % mod; f1[i] = (2 * f1[i - 1] + C(i - 1, m)) % mod; f2[i] = (2 * f2[i - 1] + C(i - 1, k)) % mod; &#125; for (int l = n; l &lt;= n + m + k; ++l) &#123; ll w = ((pw2[l - n] - f1[l - n] - f2[l - n]) % mod + mod) % mod; ans = (ans + C(l - 1, n - 1) * w % mod * pw3[n + m + k - l]) % mod; &#125; printf(&quot;%lld\\n&quot;, ans); return 0; &#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"http://blog.gyx.me/categories/Solution/"},{"name":"AtCoder","slug":"Solution/AtCoder","permalink":"http://blog.gyx.me/categories/Solution/AtCoder/"},{"name":"AtCoder Regular Contest","slug":"Solution/AtCoder/AtCoder-Regular-Contest","permalink":"http://blog.gyx.me/categories/Solution/AtCoder/AtCoder-Regular-Contest/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"},{"name":"STL","slug":"STL","permalink":"http://blog.gyx.me/tags/STL/"},{"name":"01-BFS","slug":"01-BFS","permalink":"http://blog.gyx.me/tags/01-BFS/"},{"name":"Combinatorics","slug":"Combinatorics","permalink":"http://blog.gyx.me/tags/Combinatorics/"}]},{"title":"AtCoder Regular Contest 060","slug":"ARC060","date":"2022-06-30T09:20:14.000Z","updated":"2022-07-01T11:15:47.802Z","comments":true,"path":"2022/06/30/ARC060/","link":"","permalink":"http://blog.gyx.me/2022/06/30/ARC060/","excerpt":"","text":"C - Tak and Cards 给定 \\(n\\) 个有序数字，求有多少个下标集，对应的数字平均数是 \\(A\\) 数据范围很小，用背包计数就好了，注意枚举的上下界。 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 57#define M 5007#define B 2500ll f[N][M];int main() &#123; int n = rd(), A = rd(); f[0][B] = 1; for (int i = 1; i &lt;= n; ++i) &#123; int w = rd() - A; for (int v = max(-B, -B + w); v &lt;= min(B, B + w); ++v) f[i][v + B] = f[i - 1][v + B] + f[i - 1][v - w + B]; &#125; printf(&quot;%lld\\n&quot;, f[n][B] - 1); return 0;&#125; # D - Digit Sum &gt; 给定两个数字 \\(n\\ (n\\le 10^{11})\\) 和 \\(s\\) ，求最小的进制 \\(b\\) ，使得 \\(n\\) 在 \\(b\\) 进制下的数位和等于 \\(s\\) 。 一道典型的根号讨论题目。 当 \\(b\\le \\sqrt{n}\\) 时，直接暴力验证。 当 \\(b\\ge \\sqrt{n}\\) 时，数字最多是两位数，可以写成 \\(n=pb+q,s=p+q\\) ，联立得 \\(n-s=p(b-1)\\) 注意后一种情况判断要求：\\(b\\ge \\sqrt{n},\\ 0\\le q&lt; b\\) 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt; using namespace std; using ll = long long; inline ll calc(ll n, ll b) &#123; ll ans = 0; for (; n; ans += n % b, n /= b); return ans; &#125; int main() &#123; ll n, s; cin &gt;&gt; n &gt;&gt; s; if (n &lt; s) &#123;puts(&quot;-1&quot;); return 0;&#125; if (n == s) &#123;printf(&quot;%lld\\n&quot;, n + 1); return 0;&#125; ll lim = sqrt(n); for (ll i = 2; i &lt;= lim; ++i) if (calc(n, i) == s) &#123;printf(&quot;%lld\\n&quot;, i); return 0;&#125; n -= s; ll ans = 1e18; for (ll i = sqrt(n); i &gt;= 1; --i) if (n % i == 0) &#123; if (i &gt;= lim &amp;&amp; s - n / i &lt; i + 1 &amp;&amp; s &gt;= n / i) ans = min(ans, i + 1); if (n / i &gt;= lim &amp;&amp; s - i &lt; n / i + 1 &amp;&amp; s &gt;= i) ans = min(ans, n / i + 1); &#125; printf(&quot;%lld\\n&quot;, ans == 1e18 ? -1 : ans); return 0; &#125; E - Tak and Hotels 给定数轴上的 \\(n\\) 个点，每次查询两个点 \\(a,b\\) ： 问从 \\(a\\) 到 \\(b\\) ，在给定的点之间跳跃，每次距离不超过 \\(L\\) ，最少多少次。 考虑倍增，设 \\(mx_{i,j}\\) 表示从 \\(i\\) 向右跳 \\(2^j\\) 步，最多能跳到哪里，组合的时候记得判一下最后一步即可。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt; using namespace std; using ll = long long; inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x; &#125; #define N 100007 int r[N][18], x[N]; int main() &#123; int n = rd(); int t = log2(n) + 1; for (int i = 1; i &lt;= n; ++i) x[i] = rd(); int l = rd(), q = rd(); for (int i = 1, rpos = 1; i &lt;= n; ++i) &#123; while (rpos &lt; n &amp;&amp; x[rpos + 1] - x[i] &lt;= l) ++rpos; r[i][0] = rpos; &#125; for (int i = 1; i &lt;= t; ++i) for (int l = 1; l &lt;= n; ++l) r[l][i] = r[r[l][i - 1]][i - 1]; for (; q; --q) &#123; int a = rd(), b = rd(); if (a &gt; b) swap(a, b); int ans = 0; for (int i = t; ~i; --i) if (r[a][i] &lt; b) &#123; ans += (1 &lt;&lt; i); a = r[a][i]; &#125; printf(&quot;%d\\n&quot;, ans + 1); &#125; return 0; &#125; F - Best Representation 定义无循环节（完整补齐）的字符串是好的。 定义将一个串划分为若干好的字符串，这个划分是好的。 定义一个划分是最优的，当且仅当划分是好的并且划分的子串数最少。 给定串 \\(S\\ (|S|\\le 5\\times 10^5)\\) 求最优划分所需的子串数和最优划分个数。 如果 \\(S\\) 自己本身无循环节，两个答案都是 \\(1\\) 如果 \\(S\\) 所有字母都相同，第一个答案是 \\(n\\) ，第二个是 \\(1\\) 如果 \\(S\\) 有循环节且所有字母都不同，第一个答案是 \\(2\\) （在任意循环节中间切开） 对于第三种情况枚举分割点计数，需要快速判断一个前缀/后缀有无循环节。 对正反两个串都做一下 kmp 就可以了，若 \\((n-nxt[n])\\ |\\ n\\) 则有循环节。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;#define N 500007char s[N];int nxt[N], nxtr[N];inline bool pre(int x) &#123; return (nxt[x] == 0) || (x % (x - nxt[x]) &gt; 0);&#125;inline bool suf(int x) &#123; return (nxtr[x] == 0) || (x % (x - nxtr[x]) &gt; 0);&#125;int main() &#123; scanf(&quot;%s&quot;, s + 1); int len = strlen(s + 1); bool fl = 0; for (int i = 2, pos; i &lt;= len; ++i) &#123; if (s[i] != s[i - 1]) fl = 1; pos = nxt[i - 1]; while (pos &amp;&amp; s[pos + 1] != s[i]) pos = nxt[pos]; if (pos != 0) nxt[i] = pos + 1; else nxt[i] = (s[1] == s[i]); &#125; if (!fl) &#123;printf(&quot;%d\\n1\\n&quot;, len); return 0;&#125; if (pre(len)) &#123;puts(&quot;1\\n1&quot;); return 0;&#125; puts(&quot;2&quot;); reverse(s + 1, s + 1 + len); for (int i = 2, pos; i &lt;= len; ++i) &#123; pos = nxtr[i - 1]; while (pos &amp;&amp; s[pos + 1] != s[i]) pos = nxtr[pos]; if (pos != 0) nxtr[i] = pos + 1; else nxtr[i] = (s[1] == s[i]); &#125; int ans = 0; for (int i = 1; i &lt; len; ++i) if (pre(i) &amp;&amp; suf(len - i)) ++ans; printf(&quot;%d\\n&quot;, ans); return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"http://blog.gyx.me/categories/Solution/"},{"name":"AtCoder","slug":"Solution/AtCoder","permalink":"http://blog.gyx.me/categories/Solution/AtCoder/"},{"name":"AtCoder Regular Contest","slug":"Solution/AtCoder/AtCoder-Regular-Contest","permalink":"http://blog.gyx.me/categories/Solution/AtCoder/AtCoder-Regular-Contest/"}],"tags":[{"name":"Knapsack Problem","slug":"Knapsack-Problem","permalink":"http://blog.gyx.me/tags/Knapsack-Problem/"},{"name":"Threshold Optimization","slug":"Threshold-Optimization","permalink":"http://blog.gyx.me/tags/Threshold-Optimization/"},{"name":"Binary Lifting","slug":"Binary-Lifting","permalink":"http://blog.gyx.me/tags/Binary-Lifting/"},{"name":"Greedy","slug":"Greedy","permalink":"http://blog.gyx.me/tags/Greedy/"},{"name":"KMP","slug":"KMP","permalink":"http://blog.gyx.me/tags/KMP/"}]},{"title":"A Little Charity Guarantees Almost Envy-Freeness","slug":"Almost-EFX","date":"2022-06-24T07:35:18.000Z","updated":"2022-06-01T02:39:20.603Z","comments":true,"path":"2022/06/24/Almost-EFX/","link":"","permalink":"http://blog.gyx.me/2022/06/24/Almost-EFX/","excerpt":"","text":"原文地址：arXiv : [1907.04596] 收录于 SODA 2020 的一篇论文，关于不可分割物体的公平分配。 问题模型 \\(m\\) 个商品（全集 \\(\\mathbf{M}\\) ）分配给 \\(n\\) 个竞争者，也就是求集合 \\(\\mathbf M\\) 的一个划分 \\(\\\\{ \\mathbf{X_1},\\mathbf{X_2},\\dots \\mathbf{X_n} \\\\}\\) ，尽可能公平。 最一般的问题模型，每个人 \\(i\\) 对于每个物品集合 \\(S\\subseteq T\\) 都有一个价值函数 \\(v_i(S):2^{\\mathbf{M}}\\to \\mathbb{R}_{\\ge 0}\\) Envy - Free ：没有人嫉妒他人，即在任何人眼中，别人获得的商品价值都不比自己高，即 \\(\\forall j\\ne i, v_i(\\mathbf{X_i})\\ge v_i(\\mathbf{X_j})\\) 然而很容易证明 Envy - Free 的分配不一定存在，比如考虑两个人分一个物品，且两人都认为物品有价值。 EF1 (envy - free up to one good) ：如果 \\(i\\) 嫉妒 \\(j\\) ，即 \\(v_i(\\mathbf{X_i})&lt;v_i(\\mathbf{X_j})\\) ，存在 \\(g\\in \\mathbf{X_j}\\) ，使 \\(v_i(\\mathbf{X_i})\\ge v_i(\\mathbf{X_j}\\setminus g)\\) 前人的工作已经证明 EF1 的分配一定存在，并且有快速计算的算法[1]。 抱歉，这篇文章要等到期末后再更新了～","categories":[{"name":"Summary","slug":"Summary","permalink":"http://blog.gyx.me/categories/Summary/"},{"name":"Paper Notes","slug":"Summary/Paper-Notes","permalink":"http://blog.gyx.me/categories/Summary/Paper-Notes/"}],"tags":[{"name":"Game Theory","slug":"Game-Theory","permalink":"http://blog.gyx.me/tags/Game-Theory/"}]},{"title":"Connectivity : From DFS to Dominator Tree","slug":"connectivity","date":"2022-06-01T02:54:59.000Z","updated":"2022-06-01T03:48:31.506Z","comments":true,"path":"2022/06/01/connectivity/","link":"","permalink":"http://blog.gyx.me/2022/06/01/connectivity/","excerpt":"","text":"「 连通性：从深度优先搜索到支配树 」探讨一些关于连通性的算法。","categories":[{"name":"Summary","slug":"Summary","permalink":"http://blog.gyx.me/categories/Summary/"},{"name":"Algorithms","slug":"Summary/Algorithms","permalink":"http://blog.gyx.me/categories/Summary/Algorithms/"}],"tags":[{"name":"DFS and Similar","slug":"DFS-and-Similar","permalink":"http://blog.gyx.me/tags/DFS-and-Similar/"},{"name":"Graphs","slug":"Graphs","permalink":"http://blog.gyx.me/tags/Graphs/"}]},{"title":"AtCoder Beginner Contest 253","slug":"abc253","date":"2022-05-29T00:38:14.000Z","updated":"2022-06-01T02:38:12.695Z","comments":true,"path":"2022/05/29/abc253/","link":"","permalink":"http://blog.gyx.me/2022/05/29/abc253/","excerpt":"","text":"A, B 比较简单就不写了。 我的代码 : All Submissions - SGColin C. Max - Min Query 维护一个 multiset ，支持插入一个 \\(x\\) ，删除 \\(\\min(c_i,s.count(x))\\) 个 \\(x\\) ，查询最大值-最小值。 开始想想直接模拟复杂度是对的就写了 multiset，没想到 multiset 的 lower_bound 太慢了 T 了几个点。 Upd : 经提醒应该是 count 函数太慢了，官网描述是 \"Logarithmic in size and linear in the number of matches\" ，也就是说复杂度是 \\(\\mathcal{O}(k+\\log n)\\) ，其中 \\(k\\) 是查询数字的出现次数，所以加入 \\(10^5\\) 个点之后，多查几次就超时了。 所以改为用 map 维护一个计数器，每次某个数字新出现/消失的时候再对 set 操作。 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;map&lt;int, int&gt; cnt;set&lt;int&gt; s;int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; int op = rd(); if (op == 1) &#123; int x = rd(); ++cnt[x]; if (cnt[x] == 1) s.insert(x); &#125; else if (op == 2) &#123; int x = rd(); int t = min(rd(), cnt[x]); cnt[x] -= t; if (cnt[x] == 0) s.erase(x); &#125; else printf(&quot;%d\\n&quot;, (*--s.end()) - (*s.begin())); &#125; return 0;&#125; D. FizzBuzz Sum Hard 给定 \\(n,a,b\\) 找出 \\([1,n]\\) 内不是 \\(a\\) 或 \\(b\\) 倍数的数字的和。 简单的容斥原理，扣掉 \\(a,b\\) 的倍数，加上 \\(\\text{lcm}(a,b)\\) 的倍数。 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;int gcd(int a, int b) &#123; return b ? gcd(b, a % b) : a;&#125;int main() &#123; int n = rd(), a = rd(), b = rd(); ll sum = 1ll * n * (n + 1) / 2; int ka = n / a; int kb = n / b; sum -= 1ll * a * ka * (ka + 1) / 2; sum -= 1ll * b * kb * (kb + 1) / 2; ll lcm = 1ll * a * b / gcd(a, b); ll kl = n / lcm; sum += 1ll * lcm * kl * (kl + 1) / 2; printf(&quot;%lld\\n&quot;, sum); return 0;&#125; E. Distance Sequence 计数长度为 \\(n\\) 的序列 \\(\\{a_i\\}\\) ：(1) \\(a_i\\in[1,m]\\) ; (2) \\(\\forall i\\in[2,n], |a_i-a_{i-1}|\\ge k\\) . 直接 DP ，设 \\(f_{i,j}\\) 表示长度为 \\(i\\) 的序列，结尾是 \\(j\\) 的方案数，有： \\[ f_{i,j}=\\sum_{w\\in[1,j-k]\\cup[j+k,m]} f_{i-1,w} \\] 用一个前缀和优化即可，注意下 \\(k=0\\) 时不要算重，复杂度 \\(O(nm)\\) 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 1007#define M 5007#define mod 998244353int f[N][M], sum[N][M];inline int fpow(int x, int t) &#123; int res = 1; for (; t; t &gt;&gt;= 1, x = 1ll * x * x % mod) if (t &amp; 1) res = 1ll * res * x % mod; return res;&#125;int main() &#123; int n = rd(), m = rd(), k = rd(); if (k == 0) &#123;printf(&quot;%d\\n&quot;, fpow(m, n)); return 0;&#125; for (int i = 1; i &lt;= m; ++i) &#123; f[1][i] = 1; sum[1][i] = i; &#125; for (int i = 2; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; int l = max(0, j - k); int r = min(m, j + k - 1); f[i][j] = (sum[i - 1][m] - sum[i - 1][r] + mod) % mod; f[i][j] = (f[i][j] + sum[i - 1][l]) % mod; &#125; for (int j = 1; j &lt;= m; ++j) sum[i][j] = (sum[i][j - 1] + f[i][j]) % mod; &#125; printf(&quot;%d\\n&quot;, sum[n][m]); return 0;&#125; F. Operations on a Matrix 维护一个初始是全 \\(0\\) 的 \\(n\\times m\\ (n,m\\le 2\\ast 10^5)\\) 的矩阵，支持： 对 \\([l_i,r_i]\\) 这些列的每一个元素加 \\(x\\) 将第 \\(i\\) 行全部赋值为 \\(x\\) 查询矩阵中 \\((x_i,y_i)\\) 的值 记录每行最后一次被赋值的时间戳 \\(lst_i\\) 和赋值 \\(x_i\\) ，则答案为 \\(x_i\\) + \\([lst,now]\\) 这段操作里对 \\(y_i\\) 加的值。 在线的做法就是写一个主席树 + 标记持久化； 离线的做法就是把后面的贡献写做前缀和差分，然后两个时刻维护一下。 学到了简老师的主席树写法 OwO 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define mid ((l + r) &gt;&gt; 1)#define N 200007int tot, rttot;struct node &#123; int ls, rs; ll sum;&#125; c[N &lt;&lt; 6];int rot[N], lst[N];ll x[N];int copy(int rt) &#123; c[++tot] = c[rt]; return tot;&#125;void upd(int &amp;rt, int l, int r, int L, int R, int x) &#123; rt = copy(rt); if (L &lt;= l &amp;&amp; r &lt;= R) &#123; c[rt].sum += x; return; &#125; if (L &lt;= mid) upd(c[rt].ls, l, mid, L, R, x); if (R &gt; mid) upd(c[rt].rs, mid + 1, r, L, R, x);&#125;ll query(int rtl, int rtr, int l, int r, int p) &#123; ll res = c[rtr].sum - c[rtl].sum; if (l == r) return res; if (p &lt;= mid) res += query(c[rtl].ls, c[rtr].ls, l, mid, p); else res += query(c[rtl].rs, c[rtr].rs, mid + 1, r, p); return res;&#125;int main() &#123; int n = rd(), m = rd(), q = rd(); for (int i = 1; i &lt;= q; ++i) &#123; int op = rd(); if (op == 1) &#123; ++rttot; rot[rttot] = rot[rttot - 1]; int l = rd(), r = rd(), v = rd(); upd(rot[rttot], 1, m, l, r, v); &#125; else if (op == 2) &#123; int p = rd(); x[p] = rd(); lst[p] = rttot; &#125; else &#123; int row = rd(), col = rd(); printf(&quot;%lld\\n&quot;, x[row] + query(rot[lst[row]], rot[rttot], 1, m, col)); &#125; &#125; return 0;&#125; G. Swap Many Times 对于 \\(n\\) ，初始化一个序列 \\(a_1,\\cdots,a_n\\) ，满足 \\(a_i=i\\) 。 对于 \\(n\\) ，有 \\(\\frac{n(n+1)}{2}\\) 个形如 \\((x,y)\\) 的满足 \\(1\\le x&lt;y\\le n\\) 的数对，按照 pair 的规则排序。 给定 \\(L,R\\) ，对于这个 pair 序列的第 \\(L\\) 个到第 \\(R\\) 个，依次操作：交换 \\(a_x\\) 和 \\(a_y\\) 求最终的序列。 观察这个序列， \\(x\\) 相同的 pair 是连续出现的，考虑对于同一个 \\(x\\) 把所有操作都做掉。 假设以 \\(x\\) 为 first 的在 \\([L,R]\\) 内的操作为 \\((x,y_a),(x,y_a+1),\\cdots,(x,y_b)\\) 那么实际操作的结果就是把序列中 \\(x,y_a,y_a+1,\\cdots,y_b\\) 这些位置整体向右 shift 一个位置。 枚举 \\(x\\) ，然后只需要一个支持某个位置插入删除的数据结构就可以了。 然后昨天趁机学了一下 rope ，内核是块状链表，理论复杂度 \\(\\mathcal{O}(n\\sqrt{n})\\) ，实际表现速度很快。 只能说非常好用，可惜 Clang 编译不了，是在 Custom Test 手动调试的。 p.s. 题解的做法貌似不需要数据结构，好像很精妙 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;#include &lt;ext/rope&gt;using namespace std;using namespace __gnu_cxx;typedef long long ll;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;rope&lt;int&gt; s;int main() &#123; int n = rd(); ll L = rd(), R = rd(); ll l = 0, r = 0; for (int i = 0; i &lt;= n; ++i) s.push_back(i); for (int i = 1; i &lt;= n; ++i) &#123; l = r + 1; r = l + n - i - 1; if (L &lt;= r &amp;&amp; R &gt;= l) &#123; int ll = max(l, L), rr = min(r, R); int pl = i + 1 + ll - l; int pr = i + 1 + rr - l; int x = s[pr]; s.erase(pr, 1); s.insert(pl, s[i]); s.erase(i, 1); s.insert(i, x); &#125; &#125; for (int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, s[i]); return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"http://blog.gyx.me/categories/Solution/"},{"name":"AtCoder","slug":"Solution/AtCoder","permalink":"http://blog.gyx.me/categories/Solution/AtCoder/"},{"name":"AtCoder Beginner Contest","slug":"Solution/AtCoder/AtCoder-Beginner-Contest","permalink":"http://blog.gyx.me/categories/Solution/AtCoder/AtCoder-Beginner-Contest/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"},{"name":"STL","slug":"STL","permalink":"http://blog.gyx.me/tags/STL/"},{"name":"Persistent Data Structure","slug":"Persistent-Data-Structure","permalink":"http://blog.gyx.me/tags/Persistent-Data-Structure/"}]},{"title":"Two Identical Machines Scheduling with Agreement Graphs","slug":"machine-scheduling-with-agreement-graph","date":"2022-05-25T14:03:18.000Z","updated":"2022-06-01T03:01:36.705Z","comments":true,"path":"2022/05/25/machine-scheduling-with-agreement-graph/","link":"","permalink":"http://blog.gyx.me/2022/05/25/machine-scheduling-with-agreement-graph/","excerpt":"","text":"New results in two identical machines scheduling with agreement graphs 收录于 TCS 2019 的一篇文章，基于许可图的独立双机流水安排问题的一些新进展。 问题模型 有 \\(n\\) 个任务，第 \\(i\\) 个任务需要的时间是 \\(p_i\\) 。 一共有两台机器，每个任务都需要被连续地安排到某一个机器上完成。 将任务抽象成点，给定一个许可图，两个任务有边则可以分别在两个机器上同时执行。 求一个安排方案，最小化最后一个被做完的任务完成时间。 现有结论： 许可图是树的情况下，此问题是 NP-Hard 的 许可图是毛毛虫的情况下，存在 \\(\\mathcal{O}(n)\\) 求最优解的方法 毛毛虫 毛毛虫是一种特殊的树，由一个核心路径和若干到路径距离为 \\(1\\) 的点构成。 Notation Meaning Notation Processing time \\(p\\) Maximum weighted independent set of the agreement graph \\(G\\) \\(I_p(G)\\) Weight of \\(I_p(G)\\) (a lower bound on the optimal makespan) \\(\\overline{I_p}(G) =\\sum_{j\\in I_p(G)} p_j\\) Set of neighbors of a job \\(j\\) (generalized for a subset \\(J&#39;\\)) \\(N(j)/N(J&#39;)\\) Set of leaves connected to job \\(j\\) \\(Lv(j)\\) Starting time of a job \\(j\\) \\(t_j\\) Minimum starting time of a subset \\(J&#39;\\) \\(t_j(J&#39;)=\\min_{k\\in J&#39;}\\{t_k\\}\\) Algorithm 见原文 [4.2] Caterpillar scheduling algorithm。 Polynomiality and Optimality Proof 为了简单描述，我们称在 MWIS 里的点为黑点，其余点为白点。 可以发现断掉白点之间的所有边后，这个新的图的性质是所有的边都是黑-白边。 Claim 1. 对于每个新的连通块 \\(CAT_i\\) ，其内的黑点集 \\(S_i^*\\) 仍然是 \\(CAT_i\\) 的 MWIS 假设存在其他的 MWIS \\(I_p(CAT_i)\\) 使得 \\(\\overline{I_p}(CAT_i) &gt; \\sum_{j\\in S_i^*} p_j\\) ，那么我们考虑将 \\(CAT_i\\) 这一部分的 MWIS 换成这个新的集合，其他部分的 MWIS 不变，那么还原回仍是原图的一个 IS，而这个新的 IS 比原来的 MWIS 权值还大，所以矛盾了。 \\[ \\sum_{j \\in S^{\\prime}} p_{j}=\\overline{I_{p}}(C A T)-\\sum_{j \\in S_{i}^{*}} p_{j}+\\overline{I_{p}}\\left(C A T_{i}\\right)&gt;\\overline{I_{p}}(C A T) \\] Claim 2. 对于每个新的连通块 \\(CAT_i\\) 的点集 \\(J_i\\) ，其内任何一个白点子集的点权和不会超过其邻居黑点的点权和 假设存在这样的一个白点集 \\(W\\) 满足 \\(\\sum_{j \\in W} p_{j} &gt; \\sum_{j \\in N(W)} p_{j}\\) ，那么考虑将 \\(S_i^*\\) 换成 \\(S&#39;= (S_i^*\\setminus N(W))\\cup W\\) ，易证\\(S&#39;\\) 也是一个独立集，且比 \\(S_i^*\\) 权值和还要大，矛盾。 \\[ \\sum_{j \\in S^{\\prime}} p_{j}=\\sum_{j \\in S_{i}^{*}} p_{j}-\\sum_{j \\in N(W)} p_{j}+\\sum_{j \\in W} p_{j}&gt;\\sum_{j \\in S_{i}^{*}} p_{j} \\] Claim 3. 对于任意白点 \\(\\beta\\) ，其邻居黑点都会被连续地安排在第一个机器上 分类讨论一下，如果是叶子显然；如果不是叶子，假设链上的顺序是 \\(\\alpha-\\beta-\\gamma\\) ，那么黑点顺序显然是 \\(\\alpha-(\\beta\\) 的叶子 \\()-\\gamma\\) Claim 4. 对于任意两个白点 \\(\\alpha,\\beta\\) ，如果他们被连续地安排在了某一个机器上，那么他们一定有公共邻居。 同样分类讨论 \\(\\alpha\\) 和 \\(\\beta\\) 的位置关系（分别是主干/叶子）即可。 Claim 5. 对于任意连续安排的白点集，其邻居一定是被连续安排在一个区间内的 前两条的自然结果，当然也需要第二条辅助理解一下，证明黑色一定是连续的。 Lemma 1. 每一个白点都会被安排在邻居对应的区间里 反证法，不符合的就两种情况： \\(t_\\beta &lt; t(N(\\beta ))\\) ：这种情况不存在，因为算法中每个黑点是连续安排的，如果出现该情况，这个白点会与非邻接的黑点重合，与许可图的要求相冲突。 \\(t_\\beta+p_\\beta &gt; t(N(\\beta )) + \\sum_{j\\in N(\\beta)} p_j\\) ：这种情况不存在，考虑从 \\(\\beta\\) 往前的第一个满足 \\(t_\\alpha=t_{N(\\alpha)}\\) 的任务 \\(\\alpha\\) ，那么从 \\(\\alpha\\) 到 \\(\\beta\\) 这一段是连续安排的，由事实 \\(5\\) ，连续安排的白点集，其邻居一定是被连续安排在一个区间内的，因此白点的区间就是 \\([t_\\alpha,t_\\alpha+\\sum_{j\\in[\\alpha,\\beta]} p_j]\\) ，黑点的区间就是 \\([t(N([\\alpha,\\beta])),t(N([\\alpha,\\beta])) + \\sum_{j\\in N([\\alpha,\\beta])} p_j]\\) ; 又由事实 \\(2\\) ，对于 \\(J_i\\) 内任何一个白点子集，其点权和不会超过其邻居黑点的点权和，因此有 \\(t_\\alpha+\\sum_{j\\in[\\alpha,\\beta]} p_j \\le \\sum_{j\\in N([\\alpha,\\beta])} p_j\\) ，因此 \\([\\alpha, \\beta]\\) 这一段的白点终止时间不超过黑点，因此作为最后一个完成的白点 \\(\\beta\\) ，有 \\(t_\\beta+p_\\beta \\le t(N(\\beta )) + \\sum_{j\\in N(\\beta)} p_j\\) Theorithm 2. 本算法求出的安排方案为最优解。 由引理 \\(1\\) ，每个 \\(\\sigma_i\\) 所需要的时间就是其中黑点所需的时间，即 \\(\\overline{I_p}(CAT_i)\\) ，因此总方案 \\(\\sigma\\) 所需的时间 \\(\\sum_{i} \\overline{I_p}(CAT_i) = \\overline{I_p}(CAT)\\) ，即答案下界。 总结 最后放一个 pdf 版的总结：","categories":[{"name":"Summary","slug":"Summary","permalink":"http://blog.gyx.me/categories/Summary/"},{"name":"Paper Notes","slug":"Summary/Paper-Notes","permalink":"http://blog.gyx.me/categories/Summary/Paper-Notes/"}],"tags":[{"name":"Greedy","slug":"Greedy","permalink":"http://blog.gyx.me/tags/Greedy/"},{"name":"Graphs","slug":"Graphs","permalink":"http://blog.gyx.me/tags/Graphs/"},{"name":"Scheduling","slug":"Scheduling","permalink":"http://blog.gyx.me/tags/Scheduling/"}]},{"title":"Fast Fourier Transform and Polynomials Tech","slug":"fft","date":"2022-05-18T04:08:53.000Z","updated":"2022-06-01T03:16:15.990Z","comments":true,"path":"2022/05/18/fft/","link":"","permalink":"http://blog.gyx.me/2022/05/18/fft/","excerpt":"","text":"Fundamental 放一个算法讨论组上做报告的 ppt : Structure NTT Application","categories":[{"name":"Summary","slug":"Summary","permalink":"http://blog.gyx.me/categories/Summary/"},{"name":"Algorithms","slug":"Summary/Algorithms","permalink":"http://blog.gyx.me/categories/Summary/Algorithms/"}],"tags":[{"name":"Polynomials","slug":"Polynomials","permalink":"http://blog.gyx.me/tags/Polynomials/"}]},{"title":"Codeforces Round #787 (Div. 3)","slug":"cf787","date":"2022-05-06T12:01:00.000Z","updated":"2022-06-01T02:57:47.757Z","comments":true,"path":"2022/05/06/cf787/","link":"","permalink":"http://blog.gyx.me/2022/05/06/cf787/","excerpt":"","text":"A. Food for Animals \\(a\\) 个狗粮，\\(b\\) 个猫粮，\\(c\\) 个通用粮（都能吃），能不能保证 \\(n\\) 个狗 \\(m\\) 个猫都有的吃？ 每个都先减掉专用的食物，剩下的看通用的够不够分即可。 12345inline void work() &#123; int a = rd(), b = rd(), c = rd(); int n = max(0, rd() - a), m = max(0, rd() - b); puts(n + m &gt; c ? &quot;NO&quot; : &quot;YES&quot;);&#125; B. Make It Increasing 给一个数列，每次操作把一个位置整除 \\(2\\) ，最少操作多少次使得数列严格递增？ 从后往前倒推，答案是固定的，一直做到符合要求即可。 1234567891011int a[57];inline void work() &#123; int n = rd(), ans = 0; for (int i = 1; i &lt;= n; ++i) a[i] = rd(); for (int i = n - 1; i; --i) if (a[i] &gt;= a[i + 1]) &#123; if (a[i + 1] == 0) &#123;puts(&quot;-1&quot;); return;&#125; while (a[i] &gt;= a[i + 1]) &#123;++ans; a[i] = a[i] / 2;&#125; &#125; printf(&quot;%d\\n&quot;, ans);&#125; C. Detective Task 有一幅画， \\(n\\) 个人看，中间某一时刻被某一个人偷走了。 问每个人他看的时候画还在不在，答案可能是有 (1) / 无 (0) / 忘记了 (?)。 好人会说实话/忘记了，偷走的人会随机选一个答案，求有多少个嫌疑人。 最后一个说有（1）的人，前面的人都不会是嫌疑人：如果前面的人是嫌疑人，那么他进去的时候应该已经被偷了，他就说谎了。 第一个说无（0）的人，后面的人都不会是嫌疑人：如果后面的人是嫌疑人，那么他进去的时候还没被偷，他就说谎了 因此答案是从最后一个说有的人到第一个说无的人这一段的人数。 1234567891011string s;inline void work() &#123; cin &gt;&gt; s; int n = s.length(); int l = 0, r = n - 1; for (int i = 0; i &lt; n; ++i) if (s[i] == &#x27;1&#x27;) l = i; for (int i = l; i &lt; n; ++i) if (s[i] == &#x27;0&#x27;) &#123;r = i; break;&#125; printf(&quot;%d\\n&quot;, r - l + 1);&#125; D. Vertical Paths 给一棵树，问最少分成多少个从上到下的链，并输出方案。 显然每个叶子都需要一个链，每个非叶子挑一个叶子挂上就行了，纯考实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 200007bool vis[N];int n, rt, f[N], cnt;vector&lt;int&gt; res[N], son[N];void dfs(int u, int bel) &#123; res[bel].push_back(u); if (son[u].empty()) &#123;++cnt; return;&#125; dfs(son[u][0], bel); for (int i = 1; i &lt; son[u].size(); ++i) dfs(son[u][i], son[u][i]);&#125;inline void work() &#123; n = rd(); cnt = 0; for (int i = 1; i &lt;= n; ++i) &#123;res[i].clear(); son[i].clear();&#125; for (int i = 1; i &lt;= n; ++i) &#123; f[i] = rd(); if (f[i] == i) rt = i; else son[f[i]].push_back(i); &#125; dfs(rt, rt); printf(&quot;%d\\n&quot;, cnt); for (int i = 1; i &lt;= n; ++i) if (!res[i].empty()) &#123; printf(&quot;%d\\n&quot;, (int)res[i].size()); for (auto j : res[i]) printf(&quot;%d &quot;, j); puts(&quot;&quot;); &#125; &#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; E. Replace With the Previous, Minimize 给一个字符串，每次操作你可以选定一个字符，并把串中的所有这个字符换成字典序前一个（a 变成 z ） 问 \\(k\\) 次操作内，字符串可能的字典序最小的结果是什么？ 首先如果 \\(k&gt;25\\) ，那么我从 z 到 b 都操作一遍就都变成 aaaaaaa 这样子了。 否则也一定不会对 a 操作，因为次数不够变回来了，因此操作是单向的，没有循环的。 因此按照字典序贪心就完事了，维护一个 \\(\\Sigma\\to \\Sigma\\) 的转移表，每次可以的话往前移动一下。 需要注意的是利用此前的结果，也就是每次做完之后记得把前缀覆盖一下。 12345678910111213141516string s;unordered_map&lt;char, char&gt; tr;inline void work() &#123; int n = rd(), k = rd(); cin &gt;&gt; s; for (char i = &#x27;a&#x27;; i &lt;= &#x27;z&#x27;; ++i) tr[i] = i; for (auto i : s) &#123; while (k &amp;&amp; tr[i] &gt; &#x27;a&#x27;) &#123; --tr[i]; --k; tr[i] = tr[tr[i]]; &#125; for (char j = i; j &gt;= tr[i]; --j) tr[j] = min(tr[j], tr[i]); if (k == 0) break; &#125; for (auto i : s) putchar(tr[i]); puts(&quot;&quot;);&#125; F. Vlad and Unfinished Business 给一棵树，树上的两个点 \\(x, y\\) ，以及一系列点 \\(a_1, a_2, \\dots,a_k\\) 求一个最短路径，从 \\(x\\) 出发，以任意顺序遍历完 \\(a_1, a_2, \\dots,a_k\\) ，最后走到 \\(y\\) 首先一个常见的套路（虚树）是，树上遍历一个点集的最短回路，就是所有点按照dfs序一次性访问。 现在考虑让树以 \\(x\\) 为根，现在需要遍历 \\(a_1,a_2,\\dots,a_k\\) 这些点，最后再走到 \\(y\\) 。 其实可以看成回路遍历点集 \\(x, a_1, a_2,\\dots, a_k,y\\) ，最后再把 \\(x\\) 到 \\(y\\) 的距离（也就是 \\(y\\) 的深度）扣掉。 所以按照 dfs 序依次访问即可，可能比较难写。 另外一种简单的写法是暴力往根跳，跳到第一个访问到的点即可，往答案里累加新增的点数 * 2 。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 200007vector&lt;int&gt; e[N], seq;bool vis[N];int n, k, x, y, f[N], ans;void dfs(int u, int fa, int dep) &#123; f[u] = fa; if (u == y) ans = -dep; for (auto v : e[u]) if (v != fa) dfs(v, u, dep + 1);&#125;inline void work() &#123; seq.clear(); n = rd(); k = rd(); x = rd(); y = rd(); for (int i = 1; i &lt;= n; ++i) vis[i] = 0, e[i].clear(); for (int i = 1; i &lt;= k; ++i) seq.push_back(rd()); seq.push_back(y); for (int i = 1; i &lt; n; ++i) &#123; int u = rd(), v = rd(); e[u].push_back(v); e[v].push_back(u); &#125; dfs(x, x, 0); vis[x] = 1; for (auto i : seq) for (int u = i; !vis[u]; u = f[u]) vis[u] = 1, ans += 2; printf(&quot;%d\\n&quot;, ans);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; G. Sorting Pancakes 给你一个序列，每次操作可以选两个相邻的两个位置一个 \\(-1\\) 一个 \\(+1\\) ，问最小操作多少次是的序列单减。 看到这种问题一般都是 dp ，就是状态设计需要好好考虑一下。 设 \\(f_{i,j}\\) 表示考虑了前 \\(i\\) 位，前缀和是 \\(j\\) 的最小操作数，那么转移就是枚举序列最终下一个位置的数字 \\(k\\) 。 即 \\(f_{i+1,j+k}=\\min\\{f_{i+1,j+k}, f_{i,j} + cost (i + 1, j+k)\\}\\) 其中 \\(cost(x, w)\\) 表示前缀 \\(x\\) 在此前基础上变成总和 \\(w\\) 的最小代价。 考虑 \\(f_{i,j}\\) 里已经包含了让前缀 \\(i\\) 合法的代价，现在其实只需要考虑新一位是 \\(k\\) 的代价。 本质上我们只需要考虑第 \\(i+1\\) 位和后面的后缀交流的多少次，即 \\(cost(i+1,j+k)=|\\sum_{p=1}^{i+1}a_p-(j+k)|\\) 那么怎么保证序列单减呢？把枚举 \\(k\\) 的循环放到最外面，从大到小，这样转移是从大到小的，比较妙。 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 257int a[N], s[N], f[N][N];int main() &#123; int n = rd(), m = rd(); for (int i = 1; i &lt;= n; ++i) s[i] = s[i - 1] + (a[i] = rd()); memset(f, 0x3f, sizeof(f)); f[0][0] = 0; for (int k = m; ~k; --k) for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt;= m - k; ++j) f[i + 1][j + k] = min(f[i + 1][j + k], f[i][j] + abs(j + k - s[i + 1])); printf(&quot;%d\\n&quot;, f[n][m]); return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"http://blog.gyx.me/categories/Solution/"},{"name":"Codeforces","slug":"Solution/Codeforces","permalink":"http://blog.gyx.me/categories/Solution/Codeforces/"},{"name":"Codeforces Round","slug":"Solution/Codeforces/Codeforces-Round","permalink":"http://blog.gyx.me/categories/Solution/Codeforces/Codeforces-Round/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"},{"name":"DFS and Similar","slug":"DFS-and-Similar","permalink":"http://blog.gyx.me/tags/DFS-and-Similar/"}]},{"title":"Dynamic Programming on Intervals","slug":"dp_interval","date":"2022-04-26T00:13:35.000Z","updated":"2022-06-01T03:26:01.320Z","comments":true,"path":"2022/04/26/dp_interval/","link":"","permalink":"http://blog.gyx.me/2022/04/26/dp_interval/","excerpt":"","text":"Normal Problems 区间动态规划的一般形式：枚举长度（阶段），枚举左端点，需要的话再枚举分割点 Unlock the Padlock Source:Google Kick Start 2022 Round B一个滚轮密码锁由 \\(n\\)个滚轮组成，每个的范围都是 \\([0, D-1]\\)（循环），初始是 \\(a_i\\) 。每次操作选取一个区间 \\(1 \\le l_i \\le r_i\\le n\\) ，将区间内所有滚轮都向上或向下拨一个位置。要求 \\([l_i,r_i]\\subseteq[l_{i+1},r_{i+1}]\\) ，问最少多少次把所有位置都变成 \\(0\\) 。 区间只能扩张不能收缩，因此任意时刻拨动的区间内的数字一定要相同。 如果 \\(D\\) 很小，可以设 \\(f[l][r][k]\\) 表示区间 \\([l,r]\\) 都调成 \\(k\\) 的最小代价，直接 \\(\\mathcal O(n^2D^2)\\) 求解。 那么什么时候区间能真的扩张？当且仅当区间内的值和 \\(a_{l-1}\\) 或 \\(a_{r+1}\\) 一样，才能向左或向右扩展一位。 因此 任意时刻操作区间的值一定和某个端点相同 ，设 \\(f[l][r][0/1]\\) 表示把 \\([l,r]\\) 都调成左/右端点的最小操作次数。 直接每次区间长度扩展 \\(1\\) 转移即可，复杂度 \\(\\mathcal O(n^2)\\) 。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 407int testcase;ll n, d, f[N][N][2], a[N];inline ll dis(ll a, ll b) &#123; ll w = abs(a - b); return min(w, d - w);&#125;inline void getmin(ll &amp;a, ll b) &#123;a = (a &lt; b ? a : b);&#125;inline void work() &#123; n = rd(); d = rd(); memset(f, 0x3f, sizeof(f)); for (int i = 1; i &lt;= n; ++i) &#123; a[i] = rd(); f[i][i][0] = f[i][i][1] = 0; &#125; for (int len = 1; len &lt; n; ++len) &#123; for (int l = 1; l &lt;= n - len + 1; ++l) &#123; int r = l + len - 1; getmin(f[l - 1][r][0], f[l][r][0] + dis(a[l], a[l - 1])); getmin(f[l - 1][r][0], f[l][r][1] + dis(a[r], a[l - 1])); getmin(f[l][r + 1][1], f[l][r][0] + dis(a[l], a[r + 1])); getmin(f[l][r + 1][1], f[l][r][1] + dis(a[r], a[r + 1])); &#125; &#125; ll ans = min(f[1][n][0] + dis(a[1], 0), f[1][n][1] + dis(a[n], 0)); printf(&quot;Case #%d: %lld\\n&quot;, ++testcase, ans);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; Sue 的小球 Source: SDOI2008有 \\(n\\) 个球往下落，初始坐标是\\(x_i\\) ，高度是 \\(h_i\\) ，下落速度 \\(v_i\\) ，可以下落到正无穷。初始坐标在 \\(x_0\\)，每秒可以向左/向右移动 \\(1\\)，经过某个球的坐标时就把这个球拿走，获得当前高度的得分。问拿到所有球的前提下，最大得分是多少。 得分 \\(=\\sum h_i-\\sum\\) 下降的高度，考虑动态规划求 \\(\\min\\sum\\) 下降的高度。 问题变为第 \\(i\\) 个位置每秒会消耗 \\(v_i\\) ，到一个位置就会停止消耗，是 关路灯 这个模型。 考虑把坐标排序之后离散化，拿走的球一定是一个连续的区间，因此我们可以让状态停在某一个端点。 状态设计比较特殊：设 \\(f[l][r][0/1]\\) 表示把 \\([l,r]\\) 全部拿走，最后停在左/右端点，从开始到这个时刻的最小总消耗 那么考虑每次扩展一个位置，那么所耗的时间就是两点距离，每一秒的代价就是 \\(\\sum_{i\\notin [l,r]} v_i\\) （所有没接到的球） 需要注意把初始坐标离散化进去。枚举区间动态规划复杂度 \\(\\mathcal O(n^2)\\) 。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;typedef double db;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 1007#define fr first#define sc secondpair&lt;int, double&gt; p[N];db ans, sum[N], f[N][N][2];inline void getmin(db &amp;a, db b) &#123;a = (a &lt; b ? a : b);&#125;int main() &#123; int n = rd(), c = rd(); for (int i = 1; i &lt;= n; ++i) p[i].fr = rd(); for (int i = 1; i &lt;= n; ++i) ans += rd() / 1000.0; for (int i = 1; i &lt;= n; ++i) p[i].sc = rd() / 1000.0; p[++n] = make_pair(c, 0); sort(p + 1, p + 1 + n); for (int l = 1; l &lt;= n; ++l) for (int r = 1; r &lt;= n; ++r) for (int k = 0; k &lt; 2; ++k) f[l][r][k] = 1e18; for (int i = 1; i &lt;= n; ++i) &#123; sum[i] = sum[i - 1] + p[i].sc; if (p[i].fr == c) f[i][i][0] = f[i][i][1] = 0; &#125; for (int len = 1; len &lt; n; ++len) for (int l = 1; l &lt;= n - len + 1; ++l) &#123; int r = l + len - 1; db rsum = sum[n] - sum[r] + sum[l - 1]; getmin(f[l - 1][r][0], f[l][r][0] + (p[l].fr - p[l - 1].fr) * rsum); getmin(f[l - 1][r][0], f[l][r][1] + (p[r].fr - p[l - 1].fr) * rsum); getmin(f[l][r + 1][1], f[l][r][0] + (p[r + 1].fr - p[l].fr) * rsum); getmin(f[l][r + 1][1], f[l][r][1] + (p[r + 1].fr - p[r].fr) * rsum); &#125; printf(&quot;%.3lf\\n&quot;, ans - min(f[1][n][0], f[1][n][1])); return 0;&#125; Cities Source: The45th ICPC Asia Kunming Regional有 \\(n\\) 个点，第 \\(i\\) 个点的颜色是 \\(c_i\\) ，保证每种颜色最多出现 \\(15\\) 次。每次操作可以把一段连续且颜色相同的点都改成某个颜色，问最少操作多少次使得所有点颜色相同。 先把同样颜色且连续的缩成一段，这样相邻两两颜色都不同，假设有 \\(m\\) 段。 如果所有的颜色都不同的话，那么答案就是 \\(m-1\\) ，因为每次只能改颜色相同的。 但是序列中依旧有颜色相同的，因此需要动态规划求，设 \\(f[l][r]\\) 表示把 \\([l,r]\\) 变成相同的所需的最少次数。 转移考虑 \\(c_l\\) 有没有单独消耗一次合并： 如果单独消耗了一次就是 \\(f[l][r] = f[l + 1][r] + 1\\) 如果不消耗，那么枚举相同的另一个是 \\(k\\) ，那么 \\(f[l][r] = f[l + 1][k - 1] + f[k][r] + 1\\) 后面这个方程成立的原因是，我们发现操作总是可以等效到把区间变成和端点颜色相同。 需要缩点的原因是，后一种方程里的 \\(+1\\) 是为了把 \\([l + 1][k - 1]\\) 变成和 \\(c_l\\) 相同的，不缩会求错。 枚举区间，再枚举相同颜色，因为题目限制每种颜色最多出现 \\(15\\) 次，复杂度 \\(O(15n^2)\\) 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;typedef double db;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;inline void getmin(int &amp;a, int b) &#123;a = (a &lt; b ? a : b);&#125;#define N 5007int a[N], f[N][N], lst[N], nxt[N];inline void work() &#123; int n = rd(), tot = 0; for (int i = 1, x; i &lt;= n; ++i) &#123; x = rd(); if (!tot || x != a[tot]) a[++tot] = x; lst[i] = n + 1; &#125; n = tot; for (int i = n; i; --i) &#123; nxt[i] = lst[a[i]]; lst[a[i]] = i; &#125; for (int len = 2; len &lt;= n; ++len) for (int l = 1; l &lt;= n - len + 1; ++l) &#123; int r = l + len - 1; f[l][r] = f[l + 1][r] + 1; for (int j = nxt[l]; j &lt;= r; j = nxt[j]) getmin(f[l][r], f[l + 1][j - 1] + f[j][r] + 1); &#125; printf(&quot;%d\\n&quot;, f[1][n]);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; Dire Wolf Source:2014 ICPC Asia Beijing Regional有 \\(n\\) 个恐狼先锋排成一排，第\\(i\\) 个有 \\(a_i\\) 初始攻击力，并且会为两侧的恐狼临时增加 \\(b_i\\)攻击力（死了就没了）每次杀掉一个需要承受他当前攻击力的伤害，问杀掉所有的狼，承受最少伤害是多少。 设 \\(f[l][r]\\) 表示把 \\([l,r]\\) 这个区间的所有狼杀掉所需的最小代价。 枚举最后一只杀掉的狼 \\(k\\) ，考虑此时他两侧的狼是谁？ 答案是 \\(l-1\\) 和 \\(r+1\\) ，考虑区间 DP 的阶段性，我只需要杀死当前枚举的区间的狼，所以两侧的狼都没有死过。 所以最后一只狼的攻击力是 \\(a_k+b_{l-1}+b_{r + 1}\\) ，枚举 \\(k\\) 更新，复杂度是 \\(\\mathcal O(n^3)\\) 的。 \\[ f[l][r] = \\min_{l\\le k\\le r} \\bigg\\{f[l][k-1]+f[k+1][r]+a_k+b_{l-1}+b_{r+1}\\bigg\\} \\] 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 207int a[N], b[N], testcase;ll f[N][N];inline void work() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) a[i] = rd(); for (int i = 1; i &lt;= n; ++i) b[i] = rd(); b[n + 1] = 0; for (int len = 1; len &lt;= n; ++len) for (int l = 1; l &lt;= n - len + 1; ++l) &#123; int r = l + len - 1; f[l][r] = 1e18; for (int p = l; p &lt;= r; ++p) f[l][r] = min(f[l][r], f[l][p - 1] + f[p + 1][r] + a[p] + b[l - 1] + b[r + 1]); &#125; printf(&quot;Case #%d: %lld\\n&quot;, ++testcase, f[1][n]);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; You Are the One Source:2012 ICPC Asia Tianjin Regional Online\\(n\\)个人排成一队依次入栈，任意时刻都可以按栈序弹出栈内的任意人数。第 \\(i\\) 个人如果是第 \\(k\\) 个出场的，代价是 \\(D_i\\ast (k-1)\\)，求所有人代价和最小可能是多少。 设 \\(f[l][r]\\) 表示序列里只有 \\([l,r]\\) 这些人（假设区间前后的人不存在），最小代价是多少。 观察这些人的出入栈的顺序，发现序列会被第一个人何时出栈划分为两个阶段。 第一个人第一个入栈，假设第 \\(k\\) 个出栈（他出栈前只压入第 \\(2\\sim k\\) 个人）那么序列表现为： 第 \\(2\\sim k\\) 个人出入栈，这些人前面没有其他人，代价是 \\(f[l+1][l+k-1]\\) 第一个人出栈，前面有 \\(k-1\\) 个人，代价是 \\(D_l\\ast(k-1)\\) 第 \\(k+1\\sim n\\) 个人出入栈，这些人前面都增加 \\(k\\) 个人，代价是 \\(f[l+k][r]+\\sum_{i=l+k+1}^rD_i\\ast k\\) 枚举 \\(k\\) 更新，复杂度是 \\(\\mathcal O(n^3)\\) 的。 \\[ f[l][r] =\\min_{1\\le k\\le r-l+1} \\bigg\\\\{f[l + 1][l + k-1]+D_l\\ast(k-1)+f[l+k][r] + \\sum_{i=l+k}^r D_i\\ast k\\bigg\\\\} \\] 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 107int testcase;ll d[N], sum[N], f[N][N];inline void getmin(ll &amp;a, ll b) &#123;a = (a &lt; b ? a : b);&#125;inline void work() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; d[i] = rd(); sum[i] = sum[i - 1] + d[i]; &#125; for (int len = 2; len &lt;= n; ++len) for (int l = 1; l &lt;= n - len + 1; ++l) &#123; int r = l + len - 1; f[l][r] = 1e18; for (int k = 1; k &lt;= len; ++k) getmin(f[l][r], f[l + 1][l + k - 1] + d[l] * (k - 1) + f[l + k][r] + (sum[r] - sum[l + k - 1]) * k); &#125; printf(&quot;Case #%d: %lld\\n&quot;, ++testcase, f[1][n]);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; 二叉查找树 Source: NOI2009给定 \\(n\\) 个节点的key,value,times ，修改一个点的 value 代价是\\(K\\) ，修改后要保证两两value 不同。然后把这些点建出一个 Treap，定义访问代价 \\(\\sum_{i} depth_i\\ast times_{i}\\)，最小化修改代价 + 访问代价。 核心点是 key 不能修改，所以中序遍历是固定的，根左侧是左子树，根右侧是右子树。 考虑在中序遍历上做区间 DP ，枚举谁做根，那么根的 value 应当比左右子树的节点 value 要小。 所以状态里我们还要记一下当前子树的最小 value 是多少。 设 \\(f[l][r][k]\\) 表示中序遍历区间 \\([l,r]\\) 内的点建树，里面的点 value 权值 \\(\\ge k\\) ，的最小代价。 如果这个点的权值不需要改（前提 \\(value_{rt}\\ge k\\) ），那么子树里的权值要比他大 \\[ f[l][r][k] = \\min_{l\\le rt\\le r}\\bigg\\{f[l][rt - 1][value_{rt}]+f[rt + 1][r][value_{rt}] + \\sum_{i=l}^r times_i\\bigg\\} \\] 如果这个点权值需要改，那么子树的权值下界也是 \\(k\\) \\[ f[l][r][k] = \\min_{l\\le rt\\le r}\\bigg\\{f[l][rt - 1][k]+f[rt + 1][r][k] + \\sum_{i=l}^r times_i + K\\bigg\\} \\] 因为初始两两节点 value 就不同，而且可以调整成任意实数，所以方程中对子树权值的约束不用修改。 答案是 \\(\\min_k f[1][n][k]\\) ，把权值离散化一下，DP 复杂度是 \\(\\mathcal O(n^4)\\) 的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;vector&lt;int&gt; s;unordered_map&lt;int, int&gt; tr;#define N 73struct node &#123;int k, v, t;&#125; c[N];ll f[N][N][N], sumt[N];inline void getmin(ll &amp;a, ll b) &#123;a = (a &lt; b ? a : b);&#125;int main() &#123; int n = rd(), w = rd(); for (int i = 1; i &lt;= n; ++i) c[i].k = rd(); for (int i = 1; i &lt;= n; ++i) s.push_back(c[i].v = rd()); for (int i = 1; i &lt;= n; ++i) c[i].t = rd(); sort(s.begin(), s.end()); int cnt = 0; for (auto i : s) tr[i] = ++cnt; for (int i = 1; i &lt;= n; ++i) c[i].v = tr[c[i].v]; sort(c + 1, c + 1 + n, [](node x, node y)&#123;return x.k &lt; y.k;&#125;); for (int i = 1; i &lt;= n; ++i) sumt[i] = sumt[i - 1] + c[i].t; for (int len = 1; len &lt;= n; ++len) for (int l = 1; l &lt;= n - len + 1; ++l) &#123; int r = l + len - 1; for (int k = 0; k &lt;= n; ++k) &#123; f[l][r][k] = 1e18; for (int rt = l; rt &lt;= r; ++rt) &#123; if (c[rt].v &gt;= k) getmin(f[l][r][k], f[l][rt - 1][c[rt].v] + f[rt + 1][r][c[rt].v]); getmin(f[l][r][k], f[l][rt - 1][k] + f[rt + 1][r][k] + w); &#125; f[l][r][k] += sumt[r] - sumt[l - 1]; &#125; &#125; ll ans = 1e18; for (int k = 0; k &lt;= n; ++k) ans = min(ans, f[1][n][k]); printf(&quot;%lld\\n&quot;, ans); return 0;&#125; Pre-Order Source :AtCoder Beginner Contest 252 G定义 dfs序：从根开始，每次选择未访问过的最小儿子访问，每个点第一次被访问时记入序列尾。现给定 dfs 序，问有多少棵树符合。 \\(n\\le500\\) 考虑多叉树转二叉树（左儿子右兄弟，这是一个双射），那么要求就变为右儿子一定要小于父节点的编号。 设 \\(f_{l, r}\\) 表示 \\([l,r]\\) 这段区间，以 \\(l\\) 为根形成这样一棵二叉树的方案数。 枚举右儿子是 \\(k\\in[l + 1, r], a[k] &gt; a[l]\\) ，有转移 \\(f_{l, r} = \\sum_k f_{l,k - 1} \\times f_{k, r}\\) 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 507#define mod 998244353ll a[N], f[N][N];int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; a[i] = rd(); f[i][i] = 1; &#125; for (int len = 2; len &lt; n; ++len) &#123; for (int l = 2; l &lt;= n - len + 1; ++l) &#123; int r = l + len - 1; f[l][r] = f[l + 1][r]; for (int k = l + 1; k &lt;= r; ++k) if (a[k] &gt; a[l]) f[l][r] = (f[l][r] + 1ll * max(1ll, f[l + 1][k - 1]) * f[k][r]) % mod; &#125; &#125; printf(&quot;%lld\\n&quot;, f[2][n]); return 0;&#125;","categories":[{"name":"Summary","slug":"Summary","permalink":"http://blog.gyx.me/categories/Summary/"},{"name":"Algorithms","slug":"Summary/Algorithms","permalink":"http://blog.gyx.me/categories/Summary/Algorithms/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"}]},{"title":"AtCoder Grand Contest 002","slug":"agc002","date":"2022-04-13T05:36:32.000Z","updated":"2022-05-19T01:11:25.338Z","comments":true,"path":"2022/04/13/agc002/","link":"","permalink":"http://blog.gyx.me/2022/04/13/agc002/","excerpt":"","text":"官方题解：https://img.atcoder.jp/agc002/editorial.pdf","categories":[{"name":"Solution","slug":"Solution","permalink":"http://blog.gyx.me/categories/Solution/"},{"name":"AtCoder","slug":"Solution/AtCoder","permalink":"http://blog.gyx.me/categories/Solution/AtCoder/"},{"name":"AtCoder Grand Contest","slug":"Solution/AtCoder/AtCoder-Grand-Contest","permalink":"http://blog.gyx.me/categories/Solution/AtCoder/AtCoder-Grand-Contest/"}],"tags":[]},{"title":"AtCoder Grand Contest 001","slug":"agc001","date":"2022-04-12T02:08:12.000Z","updated":"2022-06-01T03:18:33.915Z","comments":true,"path":"2022/04/12/agc001/","link":"","permalink":"http://blog.gyx.me/2022/04/12/agc001/","excerpt":"","text":"官方题解：https://img.atcoder.jp/agc001/editorial.pdf 听说多做 AGC 可以提升智力，于是来尝试提升一下智力（虽然都是抄的题解）。 A - BBQ Easy \\(2n\\) 个数，最大化两两一组分组后，每组两个数取 \\(\\min\\) 的和。 从小到大排序之后，两两组合，答案是奇数位置的和。 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;vector&lt;int&gt; a;int main() &#123; int n = (rd() &lt;&lt; 1); for (int i = 1; i &lt;= n; ++i) a.push_back(rd()); sort(a.begin(), a.end()); int ans = 0; for (int i = 0; i &lt; n; i += 2) ans += a[i]; printf(&quot;%d\\n&quot;, ans); return 0;&#125; B - Mysterious Light 边长为 \\(n\\) 的正三角形 ABC 的边 AB 上 \\(x\\) 处平行 BC 射出一条激光。 碰到边界反射，碰到此前的光线也反射，求回到起点的路径长度。 没看懂官方题解的简单做法。 首先前两段光路长度和是 \\(n\\) ，会切掉两个角，变成一个平行四边形。 对于平行四边形（边长分别为 \\(a\\) 和 \\(b\\) ），光线从一个 \\(120^\\circ\\) 角出发，沿角平分线射出距离为 \\(f(a,b)\\) 有 \\(f(a,0)=-a, f(a,b) = 2 \\ast \\displaystyle\\lfloor \\frac{a}{b}\\rfloor \\ast b +f(b, a \\% b)\\) ，也就是每次都切短边直到长短边交换，减掉最后一次多算的。 答案就是 \\(n+f(x,n-x)\\) ，递归形式和 gcd 相同，所以复杂度是 \\(\\mathcal O(\\log n)\\) 。 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;inline ll f(ll a, ll b) &#123; return b ? 2 * (a / b) * b + f(b, a % b) : -a;&#125;int main() &#123; ll n = rd(), x = rd(); printf(&quot;%lld\\n&quot;, n + f(x, n - x)); return 0;&#125; C - Shorten Diameter 给一棵树，每次可以删掉一个叶子，问最少删多少次使得直径不超过 \\(k\\) 本来想贪心每次删一个直径的端点，但是不对，因为有可能这个点会被保留到最后。 因为 \\(n\\) 只有 \\(2000\\) ，所以可以 \\(\\mathcal{O}(n^2)\\) 暴力，那么枚举中心就好了。 如果 \\(k\\) 是奇数，枚举中心的边，把树分成两棵，根就是这条边的两个端点，每棵只保留深度小于 \\(\\lfloor k/2\\rfloor\\) 的点 如果 \\(k\\) 是偶数，枚举中心的点，以这个点为根，只保留深度小于 \\(\\lfloor k/2\\rfloor\\) 的点 找到上述情况里需要删除的点最少的情况即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 2007#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;vector&lt;pii&gt; r;vector&lt;int&gt; e[N];int dep[N];void dfs(int u) &#123; for (auto v : e[u]) if (dep[v] &lt; 0) &#123;dep[v] = dep[u] + 1; dfs(v);&#125;&#125;int main() &#123; int n = rd(), k = rd(); for (int i = 1, u, v; i &lt; n; ++i) &#123; u = rd(); v = rd(); e[u].pb(v); e[v].pb(u); if (k &amp; 1) r.pb(mp(u, v)); &#125; int ans = 0; if (k &amp; 1) &#123; for (auto [u, v] : r) &#123; memset(dep, -1, sizeof(dep)); dep[u] = 0; dep[v] = 0; dfs(u); dfs(v); int tmpans = 0; for (int j = 1; j &lt;= n; ++j) tmpans += (dep[j] &lt;= k / 2); ans = max(ans, tmpans); &#125; &#125; else &#123; for (int i = 1; i &lt;= n; ++i) &#123; memset(dep, -1, sizeof(dep)); dep[i] = 0; dfs(i); int tmpans = 0; for (int j = 1; j &lt;= n; ++j) tmpans += (dep[j] &lt;= k / 2); ans = max(ans, tmpans); &#125; &#125; printf(&quot;%d\\n&quot;, n - ans); return 0;&#125; D - Arrays and Palindrome 给定序列 \\(\\{A_i\\}\\) ，满足 \\(\\sum A_i=N\\) ，需要重排 \\(\\{A_i\\}\\) ，并且构造 \\(\\{B_i\\}\\) ，满足 \\(\\sum B_i=N\\) ，且满足： 如果一个长度为 \\(N\\) 的串 \\(S\\) 满足（ \\(S[l,r]\\) 表示 \\(S[l]S[l+1]\\dots S[r]\\) 这一段子串）： \\(\\forall i,\\ S[\\sum_{j=1}^{i-1}A_j+1, \\sum_{j=1}^i A_j]\\) 是回文的（也就是按照 \\(A_i\\) 分割成若干段子串，都是回文的） \\(\\forall i,\\ S[\\sum_{j=1}^{i-1}B_j+1, \\sum_{j=1}^i B_j]\\) 是回文的（也就是按照 \\(B_i\\) 分割成若干段子串，都是回文的） 那么 一定能推出 \\(S\\) 中全部字符都相同。 好有意思的题目啊！！建议先看官方题解。 假如我们确定了 \\(\\{A\\}\\) 的顺序，那么 \\(\\{A\\}\\) 把序列分成若干段，每段对称的位置字符要相同。 我们如果把 \\(N\\) 个位置看作 \\(N\\) 个点，那么可以把 \\(A\\) 的所有要求对称的位置连一条边。 现在 \\(B\\) 相当于是要补一些边，使得所有点都连通。 假设所有的 \\(A_i\\) 均为偶数，那么令\\(|\\{B\\}|=|\\{A\\}|\\) ，先让 \\(B_i=A_i\\) ，然后 $B_1 B_1-1,B_{|{B}|}B_{|{B}|}+1 $那么（除第一段外）每一段的最后一个都和前一段的最后一个连边，连通了两段；此外每一段内的连边都是奇偶位置错开的，所以整个图是连通的。 然后考虑 \\(A_i\\) 有奇数，可以证明最多允许有两段奇数，把这两段放在两边，还是不影响答案的。 如果奇数长度段超过两个，一定无解，具体证明看官方题解，大概方法就是证明了边数凑不到 \\(n-1\\) 。 感觉这个构造真的很 useful 啊（ 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define ppb pop_back#define psb push_back#define ppf pop_front#define psf push_frontdeque&lt;int&gt; s, odd;int main() &#123; int m = rd(), n = rd(); for (int i = 1, x; i &lt;= n; ++i) &#123; x = rd(); (x &amp; 1) ? odd.psb(x) : s.psb(x); &#125; if (odd.size() &gt; 2) &#123;puts(&quot;Impossible&quot;); return 0;&#125; if (odd.size() &gt; 0) s.psf(odd[0]); if (odd.size() &gt; 1) s.psb(odd[1]); for (auto x : s) printf(&quot;%d &quot;, x); puts(&quot;&quot;); //需要注意只有一个元素和第一个元素是1的情况 if (s.size() == 1) s.psb(0); --s.front(); ++s.back(); if (s.front() == 0) s.ppf(); printf(&quot;%d\\n&quot;, s.size()); for(auto x : s) printf(&quot;%d &quot;, x); return 0;&#125; E - BBQ Hard 给定 \\(N\\) 个 \\((A_i,B_i)\\) ，求： \\[ \\sum_{i=1}^{n-1}\\sum_{j=i+1}^n {A_i+A_j+B_i+B_j\\choose A_i+A_j} \\mod 10^9+7 \\] 数据范围 \\(2\\le n\\le 2\\times 10^5,1\\le a_i,b_i\\le 2000\\) 只能往右和往上走，计数从 \\((x_0,y_0)\\) 到 \\((x_1,y_1)\\)的路径方案数，考虑哪些步是横向走，是 \\(\\displaystyle{ {x_1-x_0+y_1-y_0} \\choose {x_1-x_0}}\\) 。当然也可以用一个二维递推，令 f[x0][y0]=1 ，每次f[i][j] = f[i - 1][j] + f[i][j - 1] ，答案f[x1][y1] 。 把式中 \\(\\displaystyle{A_i+A_j+B_i+B_j\\choose A_i+A_j}\\) 变形为 \\(\\displaystyle {A_i-(-A_j)+B_i-(-B_j)\\choose A_i-(-A_j)}\\) ，可解读为从 \\((-A_j,-B_j)\\) 到 \\((A_i,B_i)\\) 的路径数。 那么把求和改一下形式，两个循环都改成从 \\(1\\) 到 \\(n\\) ，然后扣掉自己到自己的贡献，再除 \\(2\\) 就是答案。 \\[ ans = \\frac{\\sum_{i=1}^{N} \\sum_{j=1}^{N} \\displaystyle{A_{i} +B_{i}+A_{j}+B_{j} \\choose A_{i}+B_{i}}-\\sum_{i=1}^{N} {2\\ast A_{i}+2\\ast B_{i} \\choose 2 \\ast A_{i}}}{2} \\mod 10^9+7 \\] 前一半考虑用上面提到的递推方法整体一起求（加个偏移量把坐标调成正的）： 先给所有的 f[-a[i]][-b[i]] += 1 ，然后递推完查所有的 f[a[i]][b[i]] 即可。 后一半用组合数直接算就好了。总复杂度 \\(\\mathcal{O}(n+4\\ast \\max a_i\\ast \\max b_i)\\) 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define A 4007#define G 2001#define M 8007#define N 200007#define mod 1000000007#define inv2 500000004int f[A][A], fac[M], ifac[M], x[N], y[N];inline int fpow(int x, int t = mod - 2) &#123; int res = 1; for (; t; t &gt;&gt;= 1, x = 1ll * x * x % mod) if (t &amp; 1) res = 1ll * res * x % mod; return res;&#125;inline int mo(int x) &#123; for (; x &lt; 0; x += mod); for (; x &gt;= mod; x -= mod); return x;&#125;inline int C(int n, int m) &#123; if (n &lt; m) return 0; return 1ll * fac[n] * ifac[m] % mod * ifac[n - m] % mod;&#125;int main() &#123; fac[0] = ifac[0] = 1; for (int i = 1; i &lt; M; ++i) fac[i] = 1ll * fac[i - 1] * i % mod; ifac[M - 1] = fpow(fac[M - 1]); for (int i = M - 2; i; --i) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % mod; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; x[i] = rd(); y[i] = rd(); ++f[-x[i] + G][-y[i] + G]; &#125; for (int i = 1; i &lt; A; ++i) for (int j = 1; j &lt; A; ++j) f[i][j] = mo(f[i][j] + f[i - 1][j] + f[i][j - 1]); int ans = 0; for (int i = 1; i &lt;= n; ++i) ans = mo(ans + f[x[i] + G][y[i] + G] - C(2 * (x[i] + y[i]), 2 * x[i])); printf(&quot;%lld\\n&quot;, 1ll * ans * inv2 % mod); return 0;&#125; F - Wide Swap 给定一个 \\(\\{1,2,\\dots,n\\}\\) 的排列 \\(\\{P\\}\\) ，每次操作： 选取两个距离至少为 \\(k\\) 的位置 \\(i,j\\) 且 \\(|P_i-P_j|=1\\) ，交换 \\(i,j\\) 两个位置上的数。 你可以任意次数操作，问可能得到的最小字典序排列是什么。 排列求个逆（即 \\(Q_{P_i}=i\\) ），\\(Q_i\\) 的含义就是数字 \\(i\\) 的位置。 问题转化为：相邻并且差值至少为 \\(k\\) 的两个 \\(Q\\) 可以交换，\\(Q\\) 可能最小字典序是什么（小的数字位置靠前）。 如果 \\(|Q_i-Q_j|&lt;k\\) ，那么 \\(Q_i\\) 和 \\(Q_j\\)在序列里的相对顺序永远都不能改变（换到相邻就不能操作了）。反之如果两个位置差值 \\(\\ge k\\)，只要能换到相邻，就一定可以交换，如果换不到相邻，一定是上面的约束导致的。所以如果 \\(|Q_i-Q_j|\\ge k\\) ，那么\\(Q_i\\) 和 \\(Q_j\\) 在序列里的顺序没有任何要求。 只有 \" \\(a\\) 一定要在 \\(b\\) 前\" 这种约束的最小字典序排列显然可以用优先队列的拓扑排序求。 但是边的级别是 \\(\\mathcal{O}(n^2)\\) 的： \\(Q_i\\) 会向 \\(\\forall j&gt;i,Q_j\\in[Q_i-k + 1,Q_i + k-1]\\) 的所有 \\(Q_j\\) 连边。 考虑去掉一些没有意义的边：假设 \\((x,y),(y,z),(x,z)\\) 都存在，那么 \\((x,z)\\) 显然是没必要存的。 把区间拆成两块 \\([Q_i-k+1,Q_i],[Q_i,Q_i+k-1]\\) ，这两个区间内部有约束的肯定会两两连边（单向）。 因此 \\(Q_i\\) 并不需要向这里面的全部点连边，完全可以继承区间里最靠前的位置的所有边，然后让自己指向这个位置即可。 形式化的说，对于某个区间，找到 \\(pos = \\min_{Q_j\\in [\\text{interval}]} j\\) ，那么只需要连 \\(Q_i\\to Q_{pos}\\) ，其余边都间接继承 \\(Q_{pos}\\) 的。 这样边的级别（也就是拓扑排序复杂度）就是 \\(\\mathcal{O}(n)\\) 的，找 \\(pos\\) 需要单点更新查区间 \\(\\min\\) ，用线段树复杂度 \\(\\mathcal{O}(n\\log n)\\) 。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 500007#define ls (rt &lt;&lt; 1)#define rs (rt &lt;&lt; 1 | 1)#define mid ((l + r) &gt;&gt; 1)int mn[N &lt;&lt; 2];void pushup(int rt) &#123; mn[rt] = min(mn[ls], mn[rs]);&#125;void upd(int rt, int l, int r, int k, int v) &#123; if (l == r) &#123; mn[rt] = v; return; &#125; if (k &lt;= mid) upd(ls, l, mid, k, v); else upd(rs, mid + 1, r, k, v); pushup(rt);&#125;int qmn(int rt, int l, int r, int L, int R) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) return mn[rt]; int ans = 1e9; if (L &lt;= mid) ans = min(ans, qmn(ls, l, mid, L, R)); if (R &gt; mid) ans = min(ans, qmn(rs, mid + 1, r, L, R)); return ans;&#125;int p[N], q[N], deg[N];vector&lt;int&gt; e[N];#define pb push_backpriority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;que;int main() &#123; int n = rd(), k = rd(); memset(mn, 0x3f, sizeof(mn)); for (int i = 1; i &lt;= n; ++i) q[p[i] = rd()] = i; for (int i = n; i; --i) &#123; int j = qmn(1, 1, n, q[i], min(n, q[i] + k - 1)); if (j &lt;= n) &#123;e[q[i]].pb(q[j]); ++deg[q[j]];&#125; j = qmn(1, 1, n, max(1, q[i] - k + 1), q[i]); if (j &lt;= n) &#123;e[q[i]].pb(q[j]); ++deg[q[j]];&#125; upd(1, 1, n, q[i], i); &#125; for (int i = 1; i &lt;= n; ++i) if (!deg[i]) que.push(i); for (int i = 1; i &lt;= n; ++i) &#123; int u = q[i] = que.top(); que.pop(); for (auto v : e[u]) if (!(--deg[v])) que.push(v); &#125; for (int i = 1; i &lt;= n; ++i) p[q[i]] = i; for (int i = 1; i &lt;= n; ++i) printf(&quot;%d\\n&quot;, p[i]); return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"http://blog.gyx.me/categories/Solution/"},{"name":"AtCoder","slug":"Solution/AtCoder","permalink":"http://blog.gyx.me/categories/Solution/AtCoder/"},{"name":"AtCoder Grand Contest","slug":"Solution/AtCoder/AtCoder-Grand-Contest","permalink":"http://blog.gyx.me/categories/Solution/AtCoder/AtCoder-Grand-Contest/"}],"tags":[{"name":"Constructive Algorithm","slug":"Constructive-Algorithm","permalink":"http://blog.gyx.me/tags/Constructive-Algorithm/"}]},{"title":"AtCoder Beginner Contest 244","slug":"abc224","date":"2022-03-29T07:46:14.000Z","updated":"2022-05-29T00:47:40.554Z","comments":true,"path":"2022/03/29/abc224/","link":"","permalink":"http://blog.gyx.me/2022/03/29/abc224/","excerpt":"","text":"A, B, C 比较简单就不写了。 我的代码 : All Submissions - SGColin D. Swap Hats 给定两个 \"RGB\" 这个字符串的排列 \\(A,B\\) ，每次操作可以交换两个位置。 问能否正好操作 \\(10^{18}\\) 把 \\(A\\) 变成 \\(B\\) 。 假设 R=1,G=2,B=3 ，我们可以通过逆序数奇/偶把所有排列分两类。 因为只有三个位置，可以发现转换关系的连边是个完全二分图。 所以根据 \\(A\\) 和 \\(B\\) 不同的位数 \\(cnt\\) 即可判定是哪种情况。 \\(cnt=0\\) 完全相同，一直交换某两位即可。 \\(cnt=2\\) 逆序数相同，但排列不同，不可能通过偶数次交换得到。 \\(cnt=3\\) 逆序数不同，因为是完全二分图，一定可以通过两次操作把 \\(A\\) 变成 \\(B\\) ，后面参考 \\(cnt=0\\) 操作即可。 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;char a[3], b[3];inline char gc() &#123; char c = getchar(); while (!isalpha(c)) c = getchar(); return c;&#125;int main() &#123; for (int i = 0; i &lt; 3; ++i) a[i] = gc(); for (int i = 0; i &lt; 3; ++i) b[i] = gc(); int cnt = 0; for (int i = 0; i &lt; 3; ++i) cnt += (a[i] != b[i]); puts((cnt == 0 || cnt == 3) ? &quot;Yes&quot; : &quot;No&quot;); return 0;&#125; E. King Bombee 定义无向图 \\(G=(V,E)\\) 的一个长度为 \\(K\\) 的路径序列 \\(\\{A\\}\\) ： 由 \\(K+1\\) 个点编号 \\(A_0,\\dots,A_K\\in V\\) 构成，\\(A_0\\) 是起点，\\(A_K\\) 是终点，且 \\(\\forall 0\\le i &lt; K, (A_i, A_{i+1})\\in E\\) 给定无向图 \\(G\\ (|V|\\le 2000,|E|\\le 2000)\\) 求有多少个长度为 \\(K\\ (K\\le 2000)\\) 的路径序列，满足： 起点为 \\(S\\) ，终点为 \\(T\\) ，且点 \\(X\\) 在序列中出现偶数次（可以为 \\(0\\) ) 。 感觉最近 ABC 每场都会有一道比较暴力的 DP，就看敢不敢写（ 设 f[i][u][0/1] 表示当前考虑长度为 \\(i\\) 的路径，起点是 \\(S\\) ，终点是 \\(u\\) ，当前节点 \\(X\\) 在其中出现偶数/奇数次的方案数。 初始状态 f[0][S][S==X] = 1 ，答案 f[K][T][0] 。 转移暴力做就可以了，枚举下一步走哪里（ \\(u\\to v\\) ） ：f[i+1][v][k^(v == X)] += f[i][u][k] 。 这个题的核心在复杂度计算，外层枚举 \\(i\\) 是 \\(\\mathcal O(n)\\) 的，内层枚举 \\(u\\) 是 \\(\\mathcal O(n)\\) 的，枚举 \\(v\\) 复杂度怎么算？ 把后两个的复杂度放到一起考虑，就是 \\(\\sum_{u=1}^n deg(u) = \\mathcal O(m)\\) 所以总复杂度是 \\(\\mathcal O(nm)\\) 的。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 2007#define mod 998244353#define add(a, b) (a) = ((a) + (b)) % modvector&lt;int&gt; e[N];int f[N][N][2];int main() &#123; int n = rd(), m = rd(); int k = rd(), s = rd(), t = rd(), x = rd(); for (int i = 1; i &lt;= m; ++i) &#123; int u = rd(), v = rd(); e[u].push_back(v); e[v].push_back(u); &#125; f[0][s][x == s] = 1; for (int i = 0; i &lt; k; ++i) for (int u = 1; u &lt;= n; ++u) for (int k = 0; k &lt;= 1; ++k) &#123; if (!f[i][u][k]) continue; for (auto v : e[u]) &#123; int tar = (k ^ (v == x)); add(f[i + 1][v][tar], f[i][u][k]); &#125; &#125; printf(&quot;%d\\n&quot;, f[k][t][0]); return 0;&#125; F. Shortest Good Path 题意比较复杂，我简单描述一下。 定义无向图 \\(G=(V,E)\\) 的一个长度为 \\(K+1\\) 的路径序列 \\(\\{A\\}\\) ： 由 \\(K+1\\) 个点编号 \\(A_0,\\dots,A_K\\in V\\) 构成，\\(A_0\\) 是起点，\\(A_K\\) 是终点，且 \\(\\forall 0\\le i &lt; K, (A_i, A_{i+1})\\in E\\) 定义路径序列 \\(\\{A\\}\\) 符合要求序列 \\(S\\ (|S| = n, S_i = 0/1)\\) ，当且仅当： 若 \\(S_u = 0\\) ，则 \\(u\\) 在 \\(\\{A\\}\\) 中出现了偶数次（可以为 \\(0\\) ） 若 \\(S_u = 1\\) ，则 \\(u\\) 在 \\(\\{A\\}\\) 中出现了奇数次 那么对于所有的 \\(S=0,\\cdots,2^n-1\\) ，都会存在一个路径序列满足 \\(S\\) 的要求。 记满足 \\(S\\) 要求的路径序列最短为 \\(f(S)\\) ，求 \\(\\sum_{S=0}^{2^n-1}f(S)\\) 看到 ABC 出 \\(n\\le 17\\) 就是状压或者超级暴力了。 考虑路径之间互相更新转移，那么状态之间需要区分的，除了当前每个点出现奇数/偶数次以外，还有最后一个点的编号。 定义符合序列 \\(S\\) 且最后一个点是 \\(u\\) 的状态集编号为 sta[S][u] 。 那么对于每一个 \\(u\\to v\\) ，对所有的 \\(S\\) 连边 sta[S][u] -&gt; sta[S ^ (1 &lt;&lt; v)][v] 最后补上初始状态的连边 source -&gt; sta[1 &lt;&lt; u][u] 那么跑 BFS 就可以求出来每个状态所需的最小长度了（从 source 出发的距离） 那么 \\(f(S) = \\min_{u} dis[sta[S][u]]\\) 即可，复杂度即状态数乘转移数 \\(\\mathcal O(n^2\\ast 2^n)\\) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 17#define M 5000007#define pb push_backint id[1 &lt;&lt; N][N], cnt, dis[M];vector&lt;int&gt; e[M];queue&lt;int&gt; q;int main() &#123; int n = rd(), m = rd(); int S = (1 &lt;&lt; n) - 1; for (int s = 0; s &lt;= S; ++s) for (int u = 0; u &lt; n; ++u) id[s][u] = ++cnt; for (int i = 1; i &lt;= m; ++i) &#123; int u = rd() - 1, v = rd() - 1; for (int s = 0; s &lt;= S; ++s) &#123; e[id[s][u]].pb(id[s ^ (1 &lt;&lt; v)][v]); e[id[s][v]].pb(id[s ^ (1 &lt;&lt; u)][u]); &#125; &#125; for (int i = 0; i &lt; n; ++i) e[0].pb(id[1 &lt;&lt; i][i]); memset(dis, 0x3f, sizeof(dis)); dis[0] = 0; q.push(0); while (!q.empty()) &#123; int u = q.front(); q.pop(); for (auto v : e[u]) if (dis[v] &gt; dis[u] + 1) &#123;dis[v] = dis[u] + 1; q.push(v);&#125; &#125; ll ans = 0; for (int s = 1, tmp; s &lt;= S; ++s) &#123; tmp = 1e9; for (int u = 0; u &lt; n; ++u) &#123; tmp = min(tmp, dis[id[s][u]]); &#125; ans += tmp; &#125; printf(&quot;%lld\\n&quot;, ans); return 0;&#125; G. Construct Good Path 定义无向图 \\(G=(V,E)\\) 的一个长度为 \\(K+1\\) 的路径序列 \\(\\{A\\}\\) ： 由 \\(K+1\\) 个点编号 \\(A_0,\\dots,A_K\\in V\\) 构成，\\(A_0\\) 是起点，\\(A_K\\) 是终点，且 \\(\\forall 0\\le i &lt; K, (A_i, A_{i+1})\\in E\\) 定义路径序列 \\(\\{A\\}\\) 符合要求序列 \\(S\\ (|S| = n, S_i = 0/1)\\) ，当且仅当： 若 \\(S_u = 0\\) ，则 \\(u\\) 在 \\(\\{A\\}\\) 中出现了偶数次（可以为 \\(0\\) ） 若 \\(S_u = 1\\) ，则 \\(u\\) 在 \\(\\{A\\}\\) 中出现了奇数次 给定连通无向图 \\(G\\) 和要求序列 \\(S\\) ，构造一个长度不超过 \\(4\\ast |V|\\) 的序列符合 \\(S\\) 图只有连通的性质，那么可以考虑树怎么解决，其他情况找一棵生成树就可以了。 设 \\(A_u\\) 为 \\(u\\) 子树的合法序列：满足 \\(u\\) 子树内，除了 \\(u\\) 以外其他点都符合要求的一个序列。 强制叶子 \\(v\\) 对应的 \\(A_v=(v)\\) 。 其他情况如果令 \\(A_u=(u)+A_{son1}+(u)+A_{son2}+\\cdots+(u)\\) ，那么只有 \\(son\\) 这些节点会不合法。 那么对于每个导致不合法的 \\(son\\) ，给序列最后接上一个 \\((son,u)\\) 就可以保证 \\(son\\) 合法。 用数学归纳法做正确性证明：\\(|A_u|\\le 4 \\astsize_u-3\\) ，其中 \\(size_u\\) 为\\(u\\) 子树大小。对于叶子，\\(|A_u|=1=4\\ast1-3\\)假设对于一个点 \\(u\\)，所有儿子节点 \\(son\\)都符合，那么这个点的序列：必须添加 \\(cntson + 1\\) 个 \\((u)\\) ，还有所有的 \\(A_{son}\\)，其余的每个补充会增加两个点。\\[\\begin{array}{ll}|A_u| &amp; \\le \\sum_{son} A_{son} + cntson + 1 + 2 \\ast cntson\\\\\\\\\\ &amp; \\le \\sum_{son} (4 \\ast size_{son} - 3) + 3\\ast cntson +1\\\\\\\\\\ &amp; = 4 \\ast \\sum_{son} size_{son} - 3\\ast cntson + 3\\ast cntson+ 1\\\\\\\\\\ &amp; = 4 \\ast (size_u - 1) + 1\\\\\\\\\\ &amp; = 4 \\ast size_u - 3\\end{array}\\] 这样就证明了，最后根的序列大小不超过 \\(4N - 3\\) 。 最后序列中如果根节点奇偶性不对，那么随便找一个根节点的儿子 \\(son\\) ，补一个 \\((son,u,son)\\) 即可修正。 这样子序列长度的上限刚好是 \\(4N\\) ，复杂度 \\(\\mathcal{O}(n)\\)。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;inline bool gn() &#123; char c = getchar(); for (; !isdigit(c); c = getchar()); return c - &#x27;0&#x27;;&#125;#define N 100007#define pb push_backvector&lt;int&gt; e[N], res;bool vis[N], s[N];void add(int x) &#123; s[x] ^= 1; res.pb(x);&#125;void dfs(int u) &#123; vis[u] = 1; add(u); for (auto v : e[u]) if (!vis[v]) &#123; //当前点没在树里出现过 dfs(v); add(u); if (s[v]) &#123;add(v); add(u);&#125; &#125;&#125;int main() &#123; int n = rd(), m = rd(); for (int i = 1; i &lt;= m; ++i) &#123; int u = rd(), v = rd(); e[u].pb(v); e[v].pb(u); &#125; for (int i = 1; i &lt;= n; ++i) s[i] = gn(); dfs(1); if (s[1]) &#123; int son = e[1][0]; add(son); add(1); add(son); &#125; printf(&quot;%d\\n&quot;, (int)res.size()); for (auto x : res) printf(&quot;%d &quot;, x); return 0;&#125; Ex. Linear Maximization 维护一个二维向量集，支持： 插入一个二维向量 \\((x, y)\\) 查询集合中和给定向量 \\((u, v)\\) 点积的最大值 [SDOI2014]向量集 弱化版，线段树维护凸包即可。","categories":[{"name":"Solution","slug":"Solution","permalink":"http://blog.gyx.me/categories/Solution/"},{"name":"AtCoder","slug":"Solution/AtCoder","permalink":"http://blog.gyx.me/categories/Solution/AtCoder/"},{"name":"AtCoder Beginner Contest","slug":"Solution/AtCoder/AtCoder-Beginner-Contest","permalink":"http://blog.gyx.me/categories/Solution/AtCoder/AtCoder-Beginner-Contest/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"},{"name":"Constructive Algorithm","slug":"Constructive-Algorithm","permalink":"http://blog.gyx.me/tags/Constructive-Algorithm/"},{"name":"Bitmask","slug":"Bitmask","permalink":"http://blog.gyx.me/tags/Bitmask/"}]},{"title":"Google Code Jam to I/O for Women 2022","slug":"codejamio2022","date":"2022-03-27T16:00:00.000Z","updated":"2022-05-10T06:54:28.787Z","comments":true,"path":"2022/03/28/codejamio2022/","link":"","permalink":"http://blog.gyx.me/2022/03/28/codejamio2022/","excerpt":"","text":"A. Inversions Organize 给你一个 \\(2n\\times 2n\\) 的 01 矩阵，问你最少反转多少个位置，能够做到上下两半1的个数相同，左右两半1的个数相同。 以中点为原点，设最后四个象限的 1 的个数分别为 \\(a,b,c,d\\) 。 需要满足：\\(a+b=b+c=c+d=d+a\\) ，可以推出 \\(a=c,b=d\\) 。 因此把一三象限 1 的个数调整到相同、二四象限 1 的个数调整到相同即可。 答案就是 \\(|cnt_1-cnt_3|+|cnt_2-cnt_4|\\) ，复杂度 \\(\\mathcal O(n^2)\\)。 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;inline int gc() &#123; char c = getchar(); while (!isalpha(c)) c = getchar(); return c == &#x27;I&#x27;;&#125;int testcase;inline void work() &#123; printf(&quot;Case #%d: &quot;, ++testcase); int n; cin &gt;&gt; n; int m = n * 2; int a = 0, b = 0; for (int i = 1; i &lt;= m; ++i) for (int j = 1; j &lt;= m; ++j) &#123; int x = gc(); if (i &lt;= n &amp;&amp; j &lt;= n) a += x; else if (i &lt;= n &amp;&amp; j &gt; n) b += x; else if (i &gt; n &amp;&amp; j &lt;= n) b -= x; else a -= x; &#125; printf(&quot;%d\\n&quot;, abs(a) + abs(b));&#125;int main() &#123; int t; cin &gt;&gt; t; for (; t; t--) work(); return 0;&#125; B. Ingredient Optimization 有 \\(n\\) 批货物，第 \\(i\\) 批货物有 \\(L_i\\) 个，\\(M_i\\) 时刻送达，\\(M_i+E_i\\) 时刻起就不能再用了。 有 \\(q\\) 个订单，第 \\(i\\) 个在 \\(O_i\\) 时刻 \\((O_{i-1}&lt;O_i)\\) ，需要 \\(U\\) 个货物制作。 某一次做不了商店就倒闭了（后面订单都不做），问最优策略下能完成多少个订单。 贪心即可，扫描订单，每次先把当前可用的集合用一个堆维护一下。 然后优先取用最早过保质期的商品即可，处理需要一些细节，复杂度 \\(\\mathcal{O}((n+q)\\log n)\\)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 107#define fr first#define sc second#define pb push_back#define mp make_pair#define pii pair&lt;int, int&gt;vector&lt;pii&gt; q;int testcase, a[N], b[N];struct node &#123; int id; inline bool operator &lt; (const node &amp;obj) const&#123; return b[id] &gt; b[obj.id]; &#125;&#125;;priority_queue&lt;node&gt; s;inline void work() &#123; q.clear(); while (!s.empty()) s.pop(); printf(&quot;Case #%d: &quot;, ++testcase); int n = rd(), m = rd(), u = rd(); for (int i = 1; i &lt;= n; ++i) &#123; int t = rd(); a[i] = rd(); b[i] = t + rd(); q.pb(mp(t, i)); q.pb(mp(b[i], -i)); &#125; sort(q.begin(), q.end()); int ans = 0, fl = 1; for (int i = 1, ptr = 0; i &lt;= m; ++i) &#123; int t = rd(); while (ptr &lt; 2 * m &amp;&amp; q[ptr].fr &lt;= t) &#123; if (q[ptr].sc &lt; 0) a[-q[ptr].sc] = 0; else s.push((node)&#123;q[ptr].sc&#125;); ++ptr; &#125; int tmp = u; while (tmp &amp;&amp; !s.empty()) &#123; int id = s.top().id; int del = min(a[id], tmp); tmp -= del; a[id] -= del; if (a[id] == 0) s.pop(); &#125; if (tmp) fl = 0; ans += fl; &#125; printf(&quot;%d\\n&quot;, ans);&#125;int main() &#123; int t; cin &gt;&gt; t; for (; t; t--) work(); return 0;&#125; C. Interesting Outing 给一棵树，有边权，求一个最短的路径，使得所有点都至少被访问到一次。 定义 \\(f_{i,0/1}\\) 表示 \\(i\\) 的子树全部访问完，回到 / 不回到 \\(i\\) 的最短路径长度，答案就是 \\(f_{root,1}\\) 转移方程：设 \\(w_{i, son}\\) 表示 \\(i\\) 和儿子 \\(son\\) 之间的边权。 \\(f_{i,0}=\\sum_{son}(f_{son,0}+w_{i, son})\\) ， \\(f_{i,1}=f_{i,0}-\\max_{son}(f_{son,0}-f_{son,1} + w_{i,son})\\) 复杂度 \\(\\mathcal{O}(n)\\) 。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 1007int testcase, hd[N], tot;struct edge &#123;int to, nxt, w;&#125;e[N &lt;&lt; 1];ll f[N][2];void dfs(int u, int fa) &#123; ll mx = 0; for (int i = hd[u], v; i; i = e[i].nxt) if ((v = e[i].to) != fa) &#123; dfs(v, u); f[u][0] += f[v][0] + 2 * e[i].w; mx = max(mx, f[v][0] - f[v][1] + e[i].w); &#125; f[u][1] = f[u][0] - mx;&#125;inline void work() &#123; printf(&quot;Case #%d: &quot;, ++testcase); tot = 0; memset(hd, 0, sizeof(hd)); int n = rd(); for (int i = 1; i &lt; n; ++i) &#123; int u = rd(), v = rd(), w = rd(); e[++tot].to = v; e[tot].w = w; e[tot].nxt = hd[u]; hd[u] = tot; e[++tot].to = u; e[tot].w = w; e[tot].nxt = hd[v]; hd[v] = tot; &#125; ll ans = 1e18; for (int i = 1; i &lt;= n; ++i) &#123; memset(f, 0, sizeof(f)); dfs(i, i); ans = min(ans, min(f[i][0], f[i][1])); &#125; printf(&quot;%lld\\n&quot;, ans);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; D. Inventor Outlasting 给定一个 \\(R\\times C\\) 的地图，上面有黄色和绿色的点。 两个人博弈，每次可以选择一个黄色的点操作，不能操作的人输。 操作就是把这个点染黑，然后从个点按照 X 形发散染黑。具体的，就是从这个点开始按照四个 \\(45^\\circ\\) 方向扩展把所有点染黑，直到碰到边界，或当前要染的格子已经被染黑后，不继续往这个方向扩展。 问先手第一步有多少种不同的下法保证必胜。 首先观察这个地图可以拆成两张，按照 \\((\\) 行号+列号 \\()\\) 的奇偶性可以把图分开，互不影响。 进一步的，如果把坐标系转 \\(45^\\circ\\) ，可以发现每次操作就相当于把一个以黑色为边界的矩形横竖各切一刀。 所以其实是把当前的游戏转化成了四个子游戏的并，根据 SG 引理，当前状态的 SG 值就是四个子游戏的 SG 值的异或。 本质不同的游戏数取决于当前“矩形”在原地图中的位置，所以有 \\(O(R^2\\times C^2)\\) 个。 每次枚举下一个操作的是哪个位置，复杂度 \\(\\mathcal{O}(R\\times C)\\) ，所以记忆化搜索 SG 函数总复杂度 \\(\\mathcal{O}(R^3\\times C^3)\\) 。 需要注意第一次的选择的时候，是把游戏划分为五种情况的并，除了四个子矩形，还有另外一张图（奇偶性不同）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;inline int gc() &#123; char c = getchar(); for (; c != &#x27;.&#x27; &amp;&amp; c != &#x27;X&#x27;; c = getchar()); return c == &#x27;X&#x27;;&#125;#define N 107#define pb push_backbool a[2][N][N];int testcase;unordered_map&lt;ll, int&gt; sg;inline ll hash_scope(ll id, ll a, ll b, ll c, ll d) &#123; return (((a * 200 + b) * 200 + c) * 200 + d) * 2 + id;&#125;int dp(int id, int lx, int rx, int ly, int ry) &#123; if (lx &gt; rx || ly &gt; ry) return 0; ll h = hash_scope(id, lx, rx, ly, ry); if (sg.find(h) != sg.end()) return sg[h]; vector&lt;int&gt; nxt; nxt.clear(); for (int x = lx; x &lt;= rx; ++x) for (int y = ly; y &lt;= ry; ++y) if (a[id][x][y]) &#123; int a = dp(id, lx, x - 1, ly, y - 1); int b = dp(id, lx, x - 1, y + 1, ry); int c = dp(id, x + 1, rx, ly, y - 1); int d = dp(id, x + 1, rx, y + 1, ry); nxt.pb(a ^ b ^ c ^ d); &#125; sort(nxt.begin(), nxt.end()); for (int i = 0, ptr = 0; ; ++i) &#123; if (ptr &gt;= nxt.size() || nxt[ptr] &gt; i) return sg[h] = i; for (; ptr &lt; nxt.size() &amp;&amp; nxt[ptr] == i; ++ptr); &#125;&#125;inline void work() &#123; sg.clear(); memset(a, 0, sizeof(a)); int r = rd(), c = rd(); int lx = 1e9, ly = 1e9; int rx = -1e9, ry = -1e9; for (int i = 1; i &lt;= r; ++i) for (int j = 1; j &lt;= c; ++j) &#123; int id = ((i + j) &amp; 1); int x = (i + j) / 2; int y = (i - j + 100) / 2; if ((a[id][x][y] = gc())) &#123; lx = min(lx, x); rx = max(rx, x); ly = min(ly, y); ry = max(ry, y); &#125; &#125; int ans = 0; for (int id = 0; id &lt;= 1; ++id) for (int x = lx; x &lt;= rx; ++x) for (int y = ly; y &lt;= ry; ++y) if (a[id][x][y]) &#123; int a = dp(id, lx, x - 1, ly, y - 1); int b = dp(id, lx, x - 1, y + 1, ry); int c = dp(id, x + 1, rx, ly, y - 1); int d = dp(id, x + 1, rx, y + 1, ry); ans += ((a ^ b ^ c ^ d ^ dp(id ^ 1, lx, rx, ly, ry)) == 0); &#125; printf(&quot;Case #%d: %d\\n&quot;, ++testcase, ans);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125;","categories":[{"name":"Competitions","slug":"Competitions","permalink":"http://blog.gyx.me/categories/Competitions/"},{"name":"Google's Coding Competitions","slug":"Competitions/Google-s-Coding-Competitions","permalink":"http://blog.gyx.me/categories/Competitions/Google-s-Coding-Competitions/"}],"tags":[{"name":"Greedy","slug":"Greedy","permalink":"http://blog.gyx.me/tags/Greedy/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"},{"name":"Game Theory","slug":"Game-Theory","permalink":"http://blog.gyx.me/tags/Game-Theory/"}]},{"title":"Codeforces Round #777 (Div. 2)","slug":"cf777","date":"2022-03-18T16:00:00.000Z","updated":"2022-05-19T01:11:58.678Z","comments":true,"path":"2022/03/19/cf777/","link":"","permalink":"http://blog.gyx.me/2022/03/19/cf777/","excerpt":"","text":"A 和 B 比较简单就不写了。 C. Madoka and Childish Pranks 一个初始是全白的矩阵，每次可以选一个子矩阵染成棋盘（左上角是白色） 构造一个不超过 \\(n*m\\) 次的方法把矩阵染成目标样子，或输出无解。 Key ：每次染一个 \\(1\\ast 2\\) 的，可以把右侧的变黑，\\(2\\ast 1\\) 的可以把下侧的变黑。 因此对于每一行，我又可以从右往左依次染 \\(1\\ast 2\\) ，除第一列任何位置都可以染黑。 对于第一列从下往上依次染 \\(2\\ast 1\\) ，除 \\((1,1)\\) 位置外都可以染黑。 所以只要 \\((1,1)\\) 不是黑色的就都有解。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;inline int gn() &#123; char c = getchar(); for (; !isdigit(c); c = getchar()); return c - &#x27;0&#x27;;&#125;#define N 107#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;int a[N][N];vector&lt;pair&lt;pii,pii&gt;&gt; s;inline void work() &#123; s.clear(); int n = rd(), m = rd(); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) a[i][j] = gn(); if (a[1][1]) &#123;puts(&quot;-1&quot;); return;&#125; for (int i = 1; i &lt;= n; ++i) for (int j = m; j &gt; 1; --j) if (a[i][j]) s.pb(mp(mp(i,j - 1), mp(i, j))); for (int i = n; i &gt; 1; --i) if (a[i][1]) s.pb(mp(mp(i - 1, 1), mp(i, 1))); printf(&quot;%d\\n&quot;, (int)s.size()); for (auto x : s) printf(&quot;%d %d %d %d\\n&quot;, x.fr.fr, x.fr.sc, x.sc.fr, x.sc.sc);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; D. Madoka and the Best School in Russia 定义一个数字 \\(x\\) 是好的，当且仅当 \\(x\\) 是 \\(d\\) 的倍数。 定义一个数字 \\(x\\) 是漂亮的，当且仅当他不能被拆分成两个好的数的乘积（也就是只含有一个 \\(d\\) ） 给你一个好的数 \\(x\\) ，问你是否有至少两种不同的方法，把 \\(x\\) 拆成若干个漂亮的数的乘积。 方法不同即拆分得到的数集不同。 因为每个漂亮数有且仅有一个 \\(d\\) ，因此 \\(x\\) 里有几个 \\(d\\) ，就至多要拆成几个漂亮数。 先考虑把 \\(x\\) 里的 \\(d\\) 都去掉，剩下的数是 \\(y\\) ，我们至少得到一种方案是 \\(d,d,\\dots,d,d\\ast y\\) 如果 \\(y\\) 可以拆分（不是素数），那么就肯定有解； 如果 \\(y\\) 不可拆分： 如果 \\(d\\) 不可拆分，肯定无解（没有可拆的了） 如果 \\(x\\) 里只有两个 \\(d\\) ，肯定无解（没有可拆的了） 如果 \\(x\\) 里有超过三个 \\(d\\) ，肯定有解（把 \\(y\\) 和 \\(d\\) 拆分得到的三个数，分配给另外三个 \\(d\\) ） 如果 \\(x\\) 里正好有三个 \\(d\\) ，需要检验一下把 \\(d\\) 拆出来的两部分某一部分分给 \\(y\\) 会不会形成新的 \\(d\\) 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 107inline void work() &#123; int x = rd(), d = rd(); if (x % d != 0) &#123;puts(&quot;NO&quot;); return;&#125; if (x / d % d != 0) &#123;puts(&quot;NO&quot;); return;&#125; int cnt = 0; for (; x % d == 0; x /= d, ++cnt); int lim = sqrt(x); for (int i = 2; i &lt;= lim; ++i) if (x % i == 0) &#123;puts(&quot;YES&quot;); return;&#125; if (cnt == 2) &#123;puts(&quot;NO&quot;); return;&#125; lim = sqrt(d); for (int i = 2; i &lt;= lim; ++i) if (d % i == 0) &#123; if (cnt &gt; 3) &#123;puts(&quot;YES&quot;); return;&#125; if (1ll * i * x % d != 0 || 1ll * d / i * x % d != 0) &#123;puts(&quot;YES&quot;); return;&#125; &#125; puts(&quot;NO&quot;);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; E. Madoka and the Sixth-graders 题意太复杂，我简单说一下，不清楚的看原题。 给定一个共 \\(n\\) 个点的内向基环树森林，开始每个点上有一个数（是 \\(n\\) 的排列）。 每一个时刻所有点按照所在边移动一次，如果某一时刻某个点上有很多数，只保留最小的。 如果某一时刻某个点上没数了（叶子），那么按照节点编号从小到大依次往里面塞 \\(n+1,n+2,\\dots\\) 现在给出森林的形态，和经过若干时刻后每个点上的数字 \\(a_1,\\dots,a_n\\) 。 请你还原出来一个字典序最小的初始状态，保证有解。 Key 1 ：假设已知经过的时间是 \\(t\\) ，那么每个点按照边移动 \\(t\\) 步以后的位置上的数字一定是不超过 \\(n\\) 的。 证明：如果是树的部分，那么 \\(n\\) 以后的数字永远追不上；如果是环的部分，因为 \\(n\\) 以后的数字比 \\(n\\) 大，所以都会被舍弃。 Key 2 ：两个点如果在某一步之后同时移动到了同一个点，那么后面的路径都相同（因为每个点只有一个出边）。 找出经过的时间 \\(t\\) ：假设叶子个数是 \\(cnt\\) ，序列里最大是 \\(mx\\) ，那么 \\(t=\\frac{mx - n}{cnt}\\) （每一次移动会引进 \\(cnt\\) 个数）。 每个位置可能会放哪个数？ 根据前面提到的 Key，假设 \\(u\\) 走 \\(t\\) 步之后到达的点是 \\(v\\) ，那么 \\(u\\) 上开始的数字要么是 \\(a_v\\) ，要么比 \\(a_v\\) 大，在移动的过程中某一步被挤掉了。 也就是说，如果一个点集 \\(S\\) 里所有点走 \\(t\\) 步以后到达的点都是 \\(v\\) ，那么这些点初始状态里有一个必定是 \\(a_v\\) ，其他都比 \\(a_v\\) 大。 怎么找 \\(v\\) ：因为每个点都只有一条出边，因此可以直接倍增找 怎么贪心？ 我们先令结果序列 \\(b_u=a_v\\) ，也就是假设每个点的初始状态就是走 \\(t\\) 步以后的位置上的值。 设 \\(S_x=\\\\{u|b_u=x\\\\}\\) ，考虑从小到大放数字 \\(x\\) ： 如果 \\(S_x\\ne \\emptyset\\) ，那么就把 \\(x\\) 放到 \\(S_x\\) 中位置最靠前的 如果 \\(S_x=\\emptyset\\) ，那么就把 \\(x\\) 放到 \\(S_1\\cup S_2\\cup\\dots\\cup S_{x-1}\\) 中未使用的最靠前的位置里。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 100007int f[N][40], a[N], res[N];bool vis[N];queue&lt;int&gt; s[N];set&lt;int&gt; S;inline void work() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; f[i][0] = rd(); vis[f[i][0]] = 1; &#125; for (int j = 1; j &lt; 40; ++j) for (int i = 1; i &lt;= n; ++i) f[i][j] = f[f[i][j - 1]][j - 1]; int mx = 0, cnt = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (!vis[i]) ++cnt; a[i] = rd(); mx = max(mx, a[i]); &#125; cnt = (mx - n) / cnt; memset(vis, 0, sizeof(vis)); for (int i = 1; i &lt;= n; ++i) &#123; int u = i; for (int k = 30; k &gt;= 0; --k) if (cnt &amp; (1 &lt;&lt; k)) u = f[u][k]; res[i] = a[u]; s[res[i]].push(i); vis[res[i]] = 1; //Sx不空 &#125; for (int i = 1; i &lt;= n; ++i) if (vis[i]) s[i].pop(); //把i放到Si最靠前的位置 int nw = 0; for (int i = 1; i &lt;= n; ++i) if (!vis[i]) &#123; while (nw &lt;= i) &#123; while (s[nw].size()) &#123; S.insert(s[nw].front()); s[nw].pop(); &#125; ++nw; &#125; res[*S.begin()] = i; S.erase(S.begin()); &#125; for (int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, res[i]);&#125;int main() &#123; for (int t = 1; t; --t) work(); return 0;&#125; F. Madoka and Laziness 给定一个没有重复数值的数列 \\(\\{a_i\\}\\) ，问有多少种方式将数列划分为两个峰序列（严格单增再单减）。 两种划分不同，当且仅当至少某一个峰序列的峰值不同（认为 &lt;a,b&gt; 和 &lt;b,a&gt; 相同）。 Key ：最大值一定是其中一个峰的峰值。 这个观察有什么用呢？因为一个峰值固定，我们可以得到答案是 O(n) 的。 也就是说，我们只需要去检验，其他的每一个值是否有可能成为峰值即可。 怎么检验呢？只需要判断是否存在一种拆分方式，使得到每个位置之前是升的，过了这个位置之后是降的，并且没给这个序列的元素扔给最大值所在的序列都合法。 我们可以假设另一个峰值（峰值B）在最大值（峰值A）的右侧，然后把序列翻过来再做一遍即可。 这样就有三个阶段： 到峰值A前：两个序列都上升 这一阶段序列A里只要单调递增，放多大的都可以。 我们为了后面序列B还要增的考虑，应该尽量减少序列B在这一部分的最大值。 设 \\(f_i\\) 为考虑前缀 \\(i\\) ，则 \\(a_i\\) 必定为某一个序列结尾，则另一个序列结尾最小值是多少。 转移很简单，接在 \\(a_{i-1}\\) 后，或接在 \\(f_{i-1}\\) 后。 12if (a[i] &gt; a[i - 1]) f[i] = min(f[i], f[i - 1]);if (a[i] &gt; f[i - 1]) f[i] = min(f[i], a[i - 1]); 峰值A后，峰值B前：序列A下降，序列B上升 这一阶段因为两个序列单调性不同，所以贪心策略也不同。 设 \\(g_{i,0}\\) 表示第 \\(i\\) 个元素放到序列A里，另一个序列（正在上升的序列B）末尾最小是多少。 设 \\(g_{i,1}\\) 表示第 \\(i\\) 个元素放到序列B里，另一个序列（正在下降的序列A）末尾最大是多少。 转移也很简单，讨论一下接在谁后面就好了。 1234if (a[i] &lt; a[i - 1]) g[i][0] = min(g[i][0], g[i - 1][0]);if (a[i] &lt; g[i - 1][1]) g[i][0] = min(g[i][0], a[i - 1]);if (a[i] &gt; a[i - 1]) g[i][1] = max(g[i][1], g[i - 1][1]);if (a[i] &gt; g[i - 1][0]) g[i][1] = max(g[i][1], a[i - 1]); 峰值B后：两个序列都下降 倒着考虑，变成单增的，那么在保证峰值B跟着的序列合法的前提下，另一个序列（留给峰值A的）的最大值要尽可能小。 因此处理方法同第一个阶段（设为 \\(h\\) 数组）。 那么怎么判断是否合法嘞？把 \\(a_i\\) 放到序列B里，另一个序列合法（ 也就是满足 g[i][1] &gt; h[i] ） 就可以啦～ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 500007#define inf 1e9 + 7int n, a[N], f[N], g[N][2];inline int calc() &#123; int p = 0; //maxpos for (int i = 1; i &lt;= n; ++i) &#123; f[i] = g[i][0] = inf; g[i][1] = -1; if (a[i] &gt; a[p]) p = i; &#125; for (int i = 1; i &lt;= p; ++i) &#123; if (a[i] &gt; a[i - 1]) f[i] = min(f[i], f[i - 1]); if (a[i] &gt; f[i - 1]) f[i] = min(f[i], a[i - 1]); &#125; g[p][0] = f[p]; //承接第一阶段的最宽松约束 for (int i = p + 1; i &lt;= n; ++i) &#123; if (a[i] &lt; a[i - 1]) g[i][0] = min(g[i][0], g[i - 1][0]); if (a[i] &lt; g[i - 1][1]) g[i][0] = min(g[i][0], a[i - 1]); if (a[i] &gt; a[i - 1]) g[i][1] = max(g[i][1], g[i - 1][1]); if (a[i] &gt; g[i - 1][0]) g[i][1] = max(g[i][1], a[i - 1]); &#125; int ans = 0; for (int i = n; i &gt; p; --i) &#123; if (a[i] &gt; a[i + 1]) f[i] = min(f[i], f[i + 1]); if (a[i] &gt; f[i + 1]) f[i] = min(f[i], a[i + 1]); if (g[i][1] &gt; f[i]) ++ans; &#125; return ans;&#125;int main() &#123; n = rd(); for (int i = 1; i &lt;= n; ++i) a[i] = rd(); int ans = calc(); reverse(a + 1, a + 1 + n); printf(&quot;%d\\n&quot;, ans + calc()); return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"http://blog.gyx.me/categories/Solution/"},{"name":"Codeforces","slug":"Solution/Codeforces","permalink":"http://blog.gyx.me/categories/Solution/Codeforces/"},{"name":"Codeforces Round","slug":"Solution/Codeforces/Codeforces-Round","permalink":"http://blog.gyx.me/categories/Solution/Codeforces/Codeforces-Round/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"},{"name":"Constructive Algorithm","slug":"Constructive-Algorithm","permalink":"http://blog.gyx.me/tags/Constructive-Algorithm/"}]},{"title":"PAT  Autumn 2021","slug":"pat2021","date":"2021-09-11T09:43:27.000Z","updated":"2021-10-11T09:43:27.000Z","comments":true,"path":"2021/09/11/pat2021/","link":"","permalink":"http://blog.gyx.me/2021/09/11/pat2021/","excerpt":"","text":"Background 某天心血来潮拉上 Eva 同学一起报名了 PAT ～ 开学前在 官方题库 里刷了两道题热身！其实是想刷完但是太鸽了 然后就到考试时间啦！借着考试翘掉了半天的军训！好耶！ Solution ( Top Level ) 代码写的赶时间，比较丑。 A. Sorted Cartesian tree 给定 \\(n\\) 个pair&lt;priority, key&gt; ，构建一棵 \\(n\\) 个节点的二叉树，满足：节点 priority 关键字满足堆的性质，即priority 父节点小于子节点节点 key 关键字满足二叉搜索树的性质，即中序遍历key 单调不降把树建出来，输出 priority 和 key 的Level-order traversal 序列 模拟题意 dfs 建树，传一个 set&lt;node&gt; 即可。 求层序遍历一个 bfs 就够了 考场上写了个dfn+dep双关键字排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;#define N 37using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125; struct node &#123;int k, p, id;&#125; c[N];inline bool operator &lt; (const node &amp;a, const node &amp;b) &#123; if (a.p != b.p) return a.p &lt; b.p; if (a.k != b.k) return a.k &lt; b.k; return a.id &lt; b.id;&#125;int ls[N], rs[N], k[N], p[N];set&lt;node&gt; S;int dfs(set&lt;node&gt; s) &#123; if (s.empty()) return 0; node nw = *s.begin(); s.erase(nw); set&lt;node&gt; l, r; for (auto t : s) &#123; if (t.k &lt;= nw.k) l.insert(t); else r.insert(t); &#125; ls[nw.id] = dfs(l); rs[nw.id] = dfs(r); return nw.id;&#125;queue&lt;int&gt; q;int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; c[i].id = i; c[i].k = rd(); c[i].p = rd(); S.insert(c[i]); &#125; int ptr = 0, rt = dfs(S); q.push(rt); while (!q.empty()) &#123; int u = q.front(); q.pop(); if (ls[u]) q.push(ls[u]); if (rs[u]) q.push(rs[u]); k[++ptr] = c[u].k; p[ptr] = c[u].p; &#125; for (int i = 1; i &lt; n; ++i) printf(&quot;%d &quot;, k[i]); printf(&quot;%d\\n&quot;, k[n]); for (int i = 1; i &lt; n; ++i) printf(&quot;%d &quot;, p[i]); printf(&quot;%d&quot;, p[n]); return 0;&#125; B. Unity is Strength 给一张有权无向图，以及若干条可以花 \\(w_i\\) 连接 \\(u_i,v_i\\) 的无向边。先输出每个联通块的 \"块内最小编号 - 块内最小边权\"，按照块大小-最小边权-最小点编号的顺序排序然后计算把整个图联通的最小代价，除给定边外，任意两点之间都可以花\\(10^4\\) 的代价连接一条边。 并查集模拟题意即可，第一步求出来每个集合的若干信息，然后排序一下。 之后就是最小生成树，考虑给定边不一定能让整个图联通，最后答案加上（联通块数 \\(-1\\) ）\\(\\times 10^4\\) 即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;#define N 100007#define inf 1e9using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125; int f[N], mn[N], mnid[N], sz[N], totr, totc;struct road &#123; int u, v, w;&#125;r[N]; inline bool cmp2(road a, road b) &#123; return a.w &lt; b.w;&#125; inline int find(int x) &#123; return x == f[x] ? x : f[x] = find(f[x]);&#125;inline void merge(int a, int b, int w) &#123; a = find(a); b = find(b); if (a == b) &#123; mn[a] = min(mn[a], w); return; &#125; f[a] = b; sz[b] += sz[a]; mnid[b] = min(mnid[b], mnid[a]); mn[b] = min(mn[b], min(mn[a], w));&#125;struct node &#123; int mnid, sz, str;&#125;c[N]; inline bool cmp1(node a, node b) &#123; if (a.str != b.str) return a.str &gt; b.str; if (a.sz != b.sz) return a.sz &gt; b.sz; return a.mnid &lt; b.mnid;&#125;int main() &#123; int n = rd(); int m = rd(); for (int i = 1; i &lt;= n; ++i) &#123; f[i] = i; mn[i] = inf; mnid[i] = i; sz[i] = 1; &#125; for (int i = 1, u, v, w; i &lt;= m; ++i) &#123; u = rd(); v = rd(); w = rd(); if (w &gt; 0) merge(u, v, w); else r[++totr] = (road)&#123;u, v, -w&#125;; &#125; for (int i = 1; i &lt;= n; ++i) if (f[i] == i) c[++totc] = (node)&#123;mnid[i], sz[i], (mn[i] == inf ? 0 : mn[i])&#125;; sort(c + 1, c + 1 + totc, cmp1); for (int i = 1; i &lt; totc; ++i) printf(&quot;%d-%d &quot;, c[i].mnid, c[i].str); printf(&quot;%d-%d\\n&quot;, c[totc].mnid, c[totc].str); int ans = 0; sort(r + 1, r + 1 + totr, cmp2); for (int i = 1; i &lt;= totr; ++i) &#123; int u = find(r[i].u); int v = find(r[i].v); if (u != v) &#123;merge(u, v, r[i].w); ans += r[i].w;&#125; &#125; int cnt = 0; for (int i = 1; i &lt;= n; ++i) cnt += (f[i] == i); ans += (cnt - 1) * 10000; printf(&quot;%d&quot;, ans); return 0;&#125; C. Manhattan 给定一个序列 \\(\\{ a_i \\}\\ (1\\le a_i\\le3)\\)，两个人玩（开始双方均为 \\(0\\) 分），每次某个人取走最靠前的 \\(a_i\\) 加到当前的得分里。要求每个人拿完之后，当前的得分不得少于对方，问有多少种划分方案，答案\\(\\mod 10^ 9 + 7\\) 裸的 DP 就是 f[i][j] 表示当前考虑前 \\(i\\) 个数，第一个人比第二个人多 \\(j\\) 的方案数。 因为 \\(a_i\\le 3\\) ，所以如果某个人比另一个人多了超过 \\(3\\) 分，对手就无法满足要求，之后就只能是这个人拿了。 所以 j 可以把特殊的状态放到一起，范围就只有 \\(9\\) 了，复杂度 \\(O (9n)\\) ，转移要注意条件。 实现的时候整体偏移了 \\(5\\) ，也就是 \\(j=5\\) 时两个人得分一样。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;#define N 100007#define mod 1000000007using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125; int f[N][10];#define add(a,b) a = (a + b) % modint main() &#123; f[0][5] = 1; int n = rd(); for (int i = 1, x; i &lt;= n; ++i) &#123; x = rd(); for (int j = 1; j &lt;= 9; ++j) &#123; if (j - x &lt;= 1) add(f[i][1], f[i - 1][j]); if (j + x &gt;= 9) add(f[i][9], f[i - 1][j]); &#125; for (int j = 2; j &lt;= 8; ++j) &#123; if (j - x &gt; 1 &amp;&amp; j - x &lt;= 5) add(f[i][j - x], f[i - 1][j]); if (j + x &lt; 9 &amp;&amp; j + x &gt;= 5) add(f[i][j + x], f[i - 1][j]); &#125; &#125; int ans = 0; for (int i = 1; i &lt;= 9; ++i) add(ans, f[n][i]); printf(&quot;%d&quot;, ans); return 0;&#125; Summary 比赛之前比较焦虑（毕竟军训一周都没碰键盘），到考场发现左边坐的是学长。 开场把三个题都开了， 题目描述都十分迷惑（英语太差），结合样例枚举题意读题。 分不清：Preorder 先序；Inorder 中序；Postorder 后序；Level-order traversal 层序遍历 过题顺序 T2 - T1 - T3 ，看榜应该是 Rank 2，所有题都是一次过非常舒适。 然后就提前跑路了！因为 Eva 同学还在奋战，我就开始快乐的浙传半日游～ 浙传的校园就比较有感觉，总觉得杭电的楼都是一个样子的，缺点大学的气息... 井盖上超级可爱的小王子和狐狸～","categories":[{"name":"Competitions","slug":"Competitions","permalink":"http://blog.gyx.me/categories/Competitions/"},{"name":"Programming Ability Test","slug":"Competitions/Programming-Ability-Test","permalink":"http://blog.gyx.me/categories/Competitions/Programming-Ability-Test/"}],"tags":[{"name":"Union-Find Set","slug":"Union-Find-Set","permalink":"http://blog.gyx.me/tags/Union-Find-Set/"},{"name":"Counting","slug":"Counting","permalink":"http://blog.gyx.me/tags/Counting/"},{"name":"DFS and Similar","slug":"DFS-and-Similar","permalink":"http://blog.gyx.me/tags/DFS-and-Similar/"}]},{"title":"AtCoder Beginner Contest 216","slug":"abc216","date":"2021-08-29T13:37:14.000Z","updated":"2022-05-19T01:11:38.805Z","comments":true,"path":"2021/08/29/abc216/","link":"","permalink":"http://blog.gyx.me/2021/08/29/abc216/","excerpt":"","text":"E. Amusement Park 给定 \\(n\\) 个数，最多 \\(k\\) 次操作，每次可以拿走某个数 \\(a_i\\) 加入得分，然后把 \\(a_i-1\\) 放回，问得分最大值，\\(k,a_i\\le 2\\times 10^9\\) 二分最后剩下的所有数里的最大值为 \\(x\\) ，答案是把所有数都拿到 \\(x\\) 的得分，然后加上剩下次数个 \\(x\\) 的得分。 需要注意二分上界 \\(r = 2\\times 10^9\\) ，所以二分 mid = (l + r) / 2 的时候可能会爆 int 。坑死我了 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;#define N 200007using namespace std;typedef long long ll;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for(; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for(; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;ll n, k, a[N];inline bool valid(ll x) &#123; ll cnt = 0; for (int i = 1; i &lt;= n; ++i) if (a[i] &gt; x) cnt += a[i] - x; return cnt &lt;= k;&#125;inline ll sum(ll l, ll r) &#123; return (l + r) * (r - l + 1) / 2;&#125;int main() &#123; n = rd(); k = rd(); for (int i = 1; i &lt;= n; ++i) a[i] = rd(); ll l = 0, r = 2e9; while (l &lt; r) &#123; ll mid = (l + r) / 2; valid(mid) ? r = mid : l = mid + 1; &#125; ll ans = 0; for (int i = 1; i &lt;= n; ++i) if (a[i] &gt; l) &#123; ans += sum(l + 1, a[i]); k -= a[i] - l; &#125; ans += k * l; printf(&quot;%lld\\n&quot;, ans); return 0;&#125; F. Max Sum Counting 有 \\(n\\) 个数对 \\((A_i, B_i)\\)构成一个集合，问有多少个子集，满足子集内 \\(A\\) 的最大值大于 \\(B\\) 的和。 考虑枚举最大的 \\(A\\) 是谁，将所有数对按照 \\(A\\) 从小到大排序，问题转化为选哪些 \\(B\\) 。 假设现在考虑排序后第 \\(i\\) 个数对，则 \\(B_i\\) 必选，相当于计数 \\(B_1,\\cdots,B_{i-1}\\) 中选出若干，且总和不超过 \\(A_i-B_i\\) 的方案数。 因为 \\(A\\) 的值域很小，搞一个 01 背包计数即可，复杂度 \\(O(n\\times \\max A_i)\\) 。 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;#define N 5007#define mod 998244353using namespace std;typedef long long ll;int n, f[N] = &#123;1&#125;;struct node &#123;int a, b;&#125; c[N];inline bool operator &lt; (const node &amp;a, const node &amp;b) &#123; return a.a == b.a ? a.b &lt; b.b : a.a &lt; b.a;&#125;int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;c[i].a); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;c[i].b); sort(c + 1, c + 1 + n); int ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; for (int v = 0; v &lt;= c[i].a - c[i].b; ++v) ans = (ans + f[v]) % mod; for (int v = N - 1; v &gt;= c[i].b; --v) f[v] = (f[v] + f[v - c[i].b]) % mod; &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125; G. 01Sequence 构造长度为 \\(n\\) 的 \\(01\\) 序列，满足 \\(k\\) 个形如 “ \\([l_i,r_i]\\) 内至少有 \\(x_i\\) 个 \\(1\\) ” 的条件，且 \\(1\\) 的个数最少。 将约束条件按照右端点从小到大排序，考虑每个条件当前还未满足的个数。 则对于每个 \\(1\\) ，在可行的范围内往右放的贡献不低于往左放，因此从右边界依次放过来即可。 查询未满足的个数需要维护一个树状数组，复杂度 \\(O(n\\log n)\\) 。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;#define N 200007using namespace std;typedef long long ll;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for(; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for(; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;int cur[N], vis[N];#define lowbit(x) (x &amp; -x)inline void add(int x) &#123; for (; x &lt; N; x += lowbit(x)) ++cur[x];&#125;inline int calc(int x) &#123; int res = 0; for (; x; x -= lowbit(x)) res += cur[x]; return res;&#125;struct node &#123;int l, r, k;&#125; c[N];inline bool operator &lt; (const node &amp;a, const node &amp;b) &#123;return a.r &lt; b.r;&#125;int main() &#123; int n = rd(); int m = rd(); for (int i = 1; i &lt;= m; ++i) &#123; c[i].l = rd(); c[i].r = rd(); c[i].k = rd(); &#125; sort(c + 1, c + 1 + m); for (int i = 1; i &lt;= m; ++i) &#123; int nw = calc(c[i].r) - calc(c[i].l - 1); for (int ptr = c[i].r; nw &lt; c[i].k; --ptr) if (!vis[ptr]) &#123; add(ptr); ++nw; vis[ptr] = 1; &#125; &#125; for (int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, vis[i]); return 0;&#125; H. Random Robots","categories":[{"name":"Solution","slug":"Solution","permalink":"http://blog.gyx.me/categories/Solution/"},{"name":"AtCoder","slug":"Solution/AtCoder","permalink":"http://blog.gyx.me/categories/Solution/AtCoder/"},{"name":"AtCoder Beginner Contest","slug":"Solution/AtCoder/AtCoder-Beginner-Contest","permalink":"http://blog.gyx.me/categories/Solution/AtCoder/AtCoder-Beginner-Contest/"}],"tags":[{"name":"Knapsack Problem","slug":"Knapsack-Problem","permalink":"http://blog.gyx.me/tags/Knapsack-Problem/"},{"name":"Greedy","slug":"Greedy","permalink":"http://blog.gyx.me/tags/Greedy/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"http://blog.gyx.me/tags/Binary-Search/"}]},{"title":"AtCoder Beginner Contest 214","slug":"abc214","date":"2021-08-14T13:58:14.000Z","updated":"2022-05-19T01:20:35.279Z","comments":true,"path":"2021/08/14/abc214/","link":"","permalink":"http://blog.gyx.me/2021/08/14/abc214/","excerpt":"","text":"D. Sum of Maximum Weights 给定一棵树，边有边权。计算所有点对路径上最大边权的权值和，范围 \\(n\\le 10^5\\) 考虑类似 Kruskal 的过程添加树边，则每一条边加入时，对于连通的两个集合间的点对，最大边即为当前边。 因此在维护并查集的同时维护集合大小即可，贡献为 w \\(\\times\\) Size(u) \\(\\times\\) Size(v) ，复杂度 \\(O(n\\log n)\\) E. Packing Under Range Regulations 有 \\(10^9\\) 个盒子，每个盒子只能放一个球。有 \\(n\\) 个球，第 \\(i\\) 个要放在 \\([l_i,r_i]\\) 的某一个盒子中，问是否有解，范围 \\(n\\le 2\\times 10^5\\) 比较经典的贪心，考虑从左往右放，最紧急的需求肯定是右端点最小的。 按照右端点排序，依次考虑每个需求，尽量往左放，相当于区间查询最靠左的未覆盖位置，然后修改这个位置的覆盖状态。 实现可以选择动态开点线段树+线段树上区间内二分，我是用的是并查集维护下一个未覆盖的位置（疯狂的馒头）。 因为序列有 \\(10^9\\) 长，使用 unordered_map 维护并查集数组，具体实现见代码，复杂度 \\(O(n\\log n)\\) 。 1234567891011121314151617181920212223242526struct node &#123;int l, r;&#125; c[N];inline bool operator &lt; (const node &amp;a, const node &amp;b) &#123; return a.r == b.r ? a.l &lt; b.l : a.r &lt; b.r;&#125;unordered_map&lt;int, int&gt; nxt;int find(int x) &#123; return nxt[x] ? nxt[x] = find(nxt[x]) : x;&#125;void work() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123;c[i].l = rd(); c[i].r = rd();&#125; sort(c + 1, c + 1 + n); for (int i = 1, pos; i &lt;= n; ++i) &#123; if (!nxt[c[i].l]) &#123; nxt[c[i].l] = c[i].l + 1; continue; &#125; pos = find(c[i].l); if (pos &gt; c[i].r) &#123;puts(&quot;No&quot;); return;&#125; nxt[pos] = pos + 1; &#125; puts(&quot;Yes&quot;);&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"http://blog.gyx.me/categories/Solution/"},{"name":"AtCoder","slug":"Solution/AtCoder","permalink":"http://blog.gyx.me/categories/Solution/AtCoder/"},{"name":"AtCoder Beginner Contest","slug":"Solution/AtCoder/AtCoder-Beginner-Contest","permalink":"http://blog.gyx.me/categories/Solution/AtCoder/AtCoder-Beginner-Contest/"}],"tags":[{"name":"Union-Find Set","slug":"Union-Find-Set","permalink":"http://blog.gyx.me/tags/Union-Find-Set/"}]},{"title":"Freshman Year","slug":"freshman","date":"2021-07-08T02:27:14.000Z","updated":"2021-07-15T02:27:14.000Z","comments":true,"path":"2021/07/08/freshman/","link":"","permalink":"http://blog.gyx.me/2021/07/08/freshman/","excerpt":"","text":"今天是 2021 年 7 月 8 日，星期四。 一年前的今天，高考最后一门刚刚考完。走出考场，回到自己的教室，拿手机，搬行李，告别。 离开学校的时候，碰到了还在梳理交通的竞赛教练，问我考的怎么样，然后约了后天要给高一的学弟们上课。 直到昨晚，暑假回本部给又一届的学弟们上完最后一天课。从二中本部的校门里走出来，回头看看。 来杭电之前 高考完就跟爸爸妈妈说我不复读，当晚就对答案，大概 645。报了南科大综评，拿到了还算不错的校考分。 然后在南校区给高一的同学讲了比较入门的概率，也是那些在一年前的暑假认识的，刚踏入二中大门学弟。 结束的时候在空空的学校里溜达，想想他们上课时候那种纯粹的热情，一代又一代，多少有一点感慨。 走之前拍了张照片，想起来一句自认为很应景的话：“雨过天青云破处，者般颜色做将来” 连着下了两三天的小雨，只剩下竞赛生的二中 出分的晚上比较坦然，提前几分钟查到了分数，比估计的低 9 分，都扣在语文上，115 / 134 / 136 / 251。 之后的几天比较迷茫，听了几个学校的招生宣讲都不尽如人意。南科大那边几度有希望，后来终究是落空。 在我想起来杭电这所学校的时候，突然感觉就是要去这里了。 可能是高二去学军培训喜欢上了杭州这个城市，也可能是对竞赛生涯结束的不甘吧。 先自己偷偷找 Claris 要到了教练的联系方式，问了读研和专业的事情，刘老师的热情的杭州话让人很舒服。 然后就是小心翼翼地和父母交流，说我自己的想法和考虑，直到最后心里十分踏实地填上了第一志愿。 录取的结果是数学系，高考分数达到了卓越学院二次选拔的报名分数线，报了卓越学院的招生考试。 之后的假期写了几个板子，打了几场 CF 恢复一点水平，参加了 HDU 的几场内部训练，搬了一套题恰烂钱。 开学之前和岳老师吃了个饭（竟然还赶上了他生日）， 让我重心不要全部放到竞赛上，要给自己留个后路。 初到杭电 有一说一假期还是过的比较随意，虽然报名了卓越学院，但是一点没准备，9 月份忐忑地就来到杭电啦。 考试之前自己很没有底气，当时觉得能进计科班就不错了。考完觉得考的还行，因为竞赛里接触过一点高数线代的知识，觉得自己英语阅读也比较会蒙。然后晚上大概九点的时候出成绩了，震惊自己竟然过了英才班的线。 晚上给爸爸妈妈很激动地打了个电话，有点担心 11 进 9 被刷掉，一直到十二点多才睡着。 第二天面试的时候其实自己比较轻松，感觉面试向来都比较稳 比较会吹 ，面试单独面，五个老师。 面试比较自然，老师们的问题基本是跟着我的自我介绍思路走，不过还是有几个问题血压拉满。 我努力地强调自己的竞赛水平，然后冯老师问：“现在让你去打区域赛能拿到什么奖项？” 我介绍了一下高中学校和班级的情况，然后另一个老师问：“你觉得二中和衡一哪个更好？” 周老师（也是现在的导师）问：“你也不能打一辈子竞赛啊。以后有什么进一步的打算？” 我说会读研，以后可能会去当大学老师。导师笑笑说要想当教授，后面得去好点的大学读书。 面试完出来觉得自己还挺稳的，但是也不敢确定，忐忑到了晚上十点多出了结果。终于还是去学计算机了。 之后的生活很顺利，见面会，正常上课，班委选举（当了学委）。 上课的时候强迫自己去提问，回答问题，意识到自己可以做一些 由自己决定的 想做什么就做什么 的事。 遇到了自己喜欢的老师，有能够舒适相处，真心相待的一帮同学，慢慢地从高三痛苦自闭的状态走出来了。 竞赛 这段话也想写给每个学竞赛过程中感到无力的同行者。 算法竞赛的魅力在于，通过努力积累或灵机一动，你能够做出越来越难的题目，是一种对自我能力的认可。 算法竞赛的危险亦在于，你学会的东西越多，认识的厉害的人越多，面对不可计数的强者，很容易陷入自我否定。 想到杭电之前，很长一段时间都觉得，大学不会再打竞赛了。 学竞赛的过程中经历的打击，不仅是比赛和上课中受到一众神仙居高临下的压迫感，更多的其实是周围人不经意的否定和安慰。对我来说，这是一种对信心很大的打击，会想要证明自己，亦或是心里感到无力而故作轻松。 在面临是否买 D 的抉择时，我放弃了。不是担心取得不了什么结果，而是觉得压力太大了。 在选学校的时候，突然想到杭电的那一刻，有种死灰复燃的感觉。 记起来 NOIP 2018 结束的时候，在存真楼下，孙校长和我们几个刚从秦皇岛回来的学生说的几句话： “学别的竞赛的，最终的发展和竞赛不一定有关系，但是算法竞赛的学生，最终往往都会选择计算机行业。” 算法竞赛会在心里埋下一颗种子。 我不是那种一帆风顺的天才，在受到打击的时候，我会感到无力。 但当我抛开名利、和他人比较、证明自己这些功利的意义之后，我发现自己还剩下些东西，还能看到初心。 是对算法的欣赏和热爱，是理解每一个算法、做出每一个题目的瞬间，精神上的享受，这就够了。 至少在我看来，从我开始接触竞赛，到做出很多重要的选择，我决策的初心从来都不是名利，因为对算法还爱着。决定最终没有买 D 类，最大的原因还是在那个时刻，竞赛带来的痛苦超过了学习的享受，被一次次的排名裹挟，被各种机会所吸引，我越来越像一个没有自我的机器，越来越被成功学牢牢锁死。而在我选择大学的时候，竞赛对我的意义不再是未来的全部了。我能够静下来，问问自己对算法还有没有那种近乎痴迷的喜爱，能够将它作为一种兴趣去发展，不需要考虑付出和回报，至少在大学，我还是有自由支配自己的权利。 我还是那个深深爱着算法的小孩，对几十行代码背后的智慧如痴如醉。 Gold Medal (30th Place) : The 45th ICPC Asia Jinan Regional Contest, 2020 Gold Medal ( 15th Place) : The 18th Zhejiang Provincial Collegiate Programming Contest, 2021 Silver Medal (28th Place) : The 45th ICPC Asia Shenyang Regional Contest, 2021 课内学习 第一个学期不会选课，修了系统默认的 25.25 个学分， 第二个学期修了 32.25 个学分。 通识选修只完成了科技发展与科学精神（2/2），大二上应该会把剩下的指标修完。 数理基础 (23) 数分 （6 * 3.5 + 5 * 4.2）、高代（3 * 5 + 2 * 5）、离散（4 * 5）、大物1（3 * 5） CS专业课 (14) 计导（2 * 5）、程设基础（5 * 5）、数据结构（4 * 4.5）、C++ 面向对象（3 * 5） 通识教育 (8) 思修法基（3 * 5）、心理健康（1 * 4.3）、大军（2 * 4.8）、ACM（2 * 5） 外语类 (8) 英语精读 A（2 * 4.4 + 2 * 4.6）、英语听说 A（1 * 4.3 + 1 * 4.7）、实用翻译（2 * 4.6） 其他 (3.5) 大学启示录（1 * 4）、形式与政策（0.5 * 5）、科研实践（1 * 5）、体育（1 * 2.1 + 1 * 1.8） 很幸运的是遇到的老师都很认真负责，老师们对课程内容非常了解，自己遇到问题也都能很好沟通。 很多课程都觉得自己做的没那么好，对给出的成绩也常常受之有愧。 数学分析和高等代数两门数学基础课的表现截然相反，让我更清楚地意识到很大程度上我是个兴趣驱动的人。 对数分的知识体系自己本身可能就不太感兴趣，加上数分课是真的提不起来精神，两个学期的数学分析成绩都不太看的过去，数分上可能要在大三重修了。老师确实想要认真教会我，可是自己确实提不起兴趣去学。经历了数分上的洗礼，数分下还是逼着自己学了学，最后的结果算是马马虎虎吧，确实对不起老师对不起自己。 很喜欢高代老师的课，很大程度驱动我去花相对比较多的时间在这门课上。两个学期最后的结果都比较好，在自己喜欢的科目上能够看到自己做了些事情，也是让自己很开心的一件事。唯一遗憾的是期末错在了最后一节课老师强调过的一个小点上（证明正定阵需先说明对称）。大二下预定了老师的近世代数。 也很喜欢 Cathy 上的英语精读，也算是第一次能让我主动提起来学英语的兴趣。 Cathy 的课有一种很轻松的气氛，不会按照课本一板一眼的去上，讲的很多东西很受用。 感谢程设和OOP（C++）的老师对我的包容，自己在这两门课上确实有过很幼稚的行为。很佩服将近退休的老师能精确把控很多细节，随手写的代码能一遍过编译什么错都没有。 离散数学和数据结构 给了我很深刻的教训。两门都是自认为了解比较多的，数据结构甚至申请了免听。考前复习的都不是很充分，等上了考场发现要开始脑补一堆一堆的概念。期末离散卷子简单，没暴露出来什么问题。数据结构觉得自己看看书就够了，最后的成绩却不尽如人意，原因只是不知道排序里的一个既定细节，只能悔不当初。 大学物理和思想道德修养与法律基础 两门课结果意外的好，其实自己认真去学一学还是可以有效果的。中学阶段一直头疼的政治在闭卷的期末考试也写了个差不多。学不会电磁在考场上也做出来了绝大多数题。考试遇到不会的题也不能太着急，多想一会没准就通了。 体育 从中考的 \\(18\\) 分保底，到大一上的体测 \\(36\\) 分，痛失两个学期的奖学金，终究还是没逃过身体素质不行这个问题。还是感谢环境逼着我去直面体育，按着体能班的要求大一下结结实实把 40 次阳光长跑跑完了，也确实让我看到耐力可以有提升，从操场跑一圈就喘不上气，到体测的时候人生第一次把 1000 米全跑下来，确实是很激动的。也终于在锻炼身体上有了动力，首先是大二下想要和 qyy 同学一起学体育舞，其次是想要恰奖学金。 我的她 只想说爱情的体验是一种很纯粹的幸福。 愿意为她牺牲自己的一切，无时无刻都会想起她的事情，找不到她会坐如针毡，什么都做不下去。 她所高兴的事情比她还高兴，她难受的时候会跟着一起哭出来，在爱情中两个人都学会了如何照顾对方。 两个人在一起呆着常常心有灵犀，做事情反应如出一辙，很多事情不用言语。 两个人在一起呆着就是最快乐的事情，能够一起学习，散步，她在我的身边就能感受到无比的踏实。 会走到一起的人终究不会分开。心里对未来有着期盼，静下心来踏踏实实做事，继续加油。","categories":[{"name":"Life","slug":"Life","permalink":"http://blog.gyx.me/categories/Life/"}],"tags":[]},{"title":"Codeforces Round #723 (Div. 2)","slug":"cf723","date":"2021-03-28T16:00:00.000Z","updated":"2022-05-19T01:11:51.628Z","comments":true,"path":"2021/03/29/cf723/","link":"","permalink":"http://blog.gyx.me/2021/03/29/cf723/","excerpt":"","text":"A. Mean Inequality 将 \\(2n\\) 个不同的数字排成一个循环，使得任意位置的数不是相邻两个数的平均值。 从小到大排序之后，前 \\(n\\) 个和后 \\(n\\) 个交替放。 因为数字两两不同，大的数字不可能是两个小的数字的平均数，小的同理。 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125; int a[51];inline void work() &#123; int n = rd(); int m = 2 * n; for (int i = 1; i &lt;= m; ++i) a[i] = rd(); sort(a + 1, a + 1 + m); for (int i = 1; i &lt;= n; ++i) printf(&quot;%d %d &quot;, a[i], a[i + n]); puts(&quot;&quot;);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; B. I Hate 1111 询问一个正整数 \\(x\\) 是否可以拆分成若干个 \\(11,111,1111,\\dots\\) 的和 根据 麦乐鸡定理 ，\\(11\\) 和 \\(111\\) 可以组成大于 \\(11*111-111-11=1099\\) 的任何数。 所以后面的数字都没用了， \\(x\\le 1099\\) 的部分做一下 \\(11\\) 和 \\(111\\) 的完全背包，其他情况都是 YES 。 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125; #define N 1100bool f[N];inline void work() &#123; int x = rd(); puts(x &gt;= N ? &quot;YES&quot; : (f[x] ? &quot;YES&quot; : &quot;NO&quot;));&#125;int main() &#123; f[0] = 1; for (int i = 11; i &lt; N; ++i) f[i] |= f[i - 11]; for (int i = 111; i &lt; N; ++i) f[i] |= f[i - 111]; for (int t = rd(); t; --t) work(); return 0;&#125; C. Potions 给一个数列，求一个最长的子序列，使得子序列任意前缀和都 \\(\\ge 0\\) 经典的带反悔贪心，用一个小根堆维护拿了的数字。 每次先把当前的拿了，如果当前的和是负的，就一直去掉堆顶直到合法即可。 这样子在每次结束的时候都是正的，并且去掉了最少的数。 等效的贪心是每次放进来如果变成负数就看一下能不能替换堆顶。 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125; priority_queue&lt;int&gt; q;int main() &#123; int n = rd(); int ans = 0; ll nw = 0; for (int i = 1, a; i &lt;= n; ++i) &#123; a = rd(); ++ans; nw += a; q.push(-a); while (nw &lt; 0) &#123; nw += q.top(); q.pop(); --ans; &#125; &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125; D. Kill Anton 给定一个字符集只有 'A','D','O','T' 的串，将其重排使得恢复成原来的所需操作次数最大。 操作一次可以交换两个字符的位置。 猜一下操作次数只和逆序数相关（我一直不太会这种的证明），所以一定可以把同一类字符放到一起。 记 inv[i][j] 表示字符 i 前字符j 的顺序对数，即如果结果串中字符 i 在字符 j 前，增加的逆序数。 因此枚举 \\(4!\\) 种排列，计算一下哪一种逆序数最大即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const char tc[4] = &#123;&#x27;A&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;T&#x27;&#125;;ll cnt[4], inv[4][4];inline int tr(char c) &#123; if (c == &#x27;A&#x27;) return 0; if (c == &#x27;N&#x27;) return 1; return (c == &#x27;O&#x27; ? 2 : 3);&#125;string s;inline void work() &#123; cin &gt;&gt; s; for (int i = 0; i &lt; 4; ++i) &#123; cnt[i] = 0; for (int j = 0; j &lt; 4; ++j) inv[i][j] = 0; &#125; for (auto c : s) &#123; int i = tr(c); for (int j = 0; j &lt; 4; ++j) if (j != i) inv[i][j] += cnt[j]; ++cnt[i]; &#125; ll ans = -1; int p[4] = &#123;0, 1, 2, 3&#125;, res[4]; do &#123; ll tmpans = 0; for (int i = 0; i &lt; 4; ++i) for (int j = i + 1; j &lt; 4; ++j) tmpans += inv[p[i]][p[j]]; if (tmpans &gt; ans) &#123; ans = tmpans; for (int i = 0; i &lt; 4; ++i) res[i] = p[i]; &#125; &#125; while(next_permutation(p, p + 4)); for (int i = 0; i &lt; 4; ++i) for (int j = 1; j &lt;= cnt[res[i]]; ++j) putchar(tc[res[i]]); puts(&quot;&quot;);&#125;int main() &#123; int t; for (cin &gt;&gt; t; t; --t) work(); return 0;&#125; E. Oolimry and Suffix Array 给定后缀数组，求有多少个串长为 \\(n\\) ，字符集大小为 \\(k\\) 的字符串 \\(S\\) 符合这个后缀数组 后缀数组 \\(sa_i\\) 记录的是排名第 \\(i\\) 位的后缀的开始下标。 根据字典序要求，\\(S_{sa_i}\\) 和 \\(S_{sa_{i+1}}\\) 只有两种关系：\\(S_{sa_i}&lt;S_{sa_{i+1}}\\) 或 \\(S_{sa_i}=S_{sa_{i+1}}\\) 小于一定是可以的，等于的充要条件是 \\(rank_{sa_i+1}&lt;rank_{sa_{i+1}+1}\\) ，即去掉第一个字符字典序不变。 因此我们得到了含有 \\(n-1\\) 个不等号的不等式链，假设其中有 \\(a\\) 个是 \\(\\le\\) 。 我们枚举有 \\(i\\) 个 \\(\\le\\) 实际上是 \\(&lt;\\) ，那么实际字符集大小是 \\(n-i\\) ，方案数就是 \\[ \\sum_{i=0}^a{a\\choose i}{k\\choose n-i}={a+k\\choose n} \\] 等式从组合含义理解，从 \\(a+k\\) 个里选 \\(n\\) 个，定价于枚举从前 \\(a\\) 个里选 \\(i\\) 个，剩余的从后 \\(k\\) 个里选。 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 200007#define mod 998244353inline int fpow(int x, int t = mod - 2) &#123; int res = 1; for (; t; t &gt;&gt;= 1, x = 1ll * x * x % mod) if (t &amp; 1) res = 1ll * res * x % mod; return res;&#125;int rk[N], pos[N], fac[N &lt;&lt; 1] = &#123;1&#125;;int main() &#123; int n = rd(), k = rd(); for (int i = 1; i &lt;= n; ++i) rk[pos[i] = rd()] = i; for (int i = 1; i &lt; n; ++i) k += (rk[pos[i] + 1] &lt; rk[pos[i + 1] + 1]); if (k &lt; n) &#123;puts(&quot;0&quot;); return 0;&#125; for (int i = 1; i &lt;= k; ++i) fac[i] = 1ll * fac[i - 1] * i % mod; printf(&quot;%lld\\n&quot;, 1ll * fac[k] * fpow(fac[n]) % mod * fpow(fac[k - n]) % mod); return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"http://blog.gyx.me/categories/Solution/"},{"name":"Codeforces","slug":"Solution/Codeforces","permalink":"http://blog.gyx.me/categories/Solution/Codeforces/"},{"name":"Codeforces Round","slug":"Solution/Codeforces/Codeforces-Round","permalink":"http://blog.gyx.me/categories/Solution/Codeforces/Codeforces-Round/"}],"tags":[{"name":"Greedy","slug":"Greedy","permalink":"http://blog.gyx.me/tags/Greedy/"},{"name":"Constructive Algorithm","slug":"Constructive-Algorithm","permalink":"http://blog.gyx.me/tags/Constructive-Algorithm/"},{"name":"Number Theory","slug":"Number-Theory","permalink":"http://blog.gyx.me/tags/Number-Theory/"},{"name":"Counting","slug":"Counting","permalink":"http://blog.gyx.me/tags/Counting/"}]},{"title":"Render Math Equations in Hexo","slug":"mathjax","date":"2019-05-31T16:00:00.000Z","updated":"2021-05-31T16:00:00.000Z","comments":true,"path":"2019/06/01/mathjax/","link":"","permalink":"http://blog.gyx.me/2019/06/01/mathjax/","excerpt":"","text":"\\[ f(a) = \\frac{1}{2\\pi i}\\oint_{\\gamma}\\frac{f(z)}{z-a}dz \\] Beautiful and accessible math in all browsers - MathJax This post is used to check out whether the mathjax plugin (hexo-math) still works. Inline Formula Consider the sequence of \\(n\\) distinct positive integers: \\(c_1, c_2, \\cdots, c_n\\). The child calls a vertex-weighted rooted binary tree good if and only if for every vertex \\(v\\), the weight of \\(v\\) is in the set \\(\\{c_1, c_2, \\cdots, c_n\\}\\) . Also our child thinks that the weight of a vertex-weighted tree is the sum of all vertices' weights. Given an integer \\(m\\), can you for all $s (1 s ≤ m) $ calculate the number of good vertex-weighted rooted binary trees with weight \\(s\\) ? Please, check the samples for better understanding what trees are considered different. We only want to know the answer modulo \\(998244353\\) ( \\(7 × 17 × 2^{23} + 1\\) , a prime number). Block Formula \\[ \\int \\frac{dx}{cos^2x}=\\int sec^2xdx=tan x+C\\ \\] \\[ \\int \\frac{dx}{sin^2x}=\\int csc^2xdx=-cot x+C\\ \\] \\[ \\sum\\limits_{i = 0}^{E} w[i]{M \\choose i} {N \\choose iS} \\frac{(iS)!}{(S!)^{i}} \\sum\\limits_{j = 0}^{E - i} (-1)^{j} {M - i \\choose j} {N - iS \\choose jS} \\frac{(jS)!}{(S!)^{j}} (M - i - j)^{N - iS - jS} \\] \\[ = \\sum\\limits_{i = 0}^{E} w[i]{M \\choose i} {N \\choose iS} \\frac{(iS)!}{(S!)^{i}} \\sum\\limits_{j = i}^{E} (-1)^{j - i} {M - i \\choose j - i} {N - iS \\choose jS - iS} \\frac{(jS - iS)!}{(S!)^{j - i}} (M - j)^{N - jS} \\] Matrix \\[ \\begin{bmatrix} (\\omega_n^0)^0 &amp; (\\omega_n^0)^1 &amp; \\cdots &amp; (\\omega_n^0)^{n-1}\\\\\\\\ (\\omega_n^1)^0 &amp; (\\omega_n^1)^1 &amp; \\cdots &amp; (\\omega_n^1)^{n-1}\\\\\\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\\\\\ (\\omega_n^{n-1})^0 &amp; (\\omega_n^{n-1})^1 &amp; \\cdots &amp; (\\omega_n^{n-1})^{n-1} \\end{bmatrix} \\begin{bmatrix} a_0 \\\\\\\\ a_1 \\\\\\\\ \\vdots \\\\\\\\ a_{n-1} \\end{bmatrix} = \\begin{bmatrix} A(\\omega_n^0) \\\\\\\\ A(\\omega_n^1) \\\\\\\\ \\vdots \\\\\\\\ A(\\omega_n^{n-1}) \\end{bmatrix} \\] \\[ \\begin{bmatrix} a_0 \\\\\\\\ a_1 \\\\\\\\ \\vdots \\\\\\\\ a_{n-1} \\end{bmatrix} = \\frac{1}{n} \\begin{bmatrix} (\\omega_n^{-0})^0 &amp; (\\omega_n^{-0})^1 &amp; \\cdots &amp; (\\omega_n^{-0})^{n-1} \\\\\\\\ (\\omega_n^{-1})^0 &amp; (\\omega_n^{-1})^1 &amp; \\cdots &amp; (\\omega_n^{-1})^{n-1} \\\\\\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\\\\\ (\\omega_n^{-(n-1)})^0 &amp; (\\omega_n^{-(n-1)})^1 &amp; \\cdots &amp; (\\omega_n^{-(n-1)})^{n-1} \\end{bmatrix} \\begin{bmatrix} A(\\omega_n^0) \\\\\\\\ A(\\omega_n^1) \\\\\\\\ \\vdots \\\\\\\\ A(\\omega_n^{n-1}) \\end{bmatrix} \\] To prevent escaping, you need to use \\\\\\\\ to make a new line rather than \\\\ . For more about the Mathjax symbols, refer to ：The Comprehensive LaTeX Symbol List .","categories":[{"name":"Blog","slug":"Blog","permalink":"http://blog.gyx.me/categories/Blog/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-11-28T16:00:00.000Z","updated":"2018-11-28T16:00:00.000Z","comments":true,"path":"2018/11/29/hello-world/","link":"","permalink":"http://blog.gyx.me/2018/11/29/hello-world/","excerpt":"","text":"「 Hello, the lovely world. 」 「 Stay hungry, Stay foolish. 」 12345678910111213141516171819202122&gt;&gt;&gt; import thisThe Zen of Python, by Tim PetersBeautiful is better than ugly.Explicit is better than implicit.Simple is better than complex.Complex is better than complicated.Flat is better than nested.Sparse is better than dense.Readability counts.Special cases aren&#x27;t special enough to break the rules.Although practicality beats purity.Errors should never pass silently.Unless explicitly silenced.In the face of ambiguity, refuse the temptation to guess.There should be one-- and preferably only one --obvious way to do it.Although that way may not be obvious at first unless you&#x27;re Dutch.Now is better than never.Although never is often better than *right* now.If the implementation is hard to explain, it&#x27;s a bad idea.If the implementation is easy to explain, it may be a good idea.Namespaces are one honking great idea -- let&#x27;s do more of those!","categories":[{"name":"Blog","slug":"Blog","permalink":"http://blog.gyx.me/categories/Blog/"}],"tags":[]}],"categories":[{"name":"Solution","slug":"Solution","permalink":"http://blog.gyx.me/categories/Solution/"},{"name":"AtCoder","slug":"Solution/AtCoder","permalink":"http://blog.gyx.me/categories/Solution/AtCoder/"},{"name":"AtCoder Regular Contest","slug":"Solution/AtCoder/AtCoder-Regular-Contest","permalink":"http://blog.gyx.me/categories/Solution/AtCoder/AtCoder-Regular-Contest/"},{"name":"Summary","slug":"Summary","permalink":"http://blog.gyx.me/categories/Summary/"},{"name":"Paper Notes","slug":"Summary/Paper-Notes","permalink":"http://blog.gyx.me/categories/Summary/Paper-Notes/"},{"name":"Algorithms","slug":"Summary/Algorithms","permalink":"http://blog.gyx.me/categories/Summary/Algorithms/"},{"name":"AtCoder Beginner Contest","slug":"Solution/AtCoder/AtCoder-Beginner-Contest","permalink":"http://blog.gyx.me/categories/Solution/AtCoder/AtCoder-Beginner-Contest/"},{"name":"Codeforces","slug":"Solution/Codeforces","permalink":"http://blog.gyx.me/categories/Solution/Codeforces/"},{"name":"Codeforces Round","slug":"Solution/Codeforces/Codeforces-Round","permalink":"http://blog.gyx.me/categories/Solution/Codeforces/Codeforces-Round/"},{"name":"AtCoder Grand Contest","slug":"Solution/AtCoder/AtCoder-Grand-Contest","permalink":"http://blog.gyx.me/categories/Solution/AtCoder/AtCoder-Grand-Contest/"},{"name":"Competitions","slug":"Competitions","permalink":"http://blog.gyx.me/categories/Competitions/"},{"name":"Google's Coding Competitions","slug":"Competitions/Google-s-Coding-Competitions","permalink":"http://blog.gyx.me/categories/Competitions/Google-s-Coding-Competitions/"},{"name":"Programming Ability Test","slug":"Competitions/Programming-Ability-Test","permalink":"http://blog.gyx.me/categories/Competitions/Programming-Ability-Test/"},{"name":"Life","slug":"Life","permalink":"http://blog.gyx.me/categories/Life/"},{"name":"Blog","slug":"Blog","permalink":"http://blog.gyx.me/categories/Blog/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"},{"name":"STL","slug":"STL","permalink":"http://blog.gyx.me/tags/STL/"},{"name":"01-BFS","slug":"01-BFS","permalink":"http://blog.gyx.me/tags/01-BFS/"},{"name":"Combinatorics","slug":"Combinatorics","permalink":"http://blog.gyx.me/tags/Combinatorics/"},{"name":"Knapsack Problem","slug":"Knapsack-Problem","permalink":"http://blog.gyx.me/tags/Knapsack-Problem/"},{"name":"Threshold Optimization","slug":"Threshold-Optimization","permalink":"http://blog.gyx.me/tags/Threshold-Optimization/"},{"name":"Binary Lifting","slug":"Binary-Lifting","permalink":"http://blog.gyx.me/tags/Binary-Lifting/"},{"name":"Greedy","slug":"Greedy","permalink":"http://blog.gyx.me/tags/Greedy/"},{"name":"KMP","slug":"KMP","permalink":"http://blog.gyx.me/tags/KMP/"},{"name":"Game Theory","slug":"Game-Theory","permalink":"http://blog.gyx.me/tags/Game-Theory/"},{"name":"DFS and Similar","slug":"DFS-and-Similar","permalink":"http://blog.gyx.me/tags/DFS-and-Similar/"},{"name":"Graphs","slug":"Graphs","permalink":"http://blog.gyx.me/tags/Graphs/"},{"name":"Persistent Data Structure","slug":"Persistent-Data-Structure","permalink":"http://blog.gyx.me/tags/Persistent-Data-Structure/"},{"name":"Scheduling","slug":"Scheduling","permalink":"http://blog.gyx.me/tags/Scheduling/"},{"name":"Polynomials","slug":"Polynomials","permalink":"http://blog.gyx.me/tags/Polynomials/"},{"name":"Constructive Algorithm","slug":"Constructive-Algorithm","permalink":"http://blog.gyx.me/tags/Constructive-Algorithm/"},{"name":"Bitmask","slug":"Bitmask","permalink":"http://blog.gyx.me/tags/Bitmask/"},{"name":"Union-Find Set","slug":"Union-Find-Set","permalink":"http://blog.gyx.me/tags/Union-Find-Set/"},{"name":"Counting","slug":"Counting","permalink":"http://blog.gyx.me/tags/Counting/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"http://blog.gyx.me/tags/Binary-Search/"},{"name":"Number Theory","slug":"Number-Theory","permalink":"http://blog.gyx.me/tags/Number-Theory/"}]}