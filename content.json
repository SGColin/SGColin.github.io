{"meta":{"title":"Colin's Space","subtitle":"God helps those who help themselves.","description":null,"author":"Colin Gao","url":"http://blog.gyx.me","root":"/"},"pages":[{"title":"","date":"2021-12-27T16:33:22.451Z","updated":"2021-08-07T16:14:11.574Z","comments":false,"path":"about/index.html","permalink":"http://blog.gyx.me/about/index.html","excerpt":"","text":""}],"posts":[{"title":"Codeforces Records","slug":"Codeforces","date":"2024-06-15T16:06:00.000Z","updated":"2021-12-23T16:50:03.193Z","comments":true,"path":"2024/06/16/Codeforces/","link":"","permalink":"http://blog.gyx.me/2024/06/16/Codeforces/","excerpt":"Records for Competitions on Codeforces and Links of my Summaries.","text":"目前共做完了 &nbsp; 2 &nbsp; 轮 Codeforces Contests 和 &nbsp; 1 &nbsp; 套 Gym Dec / 16 - Round # 761 (4/6)Dec / 14 - Round # 760 (7/7)Nov / 26 - Round #757 (3/6)Nov / 23 - Global #17 (2/9)Nov / 22 - Edu #117 (5/7)Nov / 14 - Round #755 (2/7)Nov / 12 - Round #754 (4/6)Oct / 30 - Round #752 (5/8) A（构造）：插入最少的数使得 $a_i\\le i$ 。显然插入 $1$ 就可以了，需要插入的最少个数是 $\\max_{i=1}^n\\max(0, a_i-i)$ B（构造）：将数列分段使每段 LIS 长度异或和为 $0$ 。偶数长 $1$ 个数 $1$ 段，奇数长找长度为 $2$ 的块 LIS 为 $1$ 即可。 C（构造）：若一个前缀可以删干净，则当前数可以在前方任意位置被删掉，暴力判断 10 个质数的范围即可。 D（构造）：找到一个 $n$ 使得 $n\\ \\text{mod}\\ x = y\\ \\text{mod}\\ n$ ，其中 $x,y$ 为偶数。 若 $x&gt;y$ ，令 $n=x+y$ 若 $x=y$ ，令 $n=x$ 若 $x&lt;y$ ，令 $n=\\lfloor\\frac{y}{x}\\rfloor x+\\frac{y\\ \\text{mod}\\ x}{2}$ ，$x,y$ 为偶数保证 $y\\ \\text{mod}\\ x$ 可以被 $2$ 整除 推导的方法是设 $n=t_1x+k,y = t_2n+k$ ，整理后发现令 $t_2=1$ 即可 E（暴力）：设 $f[i][j]$ 表示有多少个 $i$ 的后缀，使得最优解中 $a_i\\to j$ ，这样每个位置只有 $\\sqrt{a_i}$ 种可能的取值，暴力转移即可，每次的贡献是 $i\\times f[i+1][j]\\times (\\lceil\\frac{a_i}{a_i+1}\\rceil - 1)$ ，清空数组的方法比较有技巧。其实子序列也可以做。 1234567891011121314151617181920212223242526272829int a[N], f[2][N];vector&lt;int&gt; pos[2];inline void work() &#123; int n = rd(); int ans = 0; for (int i = 1; i &lt;= n; ++i) a[i] = rd(); int u = (n &amp; 1), v = 1 - (n &amp; 1); for (int i = n; i; --i, u ^= 1, v ^= 1) &#123; f[u][a[i]] = 1; pos[u].push_back(a[i]); int lst = a[i]; for (auto x : pos[v]) &#123; int cnt = (a[i] + x - 1) / x; //前面的方案数为i, 后面的方案数为f[v][x] ans = (ans + 1ll * i * f[v][x] * (cnt - 1)) % mod; int tar = a[i] / cnt; f[u][tar] += f[v][x]; if (lst != tar) &#123;pos[u].push_back(tar); lst = tar;&#125; &#125; for (auto x : pos[v]) f[v][x] = 0; pos[v].clear(); &#125; printf(&quot;%d\\n&quot;, ans); for (auto x : pos[0]) f[0][x] = 0; for (auto x : pos[1]) f[1][x] = 0; pos[0].clear(); pos[1].clear();&#125; Oct / 29 - Edu #116 (4/6)Oct / 25 - Round #751 (3/8) D（不是DAG）：没注意到方案中一次跳跃可能会落到比出发点更低的地方。直接线段树优化建图是可以的。 Oct / 24 - Round #750 (7/8) A （数据范围）：因为 1,2,3 个数都大于 $0$ ，所以可以组合出 $[1,\\sum a_i]$ 内所有整数，所以拆成两部分差不会超过 $1$ D （特殊情况）：奇数构造时忘记考虑可能有相同的数字，用减法可能会产生 $0$ ，$n$ 为奇数的时候恰好是 $n$ 上界 $-1$ ，因此刚好剩出来一个 $10^4$ 的空间，直接用加法构造即可。 E （倒序转移）：要求区间越往后，长度越短+值越大，不好扩展（无法继承上一状态），转化成从右往左选区间，长度越长+值越小，这样就可以继承之前的状态了。设 $f[i][j]$ 表示到第 $i$ 个为止，最后一段长度为 $j$ 的区间和的最大值。 F （维护技巧） Oct / 17 - Round #749 (2/9)Oct / 13 - Edu #115 (0/6)Oct / 09 - Round #747 (0/6)Oct / 03 - Round #746 (5/7) B（分讨）：交换距离不小于 $k$ ，则不可移动的范围为 $[n - x + 1, x]$ ，只需保证这些位置数字正确即可。 C（性质）：注意到多个块是可以三个合并成一个的，因此任何解都等价于只划分成两个块或三个块。设所有 $a[i]$ 异或和为 $A$ ，若 $A=0$ 则可以划分为两个块。其余情况判断是否能划分成三个块，一遍 dfs 计数异或和为 $A$ 的块即可。 12345void dfs(int u, int fa) &#123; for (int i = hd[u], v; i; i = e[i].nxt) if ((v = e[i].to) != fa) &#123;dfs(v, u); a[u] ^= a[v];&#125; if (a[u] == tar) &#123;++cnt; a[u] = 0;&#125;&#125; D（构造）：寻找具有某个性质的路径可以考虑转化到欧拉序上二分。 E（性质）：注意到任意奇数长度的区间，所有数字的与和 $\\le$ 异或和，因为与和为 $1$ 的位置，异或和里也是奇数个 $1$ 。而偶数长度的区间，与和为 $1$ 的位置异或和必定为 $0$ ，因此只要判断区间所有数比与和最高位更高的部分异或和是不是 $0$ 即可，枚举与和最高位，按照异或差分的思路维护，注意区间偶数长度的要求，需要区分奇偶位置。 12345678910111213141516171819202122232425262728int a[N], lst[N][2], ans;memset(lst, 0xcf, sizeof(lst));for (int t = 20; t &gt;= 0; --t) &#123; lst[0][0] = 0; for (int i = 1, pre = 0; i &lt;= n; ++i) &#123; if (!(a[i] &amp; (1 &lt;&lt; t))) &#123; pre = 0; while (!s.empty()) &#123; int x = s.front(); s.pop(); lst[x][0] = lst[x][1] = -1; &#125; //注意区间从头开始的情况 lst[0][i &amp; 1] = i; lst[0][1 - (i &amp; 1)] = -1; &#125; else &#123; pre ^= (a[i] &gt;&gt; (t + 1)); int fl = (i &amp; 1); if (lst[pre][fl] &lt; 0) lst[pre][fl] = i; if (lst[pre][fl] &gt;= 0) ans = max(ans, i - lst[pre][fl]); s.push(pre); //记录需要清空的位置 &#125; &#125; while (!s.empty()) &#123; int x = s.front(); s.pop(); lst[x][0] = lst[x][1] = -1; &#125;&#125; Feb / 12 - Round #701 (6/6) Add and Divide 首先最优解一定是 ++b 若干次（可能为 $0$ ），然后再一直做 a=a/b 直到符合条件。 考虑最差的情况：$a=10^9,b=1$ ，至多只需 $1+\\lceil \\log_2{10^9}\\rceil = 31$ 次，所以所有答案都 $\\le 31$。 因此枚举++b 的操作次数 $k\\ (0\\le k\\le 31)$ ，然后暴力计算答案即可，复杂度 $\\text O(t\\log^2 a)$ 。 B. Replace and Keep Sorted 考虑 $b_i\\not =a_i$ ，那么考虑 $b_i$ 的取值范围： 对于 $i=l$ 的情况， $1\\le b_i&lt;a_{i+1}$ ，与 $a_i$ 不同的方案有 $a_{i + 1} - 2$ 个。 对于 $i=r$ 的情况， $a_{i-1}&lt;b_i\\le k$ ，与 $a_i$ 不同的方案有 $k - a_{i-1} - 1$ 个。 对于 $l&lt;i&lt;r$ 的情况， $a_{i-1}&lt;b_i&lt;a_{i+1}$ ，与 $a_i$ 不同的方案有 $a_{i+1}-a_{i-1}-2$ 个。 $i$ 不同的贡献是独立的，所以用前缀和优化一下第三部分的计算，各个位置的方案数求和即可。 C. Floor and Mod 设 $\\lfloor a/b\\rfloor=a\\ \\text{mod}\\ b=k$ ，根据整除理论，有 $a=k *b+k$ ，且 $k &lt; b$ 。 考虑枚举 $k$ ，去数可行的 $b$ ，那么限制条件有：$1\\le b \\le y\\ ,\\ 1\\le k*b+b=a\\le x$ 移项，得 $1\\le b\\le \\min(y,\\ x / k - 1)$ ，即 $k$ 的贡献为 $\\min(y,\\ x/k - 1)$ 。 又由 $k\\le b$ 得 $k ^2 &lt; k * b+k = a\\le x$ ，得 $k\\le \\sqrt x$ ，因此 $O(t\\sqrt x)$ 枚举 $k$ 直接计算即可。 比赛时用的另一种做法，复杂度也是 $\\text O(t\\sqrt x)$ ： 考虑枚举 $b$ ，由上知可行的 $a = k *(b+1)$ 且 $1\\le k\\le b-1$ 。 考虑枚举 $b$ ，则贡献为 $\\min(b-1,\\lfloor x/(b + 1)\\rfloor)$ ，具体的： 当 $(b+1)(b-1)\\le x$ 时，即 $b \\le \\sqrt{x + 1}$ 时，贡献为 $b-1$ ，可以等差数列求和。 否则贡献取 $\\lfloor x /(b + 1)\\rfloor$ ，整除分块计算即可。 D. Multiples and Power Differences 数据范围 $1\\le a_{i,j}\\le 16$ ，观察： $\\text{lcm}(1,2,\\cdots,16)=720720\\le 10^6 - 10^5$ $16^4 = 65536\\le 10^5$ 将矩阵黑白染色，黑色变为 $720720$ ， 白色变为 $720720+x^4$ 即可 （ $x$ 为原矩阵对应位置的数） E. Move and Swap 设 $f[u]$ 表示红点在 $u$ 时，$u$ 及其子树的最大得分。 若红蓝不交换，假设红色在 $u$ ，则最优解本质上是 $u$ 儿子最大得分 + 同深度点与 $u$ 点权最大差值。 若红蓝交换，则本质是任选同深度节点 $v$ 的最优儿子，及 $v$ 与 $u$ 点权差值。 那么转移方程具体的（设 $d[u]$ 表示节点 $u$ 的深度）：$$f[u] = \\max \\bigg \\{ \\max_{s\\in son[u]} f[s] + \\max_{d[v] = d[u]} | a_u - a_v |\\ ,\\ \\max_{d[v]=d[u]}\\bigg(|a_u-a_v| + \\max_{s\\in son[v]} f[s]\\bigg)\\bigg \\}$$可以发现转移是从深到浅转移的。第一部分直接枚举儿子转移即可，第二部分维护： $$mxp[d] = \\max_{d[v]=d}\\bigg(a_v + \\max_{s\\in son[v]} f[s]\\bigg)\\ ,\\ mxm[d] = \\max_{d[v]=d}\\bigg(-a_v + \\max_{s\\in son[v]} f[s]\\bigg)$$ 则第二部分的转移就可以表示为 $f[u] = \\max{mxp[d[u]] - a[u],mxm[d[u]]+a[u]}$ 。 F. Copy or Prefix Sum 假设当前处理到第 $i$ 位，前 $i-1$ 位的和为 $S$ ，那么 $a_i=b_i$ 或者 $a_i=b_i-S$ 都是可以的。 那么答案为什么不是 $2^n$ 呢？因为 $S=0$ 时会重复计数。 设 $f_{i,S}$ 表示前 $i$ 位填完，前缀和为 $S$ 的方案数，那么转移为： $a_i=b_i$ ： $\\forall S\\ ,\\ f_{i+1,S+b_i} += f_{i,S}$ $a_i = b_i -S$ ： $\\forall S\\ ,\\ f_{i+1,b_i}+=f_{i,S}$ ，即 $f_{i+1,b_i}=\\sum_{\\forall S} f_{i,S}$ $S=0$ 去重：$f_{i+1,b_i} -= f_{i,0}$ 综上，$i\\to i+1$ 转移的过程即为：所有的 $f$ 整体向右偏移 $b_i$ ，然后对 $f_{b_i}$ 单独赋值。 因此省略第一维，使用 map 维护第二维，用记录整体偏移量的方法优化。 记录 $tot=\\sum_{k=1}^ib_k\\ ,\\ ans=\\sum_{\\forall S} f_S$ ，递推即可，实现见 代码 。 Feb / 05 - Round #699 (4/6) A. Space Navigation 统计四个方向的移动分别有多少，只保留走向目标向量对应方向的移动，判断是否可达。 B. New Colony 观察数据范围 $n,h_i\\le 100$ 最多扔 $10^4$ 个石头就结束了，模拟 $\\text O(n^2h)$ 即可。 C. Fence Painting 首先如果最后一次涂色不在 $b_i$ 里，肯定无解。 然后如果所有涂色不能满足将所有 $a_i$ 和 $b_i$ 不一样的位置覆盖为 $b_i$ ，则无解。 剩下的情况必定有解，一种构造方法： 对每种颜色 $c$ 预处理出来所有 $a_i$ 和 $b_i$ 不同且 $b_i=c$ 的位置集合 $S_c$ 。 首先确定最后一次涂色的位置 $pos_m$ ： 若 $S_{c_m}$ 为空，则令 $pos_m$ 为任意一个 $b_i=c_m$ 的位置。 若 $S_{c_m}$ 不为空，则让 $pos_m$ 为 $S_{c_m}$ 中的任意一个，并将该位置移出 $S_{c_m}$ 。 然后时间倒序考虑，对于当前颜色 $c_j$ ： 若 $S_{c_j}$ 为空，那么让 $pos_j=pos_m$ ，因为第 $m$ 次操作是最后一次，所以肯定会覆盖。 若 $S_{c_j}$ 不为空，则让 $pos_j$ 为 $S_{c_j}$ 中任意一个位置，然后将该位置移除 $S_{c_j}$ 即可。 D. AB Graph 首先奇数长度一定有解，在两个点之间来回跑就可以了。 考虑偶数长度，如果存在连接两个点的一组边类型相同，那么就一直在这两个点之间来回跑就可以了。 剩余的情况就是每一组边都是一条 $A$ 一条 $B$ ，那么对于 $n\\ge 3$ 时很容易证明： 存在一个点 $x$ ，满足存在另两个点 $y,z$ ，边 $x\\to y$ 和 $x\\to z$ 的类型不同。 反证法：假设对于任意的点，所有的出边类型相同，入边类型相同，且两种边类型不同。不妨设点 $x$ 的所有出边类型均为 $A$ ，也就是说对于其他任意的点的入边类型均为 $A$ （由假设性质）那么对于任意另外两个点 $y,z$ 之间的边的类型，存在矛盾：$z$ 的入边由上知类型为 $A$ ，则 $y\\to z$ 是 $z$ 的入边，类型必须为 $A$。$y$ 的出边与入边类型相反，则 $y\\to z$ 是 $y$ 的出边，类型必须为 $B$ 。 因此只需要 $\\text O(n)$ 枚举 $x$ ，$\\text O(n)$ 扫描其他点，判断是否存在 $y,z$ 即可。 对于 $m = 4k$ 的情况，构造解形如 $x\\ y\\ x\\ y\\cdots x\\ y\\ x\\ z\\ x\\ \\cdots z\\ x\\ z\\ x$ 即可。 对于 $m = 4k+2$ 的情况，构造解形如 $y\\ x\\ y\\ x\\ y\\cdots x\\ y\\ x\\ z\\ x\\ \\cdots z\\ x\\ z\\ x\\ z$ 即可。","categories":[{"name":"Contests","slug":"Contests","permalink":"http://blog.gyx.me/categories/Contests/"}],"tags":[]},{"title":"Facing the Unknown","slug":"face-the-unknown","date":"2021-12-28T17:06:37.000Z","updated":"2021-12-28T17:58:12.345Z","comments":true,"path":"2021/12/29/face-the-unknown/","link":"","permalink":"http://blog.gyx.me/2021/12/29/face-the-unknown/","excerpt":"Choose to face the unknown.","text":"起因本学期选了《影视音乐鉴赏》这门课，期末要求写一篇课程论文赏析一部影片中的影视音乐。很早就想看《海上钢琴师》，而且想想这部片子里的音乐应该少不了，就趁机看掉了。不得不说顶着期末季的压力，真的很容易被感动到。 片子真的很棒，剧情节奏虽然很缓慢，但自己却能很真实的感受到人物内心丰富的世界。可圈可点的地方太多了，只能说：妙不可言，建议自己去看一遍。（这篇随笔容量太小，我对影片有很多绝妙的点评，但是写不下） 想动笔写这篇随笔的起源是，看完电影和 Eva 同学讨论，聊的很久的主题是面对未知的选择。 面对未知人们对未知的恐惧，往往来自于失去了对已知的掌控感，或许也是“未知”这个词本身的含义。 作为一个学生，从小受到的教育往往是圈好范围、划好边界的，即使是探究性问题，也往往会有标准答案。在需要接触陌生的学科，涉足陌生的领域时，自己往往会像1900一样选择不去尝试。说的难听一点，原因其实是害怕自己失去对于”已知“内容的掌控感。想象自己在面对过于开放性的问题时，手足无措的感觉确实让人望而却步。 这就要回到电影里的核心话题：为什么1900 没有选择上岸？ Take a piano. The keys begin, the keys end. You know there are 88 of them, and nobody can tell you any different. They are not infinite. You are infinite. And on those keys the music that you can make is infinite. That I can live by. But you get me up on that gangway and you roll out in front of me a keyboard of millions of keys, millions and billions of keys that never end, and that’s the truth. That keyboard is infinite. And if that keyboard is infinite, then on it there’s no music you can play. You are sitting on the wrong bench! That’s God’s piano. 钢琴的琴键固定是88个，只有创作出的音乐才是无穷的，这是我赖以为生的方式。 但陆地的生活是一个巨大的琴键，琴键本身就是是无穷的，而人无法在无穷的琴键上创作音乐。这是属于上帝的键盘。 这段 1900 的独白确实很打动人心。他从小生活的地方和他的日常生活都很干净纯粹，他对于一切都尽在掌握，乐在其中。而面对无穷的陆地生活，1900害怕了。害怕的是无穷的选择，害怕自己迷失在没有边界的生活中。因为害怕，他拒绝了开始。 All the world weighing down on you without even knowing when it ends. 不得不说自己仿佛也经历过这个过程，不过是在面对要学习知识这个相对较小的问题上。在发现知识真的是“学不完”的时候，那种恐惧的感觉确实像是整个世界压在了身上。我算是还没感受到对未知的恐惧时，就迈出去了。等发现对“未知”的恐惧时，也已经在路上走的有一段距离了，因此更想谈谈的是改变。 抛开 1900 的局限性（接触的世界有限、接触到的人往往都有着世俗的价值观），对于他阐述的理由，我想问的是：在面对未知时，是否能放下“掌控欲”，能够接受世界的无穷而去勇敢的迈出去呢？ 我觉得往往在结果无关紧要的时候都是可以接受的。但真的面对在心中很重要的事情时，往往会选择保守。 是竞赛给我带来了转折，逼着我经历了从对未知的恐惧，到一半情况下还算平和 的变化。刚开始接触竞赛，是因为觉得各种算法里蕴含的思想十分精妙有趣。但随着深入的学习，自己越来越感受到了那种面对无穷知识的恐惧感。作为传统的学生，失去了那种对于知识的掌控感后，我一度也很丧失信心。经常因为在上考场前已经确信知道有自己不会的东西，反而导致了比赛的时候畏首畏尾，不敢探索。竞赛逼着我接受现实：你永远学不完你要考的，要么放弃，要么没有回避的余地。 一点点把我磨到现在，也算是坚持下来了。现在的状态往往是这样子的：心情好感兴趣的时候可以一直深入，一通 Google 到一堆自己不会的东西，感受下知识的无边。不高兴的时候就把目光收回来，看看自己已经会的东西，敝帚自珍也还是挺开心的。至少现在能够接受自己在上考场时、面对挑战时，即使没有十足的把握，也不至于胆战心惊，把自己会的东西做好就好了。就算手里的牌再烂，也能调整好心情不至于破罐子破摔。（当然也因此养成了坏习惯，面对考试有的时候就摆烂了，最近考试周也因为这个原因几度惹 Eva 同学生气） 说玄学些，自己的信心其实更多的改为建立在对自己能力的信任上了。画大饼就是：我可以不会，但是我相信我可以学会。这种信心的两面性在我的生活中体现就很充分：在面对问题时往往会带来一份坦然，不会因为什么临时的测试过于紧张。但是这也很容易养成不好的性格，就是经常画饼充饥自我安慰，重度拖延症患者。 说回学习，每个学科的东西也本身是无边无际的，只是人为的考纲给画了个圈而已。科研，与其说是发现新事物，不如说是探索现在人类看不到的、没有理解或意识到的“未知”，变为“已知”而已。胡适先生说的好啊，怕什么真理无穷，进一寸有一寸的欢喜。知道自己在做什么就好。 世界确实是上帝的键盘，但也没必要完全参透演奏的方法才敢生活。 就像学习弹琴的人一样，没有谁是把练习曲练得熟熟的才开始碰正式的乐曲。 想想那些刚开始接触钢琴的小孩子，有几个不是上来就一通乱弹，也很开心的呢？ （哪怕是现在我和 Eva 同学也往往会从一通乱弹中获取很多乐趣 后记写到最后发现自己理说的越来越歪，站不住脚，前后互搏，想到哪里就写到哪里了。 感慨的核心大概还是挺惋惜 1900 没有下船的。以及对自己现在面对问题的态度还算接受？ 顶着数片课程论文没写，过来写这个的我也是挺离谱的。希望自己改一改拖的毛病，活过期末。 不合时宜的借用 wls 的一句话：可以是一个理想主义者，但不能用理想主义的方式做事对吧 以及最后的小彩蛋：","categories":[{"name":"Life","slug":"Life","permalink":"http://blog.gyx.me/categories/Life/"}],"tags":[]},{"title":"The 46th ICPC Asia Shenyang Regional","slug":"icpc46-shenyang","date":"2021-11-22T09:21:07.000Z","updated":"2021-12-23T16:05:04.105Z","comments":true,"path":"2021/11/22/icpc46-shenyang/","link":"","permalink":"http://blog.gyx.me/2021/11/22/icpc46-shenyang/","excerpt":"Silver Medal. Rank 44.","text":"Summary 热身赛的ABC都是去年沈阳的三道签到题，D 题是计算几何 HDU 6697。 Closest Pair of Segments &nbsp; Author：Yaohui Zeng 二分答案之后考虑将线段扩张成 “香肠”，检查是否有一对“香肠”相交。 考虑对 $x$ 扫描线，用 set 维护这些香肠关于 $y$ 的顺序，那么总是只需要检查相邻的两个香肠是否相交。亦即，对于一个插入事件，检查新的香肠是否和上下相邻的两个香肠相交，对于一个删除事件，删除香肠之后检查上下两个相邻的香肠是否相交。如果判定到相交说明答案偏大，否则答案偏小。 由于在判定到相交之前的扫描过程中，香肠都是互不相交的凸图形，可以简单地用一条连接香肠最左点和最右点的线段来描述香肠在扫描线上的相对顺序，判定香肠相交直接计算扩张前的两个线段的距离即可。 复杂度是 $O(n\\log n\\log (1/\\epsilon))$ 。 正赛开场签 BEFJ 比较顺利，F 卡了一会 char 和 string 不能直接 + ，后来改字符数组了。 之后两个半小时没过题，H 假做法 + 假代码卡了两个多小时过了。 然后 I 简单分讨了一下，不想调破罐子破摔就直接过了，这个时候刚封榜。 最后 1h 队友搞 L，最后 5 min 成功冲出来了！非常激动！ 虽然又是遗憾银首，但这次参赛体验还是很棒的，收获很多。 首先是虽然中期血崩，但是还是顶住了，在最后一个多小时补救了三题。赛后看看觉得题目并不难，重点还是赛中要有信心，I 题这种题其实有信心的话很早就可以冲出来了。 然后就是相信队友，在最后一个小时还是担心过一段时间的，甚至有点想抢机位写 G 。好在综合过题数考虑后，最后一个小时决定让队友集中精力，搞出来了 L。此外负责乱搞和思路题的队友这场也相当给力，J 题上机之后很快就过了，没有像往常一样调试很久，I 题的推式子也是他提供的方向。整场比赛中真实的感受到整个队都有在努力，很满足。 Resource热身赛题面.pdf &nbsp; 正式赛题面.pdf &nbsp; 官方题解.pptx B. Bitwise Exclusive-OR Sequence 构造 $n$ 个数 $a_1,\\dots,a_n$，满足 $m$ 个约束条件，形如 $a_{p_i}\\oplus a_{q_i} = w_i$ ，且 $\\sum a_i$ 最小。 按位考虑，那么按照每一位都可以建出来一张图，边权为 $0/1$ 表示两个数在这一位相同/不同 。 图存在矛盾的边则无解，有解时可以将每一个连通分图的点划分为两组，让个数少的那一组这一位取 $1$ 即可最小化。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;#define N 200007using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;int n, m;struct node &#123;int a, b, w;&#125; c[N];ll ans = 0;int tot, cnt[2], hd[N], col[N];struct edge &#123;int to, nxt, w;&#125;e[N &lt;&lt; 1];inline void add(int u, int v, int w) &#123; e[++tot].to = u; e[tot].w = w; e[tot].nxt = hd[v]; hd[v] = tot; e[++tot].to = v; e[tot].w = w; e[tot].nxt = hd[u]; hd[u] = tot;&#125;bool fl = 0;void dfs(int u) &#123; ++cnt[col[u]]; for (int i = hd[u], v; i; i = e[i].nxt) &#123; v = e[i].to; if (col[v] != -1) &#123; if (col[v] != (col[u] ^ e[i].w)) &#123;fl = 1; return;&#125; continue; &#125; col[v] = (col[u] ^ e[i].w); dfs(v); if(fl) return; &#125;&#125; inline bool work(int p) &#123; tot = 0; for (int i = 1; i &lt;= n; ++i) hd[i] = 0, col[i] = -1; for (int i = 1; i &lt;= m; ++i) add(c[i].a, c[i].b, ((c[i].w &amp; (1 &lt;&lt; p)) &gt; 0)); for (int i = 1; i &lt;= n; ++i) if (col[i] == -1) &#123; cnt[0] = 0; cnt[1] = 0; col[i] = 0; dfs(i); if (fl) return 1; ans += 1ll * (1 &lt;&lt; p) * min(cnt[0], cnt[1]); &#125; return 0;&#125;int main() &#123; n = rd(); m = rd(); for (int i = 1; i &lt;= m; ++i) &#123; c[i].a = rd(); c[i].b = rd(); c[i].w = rd(); &#125; for (int i = 30; i &gt;= 0; --i) if (work(i)) &#123;puts(&quot;-1&quot;); return 0;&#125; printf(&quot;%lld\\n&quot;, ans); return 0;&#125; E. Edward Gaming, the Champion 给定一个串，数串里有多少个 edgnb 1234567891011121314#include&lt;bits/stdc++.h&gt;#define N 200007using namespace std;int ans;char s[N];int main()&#123; scanf(&quot;%s&quot;, s); for (int i = 0; s[i]; ++i) if (!strncmp(s + i, &quot;edgnb&quot;, 5)) ++ans; printf(&quot;%d\\n&quot;, ans); return 0;&#125; F. Encoded Strings I 设从后往前看，字符 $c$ 第一次出现之前出现过 $k$ 个不同的字母，则映射 f(c)=&#39;a&#39;+k定义一个串 $s$ 的 Encoded String $s’$ ：对 $\\forall i\\le |s|, s’[i] = f(s[i])$ 求给定串所有前缀对应的 Encoded String 中，字典序最大的那个。 暴力求，然后按字典序排序。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;#define N 1007using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;char S[N];map&lt;char, int&gt; f;struct node &#123; int len; char a[N];&#125;s[N];inline bool cmp(node a, node b) &#123; int tot = min(a.len, b.len); for (int i = 1; i &lt;= tot; ++i) if (a.a[i] != b.a[i]) return a.a[i] &lt; b.a[i]; return a.len &lt; b.len;&#125;inline void work(int p) &#123; int cnt = 0; f.clear(); s[p].len = p; for (int i = p; i; --i) &#123; if (!f[S[i]]) f[S[i]] = ++cnt; s[p].a[i] =&#x27;a&#x27; - 1 + f[S[i]]; &#125;&#125;int main() &#123; int n = rd(); scanf(&quot;%s&quot;, S + 1); for (int i = 1; i &lt;= n; ++i) work(i); sort(s + 1, s + 1 + n, cmp); for (int i = 1; i &lt;= s[n].len; ++i) putchar(s[n].a[i]); puts(&quot;&quot;); return 0;&#125; H. Line Graph Matching一个猜结论 + tarjan 题 I. Linear Fractional Transformation 定义复数函数 $f(z)=\\frac{az+b}{cz+d}\\ (a,b,c,d\\in \\mathbb{C},ad-bc\\not=0)$，给定 $f(z_1)=w_1,f(z_2)=w_2,f(z_3)=w_3$ ，求 $f(z_0)$数据保证 $z_1,z_2,z_3,w_1,w_2,w_3$ 两两不同 若 $c=0$ ，则 $f(z)=kz+b$ ，直接用两个方程把 $k,b$ 求出后，判断第三个方程是否正确，然后代入即可。 若 $c\\not = 0$ ，则 $zf(z)+k_3f(z)=k_1z+k_2$ ，手动消元一下得：$$k_3=\\displaystyle\\frac{(w_2z_2 - w_1z_1) - \\displaystyle\\frac{z_2-z_1}{z_3-z_1} * (w_3z_3 - w_1z_1)}{\\displaystyle\\frac{z_2-z_1}{z_3-z_1} * (w_3 - w_1) - (w_2 - w_1)}$$ 比赛的时候本来想用自带的 complex&lt;double&gt; 类，但是发现 real 和 imag 不能直接赋值，就不会用了遂手写… 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;#define N 200007using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;inline double sqr(double x) &#123; return x * x;&#125;struct cp &#123; double a, b; inline cp operator + (const cp &amp;obj) const&#123; return (cp)&#123;a + obj.a, b + obj.b&#125;; &#125; inline cp operator - (const cp &amp;obj) const&#123; return (cp)&#123;a - obj.a, b - obj.b&#125;; &#125; inline cp operator * (const cp &amp;obj) const&#123; return (cp)&#123;a * obj.a - b * obj.b, a * obj.b + b * obj.a&#125;; &#125; inline cp operator / (const double x) const &#123; return (cp)&#123;a / x, b / x&#125;; &#125; inline cp operator / (const cp &amp;obj) const&#123; return (cp)&#123;a * obj.a + b * obj.b, b * obj.a - a * obj.b&#125; / (sqr(obj.a) + sqr(obj.b)); &#125; inline bool operator == (const cp &amp;obj) const&#123; return (fabs(a - obj.a) &lt;= 1e-6 &amp;&amp; fabs(b - obj.b) &lt;= 1e-6); &#125;&#125;;inline void work() &#123; cp z0, z1, z2, z3, w1, w2, w3; z1.a = rd(); z1.b = rd(); w1.a = rd(); w1.b = rd(); z2.a = rd(); z2.b = rd(); w2.a = rd(); w2.b = rd(); z3.a = rd(); z3.b = rd(); w3.a = rd(); w3.b = rd(); z0.a = rd(); z0.b = rd(); cp k = (w2 - w1) / (z2 - z1); cp b = w1 - k * z1; if (w3 == k * z3 + b) &#123; cp res = k * z0 + b; printf(&quot;%.10lf %.10lf\\n&quot;, res.a, res.b); return; &#125; cp g1, g2, g3; g1 = z1 * w1; g2 = z2 * w2; g3 = z3 * w3; cp kk = (z2 - z1) / (z3 - z1); cp k3 = ((g2 - g1) - kk * (g3 - g1)) / (kk * (w3 - w1) - (w2 - w1)); cp k1 = ((g2 - g1) + k3 * (w2 - w1)) / (z2 - z1); cp k2 = z1 * w1 + k3 * w1 - k1 * z1; cp res = (k1 * z0 + k2) / (z0 + k3); printf(&quot;%.10lf %.10lf\\n&quot;, res.a, res.b);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; 题解提供的做法比较神仙，先抄上：分式线性变换保交换比，有：$$\\frac{w_0-w_1}{w_0-w_2}\\bigg/\\frac{w_3-w_1}{w_3-w_2}=\\frac{z_0-z_1}{z_0-z_2}\\bigg/\\frac{z_3-z_1}{z_3-z_2}$$ 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;typedef complex&lt;double&gt; C;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;inline C rdc() &#123; int x = rd(), y = rd(); return C(x, y);&#125;inline void work() &#123; C z1 = rdc(), w1 = rdc(), z2 = rdc(), w2 = rdc(), z3 = rdc(), w3 = rdc(), z0 = rdc(); C res = ((z0 - z1) / (z0 - z2)) / ((z3 - z1) / (z3 - z2)) * ((w3 - w1) / (w3 - w2)); res = w2 + (w2 - w1) / (res - C(1, 0)); printf(&quot;%.12lf %.12lf\\n&quot;, res.real(), res.imag());&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; J. Luggage Lock队友强强切掉了～回头再来看 L. Perfect Matchings队友强强切掉了～回头再来看","categories":[{"name":"Competitions","slug":"Competitions","permalink":"http://blog.gyx.me/categories/Competitions/"}],"tags":[]},{"title":"The 7th CCPC Guilin Regional","slug":"ccpc7-guilin","date":"2021-11-11T04:02:07.000Z","updated":"2021-12-27T13:54:47.261Z","comments":true,"path":"2021/11/11/ccpc7-guilin/","link":"","permalink":"http://blog.gyx.me/2021/11/11/ccpc7-guilin/","excerpt":"Silver Medal. Rank 49.","text":"Summary 热身赛是澳门的三道题，B 题卡常带 $8$ 倍常数卡过去了， C 没有做出来。 正赛开场我们比较顺利，AGI过的很快，D猜了一次结论WA了，很快找出了反例。 之后猜到了E的结论，spfa 被卡了两发，改 dijkstra 之后过了，大概耗了一个小时。 之后 D 想出来了能通过写出所有反例的方法，WA了一发，发现是数组开小了，过了。 之后开了BFJK，因为 J 最先想到了一种做法，选择了先写 J ，复杂度有点高卡不过去。 还剩下一个半小时，觉得 B 的线段树比较有把握，写 + 调 + 对拍花了一个小时，过了。 最后半个小时感觉写 F 不是很有信心，于是调 JK，都是 TLE/MLE 左右横跳，卡到最后。 这次参赛体验还是不错的，我也没有像往常一样挂机，输出还可以。 赛程后一半机位交给了两个大数据结构 + 一个乱搞，我也无能为力，对于结果只能说菜是原罪了。 比较遗憾的是 F 很轻松地看出了正解，但是因为没写过不敢上机，希望之后的比赛能敢冲计算几何吧。 Resource热身赛题面.pdf &nbsp; 正式赛题面.pdf &nbsp; 官方题解.pdf &nbsp; F 题 Heltion 参考代码 A. A Hero Named Magnus 从第 $x$ 轮之后就会一直胜，此前胜率 $50\\%$ ，问至少比几轮保证能一定胜利（获胜轮数多者胜） 前面全输，答案是 $2x-1$ ，开 long long 或者 python. 1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;int main() &#123; for (int t = rd(); t; --t) printf(&quot;%lld\\n&quot;, rd() * 2 - 1); return 0;&#125; B. A Plus B Problem 维护一个 $n \\ (n\\le 10^6)$ 位数加法器，包含三个 $n$ 位数 $A+B=C$ （忽略最高位进位）。每次修改 $A$ 或 $B$ 中的一位，求修改后 $C$ 这一位的结果，以及加法器中有多少位受影响。 线段树是可以直接模拟的，支持查询前缀 $0$ 长度，前缀 $9$ 长度，区间赋值 $0$ ，区间赋值 $9$ 即可。 比较妙的做法：$C_i=(A_i+B_i+[A_j+B_j\\ge 10])\\ \\text{mod}\\ 10$ ，$j$ 为 $i$ 后面第一个 $A_i+B_i\\not= 9$ 的位置。 进位/退位影响的话，也是影响前缀 $A_j+B_j=9$ 的一段，因此需要查询 $i$ 前面第一个 $A_i+B_i\\not= 9$ 的位置。 综上，set 维护 $A_i+B_i\\not= 9$ 的位置 $i$ 即可，复杂度 $O((n+q)\\log n)$ . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;#define N 1000007using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;inline int rdc() &#123; char c = getchar(); while (!isdigit(c)) c = getchar(); return c - &#x27;0&#x27;;&#125;set&lt;int&gt; s;int a[3][N];//a[0] = c, a[1] = a, a[2] = binline void work() &#123; int r = rd(), c = rd(), x = rd(); int pos = *s.upper_bound(c); int old = a[0][c] + (a[0][pos] &gt;= 10); if (a[r][c] == x) &#123;printf(&quot;%d 0\\n&quot;, old % 10);return;&#125; if (a[0][c] != 9) s.erase(c); a[r][c] = x; a[0][c] = a[1][c] + a[2][c]; if (a[0][c] != 9) s.insert(c); int nw = a[0][c] + (a[0][pos] &gt;= 10); int ans = 2; if ((old &gt;= 10) ^ (nw &gt;= 10)) &#123; int pre = *(--s.lower_bound(c)); ans = c - pre + 1 + (pre != 0); &#125; printf(&quot;%d %d\\n&quot;, nw % 10, ans);&#125;int main() &#123; int n = rd(), q = rd(); for (int i = 1; i &lt;= n; ++i) a[1][i] = rdc(); for (int i = 1; i &lt;= n; ++i) &#123; a[2][i] = rdc(); a[0][i] = a[1][i] + a[2][i]; if (a[0][i] != 9) s.insert(i); &#125; s.insert(0); s.insert(n + 1); for (int i = 1; i &lt;= q; ++i) work(); return 0;&#125; D. Assumption is All You NeedE. Buy and Delete 给一个有向图，每条边有一个价值 $w_i$ ，你可以选总价值不超过 $c$ 的边保留，其余边删除。一组边可以被删除，当且仅当这组边不包含一个有向环。另一个人采取最优策略删除所得图的边（最少次数），问你最多能让他操作几次。 一条边都买不起的时候答案是 0 ; 买得起一条边但买不起一个环的时候答案是 1 ; 买得起环的时候，可以发现所有边可以分成无环的两组：$u&gt;v$ 和 $u&lt;v$ ，因此答案最大为 2 . 因此只需要找出最小环，使用 dijkstra 枚举起点 $O(n(m+n)\\log m)$ 即可。 spfa 已死！真的不要幻想在正赛继续用 spfa 了…$n=2000,m=5000$ 的时候竟然也能把 spfa 卡掉… 「历史的经验教训告诉我们，人们不会从历史的经验中吸取教训。」 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;#define N 2007#define fr first#define sc second#define mp make_pair#define pii pair&lt;int, int&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;int tot, hd[N], mnw = 1e9;struct edge &#123;int w, to, nxt;&#125; e[N &lt;&lt; 2];inline void add() &#123; int u = rd(); e[++tot].to = rd(); mnw = min(mnw, (e[tot].w = rd())); e[tot].nxt = hd[u]; hd[u] = tot;&#125;bool vis[N];int ans = 1e9, dis[N];priority_queue&lt;pii&gt; q;inline void dij(int s) &#123; memset(vis, 0, sizeof(vis)); memset(dis, 0x3f, sizeof(dis)); dis[s] = 0; q.push(mp(0, s)); while (!q.empty()) &#123; int u = q.top().sc; q.pop(); if (vis[u]) continue; vis[u] = 1; for (int i = hd[u], v; i; i = e[i].nxt) if (dis[v = e[i].to] &gt; dis[u] + e[i].w) &#123; dis[v] = dis[u] + e[i].w; q.push(make_pair(-dis[v], v)); &#125; else if (v == s) ans = min(ans, dis[u] + e[i].w); &#125;&#125;int main() &#123; int n = rd(), m = rd(), c = rd(); for (int i = 1; i &lt;= m; ++i) add(); for (int i = 1; i &lt;= n; ++i) dij(i); puts( c &lt; mnw ? &quot;0&quot; : (c &lt; ans ? &quot;1&quot; : &quot;2&quot;)); return 0;&#125; F. Illuminations II 给两个凸包，小凸包严格在大凸包内，现在在大凸包边界上等概率放一个点光源，问能照到小凸包周长的期望长度。 根据期望的线性，考虑小凸包每条边的贡献，有贡献的概率是： （这条边所在直线切割大凸包周长所得的可以照射到这条边的长度）/（大凸包周长） 因此只需要求出直线和凸包的两个交点即可，按照时针顺序枚举小凸包的边，交点移动方向单调。 具体找交点的方法是将直线拆成两条射线，然后射线 $s\\to t$ 和线段 $cd$ 判交，然后直线 $st$ 和直线 $cd$ 求交点即可。 实现的时候参考 Heltion 的代码学到很多！代码中有很妙的技巧，限于篇幅 没时间写 就先只贴一下我的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;#define N 1000007using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;struct vec &#123; long double x, y; long double norm2() const &#123;return x * x + y * y;&#125; long double norm() const &#123;return sqrt(norm2());&#125; vec operator + (const vec &amp;obj) const &#123;return (vec)&#123;x + obj.x, y + obj.y&#125;;&#125; vec operator - (const vec &amp;obj) const &#123;return (vec)&#123;x - obj.x, y - obj.y&#125;;&#125; vec operator * (const long double &amp;t) const &#123;return (vec)&#123;x * t, y * t&#125;;&#125; long double operator * (const vec &amp;obj) const &#123;return x * obj.x + y * obj.y;&#125; long double cross (const vec &amp;obj) const &#123;return x * obj.y - y * obj.x;&#125; long double dis(const vec &amp;obj) const &#123;return ((*this) - obj).norm();&#125;&#125;;bool cross(const vec &amp;s, const vec &amp;t, const vec &amp;c, const vec &amp;d) &#123; long double w1 = (t - s).cross(c - s); long double w2 = (t - s).cross(d - s); long double w3 = (d - c).cross(s - c); long double w4 = (d - c).cross(t - c); long double w5 = (d - c).cross(t - s); if (w1 * w2 &gt; 0 || (w3 * w4 &gt; 0 &amp;&amp; w3 * w5 &gt; 0)) return 0; if (w1 * w2 &lt; 0 || w3 * w4 &lt; 0) return 1; long double v1 = (t - s) * (c - s); long double v2 = (t - s) * (d - s); return (v1 &gt;= 0 || v2 &gt;= 0);&#125;vec cross_point(const vec &amp;a, const vec &amp;b, const vec &amp;c, const vec &amp;d) &#123; vec d0 = b - a, d1 = d - c, u = c - a; long double t = u.cross(d1) / d0.cross(d1); return a + d0 * t;&#125;int main() &#123; int n = rd(), m = rd(); vector&lt;vec&gt; p(n), q(m); for (auto&amp; [x, y] : p) &#123;x = rd(); y = rd();&#125; for (auto&amp; [x, y] : q) &#123;x = rd(); y = rd();&#125; vector&lt;long double&gt; sum(n); for (int i = 0; i &lt; n; ++i) &#123; sum[i] = (p[i] - p[(i + 1) % n]).norm(); if (i) sum[i] += sum[i - 1]; &#125; int f = 0, t = 0; long double ans = 0; for (int i = 0; i &lt; m; ++i) &#123; const vec &amp;A = q[i], &amp;B = q[(i + 1) % m]; while (!cross(B, A, p[f], p[(f + 1) % n])) f = (f + 1) % n; while (!cross(A, B, p[t], p[(t + 1) % n])) t = (t + 1) % n; long double df = cross_point(B, A, p[f], p[(f + 1) % n]).dis(p[f]) + sum[(f - 1 + n) % n]; long double dt = cross_point(A, B, p[t], p[(t + 1) % n]).dis(p[t]) + sum[(t - 1 + n) % n]; if (dt &lt; df) dt += sum.back(); ans += (A - B).norm() * (dt - df); &#125; printf(&quot;%.15Lf\\n&quot;, ans / sum.back()); return 0;&#125; G. Occupy the Cities 给一个 $01$ 序列，每秒每个 $1$ 可以选择将左侧或右侧的数变成 $1$ ，问最少多少秒全部变成 $1$ 。 可以发现连续 $1$ 的长度大于 $1$ 时，每秒向左向右都可以扩展 $1$ 个位置。 因此考虑二分答案 $x$ ，从左往右依次判断，对于长度大于 $1$ 的连续段直接计算左右扩展范围。 对于单个的 $1$ ，如果 $x-1$ 秒可以把前缀剩下的部分填完，就先向右扩展一个 ，否则先向左。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;#define N 500007using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;inline int rdc() &#123; char c = getchar(); while (!isdigit(c)) c = getchar(); return c - &#x27;0&#x27;;&#125;int n, tot;struct seg &#123;int l, r;&#125;c[N];inline void add(int l, int r) &#123; c[++tot].l = l; c[tot].r = r;&#125;inline bool valid(int x) &#123; int nwr = 0; for (int i = 1, dis; i &lt;= tot; ++i) &#123; dis = c[i].l - nwr - 1; if (dis &gt; x) return 0; nwr = c[i].r + x; if (c[i].r == c[i].l &amp;&amp; dis == x) --nwr; &#125; return nwr &gt;= n;&#125;inline void work() &#123; n = rd(); tot = 0; int l = 0, r = 0; for (int i = 1; i &lt;= n; ++i) &#123; int x = rdc(); if (x) &#123;if (!l) l = i; r = i;&#125; else &#123;if (l) add(l, r); l = 0; r = 0;&#125; &#125; if (l) add(l, r); if (c[1].l == 1 &amp;&amp; c[1].r == n) &#123;puts(&quot;0&quot;); return;&#125; l = 1; r = n; while (l &lt; r) &#123; int mid = (l + r) / 2; valid(mid) ? r = mid : l = mid + 1; &#125; printf(&quot;%d\\n&quot;, l);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; 此外官方题解给出了两个 $O(n)$ 的写法。我尝试了一下 WA 了并且非常难调遂放弃了… I. PTSD $n$ 个数 $1,\\cdots ,n$ ，第 $i$ 个数有权值 $a_i=0/1$ 。将所有数划分成若干组，答案为每组第二大 $i\\times a_i$ 的和。 贪心的拿正确性比较显然，同情况下第二名可以是大的一定拿大的，可以多拿一定多拿。 因此方案就是尽可能两两一组，第二大的 $a_i=1$ ，第一大的 $a_i=0$ 。 因此维护一个 cnt，记录还有多少个比当前大的数字还没被分组。 从大往小考虑，只要 cnt&gt;0 并且 $a_i=1$ 就将 $i$ 累加进答案，--cnt，否则 ++cnt 。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;#define N 1000007using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;inline int rdc() &#123; char c = getchar(); while (!isdigit(c)) c = getchar(); return c - &#x27;0&#x27;;&#125;int n, a[N], tot;inline void work() &#123; n = rd(); tot = 0; for (int i = 1; i &lt;= n; ++i) a[i] = rdc(); ll ans = 0; for (int i = n; i; --i) &#123; if (a[i] &amp;&amp; tot) &#123;ans += i; --tot;&#125; else ++tot; &#125; printf(&quot;%lld\\n&quot;, ans);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; J. Suﬃx Automaton队友强强补掉了～ 有空再来看 K. Tax队友强强补掉了～ 有空再来看","categories":[{"name":"Competitions","slug":"Competitions","permalink":"http://blog.gyx.me/categories/Competitions/"}],"tags":[]},{"title":"PAT  Autumn 2021","slug":"pat2021","date":"2021-09-11T09:43:27.000Z","updated":"2021-10-11T09:43:27.000Z","comments":true,"path":"2021/09/11/pat2021/","link":"","permalink":"http://blog.gyx.me/2021/09/11/pat2021/","excerpt":"Colin 同学和 Eva 同学一起参加了 PAT 2021 年秋季考试！","text":"Background某天心血来潮拉上 Eva 同学一起报名了 PAT ～ 开学前在 官方题库 里刷了两道题热身！其实是想刷完但是太鸽了 然后就到考试时间啦！借着考试翘掉了半天的军训！好耶！ Solution ( Top Level )代码写的赶时间，比较丑。 A. Sorted Cartesian tree 给定 $n$ 个 pair&lt;priority, key&gt; ，构建一棵 $n$ 个节点的二叉树，满足：节点 priority 关键字满足堆的性质，即 priority 父节点小于子节点节点 key 关键字满足二叉搜索树的性质，即中序遍历 key 单调不降把树建出来，输出 priority 和 key 的 Level-order traversal 序列 模拟题意 dfs 建树，传一个 set&lt;node&gt; 即可。 求层序遍历一个 bfs 就够了 考场上写了个dfn+dep双关键字排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;#define N 37using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125; struct node &#123;int k, p, id;&#125; c[N];inline bool operator &lt; (const node &amp;a, const node &amp;b) &#123; if (a.p != b.p) return a.p &lt; b.p; if (a.k != b.k) return a.k &lt; b.k; return a.id &lt; b.id;&#125;int ls[N], rs[N], k[N], p[N];set&lt;node&gt; S;int dfs(set&lt;node&gt; s) &#123; if (s.empty()) return 0; node nw = *s.begin(); s.erase(nw); set&lt;node&gt; l, r; for (auto t : s) &#123; if (t.k &lt;= nw.k) l.insert(t); else r.insert(t); &#125; ls[nw.id] = dfs(l); rs[nw.id] = dfs(r); return nw.id;&#125;queue&lt;int&gt; q;int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; c[i].id = i; c[i].k = rd(); c[i].p = rd(); S.insert(c[i]); &#125; int ptr = 0, rt = dfs(S); q.push(rt); while (!q.empty()) &#123; int u = q.front(); q.pop(); if (ls[u]) q.push(ls[u]); if (rs[u]) q.push(rs[u]); k[++ptr] = c[u].k; p[ptr] = c[u].p; &#125; for (int i = 1; i &lt; n; ++i) printf(&quot;%d &quot;, k[i]); printf(&quot;%d\\n&quot;, k[n]); for (int i = 1; i &lt; n; ++i) printf(&quot;%d &quot;, p[i]); printf(&quot;%d&quot;, p[n]); return 0;&#125; B. Unity is Strength 给一张有权无向图，以及若干条可以花 $w_i$ 连接 $u_i,v_i$ 的无向边。先输出每个联通块的 “块内最小编号 - 块内最小边权” ，按照块大小-最小边权-最小点编号的顺序排序然后计算把整个图联通的最小代价，除给定边外，任意两点之间都可以花 $10^4$ 的代价连接一条边。 并查集模拟题意即可，第一步求出来每个集合的若干信息，然后排序一下。 之后就是最小生成树，考虑给定边不一定能让整个图联通，最后答案加上（联通块数 $-1$ ）$\\times 10^4$ 即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;#define N 100007#define inf 1e9using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125; int f[N], mn[N], mnid[N], sz[N], totr, totc;struct road &#123; int u, v, w;&#125;r[N]; inline bool cmp2(road a, road b) &#123; return a.w &lt; b.w;&#125; inline int find(int x) &#123; return x == f[x] ? x : f[x] = find(f[x]);&#125;inline void merge(int a, int b, int w) &#123; a = find(a); b = find(b); if (a == b) &#123; mn[a] = min(mn[a], w); return; &#125; f[a] = b; sz[b] += sz[a]; mnid[b] = min(mnid[b], mnid[a]); mn[b] = min(mn[b], min(mn[a], w));&#125;struct node &#123; int mnid, sz, str;&#125;c[N]; inline bool cmp1(node a, node b) &#123; if (a.str != b.str) return a.str &gt; b.str; if (a.sz != b.sz) return a.sz &gt; b.sz; return a.mnid &lt; b.mnid;&#125;int main() &#123; int n = rd(); int m = rd(); for (int i = 1; i &lt;= n; ++i) &#123; f[i] = i; mn[i] = inf; mnid[i] = i; sz[i] = 1; &#125; for (int i = 1, u, v, w; i &lt;= m; ++i) &#123; u = rd(); v = rd(); w = rd(); if (w &gt; 0) merge(u, v, w); else r[++totr] = (road)&#123;u, v, -w&#125;; &#125; for (int i = 1; i &lt;= n; ++i) if (f[i] == i) c[++totc] = (node)&#123;mnid[i], sz[i], (mn[i] == inf ? 0 : mn[i])&#125;; sort(c + 1, c + 1 + totc, cmp1); for (int i = 1; i &lt; totc; ++i) printf(&quot;%d-%d &quot;, c[i].mnid, c[i].str); printf(&quot;%d-%d\\n&quot;, c[totc].mnid, c[totc].str); int ans = 0; sort(r + 1, r + 1 + totr, cmp2); for (int i = 1; i &lt;= totr; ++i) &#123; int u = find(r[i].u); int v = find(r[i].v); if (u != v) &#123;merge(u, v, r[i].w); ans += r[i].w;&#125; &#125; int cnt = 0; for (int i = 1; i &lt;= n; ++i) cnt += (f[i] == i); ans += (cnt - 1) * 10000; printf(&quot;%d&quot;, ans); return 0;&#125; C. Manhattan 给定一个序列 ${ a_i }\\ (1\\le a_i\\le 3)$，两个人玩（开始双方均为 $0$ 分），每次某个人取走最靠前的 $a_i$ 加到当前的得分里。要求每个人拿完之后，当前的得分不得少于对方，问有多少种划分方案，答案 $\\mod 10^ 9 + 7$ 裸的 DP 就是 f[i][j] 表示当前考虑前 $i$ 个数，第一个人比第二个人多 $j$ 的方案数。 因为 $a_i\\le 3$ ，所以如果某个人比另一个人多了超过 $3$ 分，对手就无法满足要求，之后就只能是这个人拿了。 所以 j 可以把特殊的状态放到一起，范围就只有 $9$ 了，复杂度 $O (9n)$ ，转移要注意条件。 实现的时候整体偏移了 $5$ ，也就是 $j=5$ 时两个人得分一样。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;#define N 100007#define mod 1000000007using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125; int f[N][10];#define add(a,b) a = (a + b) % modint main() &#123; f[0][5] = 1; int n = rd(); for (int i = 1, x; i &lt;= n; ++i) &#123; x = rd(); for (int j = 1; j &lt;= 9; ++j) &#123; if (j - x &lt;= 1) add(f[i][1], f[i - 1][j]); if (j + x &gt;= 9) add(f[i][9], f[i - 1][j]); &#125; for (int j = 2; j &lt;= 8; ++j) &#123; if (j - x &gt; 1 &amp;&amp; j - x &lt;= 5) add(f[i][j - x], f[i - 1][j]); if (j + x &lt; 9 &amp;&amp; j + x &gt;= 5) add(f[i][j + x], f[i - 1][j]); &#125; &#125; int ans = 0; for (int i = 1; i &lt;= 9; ++i) add(ans, f[n][i]); printf(&quot;%d&quot;, ans); return 0;&#125; Summary比赛之前比较焦虑（毕竟军训一周都没碰键盘），到考场发现左边坐的是学长。 开场把三个题都开了， 题目描述都十分迷惑（英语太差），结合样例枚举题意读题。 分不清：Preorder 先序；Inorder 中序；Postorder 后序；Level-order traversal 层序遍历 过题顺序 T2 - T1 - T3 ，看榜应该是 Rank 2，所有题都是一次过非常舒适。 然后就提前跑路了！因为 Eva 同学还在奋战，我就开始快乐的浙传半日游～ 浙传的校园就比较有感觉，总觉得杭电的楼都是一个样子的，缺点大学的气息…","categories":[{"name":"Life","slug":"Life","permalink":"http://blog.gyx.me/categories/Life/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"http://blog.gyx.me/tags/DFS/"},{"name":"Union-Find Set","slug":"Union-Find-Set","permalink":"http://blog.gyx.me/tags/Union-Find-Set/"},{"name":"Counting","slug":"Counting","permalink":"http://blog.gyx.me/tags/Counting/"}]},{"title":"Love is the Greatest","slug":"freshman","date":"2021-07-08T02:27:14.000Z","updated":"2021-07-15T02:27:14.000Z","comments":true,"path":"2021/07/08/freshman/","link":"","permalink":"http://blog.gyx.me/2021/07/08/freshman/","excerpt":"It is the time you have wasted for your rose that makes your rose so important.","text":"今天是 2021 年 7 月 8 日，星期四。 一年前的今天，高考最后一门刚刚考完。走出考场，回到自己的教室，拿手机，搬行李，告别。 离开学校的时候，碰到了还在梳理交通的竞赛教练，问我考的怎么样，然后约了后天要给高一的学弟们上课。 直到昨晚，暑假回本部给又一届的学弟们上完最后一天课。从二中本部的校门里走出来，回头看看。 来杭电之前高考完就跟爸爸妈妈说我不复读，当晚就对答案，大概 645。报了南科大综评，拿到了还算不错的校考分。 然后在南校区给高一的同学讲了比较入门的概率，也是那些在一年前的暑假认识的，刚踏入二中大门学弟。 结束的时候在空空的学校里溜达，想想他们上课时候那种纯粹的热情，一代又一代，多少有一点感慨。 走之前拍了张照片，想起来一句自认为很应景的话：“雨过天青云破处，者般颜色做将来” 出分的晚上比较坦然，提前几分钟查到了分数，比估计的低 9 分，都扣在语文上，115 / 134 / 136 / 251。 之后的几天比较迷茫，听了几个学校的招生宣讲都不尽如人意。南科大那边几度有希望，后来终究是落空。 在我想起来杭电这所学校的时候，突然感觉就是要去这里了。 可能是高二去学军培训喜欢上了杭州这个城市，也可能是对竞赛生涯结束的不甘吧。 先自己偷偷找 Claris 要到了教练的联系方式，问了读研和专业的事情，刘老师的热情的杭州话让人很舒服。 然后就是小心翼翼地和父母交流，说我自己的想法和考虑，直到最后心里十分踏实地填上了第一志愿。 录取的结果是数学系，高考分数达到了卓越学院二次选拔的报名分数线，报了卓越学院的招生考试。 之后的假期写了几个板子，打了几场 CF 恢复一点水平，参加了 HDU 的几场内部训练，搬了一套题恰烂钱。 开学之前和岳老师吃了个饭（竟然还赶上了他生日）， 让我重心不要全部放到竞赛上，要给自己留个后路。 初到杭电有一说一假期还是过的比较随意，虽然报名了卓越学院，但是一点没准备，9 月份忐忑地就来到杭电啦。 考试之前自己很没有底气，当时觉得能进计科班就不错了。考完觉得考的还行，因为竞赛里接触过一点高数线代的知识，觉得自己英语阅读也比较会蒙。然后晚上大概九点的时候出成绩了，震惊自己竟然过了英才班的线。 晚上给爸爸妈妈很激动地打了个电话，有点担心 11 进 9 被刷掉，一直到十二点多才睡着。 第二天面试的时候其实自己比较轻松，感觉面试向来都比较稳 比较会吹 ，面试单独面，五个老师。 面试比较自然，老师们的问题基本是跟着我的自我介绍思路走，不过还是有几个问题血压拉满。 我努力地强调自己的竞赛水平，然后冯老师问：“现在让你去打区域赛能拿到什么奖项？” 我介绍了一下高中学校和班级的情况，然后另一个老师问：“你觉得二中和衡一哪个更好？” 周老师（也是现在的导师）问：“你也不能打一辈子竞赛啊。以后有什么进一步的打算？”我说会读研，以后可能会去当大学老师。导师笑笑说要想当教授，后面得去好点的大学读书。 面试完出来觉得自己还挺稳的，但是也不敢确定，忐忑到了晚上十点多出了结果。终于还是去学计算机了。 之后的生活很顺利，见面会，正常上课，班委选举（当了学委）。 上课的时候强迫自己去提问，回答问题，意识到自己可以做一些 由自己决定的 想做什么就做什么 的事。 遇到了自己喜欢的老师，有能够舒适相处，真心相待的一帮同学，慢慢地从高三痛苦自闭的状态走出来了。 竞赛这段话也想写给每个学竞赛过程中感到无力的同行者。 算法竞赛的魅力在于，通过努力积累或灵机一动，你能够做出越来越难的题目，是一种对自我能力的认可。 算法竞赛的危险亦在于，你学会的东西越多，认识的厉害的人越多，面对不可计数的强者，很容易陷入自我否定。 想到杭电之前，很长一段时间都觉得，大学不会再打竞赛了。 学竞赛的过程中经历的打击，不仅是比赛和上课中受到一众神仙居高临下的压迫感，更多的其实是周围人不经意的否定和安慰。对我来说，这是一种对信心很大的打击，会想要证明自己，亦或是心里感到无力而故作轻松。 在面临是否买 D 的抉择时，我放弃了。不是担心取得不了什么结果，而是觉得压力太大了。 在选学校的时候，突然想到杭电的那一刻，有种死灰复燃的感觉。 记起来 NOIP 2018 结束的时候，在存真楼下，孙校长和我们几个刚从秦皇岛回来的学生说的几句话： “学别的竞赛的，最终的发展和竞赛不一定有关系，但是算法竞赛的学生，最终往往都会选择计算机行业。” 算法竞赛会在心里埋下一颗种子。 我不是那种一帆风顺的天才，在受到打击的时候，我会感到无力。 但当我抛开名利、和他人比较、证明自己这些功利的意义之后，我发现自己还剩下些东西，还能看到初心。 是对算法的欣赏和热爱，是理解每一个算法、做出每一个题目的瞬间，精神上的享受，这就够了。 至少在我看来，从我开始接触竞赛，到做出很多重要的选择，我决策的初心从来都不是名利，因为对算法还爱着。决定最终没有买 D 类，最大的原因还是在那个时刻，竞赛带来的痛苦超过了学习的享受，被一次次的排名裹挟，被各种机会所吸引，我越来越像一个没有自我的机器，越来越被成功学牢牢锁死。而在我选择大学的时候，竞赛对我的意义不再是未来的全部了。我能够静下来，问问自己对算法还有没有那种近乎痴迷的喜爱，能够将它作为一种兴趣去发展，不需要考虑付出和回报，至少在大学，我还是有自由支配自己的权利。 我还是那个深深爱着算法的小孩，对几十行代码背后的智慧如痴如醉。 Gold Medal (30th Place) : The 45th ICPC Asia Jinan Regional Contest, 2020 Gold Medal ( 15th Place) : The 18th Zhejiang Provincial Collegiate Programming Contest, 2021 Silver Medal (28th Place) : The 45th ICPC Asia Shenyang Regional Contest, 2021 课内学习第一个学期不会选课，修了系统默认的 25.25 个学分， 第二个学期修了 32.25 个学分。 通识选修只完成了科技发展与科学精神（2/2），大二上应该会把剩下的指标修完。 数理基础 (23) 数分 （6 * 3.5 + 5 * 4.2）、高代（3 * 5 + 2 * 5）、离散（4 * 5）、大物1（3 * 5） CS专业课 (14) 计导（2 * 5）、程设基础（5 * 5）、数据结构（4 * 4.5）、C++ 面向对象（3 * 5） 通识教育 (8) 思修法基（3 * 5）、心理健康（1 * 4.3）、大军（2 * 4.8）、ACM（2 * 5） 外语类 (8) 英语精读 A（2 * 4.4 + 2 * 4.6）、英语听说 A（1 * 4.3 + 1 * 4.7）、实用翻译（2 * 4.6） 其他 (3.5) 大学启示录（1 * 4）、形式与政策（0.5 * 5）、科研实践（1 * 5）、体育（1 * 2.1 + 1 * 1.8） 很幸运的是遇到的老师都很认真负责，老师们对课程内容非常了解，自己遇到问题也都能很好沟通。 很多课程都觉得自己做的没那么好，对给出的成绩也常常受之有愧。 数学分析和高等代数两门数学基础课的表现截然相反，让我更清楚地意识到很大程度上我是个兴趣驱动的人。 对数分的知识体系自己本身可能就不太感兴趣，加上数分课是真的提不起来精神，两个学期的数学分析成绩都不太看的过去，数分上可能要在大三重修了。老师确实想要认真教会我，可是自己确实提不起兴趣去学。经历了数分上的洗礼，数分下还是逼着自己学了学，最后的结果算是马马虎虎吧，确实对不起老师对不起自己。 很喜欢高代老师的课，很大程度驱动我去花相对比较多的时间在这门课上。两个学期最后的结果都比较好，在自己喜欢的科目上能够看到自己做了些事情，也是让自己很开心的一件事。唯一遗憾的是期末错在了最后一节课老师强调过的一个小点上（证明正定阵需先说明对称）。大二下预定了老师的近世代数。 也很喜欢 Cathy 上的英语精读，也算是第一次能让我主动提起来学英语的兴趣。 Cathy 的课有一种很轻松的气氛，不会按照课本一板一眼的去上，讲的很多东西很受用。 感谢程设和OOP（C++）的老师对我的包容，自己在这两门课上确实有过很幼稚的行为。很佩服将近退休的老师能精确把控很多细节，随手写的代码能一遍过编译什么错都没有。 离散数学和数据结构 给了我很深刻的教训。两门都是自认为了解比较多的，数据结构甚至申请了免听。考前复习的都不是很充分，等上了考场发现要开始脑补一堆一堆的概念。期末离散卷子简单，没暴露出来什么问题。数据结构觉得自己看看书就够了，最后的成绩却不尽如人意，原因只是不知道排序里的一个既定细节，只能悔不当初。 大学物理和思想道德修养与法律基础 两门课结果意外的好，其实自己认真去学一学还是可以有效果的。中学阶段一直头疼的政治在闭卷的期末考试也写了个差不多。学不会电磁在考场上也做出来了绝大多数题。考试遇到不会的题也不能太着急，多想一会没准就通了。 体育 从中考的 $18$ 分保底，到大一上的体测 $36$ 分，痛失两个学期的奖学金，终究还是没逃过身体素质不行这个问题。还是感谢环境逼着我去直面体育，按着体能班的要求大一下结结实实把 40 次阳光长跑跑完了，也确实让我看到耐力可以有提升，从操场跑一圈就喘不上气，到体测的时候人生第一次把 1000 米全跑下来，确实是很激动的。也终于在锻炼身体上有了动力，首先是大二下想要和 qyy 同学一起学体育舞，其次是想要恰奖学金。 我的她只想说爱情的体验是一种很纯粹的幸福。 愿意为她牺牲自己的一切，无时无刻都会想起她的事情，找不到她会坐如针毡，什么都做不下去。 她所高兴的事情比她还高兴，她难受的时候会跟着一起哭出来，在爱情中两个人都学会了如何照顾对方。 两个人在一起呆着常常心有灵犀，做事情反应如出一辙，很多事情不用言语。 两个人在一起呆着就是最快乐的事情，能够一起学习，散步，她在我的身边就能感受到无比的踏实。 会走到一起的人终究不会分开。心里对未来有着期盼，静下心来踏踏实实做事，继续加油。","categories":[{"name":"Life","slug":"Life","permalink":"http://blog.gyx.me/categories/Life/"}],"tags":[]},{"title":"Render Math Equations in Hexo","slug":"mathjax","date":"2019-05-31T16:00:00.000Z","updated":"2021-05-31T16:00:00.000Z","comments":true,"path":"2019/06/01/mathjax/","link":"","permalink":"http://blog.gyx.me/2019/06/01/mathjax/","excerpt":"This post is used to check out whether the mathjax plugin still works.","text":"$$f(a) = \\frac{1}{2\\pi i}\\oint_{\\gamma}\\frac{f(z)}{z-a}dz$$ Beautiful and accessible math in all browsers - MathJax This post is used to check out whether the mathjax plugin (hexo-math) still works. Inline FormulaConsider the sequence of $n$ distinct positive integers: $c_1, c_2, \\cdots, c_n$. The child calls a vertex-weighted rooted binary tree good if and only if for every vertex $v$, the weight of $v$ is in the set ${c_1, c_2, \\cdots, c_n}$ . Also our child thinks that the weight of a vertex-weighted tree is the sum of all vertices’ weights. Given an integer $m$, can you for all $s (1 \\le s ≤ m) $ calculate the number of good vertex-weighted rooted binary trees with weight $s$ ? Please, check the samples for better understanding what trees are considered different. We only want to know the answer modulo $998244353$ ( $7 × 17 × 2^{23} + 1$ , a prime number). Block Formula$$\\int \\frac{dx}{cos^2x}=\\int sec^2xdx=tan x+C\\$$ $$\\int \\frac{dx}{sin^2x}=\\int csc^2xdx=-cot x+C\\$$ $$\\sum\\limits_{i = 0}^{E} w[i]{M \\choose i} {N \\choose iS} \\frac{(iS)!}{(S!)^{i}} \\sum\\limits_{j = 0}^{E - i} (-1)^{j} {M - i \\choose j} {N - iS \\choose jS} \\frac{(jS)!}{(S!)^{j}} (M - i - j)^{N - iS - jS}$$ $$= \\sum\\limits_{i = 0}^{E} w[i]{M \\choose i} {N \\choose iS} \\frac{(iS)!}{(S!)^{i}} \\sum\\limits_{j = i}^{E} (-1)^{j - i} {M - i \\choose j - i} {N - iS \\choose jS - iS} \\frac{(jS - iS)!}{(S!)^{j - i}} (M - j)^{N - jS}$$ Matrix$$\\begin{bmatrix}(\\omega_n^0)^0 &amp; (\\omega_n^0)^1 &amp; \\cdots &amp; (\\omega_n^0)^{n-1}\\\\ (\\omega_n^1)^0 &amp; (\\omega_n^1)^1 &amp; \\cdots &amp; (\\omega_n^1)^{n-1}\\\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\(\\omega_n^{n-1})^0 &amp; (\\omega_n^{n-1})^1 &amp; \\cdots &amp; (\\omega_n^{n-1})^{n-1}\\end{bmatrix}\\begin{bmatrix}a_0 \\\\a_1 \\\\\\vdots \\\\a_{n-1}\\end{bmatrix}=\\begin{bmatrix}A(\\omega_n^0) \\\\A(\\omega_n^1) \\\\\\vdots \\\\A(\\omega_n^{n-1})\\end{bmatrix}$$ $$\\begin{bmatrix}a_0 \\\\a_1 \\\\\\vdots \\\\a_{n-1}\\end{bmatrix}=\\frac{1}{n}\\begin{bmatrix}(\\omega_n^{-0})^0 &amp; (\\omega_n^{-0})^1 &amp; \\cdots &amp; (\\omega_n^{-0})^{n-1} \\\\(\\omega_n^{-1})^0 &amp; (\\omega_n^{-1})^1 &amp; \\cdots &amp; (\\omega_n^{-1})^{n-1} \\\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\(\\omega_n^{-(n-1)})^0 &amp; (\\omega_n^{-(n-1)})^1 &amp; \\cdots &amp; (\\omega_n^{-(n-1)})^{n-1}\\end{bmatrix}\\begin{bmatrix}A(\\omega_n^0) \\\\A(\\omega_n^1) \\\\\\vdots \\\\A(\\omega_n^{n-1})\\end{bmatrix}$$ To prevent escaping, you need to use \\\\\\\\ to make a new line rather than \\\\ . For more about the Mathjax symbols, refer to ：The Comprehensive LaTeX Symbol List .","categories":[{"name":"Blog","slug":"Blog","permalink":"http://blog.gyx.me/categories/Blog/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-11-28T16:00:00.000Z","updated":"2018-11-28T16:00:00.000Z","comments":true,"path":"2018/11/29/hello-world/","link":"","permalink":"http://blog.gyx.me/2018/11/29/hello-world/","excerpt":"「 Hello, the lovely world. 」","text":"「 Hello, the lovely world. 」 「 Stay hungry, Stay foolish. 」 12345678910111213141516171819202122&gt;&gt;&gt; import thisThe Zen of Python, by Tim PetersBeautiful is better than ugly.Explicit is better than implicit.Simple is better than complex.Complex is better than complicated.Flat is better than nested.Sparse is better than dense.Readability counts.Special cases aren&#x27;t special enough to break the rules.Although practicality beats purity.Errors should never pass silently.Unless explicitly silenced.In the face of ambiguity, refuse the temptation to guess.There should be one-- and preferably only one --obvious way to do it.Although that way may not be obvious at first unless you&#x27;re Dutch.Now is better than never.Although never is often better than *right* now.If the implementation is hard to explain, it&#x27;s a bad idea.If the implementation is easy to explain, it may be a good idea.Namespaces are one honking great idea -- let&#x27;s do more of those!","categories":[{"name":"Blog","slug":"Blog","permalink":"http://blog.gyx.me/categories/Blog/"}],"tags":[]}],"categories":[{"name":"Contests","slug":"Contests","permalink":"http://blog.gyx.me/categories/Contests/"},{"name":"Life","slug":"Life","permalink":"http://blog.gyx.me/categories/Life/"},{"name":"Competitions","slug":"Competitions","permalink":"http://blog.gyx.me/categories/Competitions/"},{"name":"Blog","slug":"Blog","permalink":"http://blog.gyx.me/categories/Blog/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"http://blog.gyx.me/tags/DFS/"},{"name":"Union-Find Set","slug":"Union-Find-Set","permalink":"http://blog.gyx.me/tags/Union-Find-Set/"},{"name":"Counting","slug":"Counting","permalink":"http://blog.gyx.me/tags/Counting/"}]}