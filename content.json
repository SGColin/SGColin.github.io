{"meta":{"title":"Colin's Space","subtitle":"God helps those who help themselves.","description":null,"author":"Colin Gao","url":"http://blog.gyx.me","root":"/"},"pages":[{"title":"","date":"2022-04-13T03:56:52.822Z","updated":"2021-08-07T16:14:11.574Z","comments":false,"path":"about/index.html","permalink":"http://blog.gyx.me/about/index.html","excerpt":"","text":""}],"posts":[{"title":"[Top] We Bare Bears!","slug":"WeBareBears","date":"2022-12-31T16:10:14.000Z","updated":"2022-08-31T02:59:55.555Z","comments":true,"path":"2023/01/01/WeBareBears/","link":"","permalink":"http://blog.gyx.me/2023/01/01/WeBareBears/","excerpt":"","text":"个人题解点表格中比赛名称跳转。 Training Records Date Contest Rank Solved Upsolved Solution 2022/07/31 The 7th CCPC Finals (CCPC Finals 2021) 20 7 / 12 7 / 12 2022/08/31 2021-2022 ICPC Latin American Regional Multi-University Training Date Contest Rank Solved Upsolved Solution 2022/07/23 2022 Nowcoder Multi-University Training Contest 2 40 9 / 12 10 / 12 2022/07/25 2022 Nowcoder Multi-University Training Contest 3 16 6 / 10 8 / 10 Done. 2022/07/26 2022 HDU Multi-University Training Contest 3 45 7 / 12 9 / 12 2022/07/28 2022 HDU Multi-University Training Contest 4 79 8 / 11 8 / 11 2022/07/30 2022 Nowcoder Multi-University Training Contest 4 16 10 / 14 11 / 14 2022/08/01 2022 Nowcoder Multi-University Training Contest 5 - 9 / 11 10 / 11 - 2022/08/02 2022 HDU Multi-University Training Contest 5 81 6 / 12 7 / 12 2022/08/04 2022 HDU Multi-University Training Contest 6 73 7 / 12 7 / 12 2022/08/06 2022 Nowcoder Multi-University Training Contest 6 65 6 / 13 8 / 13 2022/8/08 2022 Nowcoder Multi-University Training Contest 7 11 7 / 12 8 / 12 Done. 2022/08/09 2022 HDU Multi-University Training Contest 7 79 6 / 11 9 / 11 2022/08/11 2022 HDU Multi-University Training Contest 8 29 9 / 13 9 / 13 Done. 2022/08/13 2022 Nowcoder Multi-University Training Contest 8 28 3 / 12 4 / 12 2022/08/15 2022 Nowcoder Multi-University Training Contest 9 24 8 / 11 8 / 11 2022/08/16 2022 HDU Multi-University Training Contest 9 60 6 / 11 6 / 11 2022/08/17 2022 Nowcoder Multi-University Training Contest 0 29 6 / 13 6 / 13 2022/08/18 2022 HDU Multi-University Training Contest 10 14 10 / 12 10 / 12 2022/08/20 2022 Nowcoder Multi-University Training Contest 10 37 5 / 11 5 / 11","categories":[{"name":"Summary","slug":"Summary","permalink":"http://blog.gyx.me/categories/Summary/"},{"name":"Competitive Programming","slug":"Summary/Competitive-Programming","permalink":"http://blog.gyx.me/categories/Summary/Competitive-Programming/"}],"tags":[]},{"title":"DSU on Tree","slug":"dsu_on_tree","date":"2022-08-31T00:13:35.000Z","updated":"2022-09-06T13:05:18.223Z","comments":true,"path":"2022/08/31/dsu_on_tree/","link":"","permalink":"http://blog.gyx.me/2022/08/31/dsu_on_tree/","excerpt":"","text":"Analysis DSU on Tree 在一些比较简单的子树问题时可以替代点分治，复杂度也是 \\(\\mathcal O(n\\log n)\\) 。 按子树 size 轻重链剖分，然后使用某个数据结构统计每个点的子树信息： 先让轻儿子统计子树信息，并撤销对数据结构的影响； 如果有重儿子，统计重儿子子树信息，保留对数据结构的影响（不撤销）； 向数据结构中添加轻儿子子树信息和当前点信息，统计当前点信息。 复杂度分析：每个点只会在到根路径上遇到轻边时被添加 /撤销，由轻重连剖分每个点到根的路径上至多 \\(\\log n\\) 条轻边。所以总复杂度是 \\(\\mathcal O(n \\log n)\\) ，由于明显跑不满所以常数会很小。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 100007#define pb push_backint sz[N], mxs[N];vector&lt;int&gt; e[N];void dfs(int u, int fa) &#123; sz[u] = 1; for (auto v : e[u]) if (v != fa) &#123; dfs(v, u); sz[u] += sz[v]; if (sz[v] &gt; sz[mxs[u]]) mxs[u] = v; &#125;&#125;inline void upd(int u) &#123; // adding information of u into data structures&#125;inline void del(int u) &#123; // deleting information of u from data structures&#125;void upd(int u, int fa) &#123; upd(u); for (auto v : e[u]) if (v != fa) upd(v, u);&#125;void del(int u, int fa) &#123; del(u); for (auto v : e[u]) if (v != fa) del(v, u);&#125;void dsu(int u, int fa) &#123; for (auto v : e[u]) if (v != fa &amp;&amp; v != mxs[u]) &#123;dsu(v, u); del(v, u);&#125; if (mxs[u]) dsu(mxs[u], u); for (auto v : e[u]) if (v != fa &amp;&amp; v != mxs[u]) upd(v, u); upd(u); &#125;int main() &#123; int n = rd(); for (int i = 1; i &lt; n; ++i) &#123; int u = rd(), v = rd(); e[u].pb(v); e[v].pb(u); &#125; dfs(1, 1); dsu(1, 1); return 0;&#125; CF 600 E. Lomsat gelral 一棵树每个点有一个颜色 \\(c_i\\) ，求每个点子树内出现次数最多的颜色的和。 对颜色维护 cnt 数组，由于 DSU 统计时只有加法，因此可以记录出现最多的次数 mx 和最多次数的颜色的和 res 。 每次 ++cnt[col[u]] 的时候讨论一下和 mx 的关系更新即可（见 upd 函数）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 100007#define pb push_backll ans[N], res;int cnt[N], col[N], mx;int sz[N], mxs[N];vector&lt;int&gt; e[N];void dfs(int u, int fa) &#123; sz[u] = 1; for (auto v : e[u]) if (v != fa) &#123; dfs(v, u); sz[u] += sz[v]; if (sz[v] &gt; sz[mxs[u]]) mxs[u] = v; &#125;&#125;inline void upd(int u) &#123; // adding information of u into data structures ++cnt[col[u]]; if (cnt[col[u]] &gt; mx) &#123;mx = cnt[col[u]]; res = col[u];&#125; else if (cnt[col[u]] == mx) res += col[u];&#125;inline void del(int u) &#123; // deleting information of u from data structures mx = 0; res = 0; cnt[col[u]] = 0;&#125;void upd(int u, int fa) &#123; upd(u); for (auto v : e[u]) if (v != fa) upd(v, u);&#125;void del(int u, int fa) &#123; del(u); for (auto v : e[u]) if (v != fa) del(v, u);&#125;void dsu(int u, int fa) &#123; for (auto v : e[u]) if (v != fa &amp;&amp; v != mxs[u]) &#123;dsu(v, u); del(v, u);&#125; if (mxs[u]) dsu(mxs[u], u); for (auto v : e[u]) if (v != fa &amp;&amp; v != mxs[u]) upd(v, u); upd(u); ans[u] = res;&#125;int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) col[i] = rd(); for (int i = 1; i &lt; n; ++i) &#123; int u = rd(), v = rd(); e[u].pb(v); e[v].pb(u); &#125; dfs(1, 1); dsu(1, 1); for (int i = 1; i &lt;= n; ++i) printf(&quot;%lld &quot;, ans[i]); return 0;&#125; CF 1009 F. Dominant Indices 给一棵树，对于每一个点求最小的 \\(k\\) ，使得子树内到他距离为 \\(k\\) 的点最多。 做法和上一题完全相同，每次更新的时候讨论，超过了 mx 直接覆盖 res ，等于 mx 和 res 取 \\(\\min\\) 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;#define pic pair&lt;int, char&gt;#define aint(x) (x).begin(), (x).end()#define lowbit(x) ((x) &amp; -(x))#define N 1000007int cnt[N], ans[N], mx, res;int sz[N], mxs[N], dep[N];vector&lt;int&gt; e[N];void dfs(int u, int fa) &#123; sz[u] = 1; dep[u] = dep[fa] + 1; for (auto v : e[u]) if (v != fa) &#123; dfs(v, u); sz[u] += sz[v]; if (sz[v] &gt; sz[mxs[u]]) mxs[u] = v; &#125;&#125;inline void upd(int u) &#123; // adding information of u into data structures ++cnt[dep[u]]; if (cnt[dep[u]] &gt; mx) &#123;mx = cnt[dep[u]]; res = dep[u];&#125; else if (cnt[dep[u]] == mx) res = min(res, dep[u]);&#125;inline void del(int u) &#123; // deleting information of u from data structures mx = 0; res = 0; cnt[dep[u]] = 0;&#125;void upd(int u, int fa) &#123; upd(u); for (auto v : e[u]) if (v != fa) upd(v, u);&#125;void del(int u, int fa) &#123; del(u); for (auto v : e[u]) if (v != fa) del(v, u);&#125;void dsu(int u, int fa) &#123; for (auto v : e[u]) if (v != fa &amp;&amp; v != mxs[u]) &#123;dsu(v, u); del(v, u);&#125; if (mxs[u]) dsu(mxs[u], u); for (auto v : e[u]) if (v != fa &amp;&amp; v != mxs[u]) upd(v, u); upd(u); ans[u] = res - dep[u];&#125;int main() &#123; int n = rd(); for (int i = 1; i &lt; n; ++i) &#123; int u = rd(), v = rd(); e[u].pb(v); e[v].pb(u); &#125; dfs(1, 1); dsu(1, 1); for (int i = 1; i &lt;= n; ++i) printf(&quot;%d\\n&quot;, ans[i]); return 0;&#125; CF 208 E. Blood Cousins 给一个森林，\\(q\\) 次问与 \\(u_i\\) 有共同的第 \\(k_i\\) 级祖先的点的个数。 询问其实与 \\(u_i\\) 关系不大，离线后是绑定在 \\(u_i\\) 的 \\(k_i\\) 级祖先上的，因此需要快速求 \\(k\\) 级祖先。 然后使用 DSU 求出 dep 的 cnt 数组即可，由于 DSU 本身也要用到轻重剖分，所以求祖先就也用树剖实现了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 100007#define fr first#define sc second#define pb push_back#define mp make_pair#define pii pair&lt;int, int&gt;int tot, dfn[N], seq[N], top[N], dep[N], ans[N], cnt[N], fa[N];int sz[N], mxs[N];vector&lt;int&gt; son[N];vector&lt;pii&gt; que[N];void dfs(int u) &#123; sz[u] = 1; for (auto v : son[u]) &#123; dfs(v); sz[u] += sz[v]; if (sz[v] &gt; sz[mxs[u]]) mxs[u] = v; &#125;&#125;void dfs2(int u, int t) &#123; top[u] = t; dfn[u] = ++tot; seq[tot] = u; if (mxs[u]) &#123;dep[mxs[u]] = dep[u] + 1; dfs2(mxs[u], t);&#125; for (auto v : son[u]) if (!dfn[v]) &#123;dep[v] = dep[u] + 1; dfs2(v, v);&#125;&#125;void upd(int u) &#123; ++cnt[dep[u]]; for (auto v : son[u]) upd(v);&#125;void del(int u) &#123; --cnt[dep[u]]; for (auto v : son[u]) del(v);&#125;void dsu(int u) &#123; for (auto v : son[u]) if (v != mxs[u]) &#123;dsu(v); del(v);&#125; if (mxs[u]) dsu(mxs[u]); for (auto v : son[u]) if (v != mxs[u]) upd(v); ++cnt[dep[u]]; for (auto q : que[u]) ans[q.sc] = cnt[dep[u] + q.fr] - 1;&#125;inline int anc(int u, int k) &#123; if (dep[u] &lt; k) return 0; int nw = u; while (dep[u] - dep[top[nw]] &lt; k) nw = fa[top[nw]]; return seq[dfn[nw] - (k - (dep[u] - dep[nw]))];&#125;int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) son[fa[i] = rd()].pb(i); for (auto u : son[0]) dfs(u); for (auto u : son[0]) dfs2(u, u); int q = rd(); for (int i = 1; i &lt;= q; ++i) &#123; int u = rd(), k = rd(); int w = anc(u, k); if (w == 0) continue; que[w].pb(mp(k, i)); &#125; for (auto u : son[0]) &#123;dsu(u); del(u);&#125; for (int i = 1; i &lt;= q; ++i) printf(&quot;%d &quot;, ans[i]); return 0;&#125; 另一种比较有意思的做法： 全部离线，DFS 时用栈记录从根到当前点的路径，得到 \\(k\\) 级祖先，复杂度 \\(\\mathcal O(n)\\) 。 将询问按深度分类，先将该深度的点加入数据结构，然后就相当于求 DFS 序上区间和。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;#define pic pair&lt;int, char&gt;#define aint(x) (x).begin(), (x).end()#define lowbit(x) ((x) &amp; -(x))#define N 100007vector&lt;pii&gt; q[N], que[N];int tot, dfn[N], sz[N], ans[N], stk[N], c[N];vector&lt;int&gt; son[N], cur[N];inline void add(int p, int x) &#123; for (; p &lt; N; p += lowbit(p)) c[p] += x;&#125;inline int sum(int p) &#123; int res = 0; for (; p; p -= lowbit(p)) res += c[p]; return res;&#125;inline int sum(int l, int r) &#123; return sum(r) - sum(l - 1);&#125;void dfs(int u, int dep) &#123; sz[u] = 1; stk[dep] = u; cur[dep].pb(u); dfn[u] = ++tot; for (auto v : son[u]) &#123;dfs(v, dep + 1); sz[u] += sz[v];&#125; for (auto [k, id] : q[u]) if (dep &gt; k) que[dep].pb(mp(stk[dep - k], id));&#125;int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) son[rd()].pb(i); int m = rd(); for (int i = 1; i &lt;= m; ++i) &#123; int u = rd(), k = rd(); q[u].pb(mp(k, i)); &#125; for (auto u : son[0]) dfs(u, 1); for (int i = 1; i &lt;= n; ++i) &#123; for (auto u : cur[i]) add(dfn[u], 1); for (auto [u, id] : que[i]) ans[id] = sum(dfn[u], dfn[u] + sz[u] - 1) - 1; for (auto u : cur[i]) add(dfn[u], -1); &#125; for (int i = 1; i &lt;= m; ++i) printf(&quot;%d &quot;, ans[i]); return 0;&#125; CF 246 E. Blood Cousins Return 一棵树每个点上有一个字符串，多次询问 \\(u_i\\) 子树内深度为 \\(k\\) 的点对应的字符串集合中有多少个不同的。 还是上面那个问题，改成用一个 unordered_map 来计数每个深度的字符串即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 100007#define fr first#define sc second#define pb push_back#define mp make_pair#define pii pair&lt;int, int&gt;int dfn[N], top[N], dep[N], ans[N], tot, seq[N], fa[N];int sz[N], mxs[N];string nam[N];vector&lt;int&gt; son[N];vector&lt;pii&gt; que[N];unordered_map&lt;string, int&gt; cnt[N];void dfs(int u) &#123; sz[u] = 1; for (auto v : son[u]) &#123; dfs(v); sz[u] += sz[v]; if (sz[v] &gt; sz[mxs[u]]) mxs[u] = v; &#125;&#125;void dfs2(int u, int t) &#123; top[u] = t; dfn[u] = ++tot; seq[tot] = u; if (mxs[u]) &#123;dep[mxs[u]] = dep[u] + 1; dfs2(mxs[u], t);&#125; for (auto v : son[u]) if (!dfn[v]) &#123;dep[v] = dep[u] + 1; dfs2(v, v);&#125;&#125;inline void upd(int u) &#123; // adding information of u into data structures ++cnt[dep[u]][nam[u]];&#125;inline void del(int u) &#123; // deleting information of u from data structures --cnt[dep[u]][nam[u]]; if (!cnt[dep[u]][nam[u]]) cnt[dep[u]].erase(nam[u]);&#125;void upd(int u, int fa) &#123; upd(u); for (auto v : son[u]) upd(v, u);&#125;void del(int u, int fa) &#123; del(u); for (auto v : son[u]) del(v, u);&#125;void dsu(int u, int fa) &#123; for (auto v : son[u]) if (v != mxs[u]) &#123;dsu(v, u); del(v, u);&#125; if (mxs[u]) dsu(mxs[u], u); for (auto v : son[u]) if (v != mxs[u]) upd(v, u); upd(u); for (auto q : que[u]) &#123; int d = q.fr, id = q.sc; ans[id] = cnt[dep[u] + d].size(); &#125;&#125;int main() &#123; cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false); int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; nam[i] &gt;&gt; fa[i]; son[fa[i]].pb(i); &#125; for (auto u : son[0]) dfs(u); for (auto u : son[0]) dfs2(u, u); int q; cin &gt;&gt; q; for (int i = 1, u, k; i &lt;= q; ++i) &#123; cin &gt;&gt; u &gt;&gt; k; if (dep[u] + k &gt; n) continue; que[u].pb(mp(k, i)); &#125; for (auto u : son[0]) &#123;dsu(u, u); del(u, u);&#125; for (int i = 1; i &lt;= q; ++i) cout &lt;&lt; ans[i] &lt;&lt; endl; return 0;&#125; CF 570 D. Tree Requests 一棵树每个点上有一个字符，每次询问 \\(u_i\\) 子树内深度为 \\(k_i\\) 的所有点上的字符是否可以通过重排形成回文串。 形成回文串的条件是出现奇数次的字符至多一种。 用 DSU on Tree 维护 cnt[dep][c] 表示在 dep 这个深度上的点字符 c 的出现次数。 再用一个 odd[dep] 表示 cnt[dep][c] 是奇数的 c 的个数，询问 Yes 就是对应深度的 odd[dep] &lt;= 1 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;#define pic pair&lt;int, char&gt;#define aint(x) (x).begin(), (x).end()#define lowbit(x) ((x) &amp; -(x))#define N 500007bool ans[N];int cnt[N][26], ch[N], odd[N];int sz[N], mxs[N], dep[N];vector&lt;int&gt; son[N];vector&lt;pii&gt; que[N];void dfs(int u, int fa) &#123; sz[u] = 1; dep[u] = dep[fa] + 1; for (auto v : son[u]) &#123; dfs(v, u); sz[u] += sz[v]; if (sz[v] &gt; sz[mxs[u]]) mxs[u] = v; &#125;&#125;inline void upd(int u) &#123; // adding information of u into data structures ++cnt[dep[u]][ch[u]]; (cnt[dep[u]][ch[u]] &amp; 1) ? ++odd[dep[u]] : --odd[dep[u]];&#125;inline void del(int u) &#123; // deleting information of u from data structures cnt[dep[u]][ch[u]] = odd[dep[u]] = 0;&#125;void upd(int u, int fa) &#123; upd(u); for (auto v : son[u]) if (v != fa) upd(v, u);&#125;void del(int u, int fa) &#123; del(u); for (auto v : son[u]) if (v != fa) del(v, u);&#125;void dsu(int u, int fa) &#123; for (auto v : son[u]) if (v != fa &amp;&amp; v != mxs[u]) &#123;dsu(v, u); del(v, u);&#125; if (mxs[u]) dsu(mxs[u], u); for (auto v : son[u]) if (v != fa &amp;&amp; v != mxs[u]) upd(v, u); upd(u); for (auto [k, id] : que[u]) ans[id] = (odd[k] &lt;= 1);&#125;int main() &#123; int n = rd(), m = rd(); for (int i = 2; i &lt;= n; ++i) son[rd()].pb(i); char c = getchar(); while (!isalpha(c)) c = getchar(); for (int i = 1; i &lt;= n; ++i, c = getchar()) ch[i] = c - &#x27;a&#x27;; for (int i = 1; i &lt;= m; ++i) &#123; int u = rd(), k = rd(); que[u].pb(mp(k, i)); &#125; dfs(1, 1); dsu(1, 1); for (int i = 1; i &lt;= m; ++i) puts(ans[i] ? &quot;Yes&quot; : &quot;No&quot;); return 0;&#125; CF 375 D. Tree and Queries 一棵树每个点有一个颜色，每次询问 \\(u_i\\) 子树内出现次数超过 \\(k_i\\) 的颜色数。 DSU on Tree 求出来子树内颜色的出现次数 cnt 数组，再对 cnt 求出现次数 cnt' 数组，询问就是问 cnt' 的 \\(k_i\\) 后缀和。 因此很容易 \\(\\mathcal O(n\\log^2 n)\\) 做，额外再用一个树状数组维护 cnt' 就好了。 但实际上可以 \\(\\mathcal O(n\\log n)\\) 处理，我们实际在做：1. 对 cnt' 中某个位置 x 执行 --cnt'[x], ++cnt'[x+1]; 2. 求后缀和。 可以发现修改操作对后缀和数组的影响是 \\(\\mathcal O(1)\\) 的，所以我们可以直接在修改的同时维护每个位置的后缀和。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;#define pic pair&lt;int, char&gt;#define aint(x) (x).begin(), (x).end()#define lowbit(x) ((x) &amp; -(x))#define N 100007int col[N], cnt[N], sum[N], ans[N];int sz[N], mxs[N], dep[N];vector&lt;int&gt; e[N];vector&lt;pii&gt; que[N];void dfs(int u, int fa) &#123; sz[u] = 1; dep[u] = dep[fa] + 1; for (auto v : e[u]) if (v != fa) &#123; dfs(v, u); sz[u] += sz[v]; if (sz[v] &gt; sz[mxs[u]]) mxs[u] = v; &#125;&#125;inline void upd(int u) &#123; // adding information of u into data structures ++sum[++cnt[col[u]]];&#125;inline void del(int u) &#123; // deleting information of u from data structures sum[cnt[col[u]]--]--;&#125;void upd(int u, int fa) &#123; upd(u); for (auto v : e[u]) if (v != fa) upd(v, u);&#125;void del(int u, int fa) &#123; del(u); for (auto v : e[u]) if (v != fa) del(v, u);&#125;void dsu(int u, int fa) &#123; for (auto v : e[u]) if (v != fa &amp;&amp; v != mxs[u]) &#123;dsu(v, u); del(v, u);&#125; if (mxs[u]) dsu(mxs[u], u); for (auto v : e[u]) if (v != fa &amp;&amp; v != mxs[u]) upd(v, u); upd(u); for (auto [k, id] : que[u]) ans[id] = sum[k];&#125;int main() &#123; int n = rd(), m = rd(); for (int i = 1; i &lt;= n; ++i) col[i] = rd(); for (int i = 1; i &lt; n; ++i) &#123; int u = rd(), v = rd(); e[u].pb(v); e[v].pb(u); &#125; for (int i = 1; i &lt;= m; ++i) &#123; int u = rd(), k = rd(); que[u].pb(mp(k, i)); &#125; dfs(1, 1); dsu(1, 1); for (int i = 1; i &lt;= m; ++i) printf(&quot;%d\\n&quot;, ans[i]); return 0;&#125; CF 741 D. Arpa’s letter-marked tree and Mehrdad’s Dokhtar-kosh paths 一棵树每条边上有一个字符 (a - v) ，每次询问 \\(u_i\\) 子树内最长的简单路径，满足其上的字符重排可形成回文串。 \\((u,v)\\) 路径信息 \\(=u\\) 到根信息 \\(+v\\) 到根信息 \\(-2*lca(u,v)\\) 到根信息。 字符集只有 \\(22\\) ，状压 \\(u\\) 到根每个字符的奇偶性 \\(s_u\\) ，路径信息即为 \\(s_u\\oplus s_v\\) （lca 信息因为异或两次消掉了） 考虑路径合并，每个点可能的配对方案只有 \\(23\\) 种（异或后为 \\(0\\) 或 \\(2\\) 的幂次） DSU on Tree，统计此前子树的信息，维护每个状压值的最深深度，保证 lca 是当前点需整个子树先查询后插入。 写挂的地方：1. 子树内最长要和儿子的 ans 取 \\(\\max\\) ；2.枚举配对的状态时，得保证存在再更新。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;#define pic pair&lt;int, char&gt;#define aint(x) (x).begin(), (x).end()#define lowbit(x) ((x) &amp; -(x))#define N 500007int ch[N], sta[N], mxd[1 &lt;&lt; 22], ans[N], res;int sz[N], mxs[N], dep[N];vector&lt;int&gt; son[N];void dfs(int u, int fa, int S) &#123; sz[u] = 1; dep[u] = dep[fa] + 1; if (u != 1) S ^= (1 &lt;&lt; ch[u]); sta[u] = S; for (auto v : son[u]) &#123; dfs(v, u, S); sz[u] += sz[v]; if (sz[v] &gt; sz[mxs[u]]) mxs[u] = v; &#125;&#125;inline void upd(int u) &#123; // adding information of u into data structures mxd[sta[u]] = max(mxd[sta[u]], dep[u]);&#125;inline void del(int u) &#123; // deleting information of u from data structures mxd[sta[u]] = 0; res = 0;&#125;void upd(int u, int fa) &#123; upd(u); for (auto v : son[u]) if (v != fa) upd(v, u);&#125;void del(int u, int fa) &#123; del(u); for (auto v : son[u]) if (v != fa) del(v, u);&#125;void updans(int u, int del) &#123; // 枚举配对的状态需要保证存在！！！ if (mxd[sta[u]]) res = max(res, dep[u] + mxd[sta[u]] - 2 * del); for (int i = 0; i &lt; 22; ++i) if (mxd[sta[u] ^ (1 &lt;&lt; i)]) res = max(res, dep[u] + mxd[sta[u] ^ (1 &lt;&lt; i)] - 2 * del);&#125;void getans(int u, int del) &#123; updans(u, del); for (auto v : son[u]) getans(v, del);&#125;void dsu(int u, int fa) &#123; for (auto v : son[u]) if (v != fa &amp;&amp; v != mxs[u]) &#123;dsu(v, u); del(v, u);&#125; if (mxs[u]) dsu(mxs[u], u); updans(u, dep[u]); upd(u); for (auto v : son[u]) if (v != fa &amp;&amp; v != mxs[u]) &#123; getans(v, dep[u]); res = max(res, ans[v]); upd(v, u); &#125; ans[u] = res;&#125;int main() &#123; int n = rd(); for (int i = 2; i &lt;= n; ++i) &#123; son[rd()].pb(i); char c = getchar(); while (!isalpha(c)) c = getchar(); ch[i] = (c - &#x27;a&#x27;); &#125; dfs(1, 1, 0); dsu(1, 1); for (int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, ans[i]); return 0;&#125; HDU 7255 Expected Inversions 换根 + DSU on Tree 统计信息，见多校题解。","categories":[{"name":"Summary","slug":"Summary","permalink":"http://blog.gyx.me/categories/Summary/"},{"name":"Algorithms","slug":"Summary/Algorithms","permalink":"http://blog.gyx.me/categories/Summary/Algorithms/"}],"tags":[{"name":"DFS and Similar","slug":"DFS-and-Similar","permalink":"http://blog.gyx.me/tags/DFS-and-Similar/"}]},{"title":"AtCoder Beginner Contest 266","slug":"Atcoder/abc266","date":"2022-08-30T13:58:14.000Z","updated":"2022-08-31T03:02:21.232Z","comments":true,"path":"2022/08/30/Atcoder/abc266/","link":"","permalink":"http://blog.gyx.me/2022/08/30/Atcoder/abc266/","excerpt":"","text":"ABCD 比较简单就不写了。 E. Throwing the Die 有 \\(k\\) 次掷骰子的机会，可以任意时刻喊停，得分就是停的时候骰子向上的数字，问最优策略期望得分。 期望要倒着算。设 \\(f[x]\\) 表示可以掷 \\(x\\) 次的最优期望得分，首先有 \\(f[1] = 3.5\\) 。 接下来考虑 \\(f[i]\\) 已知求 \\(f[i + 1]\\) ：枚举第 \\(i+1\\) 次的六种可能情况，如果本次得分比 \\(f[i]\\) 要大就不会再投了，否则会继续投。 因此方程为 \\(f[i + 1] =\\frac{1}{6}\\sum_{j=1}^6j\\times\\big[j &gt; f[i]\\big]+f[i]\\times \\big[j \\le f[i]\\big]\\) 。 12345678910111213int main() &#123; int n = rd(); double f[101] = &#123;0, 3.5&#125;; for (int i = 2; i &lt;= n; ++i) &#123; f[i] = 0; for (int j = 1; j &lt;= 6; ++j) &#123; if (1.0 * j &lt; f[i - 1]) f[i] += f[i - 1] / 6; else f[i] += j / 6.0; &#125; &#125; printf(&quot;%.10lf\\n&quot;, f[n]); return 0;&#125; F. Well-defined Path Queries on a Namori 给一棵无向基环树，\\(q\\) 次问 \\(u_i\\) 和 \\(v_i\\) 之间的简单路径是否唯一。 路径不经过环就唯一，因此拓扑把环找出来删掉，如果两个点在同一棵树内答案就是 Yes 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 200007#define pb push_backvector&lt;int&gt; e[N];bool vis[N];int deg[N];queue&lt;int&gt; q;int col[N], cnt;void dfs(int u, int c) &#123; for (auto v : e[u]) if (!col[v]) &#123; col[v] = c; dfs(v, c); &#125;&#125;int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; int u = rd(), v = rd(); e[u].pb(v); e[v].pb(u); ++deg[u]; ++deg[v]; &#125; for (int i = 1; i &lt;= n; ++i) if (deg[i] == 1) &#123;vis[i] = true; q.push(i);&#125; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (auto v : e[u]) if (!vis[v]) &#123; --deg[v]; if (deg[v] == 1) &#123; vis[v] = true; q.push(v); &#125; &#125; &#125; for (int i = 1; i &lt;= n; ++i) if (!vis[i]) col[i] = ++cnt; for (int i = 1; i &lt;= n; ++i) if (!vis[i]) dfs(i, col[i]); for (int q = rd(); q; --q) &#123; int u = rd(), v = rd(); puts(col[u] == col[v] ? &quot;Yes&quot; : &quot;No&quot;); &#125; return 0;&#125; G. Yet Another RGB Sequence 计数 \\(R\\) 个 r ，\\(G\\) 个 g ，\\(B\\) 个 b 的字符串，且其中rg 子串恰好 \\(k\\ (k\\le \\min(R,G))\\) 个。 先数出来 \\(k\\) 个 rg 、\\(G-k\\) 个 g 、\\(B\\) 个 b 的字符串个数是 \\(\\frac{(G+B)!}{k!(G-k)!B!}\\) （多重集的排列） 再将剩下的 \\(R-k\\) 个 r 插进去，因为不能插在 g 前面，所以只能插在 rg 或 b 的前面（及最后） 因此就是 \\(B+k\\) 个隔板和 \\(R-k\\) 个球的排列个数问题，方案数为 \\({R+B\\choose R-k}\\) ，两部分乘起来即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 2000007#define mod 998244353int fac[N], ifac[N];inline int fpow(int x, int t) &#123; int res = 1; for (; t; t &gt;&gt;= 1, x = 1ll * x * x % mod) if (t &amp; 1) res = 1ll * res * x % mod; return res;&#125; inline void init() &#123; fac[0] = ifac[0] = 1; for (int i = 1; i &lt; N; ++i) fac[i] = 1ll * fac[i - 1] * i % mod; ifac[N - 1] = fpow(fac[N - 1], mod - 2); for (int i = N - 2; i; --i) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % mod;&#125; inline int C(int n, int m) &#123; if (n &lt; m) return 0; return 1ll * fac[n] * ifac[m] % mod * ifac[n - m] % mod;&#125;int main() &#123; init(); int r = rd(), g = rd(), b = rd(), k = rd(); r -= k; g -= k; int ans = 1ll * fac[g + b + k] * ifac[g] % mod * ifac[b] % mod * ifac[k] % mod; b += k; printf(&quot;%lld\\n&quot;, 1ll * ans * C(r + b, r) % mod); return 0;&#125; Ex. Snuke Panic (2D) 二维平面上 \\(n\\ (n\\le 10^5)\\) 个点，位于 \\((x_i,y_i)\\) ，出现时间 \\(t_i\\) ，价值 \\(a_i\\) 。 开始你在 \\((0,0)\\) ，每秒四选一：\\(x\\) 方向 \\(+1/-1/y\\) 方向 \\(+1/\\) 不动。 恰好在 \\(t_i\\) 时刻到达 \\((x_i,y_i)\\) ，可以获得 \\(a_i\\) ，求能得到的最大价值。 直接设 \\(f[t][x][y]\\) 表示前 \\(t\\) 秒， \\(t\\) 时在 \\((x,y)\\) 能得到的最大价值；设 \\(val(t,x,y)\\) 表示 \\(t\\) 时刻 \\((x,y)\\) 的价值。 \\[ f[t][x][y]= \\max \\{f[t&#39;][x&#39;][y&#39;]\\ |\\ t&#39; \\le t, y&#39; \\le y, |x-x&#39;|+y-y&#39;\\le t - t&#39;\\} + val(t,x,y) \\] 由后两个限制条件有 \\(t-t\\ge y - y&#39;\\ge 0\\) 因此第一个条件可以丢掉，剩下的条件写为： \\[ \\left\\{ \\begin{array}{l} y&#39; \\le y\\\\ x - x&#39; + y - y&#39; \\le t - t&#39;\\\\ x&#39;-x + y - y&#39; \\le t - t&#39; \\end{array} \\right. \\ \\ \\Longrightarrow \\left\\{ \\begin{array}{l} y&#39; \\le y\\\\ t&#39; - x&#39; - y&#39; \\le t - x - y\\\\ t&#39; + x&#39; - y&#39; \\le t + x - y \\end{array} \\right. \\] 可以发现做个线性变换之后是个三维偏序，令 \\(a=t-x-y,b=t+x-y\\) ，有： \\[ f[a][b][y] = \\max\\{f[a&#39;][b&#39;][y&#39;]\\ |\\ a&#39;\\le a, b&#39;\\le b, y&#39;\\le y \\} + val(a,b,y) \\] 三维都从小到大排序后可以去掉一维，剩下两维用二维树状数组维护即可，答案显然只会在 \\(val(a,b,y)\\) 有值处统计到。 但是即使离散化的二维树状数组也开不下，需要将一维用 unordered_map 代替，时空复杂度均为 \\(\\mathcal O(n\\log^2n)\\) 。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define pb push_back#define lowbit(x) ((x) &amp; -(x))#define all(x) (x).begin(), (x).end()#define N 100007struct node &#123;int y, a, b, w;&#125; g[N];vector&lt;int&gt; A, B;int X, Y;unordered_map&lt;int, ll&gt; c[N];inline ll max(ll a, ll b) &#123;return a &gt; b ? a : b;&#125;inline void upd(int x, int y, ll w) &#123; for (int i = x; i &lt;= X; i += lowbit(i)) for (int j = y; j &lt;= Y; j += lowbit(j)) c[i][j] = max(c[i][j], w);&#125;inline ll qmax(int x, int y) &#123; ll res = 0; for (int i = x; i; i -= lowbit(i)) for (int j = y; j; j -= lowbit(j)) res = max(res, c[i][j]); return res;&#125;int main() &#123; int n = rd(), m = 0; for (int i = 1; i &lt;= n; ++i) &#123; int t = rd(), x = rd(), y = rd(), w = rd(); if (t - x - y &lt; 0 || t + x - y &lt; 0) continue; g[++m].y = y; g[m].w = w; g[m].a = t - x - y; A.pb(g[m].a); g[m].b = t + x - y; B.pb(g[m].b); &#125; n = m; auto cmp = [&amp;](node a, node b) &#123; if (a.y != b.y) return a.y &lt; b.y; if (a.a != b.a) return a.a &lt; b.a; return a.b &lt; b.b; &#125;; sort(g + 1, g + 1 + n, cmp); sort(all(A)); A.erase(unique(all(A)), A.end()); X = A.size(); sort(all(B)); B.erase(unique(all(B)), B.end()); Y = B.size(); ll ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; int a = lower_bound(all(A), g[i].a) - A.begin() + 1; int b = lower_bound(all(B), g[i].b) - B.begin() + 1; ll nw = qmax(a, b) + g[i].w; ans = max(ans, nw); upd(a, b, nw); &#125; printf(&quot;%lld\\n&quot;, ans); return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"http://blog.gyx.me/categories/Solution/"},{"name":"AtCoder","slug":"Solution/AtCoder","permalink":"http://blog.gyx.me/categories/Solution/AtCoder/"},{"name":"AtCoder Beginner Contest","slug":"Solution/AtCoder/AtCoder-Beginner-Contest","permalink":"http://blog.gyx.me/categories/Solution/AtCoder/AtCoder-Beginner-Contest/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"},{"name":"Counting","slug":"Counting","permalink":"http://blog.gyx.me/tags/Counting/"},{"name":"Fenwick Tree","slug":"Fenwick-Tree","permalink":"http://blog.gyx.me/tags/Fenwick-Tree/"}]},{"title":"Metacamp 2022","slug":"metacamp2022","date":"2022-08-23T14:43:27.000Z","updated":"2022-08-12T07:38:09.843Z","comments":true,"path":"2022/08/23/metacamp2022/","link":"","permalink":"http://blog.gyx.me/2022/08/23/metacamp2022/","excerpt":"","text":"补题地址 &amp; 官方题解：Online A , Solution | Online B , Solution 复读机 \\(n\\) 个人，每个人有一个 \\(a_i,b_i\\) ，每次可以让 \\(a_i\\leftarrow a_{b_i}\\) ，求最小操作次数使得所有数字都一样。 图是一个内向基环树森林，显然只有环内的颜色有可能成为最终颜色，因此求一下所有环上颜色的交。 假设最终的颜色是 \\(w\\) ，那么最终需要的操作次数就是 \\(n-cnt_w\\) ，每次把一条不是 \\(w\\) 的链依次染色即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;using namespace std;using ll = long long;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 1000007int a[N], b[N], deg[N];bool vis[N];queue&lt;int&gt; q;map&lt;int, int&gt; cnt, tmpcnt;int tot;void dfs(int u) &#123; vis[u] = 1; if (tmpcnt[a[u]] != tot) &#123; if (tmpcnt[a[u]] &lt; tot - 1) tmpcnt[a[u]] = 0; else tmpcnt[a[u]] = tot; &#125; if (!vis[b[u]]) dfs(b[u]);&#125;inline void work() &#123; tot = 0; int n = rd(); cnt.clear(); tmpcnt.clear(); for (int i = 1; i &lt;= n; ++i) &#123; ++cnt[a[i] = rd()]; deg[i] = 0; vis[i] = false; &#125; for (int i = 1; i &lt;= n; ++i) ++deg[b[i] = rd()]; for (int i = 1; i &lt;= n; ++i) if (!deg[i]) q.push(i); while (!q.empty()) &#123; int u = q.front(); q.pop(); --deg[b[u]]; vis[u] = true; if (!deg[b[u]]) q.push(b[u]); &#125; for (int i = 1; i &lt;= n; ++i) if (!vis[i]) &#123;++tot; dfs(i);&#125; int ans = 1e9; for (int u = 1; u &lt;= n; ++u) if (tmpcnt[a[u]] == tot) &#123; ans = min(ans, n - cnt[a[u]]); &#125; printf(&quot;%d\\n&quot;, ans &lt; 1e9 ? ans : -1);&#125; int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; 石头剪刀布 两个剪刀石头布的等长序列，每次可以把自己的序列的某个数移到最后，求赢的次数减操作次数的最大值。 性质是被移到后面的数字顺序任意，因此被移到后面的数字可以尽量匹配赢。 设 \\(f[i][a][b][c]\\) 表示前 \\(i\\) 个，把 \\(a\\) 个剪刀、\\(b\\) 个石头、\\(c\\) 个布移动到后面，剩余的最大赢次数。 最后对每个状态扫描的时候统计被操作的数字能赢多少即可，对每种记个后缀和即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;using namespace std;using ll = long long;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;#define rep(i, x, y) for (int i = (x); i &lt;= (y); ++i)#define per(i, x, y) for (int i = (x); i &gt;= (y); --i)inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 107char A[N], B[N];int f[N][N][N][N], a[N], b[N];inline int tr(char c) &#123; if (c == &#x27;r&#x27;) return 2; if (c == &#x27;s&#x27;) return 1; return 0;&#125;inline int win(int a, int b) &#123; if (a == 2 &amp;&amp; b == 1) return 1; if (a == 1 &amp;&amp; b == 0) return 1; if (a == 0 &amp;&amp; b == 2) return 1; return 0;&#125;int suf[3][N];int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); scanf(&quot;%s&quot;, A + 1); scanf(&quot;%s&quot;, B + 1); for (int i = 1; i &lt;= n; ++i) &#123; a[i] = tr(A[i]); b[i] = tr(B[i]); &#125; for (int i = n; i; --i) &#123; for (int j = 0; j &lt; 3; ++j) suf[j][i] = suf[j][i + 1]; suf[b[i]][i]++; &#125; memset(f, 0xcf, sizeof(f)); f[0][0][0][0] = 0; for (int i = 1; i &lt;= n; ++i) for (int x = 0; x &lt;= i; ++x) for (int y = 0; y &lt;= i - x; ++y) for (int z = 0; z &lt;= i - x - y; ++z) &#123; int p = i - x - y - z; f[i][x][y][z] = max(f[i][x][y][z], f[i - 1][x][y][z] + win(a[i], b[p])); if (a[i] == 0 &amp;&amp; x) f[i][x][y][z] = max(f[i][x][y][z], f[i - 1][x - 1][y][z]); if (a[i] == 1 &amp;&amp; y) f[i][x][y][z] = max(f[i][x][y][z], f[i - 1][x][y - 1][z]); if (a[i] == 2 &amp;&amp; z) f[i][x][y][z] = max(f[i][x][y][z], f[i - 1][x][y][z - 1]); &#125; int ans = 0; for (int x = 0; x &lt;= n; ++x) for (int y = 0; y &lt;= n - x; ++y) for (int z = 0; z &lt;= n - x - y; ++z) &#123; int tot = x + y + z; int nw = f[n][x][y][z] + min(x, suf[2][n - tot + 1]) + min(y, suf[0][n - tot + 1]) + min(z, suf[1][n - tot + 1]); ans = max(ans, nw - tot); &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125; KSharpe 给定一个 \\(01\\) 序列，求所有区间权值 =（均值 / 标准差）的第 \\(k\\) 大，特殊的如果标准差为 \\(0\\) 则权值也定义为 \\(0\\) 。 推一推发现权值的平方 = 区间 \\(1\\) 的个数 / 区间 \\(0\\) 的个数，二分权值的平方第 \\(k\\) 大为 \\(w\\) ，即统计多少个 \\(l,r\\) 满足： \\[ \\frac{sum_r-sum_{l-1}}{(r - sum_r) - (l-1 - sum_{l-1})}\\ge w \\] 记 \\(f(x) =sum_x-w(x - sum_x)\\) ，所求即 \\(f(r)\\ge f(l-1)\\) ，离散化 + 树状数组统计顺序对即可。 特殊的全 \\(1\\) 区间会认为大于 \\(w\\) 恒成立，所以需要扣掉。提前数一下即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;using namespace std;using ll = long long;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;#define rep(i, x, y) for (int i = (x); i &lt;= (y); ++i)#define per(i, x, y) for (int i = (x); i &gt;= (y); --i)inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 100007ll k;int n, sum[N];ll c[N];vector&lt;pair&lt;double, int&gt; &gt; s;inline int lowbit(int x) &#123;return x &amp; -x;&#125;inline void add(int x) &#123; for (; x &lt; N; x += lowbit(x)) ++c[x];&#125;inline ll calc(int x) &#123; ll res = 0; for (; x; x -= lowbit(x)) res += c[x]; return res;&#125;ll cntint1 = 0;int ha[N];inline bool valid(double x) &#123; s.clear(); s.pb(mp(0, 0)); for (int i = 1; i &lt;= n; ++i) s.pb(mp(sum[i] - x * (i - sum[i]), i)); sort(s.begin(), s.end()); int cnt = 0; ha[s[0].sc] = ++cnt; for (int i = 1; i &lt;= n; ++i) &#123; if (s[i].fr != s[i - 1].fr) ++cnt; ha[s[i].sc] = cnt; &#125; memset(c, 0, sizeof(c)); add(ha[0]); ll tot = 0; for (int i = 1; i &lt;= n; ++i) &#123; tot += calc(ha[i]); add(ha[i]); &#125; return tot - cntint1 &gt;= k;&#125;int main() &#123; n = rd(); k = rd(); int cnt1 = 0; for (int i = 1; i &lt;= n; ++i) &#123; int w = rd(); sum[i] = sum[i - 1] + w; if (w == 1) ++cnt1; else &#123;cntint1 += 1ll * cnt1 * (cnt1 + 1) / 2; cnt1 = 0;&#125; &#125; cntint1 += 1ll * cnt1 * (cnt1 + 1) / 2; double l = 0, r = n; for (int i = 1; i &lt;= 100; ++i) &#123; double mid = (r + l) / 2; valid(mid) ? l = mid : r = mid; &#125; printf(&quot;%.10lf\\n&quot;, sqrt(l)); return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"http://blog.gyx.me/categories/Solution/"},{"name":"Others","slug":"Solution/Others","permalink":"http://blog.gyx.me/categories/Solution/Others/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"},{"name":"DFS and Similar","slug":"DFS-and-Similar","permalink":"http://blog.gyx.me/tags/DFS-and-Similar/"},{"name":"System of Difference Constraints","slug":"System-of-Difference-Constraints","permalink":"http://blog.gyx.me/tags/System-of-Difference-Constraints/"}]},{"title":"2022 HDU Multi-University Training Contest 8","slug":"HDU/hdu2022-8","date":"2022-08-11T14:24:33.000Z","updated":"2022-08-12T05:28:31.323Z","comments":true,"path":"2022/08/11/HDU/hdu2022-8/","link":"","permalink":"http://blog.gyx.me/2022/08/11/HDU/hdu2022-8/","excerpt":"","text":"1001. Theramore 给一个 \\(01\\) 序列，每次可以对称翻转一个奇数长度的区间，问任意次操作能得到的最小字典序序列。 核心点是翻转不会交换奇偶位上的数字，所以只用长度为 \\(3\\) 的操作，对奇偶分别排序即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;using ll = long long;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 100007char s[N];int even[2], odd[2];inline void work() &#123; odd[0] = odd[1] = even[0] = even[1] = 0; scanf(&quot;%s&quot;, s + 1); int n = strlen(s + 1); for (int i = 1; i &lt;= n; ++i) &#123; if (i &amp; 1) ++odd[s[i] - &#x27;0&#x27;]; else ++even[s[i] - &#x27;0&#x27;]; &#125; for (int i = 1; i &lt;= n; ++i) &#123; if (i &amp; 1) &#123; if (odd[0]) &#123;putchar(&#x27;0&#x27;); --odd[0];&#125; else putchar(&#x27;1&#x27;); &#125; else &#123; if (even[0]) &#123;putchar(&#x27;0&#x27;); --even[0];&#125; else putchar(&#x27;1&#x27;); &#125; &#125; puts(&quot;&quot;);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; 1005. Ironforge 给一条链，每个点上有一个数字，每条边上有一个质数，多次询问是否能从 \\(x\\) 到 \\(y\\) 。 每次经过一个点就可以得到这个点的全部质数，经过一条边必须要有边上的质数才能通过。 复杂度分析题，主要目的是利用相邻的点的信息，求出每个点出发的可达区间 \\([l_i,r_i]\\) 。 判断能否通过边：预处理出来每条边两侧最近的包含对应质数的点的位置，想要通过区间要包含对应一侧的点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;using namespace std;using ll = long long;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 200007bool vis[N];int prm[N], mnd[N], tot;int a[N], b[N], l[N], r[N], lst[N], L[N], R[N];inline bool inseg(int x, int pos) &#123; return pos &gt;= l[x] &amp;&amp; pos &lt;= r[x];&#125;inline void work() &#123; int n = rd(), m = rd(); for (int i = 1; i &lt;= n; ++i) l[i] = r[i] = i, a[i] = rd(); for (int i = 1; i &lt; N; ++i) lst[i] = 0; for (int i = 1; i &lt; n; ++i) &#123; int w = a[i]; while(w &gt; 1) &#123;lst[mnd[w]] = i; w = w / prm[mnd[w]];&#125; b[i] = mnd[rd()]; L[i] = lst[b[i]]; &#125; for (int i = 1; i &lt; N; ++i) lst[i] = n + 1; for (int i = n - 1; i; --i) &#123; int w = a[i + 1]; while (w &gt; 1) &#123;lst[mnd[w]] = i + 1; w = w / prm[mnd[w]];&#125; R[i] = lst[b[i]]; &#125; for (int i = n - 1; i; --i) while (r[i] &lt; n &amp;&amp; inseg(i, L[r[i]])) r[i] = r[r[i] + 1]; for (int i = 2; i &lt;= n; ++i) &#123; if (!inseg(i, R[l[i] - 1])) continue; if (r[i - 1] &gt;= i) &#123;l[i] = l[i - 1]; r[i] = r[i - 1]; continue;&#125; l[i] = l[i - 1]; bool fl = 1; while (fl) &#123; fl = 0; if (l[i] &gt; 1 &amp;&amp; inseg(i, R[l[i] - 1])) &#123; if (r[l[i] - 1] &gt;= i) &#123; r[i] = r[l[i] - 1]; l[i] = l[l[i] - 1]; break; &#125; l[i] = l[l[i] - 1]; fl = 1; &#125; if (r[i] &lt; n &amp;&amp; inseg(i, L[r[i]])) &#123; r[i] = r[r[i] + 1]; fl = 1; &#125; &#125; &#125; for (; m; --m) &#123; int x = rd(), y = rd(); puts(y &gt;= l[x] &amp;&amp; y &lt;= r[x] ? &quot;Yes&quot; : &quot;No&quot;); &#125;&#125;int main() &#123; for (int i = 2; i &lt; N; ++i) &#123; if (!vis[i]) &#123;prm[tot] = i; mnd[i] = tot++;&#125; for (int j = 0, w; j &lt; tot; ++j) &#123; if (1ll * i * prm[j] &gt;= N) break; mnd[w = i * prm[j]] = j; vis[w] = 1; if (j == mnd[i]) break; &#125; &#125; for (int t = rd(); t; --t) work(); return 0;&#125; 1007. Darnassus 给一个排列，建完全图 \\(i\\) 和 \\(j\\) 之间边权为 \\(|i-j|\\times |p_i-p_j|\\) ，求最小生成树。 注意到如果相邻连边边权都不会超过 \\(n\\) ，所以只需要保留 \\(n\\) 以内的边。 因此乘积两部分都按根号枚举即可，用桶排序保存所有的边，总复杂度 \\(\\mathcal O(n\\sqrt n\\alpha(n))\\)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;using namespace std;using ll = long long;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 50007int f[N], p[N], q[N];vector&lt;pii&gt; e[N];inline int find(int x) &#123;return x == f[x] ? x : f[x] = find(f[x]);&#125;inline int Abs(int x) &#123;return x &lt; 0 ? -x : x;&#125;inline void work() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; f[i] = i; p[i] = rd(); q[p[i]] = i; e[i].clear(); &#125; int lim = sqrt(n) + 1; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = max(1, i - lim), w; j &lt; i; ++j) &#123; if ((w = (i - j) * Abs(p[j] - p[i])) &gt; n) continue; e[w].pb(mp(i, j)); &#125; for (int j, w, pj = max(1, p[i] - lim); pj &lt; p[i]; ++pj) &#123; j = q[pj]; if (Abs(q[pj] - i) &lt;= lim) continue; if ((w = (p[i] - pj) * Abs(j - i)) &gt; n) continue; e[w].pb(mp(i, j)); &#125; &#125; ll ans = 0; int cnt = n - 1; for (int i = 1; i &lt;= n; ++i) &#123; for (auto cur : e[i]) &#123; int u = cur.fr, v = cur.sc; if (find(u) != find(v)) &#123; --cnt; f[find(u)] = find(v); ans += i; &#125; if (!cnt) break; &#125; if (!cnt) break; &#125; printf(&quot;%lld\\n&quot;, ans);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; 1008. Orgrimmar 给一棵树，求最大解离集的大小（诱导子图里每个点度不超过 \\(1\\) ） 设状态 dp[u][0/1/2] 表示 \\(u\\) 节点：没选 / 选了，但儿子都没选 / 选了，并且选了一个儿子。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;using ll = long long;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 500007vector&lt;int&gt; e[N];int f[N][3];// f[u][0] : not choose u// f[u][1] : choose u, not choose u&#x27;s son// f[u][2] : choose u, choose u&#x27;s sonvoid dfs(int u, int fa) &#123; int dlt = 0; f[u][0] = 0; f[u][1] = 1; f[u][2] = 1; for (auto v : e[u]) if (v != fa) &#123; dfs(v, u); f[u][0] += max(&#123;f[v][0], f[v][1], f[v][2]&#125;); f[u][1] += f[v][0]; dlt = max(dlt, f[v][1] - f[v][0]); &#125; f[u][2] = f[u][1] + dlt;&#125;inline void work() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) e[i].clear(); for (int i = 1; i &lt; n; ++i) &#123; int u = rd(), v = rd(); e[u].pb(v); e[v].pb(u); &#125; dfs(1, 1); printf(&quot;%d\\n&quot;, max(&#123;f[1][0], f[1][1], f[1][2]&#125;));&#125;int main() &#123; int size(512&lt;&lt;20); // 512M __asm__ ( &quot;movq %0, %%rsp\\n&quot;::&quot;r&quot;((char*)malloc(size)+size)); for (int t = rd(); t; --t) work(); exit(0);&#125; 1010. Vale of Eternal 给一个点集，每秒每个点向上下左右距离 \\(1\\) 的位置复制一个点，问第 \\(t\\) 秒所有点的凸包面积大小。 柴老师推的式子，前 \\(t\\) 秒的增量为 \\(2t^2+t\\sum \\max(|\\Delta x|,|\\Delta y|)\\) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include&lt;bits/stdc++.h&gt;using namespace std;using ll = long long;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;#define rep(i, x, y) for (int i = (x); i &lt;= (y); ++i)#define per(i, x, y) for (int i = (x); i &gt;= (y); --i)inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;typedef long long T;#define let const auto#define lett const T#define letp const P // P for point#define lets const S // S for segment#define letl const L // L for line#define letc const C // C for convex#define z(x) (abs((x)) &lt;= eps) // is zeroconst T eps = 1e-8;constexpr double PI=3.1415926535897932384;struct P &#123; T x, y; P (T x = 0, T y = 0) : x(x), y(y) &#123;&#125; P operator + (letp &amp;p) const &#123;return &#123;x + p.x, y + p.y&#125;;&#125; P operator - (letp &amp;p) const &#123;return &#123;x - p.x, y - p.y&#125;;&#125; P operator * (lett &amp;d) const &#123;return &#123;x * d, y * d&#125;;&#125; P operator / (lett &amp;d) const &#123;return &#123;x / d, y / d&#125;;&#125; P operator - () const &#123;return &#123;-x, -y&#125;;&#125; T operator | (letp &amp;p) const &#123;return x * p.x + y * p.y;&#125; // dot T operator ^ (letp &amp;p) const &#123;return x * p.y - y * p.x;&#125; // cross // P rot(double ang) const &#123; // counterclockwise rotation (ang) angle // double cosa = cos(ang), sina = sin(ang); // return &#123;x * cosa - y * sina, x * sina + y * cosa&#125;; // &#125; bool operator == (letp &amp;p) const &#123;return z(x - p.x) &amp;&amp; z(y - p.y);&#125; bool operator != (letp &amp;p) const &#123;return ! operator == (p);&#125; bool operator &lt; (letp &amp;p) const &#123;return z(x - p.x) ? y &lt; p.y : x &lt; p.x;&#125; bool operator &gt; (letp &amp;p) const &#123;return !(*this &lt; p || *this == p);&#125; // left(counterclockwise) = 1 | on = 0 | right(clockwise) = -1 int ori(letp &amp;p) const &#123;T t = (*this) ^ p; return (t &gt; eps) - (t &lt; -eps);&#125; T norm() const &#123;return x * x + y * y;&#125;&#125; zero;double abs(letp &amp;p) &#123;return sqrt(p.norm());&#125;P normalize(letp &amp;p) &#123;return p / abs(p);&#125;P perp(letp &amp;p) &#123;return &#123;-p.y, p.x&#125;;&#125; // turn pi / 2 leftP perpr(letp &amp;p) &#123;return &#123;p.y, -p.x&#125;;&#125; // turn pi / 2 rightbool orth(letp &amp;p, letp &amp;q) &#123;return (p | q) == 0;&#125;bool para(letp &amp;p, letp &amp;q) &#123;return (p ^ q) == 0;&#125;struct Polygon &#123; vector&lt;P&gt; p; // counterclockwise Polygon(const vector&lt;P&gt; p = &#123;&#125;) : p(p) &#123;&#125; size_t nxt(const size_t i) const &#123;return i == p.size() - 1 ? 0 : i + 1;&#125; size_t pre(const size_t i) const &#123;return i == 0 ? p.size() - 1 : i - 1;&#125; T double_area() const &#123; T sum = 0; for (size_t i = 0; i &lt; p.size(); ++i) sum += (p[i] ^ p[nxt(i)]); return sum; &#125;&#125;;struct C : Polygon &#123; C (const vector&lt;P&gt; &amp;p = &#123;&#125;) : Polygon(p) &#123;&#125;&#125;;C convexHull(vector&lt;P&gt; p) &#123; vector&lt;P&gt; st; sort(p.begin(), p.end()); const auto check = [](const vector&lt;P&gt; &amp;st, letp &amp;u) &#123; const auto back1 = st.back(), back2 = *prev(st.end(), 2); return (back1 - back2).ori(u - back2) &lt;= 0; &#125;; for (letp &amp;u : p) &#123; while (st.size() &gt; 1 &amp;&amp; check(st, u)) st.pop_back(); st.push_back(u); &#125; size_t k=st.size(); p.pop_back(); reverse(p.begin(),p.end()); for (letp &amp;u : p) &#123; while (st.size() &gt; k &amp;&amp; check(st, u)) st.pop_back(); st.push_back(u); &#125; st.pop_back(); return &#123;st&#125;;&#125;C c;vector&lt;P&gt; p;inline void work() &#123; p.clear(); int n = rd(), q = rd(); p.resize(n); for (int i = 0; i &lt; n; ++i) &#123;p[i].x = rd(); p[i].y = rd();&#125; c = convexHull(p); ll s = c.double_area(); ll dlt = 0; for (size_t i = 0; i &lt; c.p.size(); ++i) &#123; P cur = c.p[c.nxt(i)] - c.p[i]; dlt += max(abs(cur.x), abs(cur.y)); &#125; for (int i = 1; i &lt;= q; ++i) &#123; ll t = rd(); ll ans = s + 4 * t * t + 2 * t * dlt; printf(&quot;%lld&quot;, ans / 2); puts((ans &amp; 1) ? &quot;.5&quot; : &quot;.0&quot;); &#125;&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"http://blog.gyx.me/categories/Solution/"},{"name":"HDU","slug":"Solution/HDU","permalink":"http://blog.gyx.me/categories/Solution/HDU/"}],"tags":[{"name":"Geometry","slug":"Geometry","permalink":"http://blog.gyx.me/tags/Geometry/"}]},{"title":"2022 NowCoder Multi-University Training Contest 7","slug":"Nowcoder/nc2022-7","date":"2022-08-08T14:24:33.000Z","updated":"2022-08-10T12:34:55.617Z","comments":true,"path":"2022/08/08/Nowcoder/nc2022-7/","link":"","permalink":"http://blog.gyx.me/2022/08/08/Nowcoder/nc2022-7/","excerpt":"","text":"B. Rotate Sum 3 给一个凸包，每次操作将凸包按某个对称轴在三维空间里旋转任意角度，求无数次操作后扫过的体积。 如果只有一个对称轴，答案就是若干个圆台的体积之和。 如果有超过一个对称轴，由于所有对称轴都过重心，最终的旋转体会形成一个球，半径是凸包顶点和重心的最远距离。 找对称轴：将凸包展开成角度和边长的序列，然后复制一遍跑 manacher ，如果某个中心的回文半径大于 2n 即为对称轴。 构造序列：角 \\(ABC\\) 用点积 \\(|BA||BC|\\cos \\alpha\\) 代替（ \\(\\cos\\alpha\\) 可以区分 \\([0,\\pi)\\) 的所有角度， 此外对称要求两侧边也一样长，所以不用除掉模长），边长用长度平方代替，这样就都是整数，没有精度问题了。 计数对称轴：由于一个对称轴可能会被找到两次，需要去重，因为都过重心，所以方向向量叉积不等于 \\(0\\) 即为不同。 算体积：取直线一侧的点，按照逆时针顺序依次算。代码里偷懒，直接复制出来一遍做，一定有一段是包含完整的点集。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include&lt;bits/stdc++.h&gt;using namespace std;using ll = long long;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;typedef long double T;#define lett const T#define letp const P // P for point#define lets const S // S for segment#define letl const L // L for line#define letc const C // C for convex#define z(x) (abs((x)) &lt;= eps) // is zeroconst T eps = 1e-8;const T inf = 1e18;constexpr long double pi = 3.1415926535897932384;struct P &#123; T x, y; P (T x = 0, T y = 0) : x(x), y(y) &#123;&#125; P operator + (letp &amp;p) const &#123;return &#123;x + p.x, y + p.y&#125;;&#125; P operator - (letp &amp;p) const &#123;return &#123;x - p.x, y - p.y&#125;;&#125; P operator * (lett &amp;d) const &#123;return &#123;x * d, y * d&#125;;&#125; P operator / (lett &amp;d) const &#123;return &#123;x / d, y / d&#125;;&#125; T operator | (letp &amp;p) const &#123;return x * p.x + y * p.y;&#125; // dot T operator ^ (letp &amp;p) const &#123;return x * p.y - y * p.x;&#125; // cross bool operator == (letp &amp;p) const &#123;return z(x - p.x) &amp;&amp; z(y - p.y);&#125; bool operator != (letp &amp;p) const &#123;return ! operator == (p);&#125; bool operator &lt; (letp &amp;p) const &#123;return z(x - p.x) ? y &lt; p.y : x &lt; p.x;&#125; bool operator &gt; (letp &amp;p) const &#123;return !(*this &lt; p || *this == p);&#125; int ori(letp &amp;p) const &#123;T t = (*this) ^ p; return (t &gt; eps) - (t &lt; -eps);&#125; T norm() const &#123;return x * x + y * y;&#125; P proj (letp &amp;p) const &#123;return (*this) * (((*this) | p) / norm());&#125; P refl (letp &amp;p) const &#123;return proj(p) * 2 - p;&#125;&#125; zero;long double abs(letp &amp;p) &#123;return sqrt(p.norm());&#125;P normalize(letp &amp;p) &#123;return p / abs(p);&#125;P perp(letp &amp;p) &#123;return &#123;-p.y, p.x&#125;;&#125; // turn pi / 2 leftP perpr(letp &amp;p) &#123;return &#123;p.y, -p.x&#125;;&#125; // turn pi / 2 rightbool orth(letp &amp;p, letp &amp;q) &#123;return (p | q) == 0;&#125;bool para(letp &amp;p, letp &amp;q) &#123;return (p ^ q) == 0;&#125;struct L &#123; P p, v; int ori (letp &amp;a) const &#123;return v.ori(a - p);&#125; P inter(letl &amp;l) const &#123;return p + v * ((l.v ^ (p - l.p)) / (v ^ l.v));&#125; L shift(letp &amp;d) const &#123;return &#123;p + d, v&#125;;&#125; L shiftl(double d) const &#123;return &#123;p + perp(v) * d / abs(v), v&#125;;&#125; long double dis(letp &amp;a) const &#123;return abs(v ^ (a - p)) / abs(v);&#125; &#125;;vector&lt;P&gt; c;#define N 400007long double a[N];int p[N];#define pre(x) (x == 0 ? n - 1 : x - 1)#define nxt(x) (x == n - 1 ? 0 : x + 1)vector&lt;int&gt; s;long double v(long double r, long double R, long double h) &#123; return 1 / 3.0 * pi * h * (r * r + R * R + r * R);&#125;int main() &#123; int n = rd(); P cent; cent.x = cent.y = 0; for (int i = 1; i &lt;= n; ++i) &#123; long double x = rd(), y = rd(); cent.x += x; cent.y += y; c.pb(&#123;x, y&#125;); &#125; cent = cent / n; int tot = 0; for (int i = 0; i &lt; n; ++i) &#123; a[++tot] = ((c[pre(i)] - c[i]) | (c[nxt(i)] - c[i])); a[++tot] = (c[nxt(i)] - c[i]).norm(); &#125; for (int i = 2 * n + 1; i &lt;= 4 * n; ++i) a[i] = a[i - 2 * n]; tot = 4 * n; int pos = 0, R = 0; for (int i = 1; i &lt;= 2 * n; ++i) &#123; if (i &lt; R) p[i] = min(p[(pos &lt;&lt; 1) - i], R - i); else p[i] = 1; while (1 &lt;= i - p[i] &amp;&amp; i + p[i] &lt;= tot &amp;&amp; z(a[i - p[i]] - a[i + p[i]])) ++p[i]; if (i + p[i] &gt; R) pos = i, R = i + p[i]; if (2 * p[i] - 1 &gt;= 2 * n) s.pb(i); &#125; long double d = 0; for (int i = 0; i &lt; n; ++i) d = max(d, abs(cent - c[i])); long double ball = 4.0 / 3.0 * pi * d * d * d; bool fl = 0; P dir; for (auto i : s) &#123; if (i &amp; 1) &#123; // node int cur = i / 2; P dr = c[cur] - cent; if (!fl) &#123;dir = dr; fl = 1;&#125; else &#123; if (!z(dir ^ dr)) &#123;printf(&quot;%.12Lf\\n&quot;, ball); return 0;&#125; &#125; &#125; else &#123; int cur = i / 2 - 1; P ct = (c[cur] + c[nxt(cur)]) / 2; P dr = ct - cent; if (!fl) &#123;dir = dr; fl = 1;&#125; else &#123; if (!z(dir ^ dr)) &#123;printf(&quot;%.12Lf\\n&quot;, ball); return 0;&#125; &#125; &#125; &#125; if (!fl) &#123;puts(&quot;0&quot;); return 0;&#125; L l&#123;cent, dir&#125;; fl = 0; for (int i = 0; i &lt; n; ++i) c.pb(c[i]); long double ans = 0, tmp = 0; P lstp; for (auto nw : c) &#123; if (l.ori(nw) &gt;= 0) &#123; if (fl) &#123; tmp += v(l.dis(lstp), l.dis(nw), fabs(((lstp - nw) | l.v) / abs(l.v))); &#125; fl = 1; lstp = nw; &#125; else &#123;ans = max(ans, tmp); fl = 0; tmp = 0;&#125; &#125; ans = max(ans, tmp); printf(&quot;%.12Lf\\n&quot;, ans); return 0;&#125; 一道类似的多边形找对称轴题：[POI 2007] Axes of Symmetry F. Candies \\(n\\) 个数字形成一个环，每次可以删掉两个相邻的相同或和为 \\(a\\) 的两个数字，问最多能删几次。 每次暴力找到一个位置删除即可。证明比较巧妙： 对于所有的 \\(x\\in [a / 2, a]\\) 将 \\(x\\) 变为 \\(a-x\\) ，可以发现原本允许消除的数对现在依然允许消除。 因此只剩下相邻且相同的数字才可以消除，此时贪心显然是对的，删除顺序不会改变答案大小。 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;deque&lt;int&gt; s;int main() &#123; int n = rd(), a = rd(), ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; s.push_back(rd()); while (s.size() &gt;= 2) &#123; int x = s[s.size() - 1], y = s[s.size() - 2]; if (x != y &amp;&amp; x + y != a) break; ++ans; s.pop_back(); s.pop_back(); &#125; &#125; while (s.size() &gt;= 2) &#123; if (s.front() == s.back() || s.front() + s.back() == a) &#123; ++ans; s.pop_front(); s.pop_back(); &#125; else break; &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125; K. Great Party 有 \\(n\\) 堆石子，每堆 \\(a_i\\) 个，每次选一堆拿走若干个，剩余的可以选择合并到某一堆现存的中。 每次询问一个区间，问有多少个子区间先手必胜。 少见的做出来的博弈题，按堆数从小到大考虑。 只有一堆，必胜；只有两堆，如果一样的话，因为不敢合并，所以可以对称操作，必败，否则必胜；三堆的必胜，因为可以通过拿+合并变成两堆一样多的；四堆的情况谁拿成三堆就输，因为三堆必胜，所以四堆的时候可以看成是 \\(a_i-1\\) 的 NIM 游戏，因为都拿到 \\(1\\) 就不得不合并了。五堆的时候一定可以对最大的操作使得变成四堆且 NIM 和为 \\(0\\) 。因此： 偶数个即为 \\(a_i - 1\\) 的 NIM 游戏，因为转换成奇数的那个人必败。 奇数先手必胜，先手对最大那堆石子操作，使得剩偶数个且石子个数减一的异或和为0的局面。 所以变成了查询区间内有多少个偶数长度的子区间异或和为 \\(0\\) ，莫队分奇偶统计即可。（让胖胖写的） L. Maximum Range","categories":[{"name":"Solution","slug":"Solution","permalink":"http://blog.gyx.me/categories/Solution/"},{"name":"Nowcoder","slug":"Solution/Nowcoder","permalink":"http://blog.gyx.me/categories/Solution/Nowcoder/"}],"tags":[{"name":"Constructive Algorithm","slug":"Constructive-Algorithm","permalink":"http://blog.gyx.me/tags/Constructive-Algorithm/"},{"name":"Game Theory","slug":"Game-Theory","permalink":"http://blog.gyx.me/tags/Game-Theory/"},{"name":"Geometry","slug":"Geometry","permalink":"http://blog.gyx.me/tags/Geometry/"}]},{"title":"2022 NowCoder Multi-University Training Contest 3","slug":"Nowcoder/nc2022-3","date":"2022-07-26T00:41:33.000Z","updated":"2022-08-08T14:52:36.721Z","comments":true,"path":"2022/07/26/Nowcoder/nc2022-3/","link":"","permalink":"http://blog.gyx.me/2022/07/26/Nowcoder/nc2022-3/","excerpt":"","text":"A. Ancestor 给两棵 \\(n\\) 个节点的树 \\(A,B\\) 和一个数集 \\(S\\) ，问有多少个数满足 \\(\\{S\\setminus a_i\\}\\) 在 \\(A\\) 中的 LCA 的点权比 \\(B\\) 中的大。 \\(\\mathcal O(n\\log n)\\) 的做法是暴力求出来给定节点序列在两棵树中前后缀的 LCA ，最后每个合并一下两侧即可。 有一个比较妙的 \\(\\mathcal O(n)\\) 做法：考虑哪些点会作为 \\(|S|-1\\) 个点的 LCA 。 我们将数集里每个点的点权设为 \\(1\\) ，至多存在一个点 \\(u\\) ，满足 \\(u\\) 子树和为 \\(|S|-1\\) 且深度最深。 如果删掉的是这 \\(|S|-1\\) 个点中的某一个，剩余的点的 LCA 就是 \\(S\\) 中所有点的 LCA 。 否则剩余的点就是这 \\(|S| -1\\) 个点，答案就是 \\(u\\) 如果不存在这样的 \\(u\\) ，那么答案永远都是 \\(S\\) 中所有点的 LCA 。 综上可以发现，删掉某个点之后剩余点的 LCA 可能的结果至多两种，因此可以一遍 DFS 之后 \\(\\mathcal O(1)\\) 查询。 特殊情况是 \\(k=2\\) 的时候 \\(u\\) 会有两个，所以单独判一下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;#define pb push_back#define rep(i, x, y) for (int i = (x); i &lt;= (y); ++i)#define per(i, x, y) for (int i = (x); i &gt;= (y); --i)inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 100007int n, k, tot, x[N];struct tree &#123; int lca, sub, cur; int sz[N], sum[N], val[N]; vector&lt;int&gt; son[N]; void dfs(int u) &#123; for (auto v : son[u]) dfs(v); for (auto v : son[u]) &#123;sz[u] += sz[v]; sum[u] ^= sum[v];&#125; if (!lca &amp;&amp; sz[u] == k) lca = u; if (!sub &amp;&amp; sz[u] == k - 1) &#123;sub = u; cur = sum[u] ^ tot;&#125; &#125; int query(int u) &#123;return u == cur ? val[sub] : val[lca];&#125;&#125; tr[2];int main() &#123; n = rd(); k = rd(); rep(i, 1, k) tot ^= (x[i] = rd()); rep(id, 0, 1) &#123; rep(i, 1, n) tr[id].val[i] = rd(); rep(i, 2, n) tr[id].son[rd()].pb(i); rep(i, 1, k) &#123;++tr[id].sz[x[i]]; tr[id].sum[x[i]] ^= x[i];&#125; &#125; int ans = 0; if (k &gt; 2) &#123; rep(id, 0, 1) tr[id].dfs(1); rep(i, 1, k) ans += tr[0].query(x[i]) &gt; tr[1].query(x[i]); &#125; else &#123; rep(i, 1, 2) ans += (tr[0].val[x[i]] &gt; tr[1].val[x[i]]); &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125; B. Boss 有 \\(n\\) 个员工要派到 \\(m\\) 个城市, 每个城市需要 \\(a_{i}\\) 个员工，且 \\(\\sum_{i=1}^{m} a_{i}=n\\ (n \\leq 10^{5}, m \\leq 10)\\), 求最小费用。 （借鉴柴老师博客） 最小费用流模版题，但是直接跑费用流复杂度不对，要根据图的性质优化求最短路的算法。 左边是城市, 右边是员工, 每次找一条最短路, 必然是先走到左边的点, 再经过若干次反悔, 最后走到右边的点。 一次反悔, 指先从左边走到右边, 再从右边走到左边，也就是 \\(dis_{u,x}+dis_{x,v}\\) 。 所以路径可以拆成两部分：在左侧从 \\(u\\) 开始经过若干次到 \\(v\\) ，然后从 \\(v\\) 选择右侧一个可以走的点走掉。 对于左侧的点之间维护 \\(m^2\\) 个堆代表当前从 \\(u\\) 经过一次反悔到 \\(v\\) 的最短距离，每次增广用堆顶的直跑一遍 floyd 。 对于每个左侧的点维护一个堆代表到右侧所有可行的距离里最短的，第二部分的距离就是堆顶的值。 求最短路就枚举所有的可能的 \\(u,v\\) ，因此单次增光复杂度为 \\(\\mathcal O(m^2\\log n+m^3)\\) ，一共增广 \\(n\\) 次。 第一部分的堆维护的时候要考虑退流，求途径的节点需要再floyd 的时候记一个 pre ，然后 dfs 往回找，细节见代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define K 11#define N 100007bool use[N];ll ans;int rem[K], dis[K][K], pre[K][K], mn[K][K];int c[K][N], n, k;bool go[K][N], back[N][K];bool vis[K][K][N];priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt; &gt; q[K][K], p[K];vector&lt;int&gt; s;void dfs(int u, int v) &#123; if (!pre[u][v]) &#123; go[u][mn[u][v]] = back[mn[u][v]][v] = false; back[mn[u][v]][u] = go[v][mn[u][v]] = true; s.pb(mn[u][v]); return; &#125; dfs(u, pre[u][v]); dfs(pre[u][v], v);&#125;inline void work() &#123; memset(dis, 0x3f, sizeof(dis)); for (int u = 1; u &lt;= k; ++u) &#123; dis[u][u] = 0; while (!p[u].empty() &amp;&amp; use[p[u].top().second]) p[u].pop(); for (int v = 1; v &lt;= k; ++v) &#123; while (!q[u][v].empty()) &#123; int x = q[u][v].top().second; if (!go[u][x] || !back[x][v]) &#123;vis[u][v][x] = false; q[u][v].pop();&#125; else break; &#125; if (q[u][v].size()) &#123; dis[u][v] = q[u][v].top().first; mn[u][v] = q[u][v].top().second; pre[u][v] = 0; &#125; &#125; &#125; for (int t = 1; t &lt;= k; ++t) for (int u = 1; u &lt;= k; ++u) for (int v = 1; v &lt;= k; ++v) if (dis[u][v] &gt; dis[u][t] + dis[t][v]) &#123; pre[u][v] = t; dis[u][v] = dis[u][t] + dis[t][v]; &#125; int mnu, mnv, cst = 1e9; for (int u = 1; u &lt;= k; ++u) if (rem[u]) for (int v = 1; v &lt;= k; ++v) &#123; int nw = dis[u][v] + p[v].top().first; if (nw &lt; cst) &#123;cst = nw; mnu = u; mnv = v;&#125; &#125; ans += cst; --rem[mnu]; s.clear(); if (mnu != mnv) dfs(mnu, mnv); s.pb(p[mnv].top().second); go[mnv][p[mnv].top().second] = false; back[p[mnv].top().second][mnv] = true; use[p[mnv].top().second] = true; for (auto t : s) &#123; for (int u = 1; u &lt;= k; ++u) for (int v = 1; v &lt;= k; ++v) if (go[u][t] &amp;&amp; back[t][v] &amp;&amp; !vis[u][v][t]) &#123; vis[u][v][t] = true; q[u][v].push(mp(c[u][t] - c[v][t], t)); &#125; &#125;&#125;int main() &#123; n = rd(); k = rd(); for (int i = 1; i &lt;= k; ++i) rem[i] = rd(); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= k; ++j) &#123; c[j][i] = rd(); go[j][i] = true; p[j].push(mp(c[j][i], i)); &#125; for (int i = 1; i &lt;= n; ++i) work(); printf(&quot;%lld\\n&quot;, ans); return 0;&#125; D. Directed 胖胖补的，戳我围观 F. Fief 无向图每次询问两个点 \\(x,y\\) ，问是否存在一个点编号的排列以 \\(x\\) 开头以 \\(y\\) 结尾，且任意位置断开得到的两段都连通。 这个问题的学名叫 “双极定向”，存一篇博客 浅谈双极定向及其应用 - zx2003 最后我们得出的结论是图必须联通，圆方树上的方点必须成一条链，询问的点不能是割点。 此外 \\(n=2\\) 的时候图不连通也是正确的，实在太细节了。让胖胖去写的，回头补完再贴代码。 G. Geometry 给两个不交的凸包 \\(A,B\\) ，每个凸包有个速度向量 \\(v\\) ，问两凸包碰撞的时间。 首先运动是相对的，所以可以固定凸包 \\(A\\) ，凸包 \\(B\\) 的速度向量变为 \\(v_B - v_A\\) 。 接下来就是套路题，同 [JSOI 2018] 战争，找一条射线与 \\(A+(-B)\\) 的交点，然后计算到交点的时刻即可。 因为只询问一次，所以枚举闵可夫斯基和上的每一条边直接和射线求交更新，其实可以优化到 \\(\\mathcal O(\\log n)\\) 查询。 因为数据范围有 \\(10^9\\) ，所以点积叉积的范围有 \\(10^{18}\\) ，直接判断交点是否在线段上可能会出一些问题。 一个判断阶段无精度误差的方法：分成端点在射线上、端点在射线两侧两种情况更新答案。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203#include&lt;bits/stdc++.h&gt;using namespace std;using ll = long long;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;#define rep(i, x, y) for (int i = (x); i &lt;= (y); ++i)#define per(i, x, y) for (int i = (x); i &gt;= (y); --i)inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;typedef double T;#define lett const T&amp;#define letp const P&amp; // P for point#define lets const S&amp; // S for segment#define letl const L&amp; // L for line#define letc const C&amp; // C for convex#define z(x) (abs((x)) &lt;= eps) // is zeroconst T eps = 1e-8;constexpr long double PI=3.1415926535897932384;struct P &#123; T x, y; P (T x = 0, T y = 0) : x(x), y(y) &#123;&#125; P operator + (letp p) const &#123;return &#123;x + p.x, y + p.y&#125;;&#125; P operator - (letp p) const &#123;return &#123;x - p.x, y - p.y&#125;;&#125; P operator * (lett d) const &#123;return &#123;x * d, y * d&#125;;&#125; P operator / (lett d) const &#123;return &#123;x / d, y / d&#125;;&#125; T operator | (letp p) const &#123;return x * p.x + y * p.y;&#125; // dot T operator ^ (letp p) const &#123;return x * p.y - y * p.x;&#125; // cross P rot(double ang) const &#123; // rotation (ang) angle, need T = double double cosa = cos(ang), sina = sin(ang); return &#123;x * cosa - y * sina, x * sina + y * cosa&#125;; &#125; bool operator == (letp p) const &#123;return z(x - p.x) &amp;&amp; z(y - p.y);&#125; bool operator != (letp p) const &#123;return ! operator == (p);&#125; bool operator &lt; (letp p) const &#123;return z(x - p.x) ? y &lt; p.y : x &lt; p.x;&#125; bool operator &gt; (letp p) const &#123;return !(*this &lt; p || *this == p);&#125; int ori(letp p) const &#123;T t = (*this) ^ p; return (t &gt; eps) - (t &lt; -eps);&#125; T norm() const &#123;return x * x + y * y;&#125; P proj (letp p) const &#123;return (*this) * (((*this) | p) / norm());&#125; P refl (letp p) const &#123;return proj(p) * 2 - p;&#125;&#125; zero;double abs(letp p) &#123;return sqrt(p.norm());&#125;P normalize(letp p) &#123;return p / abs(p);&#125;P perp(letp p) &#123;return &#123;-p.y, p.x&#125;;&#125; // turn pi / 2 leftP perpr(letp p) &#123;return &#123;p.y, -p.x&#125;;&#125; // turn pi / 2 rightbool orth(letp p, letp q) &#123;return (p | q) == 0;&#125;bool para(letp p, letp q) &#123;return (p ^ q) == 0;&#125;struct argcmp &#123; // compared by polar angle bool operator() (letp a, letp b) const &#123; const auto quad = [](letp a) &#123; if (a.y &lt; -eps) return 1; // halfplane with negative y if (a.y &gt; eps) return 4; // halfplane with positive y if (a.x &lt; -eps) return 5; // negative x-axis if (a.x &gt; eps) return 3; // positive x-axis return 2; // origin &#125;; const int qa = quad(a), qb = quad(b); if (qa != qb) return qa &lt; qb; const auto t = a ^ b; //in the same quad // sorted by length in increasing order when parallel // if (z(t)) return norm(a) &lt; norm(b) - eps; return t &gt; eps; &#125; &#125;;struct L &#123; P p, v; int ori (letp a) const &#123;return v.ori(a - p);&#125; P inter(letl l) const &#123;return p + v * ((l.v ^ (p - l.p)) / (v ^ l.v));&#125; &#125;;struct S &#123; P a, b; // on = -1 | out = 0 | in = 1 int is_on(letp p) const &#123; if (p == a || p == b) return -1; return (p - a).ori(p - b) == 0 &amp;&amp; ((p - a) | (p - b)) &lt; -eps; &#125; // cross on endpoints = -1 | not inter = 0 | inside = 1 int is_inter(lets s) const &#123; if (is_on(s.a) || is_on(s.b) || s.is_on(a) || s.is_on(b)) return -1; letl l&#123;a, b - a&#125;, ls&#123;s.a,s.b - s.a&#125;; return l.ori(s.a) * l.ori(s.b) == -1 &amp;&amp; ls.ori(a) * ls.ori(b) == -1; &#125;&#125;;struct Polygon &#123; vector&lt;P&gt; p; // counterclockwise Polygon(const vector&lt;P&gt; p = &#123;&#125;) : p(p) &#123;&#125; size_t nxt(const size_t i) const &#123;return i == p.size() - 1 ? 0 : i + 1;&#125; size_t pre(const size_t i) const &#123;return i == 0 ? p.size() - 1 : i - 1;&#125; &#125;;struct C : Polygon &#123; C (const vector&lt;P&gt; &amp;p = &#123;&#125;) : Polygon(p) &#123;&#125; C operator + (letc c) const &#123; const auto &amp;p = this -&gt; p; vector&lt;S&gt; e1(p.size()), e2(c.p.size()); vector&lt;S&gt; edge(p.size() + c.p.size()); vector&lt;P&gt; res; res.reserve(p.size() + c.p.size()); const auto cmp = [](lets u, lets v) &#123; return argcmp()(u.b - u.a, v.b - v.a); &#125;; for (size_t i = 0; i &lt; p.size(); ++i) e1[i] = &#123;p[i], p[this -&gt; nxt(i)]&#125;; for (size_t i = 0; i &lt; c.p.size(); ++i) e2[i] = &#123;c.p[i], c.p[c.nxt(i)]&#125;; rotate(e1.begin(), min_element(e1.begin(), e1.end(), cmp), e1.end()); rotate(e2.begin(), min_element(e2.begin(), e2.end(), cmp), e2.end()); merge(e1.begin(), e1.end(), e2.begin(), e2.end(), edge.begin(), cmp); const auto check = [](const vector&lt;P&gt; &amp;res, letp u) &#123; const auto b1 = res.back(), b2 = *prev(res.end(), 2); return (b1 - b2).ori(u - b1) == 0 &amp;&amp; ((b1 - b2) | (u - b1)) &gt;= -eps; &#125;; auto u = e1[0].a + e2[0].a; for (const auto &amp;v : edge) &#123; while (res.size() &gt; 1 &amp;&amp; check(res, u)) res.pop_back(); res.push_back(u); u = u + v.b - v.a; &#125; if (res.size() &gt; 1 &amp;&amp; check(res, res[0])) res.pop_back(); return &#123;res&#125;; &#125; // O(log n) : on = -1 | out = 0 | in = 1 int is_in(letp a) const &#123; const auto &amp;p = this -&gt; p; if (p.size() == 1) return a == p[0] ? -1 : 0; if (p.size() == 2) return S&#123;p[0], p[1]&#125;.is_on(a) ? -1 : 0; if (a == p[0]) return -1; if ((p[1] - p[0]).ori(a - p[0]) == -1) return 0; if ((p.back() - p[0]).ori(a - p[0]) == 1) return 0; const auto cmp = [&amp;](letp u, letp v) &#123;return (u - p[0]).ori(v - p[0]) == 1;&#125;; const size_t i = lower_bound(p.begin() + 1, p.end(), a, cmp) - p.begin(); if (i == 1) return S&#123;p[0], p[i]&#125;.is_on(a) ? -1 : 0; if (i == p.size() - 1 &amp;&amp; S&#123;p[0], p[i]&#125;.is_on(a)) return -1; if (S&#123;p[i - 1], p[i]&#125;.is_on(a)) return -1; return (p[i] - p[i-1]).ori(a - p[i - 1]) &gt; 0; &#125;&#125; c, c_;int main() &#123; int n = rd(); c.p.resize(n); for (int i = 0; i &lt; n; ++i) &#123; T x = rd(), y = rd(); c.p[i] = &#123;x, y&#125;; &#125; n = rd(); c_.p.resize(n); for (int i = 0; i &lt; n; ++i) &#123; T x = -rd(), y = -rd(); c_.p[i] = &#123;x, y&#125;; &#125; c = c + c_; P v; v.x = -rd(); v.y = -rd(); v.x += rd(); v.y += rd(); if (c.is_in(zero)) &#123;puts(&quot;0&quot;); return 0;&#125; if (v == zero) &#123;puts(&quot;-1&quot;); return 0;&#125; L l&#123;zero, v&#125;; double ans = 1e20; for (size_t i = 0; i &lt; c.p.size(); ++i) &#123; const P a = c.p[i], b = c.p[c.nxt(i)]; const int oa = v.ori(a), ob = v.ori(b); if (oa == 0 &amp;&amp; (a | v) &gt; eps) ans = min(ans, abs(a) / abs(v)); if (ob == 0 &amp;&amp; (b | v) &gt; eps) ans = min(ans, abs(b) / abs(v)); if (oa != 0 &amp;&amp; ob != 0 &amp;&amp; oa != ob) &#123; P p = l.inter(L&#123;a, b - a&#125;); if ((p | v) &gt; eps) ans = min(ans, abs(p) / abs(v)); &#125; &#125; if (ans &lt; 1e20) printf(&quot;%.10lf\\n&quot;, ans); else puts(&quot;-1&quot;); return 0;&#125; J. Journey 有 \\(n\\) 个四通路口连接若干条双向道路（视为两条），每次到路口右转无代价，其他方向代价都是 \\(1\\) 。 问从 \\(s_1\\) 到 \\(s_2\\) 的路出发，到 \\(t_1\\) 到 \\(t_2\\) 的路的最小代价。 以每条路（单向）为点建图，01-BFS 即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 2000007unordered_map&lt;ll, int&gt; f;inline ll ha(int u, int v) &#123;return 1ll * u * 1e9 + v;&#125;int tot, dis[N];vector&lt;int&gt; e0[N], e1[N];bool vis[N];deque&lt;int&gt; q;void bfs(int s) &#123; memset(dis, 0x3f, sizeof(dis)); dis[s] = 0; q.push_back(s); while (!q.empty()) &#123; int u = q.front(); q.pop_front(); if (vis[u]) continue; vis[u] = 1; for (auto v : e0[u]) if (dis[v] &gt; dis[u]) &#123; dis[v] = dis[u]; q.push_front(v); &#125; for (auto v : e1[u]) if (dis[v] &gt; dis[u] + 1) &#123; dis[v] = dis[u] + 1; q.push_back(v); &#125; &#125; &#125;int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; int c[4]; for (int j = 0; j &lt; 4; ++j) &#123; c[j] = rd(); if (!c[j]) continue; if (!f[ha(i, c[j])]) f[ha(i, c[j])] = ++tot; if (!f[ha(c[j], i)]) f[ha(c[j], i)] = ++tot; &#125; for (int j = 0; j &lt; 4; ++j) if (c[j]) &#123; if (c[(j + 1) % 4]) e0[f[ha(c[j], i)]].push_back(f[ha(i, c[(j + 1) % 4])]); for (int w = 2; w &lt;= 4; ++w) &#123; int t = (j + w) % 4; if (c[t]) e1[f[ha(c[j], i)]].push_back(f[ha(i, c[t])]); &#125; &#125; &#125; int x = rd(), y = rd(); if (!f[ha(x, y)]) f[ha(x, y)] = ++tot; int u = f[ha(x, y)]; x = rd(), y = rd(); if (!f[ha(x, y)]) f[ha(x, y)] = ++tot; int v = f[ha(x, y)]; bfs(u); printf(&quot;%d\\n&quot;, dis[v] &gt;= 1e9 ? -1 : dis[v]); return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"http://blog.gyx.me/categories/Solution/"},{"name":"Nowcoder","slug":"Solution/Nowcoder","permalink":"http://blog.gyx.me/categories/Solution/Nowcoder/"}],"tags":[{"name":"01-BFS","slug":"01-BFS","permalink":"http://blog.gyx.me/tags/01-BFS/"},{"name":"Flows","slug":"Flows","permalink":"http://blog.gyx.me/tags/Flows/"},{"name":"Minkowski Sum","slug":"Minkowski-Sum","permalink":"http://blog.gyx.me/tags/Minkowski-Sum/"},{"name":"Connectivity","slug":"Connectivity","permalink":"http://blog.gyx.me/tags/Connectivity/"}]},{"title":"AtCoder Beginner Contest 259","slug":"Atcoder/abc259","date":"2022-07-13T13:58:14.000Z","updated":"2022-08-31T02:32:30.990Z","comments":true,"path":"2022/07/13/Atcoder/abc259/","link":"","permalink":"http://blog.gyx.me/2022/07/13/Atcoder/abc259/","excerpt":"","text":"A - Growth Record 主人公 \\(N\\) 岁的时候身高是 \\(T\\) , 已知他 \\([1,X]\\) 期间每年长 \\(D\\) ，后面不长个子，问 \\(M\\) 岁的时候身高多少 \\(0\\) 岁的身高是 \\(T−X\\times D\\) ，然后分情况讨论。 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;int main() &#123; int n = rd(), m = rd(), x = rd(), t = rd(), d = rd(); int st = t - x * d; if (m &gt; x) printf(&quot;%d\\n&quot;, t); else printf(&quot;%d\\n&quot;, st + m * d); return 0;&#125; B - Counterclockwise Rotation 给定坐标 \\((x,y)\\) 问绕原点逆时针旋转 \\(d\\) 角度后的坐标。 坐标为 \\(x^{\\prime}=x * \\cos d-y * \\sin d, y^{\\prime}=x * \\sin d+y * \\cos d\\)，可以用各种方法(诱导公式/旋转矩阵)推。 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;using ld = long double;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;const ld PI = 3.1415926535;struct vec &#123; ld x, y; vec turn (ld ang) &#123; // 逆时针旋转 ang 角度 ld cosa = cos(ang), sina = sin(ang); return (vec)&#123;x * cosa - y * sina, x * sina + y * cosa&#125;; &#125;&#125;;int main() &#123; vec a; a.x = rd(); a.y = rd(); ld d = rd() / 180.0 * PI; a = a.turn(d); printf(&quot;%.10Lf %.10Lf\\n&quot;, a.x, a.y); return 0;&#125; C - XX to XXX 给定两个串 \\(S\\) 和 \\(T\\), 每次可以向 \\(S\\) 中相邻且相同的两个字符中间塞一个相同的字符。问若干次操作后 \\(S\\) 是否能变成 \\(T\\) 。 考虑双指针 \\(\\left(p t r_s, p t r_t\\right)\\), 从头对齐往后扫描，每次先不考虑扩张, 能不能匹配上。 如果不能匹配上，即 \\(S\\left[p t r_s\\right] \\neq T\\left[p t r_t\\right]\\), 那么 \\(T\\left[p t r_t\\right]\\) 只能往回看，尝试用 \\(S\\left[p t r_s-1\\right]\\) 和 \\(S\\left[p t r_s-2\\right]\\) 来扩张, 否则无解。 记得最后要判断一下两个串的指针是否都走到了结尾。 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;#define N 200007char s[N], t[N];int main() &#123; scanf(&quot;%s&quot;, s + 1); scanf(&quot;%s&quot;, t + 1); int n = strlen(s + 1); int m = strlen(t + 1); int ptr = 1; for (int i = 1; i &lt;= m; ++i) &#123; if (s[ptr] == t[i]) &#123;++ptr; continue;&#125; if (s[ptr - 1] != t[i]) &#123;puts(&quot;No&quot;); return 0;&#125; if (ptr &lt;= 1 || s[ptr - 1] != s[ptr - 2]) &#123; puts(&quot;No&quot;); return 0; &#125; &#125; puts(ptr == n + 1 ? &quot;Yes&quot; : &quot;No&quot;); return 0;&#125; D - Circumferences 给定二维平面上的 \\(n\\) 个圆, 以及某个圆上的起点和某个圆上的终点。 只能走圆的边界 (可以通 过两圆交点更换所在的圆），问能否从起点走到终点? 并查集判连通性, 数据范围只需要 \\(n^2\\) 暴力枚举判断是否有交点即可。 判断两圆有交点：不相离也不包含。 相离：圆心距大于两圆半径之和。 包含：圆心距小于两圆半径之差的绝对值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 3007ll x[N], y[N], r[N];int f[N];int find(int x) &#123; return x == f[x] ? x : (f[x] = find(f[x]));&#125;inline ll sqr(ll x) &#123;return x * x;&#125;int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) f[i] = i; int sx = rd(), sy = rd(); int tx = rd(), ty = rd(); for (int i = 1; i &lt;= n; ++i) &#123; x[i] = rd(); y[i] = rd(); r[i] = rd(); &#125; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) &#123; if (sqr(x[i] - x[j]) + sqr(y[i] - y[j]) &gt; sqr(r[i] + r[j])) continue; if (sqr(x[i] - x[j]) + sqr(y[i] - y[j]) &lt; sqr(r[i] - r[j])) continue; int u = find(i), v = find(j); f[u] = v; &#125; int px, py; for (int i = 1; i &lt;= n; ++i) &#123; if (sqr(sx - x[i]) + sqr(sy - y[i]) == sqr(r[i])) px = i; if (sqr(tx - x[i]) + sqr(ty - y[i]) == sqr(r[i])) py = i; &#125; puts(find(px) == find(py) ? &quot;Yes&quot; : &quot;No&quot;); return 0;&#125; E - LCM on Whiteboard 给定 \\(n\\) 个数字的标准分解, 将其中的某一个变成 \\(1\\) , 问操作后所有数字的最小公倍数有多少种不同的可能性? 结论是所有数字的最小公倍数等于 每个质因数的指数 取 所有数字对应质因数指数的 \\(\\max\\)。 一个数字变成 \\(1\\) 相当于对于 LCM 什么都不提供, 那么什么时候会导致 LCM 变化呢? 首先他的某一个质因数指数要和 LCM 对应的相同, 其次这个最大值在所有数字中是唯一的。 两个 unordered_map 实现： mx[i] 记录质因数 \\(i\\) 出现过的最大指数是多少, cnt[i] 记录有多少个数字对应这个最大指数。 那么一个数字有贡献也就对应于 e[i]==mx[i] &amp;&amp; cnt[i]==1 。 此外没有影响的所有数字总体会对答案产生一个贡献, 即原本所有数的 LCM 。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;using ld = long double;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 200007#define fr first#define sc second#define pb push_back#define mp make_pair#define pii pair&lt;int, int&gt;unordered_map&lt;int, int&gt; mx, cnt;vector&lt;pii&gt; s[N];int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; int m = rd(); for (int j = 1; j &lt;= m; ++j) &#123; int a = rd(), b = rd(); s[i].pb(mp(a, b)); if (mx[a] &lt; b) &#123;mx[a] = b; cnt[a] = 1;&#125; else if (mx[a] == b) ++cnt[a]; &#125; &#125; bool fl = 0; int ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; bool tag = 0; for (auto [a, b] : s[i]) &#123; if (mx[a] == b &amp;&amp; cnt[a] == 1) &#123;tag = 1; break;&#125; &#125; if (tag) ++ans; else fl = 1; &#125; ans += fl; printf(&quot;%d\\n&quot;, ans); return 0;&#125; F - Select Edges 给定一棵树, 每条边有一个边权 \\(w\\), 每个点有一个限制 \\(d_i\\) 。 选一个边集, 使得每个点相邻的边在这个集合里的个数不超过 \\(d_i\\), 并且最大化集合里边的 \\(\\sum w\\) 。 设 \\(f[i][0 / 1]\\) 表示节点 \\(i\\) 及其子树内, 是否要选 \\(i\\) 到父亲的边 \\((0/1)\\) ， 能得到的最大价值。 不选到父亲的边: 就是最多把 \\(d_i\\) 个儿子的贡献从 \\(f [son] [0]\\) 改为 \\(f[s o n] [1] +w[u][son]\\) ，挑能贡献最多的选（修改后较修改前差值最大的 \\(d_i\\) 个) 选到父亲的边： 就是最多把 \\(d_i-1\\) 个儿子的贡献从 \\(f [son] [0]\\) 改为 \\(f[s o n] [1] +w[u][son]\\) ; 特殊的如果 \\(d_i=0\\) 则 \\(f[i][1]=-\\mathrm{inf}\\) 直接 DP 就好了, 复杂度是 \\(O(n \\log n)\\) 的（因为涉及到儿子贡献的排序）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;using ld = long double;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 300007#define fr first#define sc second#define pb push_back#define mp make_pair#define pii pair&lt;int, int&gt;vector&lt;pii&gt; e[N];vector&lt;ll&gt; tmp;int d[N];ll f[N][2];void dfs(int u, int fa) &#123; ll sum = 0; for (auto [v, w] : e[u]) if (v != fa) dfs(v, u); tmp.clear(); for (auto [v, w] : e[u]) if (v != fa) &#123; sum += f[v][0]; tmp.push_back(f[v][1] + w - f[v][0]); &#125; sort(tmp.begin(), tmp.end()); reverse(tmp.begin(), tmp.end()); if (d[u] == 0) &#123; f[u][0] = sum; f[u][1] = -1e18; &#125; else &#123; f[u][0] = f[u][1] = sum; int len = tmp.size(); for (int i = 0; i &lt; len; ++i) &#123; if (tmp[i] &lt; 0) break; if (i &lt; d[u]) f[u][0] += tmp[i]; if (i &lt; d[u] - 1) f[u][1] += tmp[i]; &#125; &#125;&#125;int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) d[i] = rd(); for (int i = 1; i &lt; n; ++i) &#123; int u = rd(), v = rd(), w = max(0, rd()); e[u].pb(mp(v, w)); e[v].pb(mp(u, w)); &#125; dfs(1, 1); printf(&quot;%lld\\n&quot;, max(f[1][0], f[1][1])); return 0;&#125; Ex - Yet Another Path Counting 给定一个矩阵 \\(A_{n \\times n}(1 \\leq n \\leq 400)\\), 从某个格子出发, 每次可以向右或向下走。问起点终点的数字相同的路径有多少条? 首先枚举数字是多少，然后考虑计算这个数字对应的所有点之间的贡献。根据每种数字出现次数讨论: 如果出现次数不超过 \\(n\\), 那么直接暴力枚举任意两个位置算贡献, 答案是 \\(\\left(\\begin{array}{c}\\Delta x+\\Delta y \\\\ \\Delta x\\end{array}\\right)\\) 。 复杂度是 \\(O\\left(\\sum_{\\sum c n t_i=n^2, c n t_i \\leq n} c n t_i^2\\right) \\leq O\\left(n \\times n^2\\right)=O\\left(n^3\\right)\\) ，用 \\(a^2+b^2 \\leq(a+b)^2\\) 放缩一下。 如果出现次数超过 \\(n\\), 那么种类数不会超过 \\(n\\) 个, 对每种颜色跑一个 \\(O\\left(n^2\\right)\\) 的 DP： 这个 DP 和 AGC001E 的方法是一样的，设 f[i][j] 表示所有可能的起点走到 \\((i,j)\\) 的总方案数。 f[i][j] = f[i - 1][j] + f[i][j - 1] ，此外如果这个点是我们要的颜色还要 f[i][j]++ 。 因此总复杂度也是 \\(O(n^3)\\) 的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;using ld = long double;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 1007#define NN 407#define M 160007#define mod 998244353#define pb push_back#define mp make_pair#define pii pair&lt;int, int&gt;int n, c[N][N], a[NN][NN], f[NN][NN], ans;vector&lt;pii&gt; pos[M];inline void calc(int col) &#123; memset(f, 0, sizeof(f)); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) &#123; f[i][j] = (f[i - 1][j] + f[i][j - 1]) % mod; if (a[i][j] == col) &#123; f[i][j] = (f[i][j] + 1) % mod; ans = (ans + f[i][j]) % mod; &#125; &#125;&#125;int main() &#123; c[0][0] = 1; for (int i = 1; i &lt; N; ++i) &#123; c[i][0] = 1; for (int j = 1; j &lt;= i; ++j) c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % mod; &#125; n = rd(); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) &#123; a[i][j] = rd(); pos[a[i][j]].push_back(mp(i, j)); &#125; for (int i = n * n; i; --i) &#123; if (pos[i].size() &gt; n) calc(i); else &#123; int sz = pos[i].size(); for (int j = 0; j &lt; sz; ++j) for (int k = 0; k &lt; sz; ++k) &#123; auto [sx, sy] = pos[i][j]; auto [tx, ty] = pos[i][k]; if (tx &lt; sx || ty &lt; sy) continue; ans = (ans + c[tx - sx + ty - sy][tx - sx]) % mod; &#125; &#125; &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"http://blog.gyx.me/categories/Solution/"},{"name":"AtCoder","slug":"Solution/AtCoder","permalink":"http://blog.gyx.me/categories/Solution/AtCoder/"},{"name":"AtCoder Beginner Contest","slug":"Solution/AtCoder/AtCoder-Beginner-Contest","permalink":"http://blog.gyx.me/categories/Solution/AtCoder/AtCoder-Beginner-Contest/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"},{"name":"Counting","slug":"Counting","permalink":"http://blog.gyx.me/tags/Counting/"},{"name":"Threshold Optimization","slug":"Threshold-Optimization","permalink":"http://blog.gyx.me/tags/Threshold-Optimization/"},{"name":"Number Theory","slug":"Number-Theory","permalink":"http://blog.gyx.me/tags/Number-Theory/"}]},{"title":"Sophomore Year","slug":"sophomore","date":"2022-07-05T14:14:43.000Z","updated":"2022-07-31T16:32:46.432Z","comments":true,"path":"2022/07/05/sophomore/","link":"","permalink":"http://blog.gyx.me/2022/07/05/sophomore/","excerpt":"","text":"今天是 2021 年 7 月 6 日，星期三。 两年前的今天，高考的前夜。担心感冒不敢开空调，燥热地躺在床上，辗转反侧。 碰巧昨晚又梦到了还在高中，困扰在时时刻刻的恐惧中，惊醒后久久才反应过来，已经上了两年大学了。 正好今天 22 级班助的聘用正式确定下来了，大二的生活算是尘埃落定，回顾一下这一年。 算法竞赛 首先谈竞赛，这一年算是经历了很多事情，打了一年的银，但是对竞赛的感情经历了很多变化。 大概从去年 7 月份的沈阳银首开始，自己进入了一个目标很不明确的时期。 暑假多校打的一般，除此外也没有进行太多的训练。队内排名基本稳定在第三名的位置（和前后都有一定距离）。 温水煮青蛙，没有紧张感，也没有什么太具体的目标。就这样浑浑噩噩的打了网络赛、CCPC 桂林银、ICPC 沈阳银。 寒假安排的很紧，除了算法竞赛还插了数模美赛集训、DL &amp; CV 的假期交流课程、兼职教小孩 C 语言。 但就最后的结果来看，寒假可以说碌碌无为。美赛拿了 S 奖，线上交流没学到太多，竞赛的刷题量只能说保持水平。 如何评价 2022 年 ICPC 昆明赛区？ 开学之后为了备战省赛和昆明，训练量加了不少，也是有点魔怔的一段时间。 3 月某天看到了一个人的 CodeForces 满屏绿色，有点受刺激，于是自己也离谱地连续打卡了近 50 天。 期间课几乎都没听，作业都尽量用最短的时间解决掉了，计组实验也和冯老师说全部都堆到比赛后验收。 于是到了浙江省赛和昆明。因为疫情各种延期，两个比赛在同一个周末的两天举办。 省赛打的很顺利，前两个小时几次榜一，最后因为做不动期望题 E 拿了第四，不过也算是不错的成绩。 昆明打之前觉得一切准备的都还不错，甚至还有 Eva 在做志愿者，应该会很踏实。 然而正赛开始之后就傻眼了。首先是大量的期望概率题目，签到想不出来；接下来比赛节奏完全没体验过，1h 过了一题，然后一直持续到 4h 才有过题。期间一直让自己冷静下来，安慰自己把有想法的题都过了就没问题，但是心里一直很慌。直到最后真的三题结束了，自己还没有反应过来发生了什么。 印象很深的是 Eva 走过来坐在我旁边，哭了出来，我问她为什么哭，她说真的替我很伤心。 反应过来之后，想想自己花了大半个学期训练，课程都快结束了，什么都没开始学；竞赛也没拿到想要的奖项，甚至差两名就要打铜；正逢当天是 2022 的多省联合省选。一切都让我回忆起了当年省选退役时那段黑暗的日子，无力挣扎，也很想哭。 当晚自然是又做了噩梦，时间线十分的混乱，又是刚退役回去学文化课，又是赛场上自己一个又一个错误的决定。 仿佛自己又要面对竞赛打的不好就会退役，退役就要回去面对那段整日担惊受怕、生活在高压和恐惧中的文化课生活。 昆明之后经历的生活也确实像高中退役后补欠下的债，上课听不懂，作业不会做，计算机组成原理四五个大实验一点还没开始写（甚至是还没学会）。最噩梦的是期末季也开始了，在大家都开始复习的时候，自己从头开始。 之后五月的某天，因为要宣传这个赛季的结果，集训队开了一次会，然后拍集体照。 开会的时候，刘老师谈到了暑假组队的事情：“原则上自由组队，大家敞开说，原有的队伍也可以重组，不要拿队伍磨合的好说事情，留给磨合的时间有很多。” 听完我突然有了重组的想法，虽然昆明爆炸的主要原因是我决策失误，但是这个赛季的队伍确实也有明显的问题。 之后也有两个比较巧合的事情让我真的开始思考这件事情。一个是在高级数据结构课上，刘老师突然问我，我们队要不要重组。另一个是恰好有一个实力比较强的队伍会拆散，其中一个队员的长处我认为比较互补。 但是提出换队友这个事情确实比较尴尬，首先打了一年银并不是某一个人的问题，其次确实这只是我自己的想法。自己根本不知道该如何开口商量这个事情，如果真的换了，我也不知道应该怎么面对被换出去的队友。 经历了很长一段的权衡后，我终于还是和刘老师商量了这个事情。第二天刘老师给我的答复是：如果所有人都同意，他可以同意。那天纠结了很久，最后一口气和相关的所有人都聊完了。中间聊天的过程真的很害怕，自己不知道怎么开口，也不好意思开口。但好在最后所有人都同意了，更换的队友也和另外两个很强的选手重新组了队伍。 真的很感谢涉及到这个艰难的过程的所有人，大家都因为我的选择或多或少受到了一些影响，尤其是被换出去的队友。到现在我还是很内疚，真的很感谢他能理解我的想法。 接下来的比赛只剩下了校赛，第 26 次 CSP 和蓝桥杯的国赛。这段时间几乎都在做期末大作业，偶尔做几道题保持水平。 但意外的是这几场比赛打的都还可以，杭电校赛靠手速拿到了一等奖，CSP - 26 靠卡常 AK 了。如何评价 CSP - 26 此外 5 月底的时候刘老师找到我，让我作为负责人组织一下今年广西省赛的出题，兴奋又有点紧张。 于是在期末前的几个星期，拉了出题团队，大家一起挤时间出题造题，还在考试周期间拉了几个集训队员验题。 期末最后一门考完当晚开始赶工题目的最后一部分，配置spj 到了半夜两点多，第二天早上修 pdf 版题面又发现了好多语法错误，改完反复读了好几遍之后终于在 ddl 前整理好了。 好在最后两天的比赛都很圆满，第一次做正式比赛的负责人，感觉收获很多（ 至少学会了用 PTA 和 Polygon ）。 把 Colin 和 Eva 的名字留在一场正式赛的题面里，以及给好多人讲题都是曾经的梦想啊。如何评价第五届GXCPC 总而言之，这一年的竞赛经历虽然比较曲折，但也确实让我认真地思考了自己到底想要什么。 下一个赛季大概率是最后一年参赛了，希望自己在想要摆烂的时候能从这一年的经历中汲取动力，加油。 课内学习 单从成绩上来看，和大一相比可能课程难度降低了，所以成绩比大一要好一些。 大二上意外地打出了历史最高绩点；大二下某门学分很重的课因为某些原因爆炸了，绩点没稳住，不过也过去了。 成绩撇开不谈，记录几门我觉得很收获很多或值得推荐的课程和老师，仅供参考。 形式语言与自动机（黄孝喜老师）：收获主要是此前对这个领域了解很少，上完能比较充分的了解到这个领域的一些基础模型，学编译的时候也能轻松些。课程中涉及到很多非常好玩的小算法，其中的构造思路也是比较有意义的。我最后期末考前还在沉迷构造图灵机无法自拔（虽然非常遗憾期末不考） 数字电路/计算机组成原理（冯建文老师）：作为一个对硬件十分反感的人来说真的很感谢冯老师硬逼着我把偏硬的这两门课学完了。作业和实验的任务量都比较大，但是冯老师真的非常负责，有什么问题基本都会不厌其烦的回答完。对我而言主要收获是学到了一个计算机系的学生应该知道的硬件相关内容。 概率论与数理统计（张安老师）：老师人超好，授课很清晰，要求很明确，作业量不大，治好了我的积分恐惧症。 密码学（胡耿然老师）：比较全面的介绍密码学的基础内容，上课也很轻松，对数论有一些要求（快速幂和逆元）。 影视音乐鉴赏（徐艳老师）：上课主要是看电影，很适合在繁忙的课程安排中放松一下。需要做的事情非常非常少，只要做完要求的事情就可以放心拿很好很好的成绩（不能再明说了，懂得都懂吧） 电子钢琴（盛晨老师）：这个课偏钢琴普及向，课程考核也主要根据每个人的基础决定，期末考试就是一首自选曲目。因为我和 Eva 都有一些底子，所以上课基本就是两个人弹想弹的曲子，一个学期弹了很多四手联弹非常开心，期末也选择了四手联弹的方式，选的《摇篮曲》。推荐的原因主要是很难有其他方式可以如此方便的摸到键盘，所以比较感兴趣的同学推荐试一试，没坑，但是如果在意成绩的话最好还是有一点钢琴基础。 体育舞蹈（董晓波老师）：每周都能和 Eva 去跳一次舞非常开心！上课比较轻松，老师教的很好，运动量即使是我也能撑得住，成绩对我来说也非常满意了。此外貌似有几组同学经过一个学期真的成了情侣，有需求的同学可以去试试桃花运（ 未来 大二这一年一直在考虑未来的发展，如果决定进企业的话，对我而言其实本科毕业直接上班可能比读研更有效。 借助一些契机和尝试，也让我明白自己还是有热爱的，所以决定试一试，本科毕业之后继续读书，先不去工作啦。 关于方向，还是决定离开机器学习这个领域了，非常感谢导师能够理解和支持我的想法。 毕竟还年轻，还有试错的机会，此时能比较轻松地放下对失败的顾虑，去追求自己的学术理想何尝不是一件大幸事。 我们 我们的爱情在这一年里有很多很感动的时刻，也有很多次吵架走到低谷。 时间长了不像刚开始谈恋爱那样激烈，但是日常平静生活中的一次次相互扶持，润物无声。 关于爱情，还是没有什么太多可以讲出来的，所以分享几个这一年中我觉得值得纪念的事情吧： 一起选修了电子钢琴，期末考核曲目选择了四手联弹《摇篮曲》 我通过大二上的体测，大二下一起选修了体育舞蹈，作为舞伴一起上课和考试 印象很深的是大二上体测的最后一项一千米，Eva 最后两圈全程陪我跑完，按照商量好的方案每 10 秒给我报一次时间。 最后的一段冲刺真的没有力气了，完全盯着终点线的 Eva 在跑。最后体测分数正好 60 分，0.1 都没多。 大二两次期末的突击复习，能一起承受住期末的压力，比较平稳的度过。 其实主要是帮我复习，因为有的课我考试前一天还啥都不会， Eva 经常因为压力太大会哭出来。 复习期间压力很大的环境下很容易发生争吵，真的很感动我们能一起挺过来那段时间，生气也能快速调整情绪。 教 Eva 学算法， Eva 能进杭电女队，参加下一个赛季的女生赛（Eva 进队的时候我真的很激动）。 一起去当下一届英才班的班助（大一刚谈恋爱的时候就聊起来过这个事情，发现我们都挺喜欢带学弟学妹的）。 最后很想分享一句话，在两个人的感情遇到问题的时候，我觉得这是一个很好的衡量自己做的是否正确的标准。","categories":[{"name":"Life","slug":"Life","permalink":"http://blog.gyx.me/categories/Life/"}],"tags":[]},{"title":"AtCoder Regular Contest 061","slug":"Atcoder/ARC061","date":"2022-07-01T09:20:14.000Z","updated":"2022-07-01T11:21:28.584Z","comments":true,"path":"2022/07/01/Atcoder/ARC061/","link":"","permalink":"http://blog.gyx.me/2022/07/01/Atcoder/ARC061/","excerpt":"","text":"C - Many Formulas 给定一个数字串，可以在任意位置添加加号，问所有表达式结果的和是多少。 考虑一个前缀后面补一个新的数字： + 如果断开，那么前缀的贡献是前面的结果 + 如果不断开，那么前缀的贡献是前面除去最后一段 + 最后一段 \\(\\times 10\\) + 最后一个数字的贡献就是数值 \\(\\times 2^{len}\\) ，即可能的划分方案数 记 \\(f_i\\) 表示前缀 \\(i\\) 的答案，\\(g_i\\) 表示前缀 \\(i\\) 最后一段的答案，有： \\[ \\begin{array}{l} f_i &amp;= 2^i * digit_i + f_{i-1} + (f_{i-1} - g_{i-1}) + g_{i-1} \\times 10\\\\ g_i &amp;= 2^i * digit_i + g_{i-1} \\times 10 \\end{array} \\] 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt; using namespace std; using ll = long long; inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x; &#125; char s[11]; ll f[11], g[11]; int main() &#123; scanf(&quot;%s&quot;, s + 1); int len = strlen(s + 1); for (int i = 1, pw = 1; i &lt;= len; ++i, pw = pw * 2) &#123; f[i] = pw * (s[i] - &#x27;0&#x27;) + f[i - 1] * 2 + g[i - 1] * 9; g[i] = pw * (s[i] - &#x27;0&#x27;) + g[i - 1] * 10; &#125; printf(&quot;%lld\\n&quot;, f[len]); return 0; &#125; D - Snuke's Coloring 给定一个 \\(H\\times W\\) 的网格，初始所有位置都是白色，然后给定 \\(n\\) 个点染成黑色。 问所有的九宫格里，黑色点数为 \\(0\\dots 9\\) 的九宫格分别有多少个。 初始所有的九宫格都是白色，然后每次加入一个点模拟一下即可。 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt; using namespace std; using ll = long long; inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x; &#125; unordered_map&lt;ll, bool&gt; vis; inline ll pos(int x, int y) &#123;return 1ll * x * 1000000000 + y;&#125; ll ans[10]; int main() &#123; int h = rd(), w = rd(); ans[0] = 1ll * (h - 2) * (w - 2); for (int n = rd(); n; --n) &#123; int x = rd(), y = rd(); for (int a = max(1, x - 2); a &lt;= min(x, h - 2); ++a) for (int b = max(1, y - 2); b &lt;= min(y, w - 2); ++b) &#123; int cnt = 0; for (int dx = 0; dx &lt; 3; ++dx) for (int dy = 0; dy &lt; 3; ++dy) cnt += vis[pos(a + dx, b + dy)]; --ans[cnt]; ++ans[cnt + 1]; &#125; vis[pos(x, y)] = 1; &#125; for (int i = 0; i &lt; 10; ++i) printf(&quot;%lld\\n&quot;, ans[i]); return 0; &#125; E - Snuke's Subway Trip \\(n\\) 个点 \\(m\\) 条边的无向图，每个边有一个颜色。 一个路径的初始代价是 \\(1\\) ，每换一次颜色代价 \\(+1\\) ，求 \\(1\\) 到 \\(n\\) 的最短路。 考虑直接建分层图（每个点的实点建立 \\(m\\) 个虚点，虚点间连原图的边）。 真实的点向对应的虚点连边权为 \\(1\\) ，虚点之间连原图的边边权为 \\(0\\) ，最终答案除 \\(2\\) 即可。 可以发现有用的点其实只有 \\(\\mathcal{O}(n+m)\\) ，因此可以直接建图做（用一个 unordered_map ）。 然后在图上跑 01-BFS 即可，复杂度 \\(\\mathcal{O}(n+m)\\) 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt; using namespace std; using ll = long long; inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x; &#125; #define N 500007 #define M 2000007 unordered_map&lt;int, int&gt; id[N]; int tot, hd[N]; struct node&#123;int to, nxt; bool w;&#125; e[M]; inline void add(int u, int v, bool w) &#123; e[++tot].to = v; e[tot].w = w; e[tot].nxt = hd[u]; hd[u] = tot; e[++tot].to = u; e[tot].w = w; e[tot].nxt = hd[v]; hd[v] = tot; &#125; int dis[N]; bool vis[N]; deque&lt;int&gt; q; int main() &#123; int n = rd(), m = rd(); int totn = n; for (int i = 1; i &lt;= m; ++i) &#123; int u = rd(), v = rd(), c = rd(); if (!id[u][c]) &#123;id[u][c] = ++totn; add(u, totn, 1);&#125; if (!id[v][c]) &#123;id[v][c] = ++totn; add(v, totn, 1);&#125; add(id[u][c], id[v][c], 0); &#125; memset(dis, 0x3f, sizeof(dis)); dis[1] = 0; q.push_back(1); while (!q.empty()) &#123; int u = q.front(); q.pop_front(); if (vis[u]) continue; vis[u] = 1; for (int i = hd[u], v; i; i = e[i].nxt) &#123; if (dis[u] + e[i].w &lt; dis[v = e[i].to]) &#123; dis[v] = dis[u] + e[i].w; e[i].w ? q.push_back(v) : q.push_front(v); &#125; &#125; &#125; printf(&quot;%d\\n&quot;, dis[n] == dis[0] ? -1 : dis[n] / 2); return 0; &#125; F - Card Game for Three 三个人 A,B,C ，每个人分别有 \\(n,m,k\\) 张卡，每张卡的卡面都可能是 A/B/C 之一。 从 A 开始翻牌，每次翻到的牌子上写的是谁，下一个翻牌的就是谁。 轮到某个人时，如果他没有牌了就胜利，问总共 \\(3^{n+m+k}\\) 种方案中，A 胜利的方案数有多少。 这道题目的出发点完全想错了，不能将三个人分开想，因为有可能会有 A - B - C - A 循环。 考虑将整个操作序列连起来（长度 \\(n+m+k\\) ），每个操作序列一定对应于一种牌序。 那么也就是要求：某个前缀有 \\(n\\) 个 A ，且这段前缀内 B, C 的数量对应不超过 \\(m,k\\) 。 前一个条件避免数重，强制最后一个是 A 即可。 后一个条件考虑容斥做，由于长度限制容易发现两个反例只会出现一个： \\[ \\begin{array}{l} ans &amp;= \\displaystyle \\sum_{len=n}^{n+m+k} {len - 1\\choose n - 1}\\bigg({2^{len - n} - \\sum_{a = m+1}^{len - n}{len - n\\choose a}-\\sum_{b=k+1}^{len - n}{len - n\\choose b}}\\bigg)3^{n+m+k-len} \\end{array} \\] 设 \\(f_x=\\sum_{i=m}^x{x\\choose i}\\) ，然后用组合数定义优化这个东西： \\[ f_x = \\sum_{i=m}^x{x\\choose i} = \\sum_{i=m}^x \\bigg({x-1\\choose i}+{x-1\\choose i - 1}\\bigg) = 2f_{x-1} + {x - 1\\choose m - 1} \\] 就变成 \\(\\mathcal{O}(n+m+k)\\) 的了。。。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt; using namespace std; using ll = long long; inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x; &#125; #define N 1000007 #define mod 1000000007 namespace Comb &#123; int fac[N], ifac[N]; inline int fpow(int x, int t) &#123; int res = 1; for (; t; t &gt;&gt;= 1, x = 1ll * x * x % mod) if (t &amp; 1) res = 1ll * res * x % mod; return res; &#125; inline void init() &#123; fac[0] = ifac[0] = 1; for (int i = 1; i &lt; N; ++i) fac[i] = 1ll * fac[i - 1] * i % mod; ifac[N - 1] = fpow(fac[N - 1], mod - 2); for (int i = N - 2; i; --i) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % mod; &#125; inline ll C(int n, int m) &#123; if (n &lt; m) return 0; return 1ll * fac[n] * ifac[m] % mod * ifac[n - m] % mod; &#125; &#125; using namespace Comb; ll pw2[N] = &#123;1&#125;, pw3[N] = &#123;1&#125;, f1[N], f2[N]; int main() &#123; init(); ll ans = 0; int n = rd(), m = rd(), k = rd(); for (int i = 1; i &lt; N; ++i) &#123; pw2[i] = (pw2[i - 1] &lt;&lt; 1) % mod; pw3[i] = pw3[i - 1] * 3 % mod; f1[i] = (2 * f1[i - 1] + C(i - 1, m)) % mod; f2[i] = (2 * f2[i - 1] + C(i - 1, k)) % mod; &#125; for (int l = n; l &lt;= n + m + k; ++l) &#123; ll w = ((pw2[l - n] - f1[l - n] - f2[l - n]) % mod + mod) % mod; ans = (ans + C(l - 1, n - 1) * w % mod * pw3[n + m + k - l]) % mod; &#125; printf(&quot;%lld\\n&quot;, ans); return 0; &#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"http://blog.gyx.me/categories/Solution/"},{"name":"AtCoder","slug":"Solution/AtCoder","permalink":"http://blog.gyx.me/categories/Solution/AtCoder/"},{"name":"AtCoder Regular Contest","slug":"Solution/AtCoder/AtCoder-Regular-Contest","permalink":"http://blog.gyx.me/categories/Solution/AtCoder/AtCoder-Regular-Contest/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"},{"name":"Combinatorics","slug":"Combinatorics","permalink":"http://blog.gyx.me/tags/Combinatorics/"},{"name":"STL","slug":"STL","permalink":"http://blog.gyx.me/tags/STL/"},{"name":"01-BFS","slug":"01-BFS","permalink":"http://blog.gyx.me/tags/01-BFS/"}]},{"title":"AtCoder Regular Contest 060","slug":"Atcoder/ARC060","date":"2022-06-30T09:20:14.000Z","updated":"2022-08-31T11:07:09.782Z","comments":true,"path":"2022/06/30/Atcoder/ARC060/","link":"","permalink":"http://blog.gyx.me/2022/06/30/Atcoder/ARC060/","excerpt":"","text":"C - Tak and Cards 给定 \\(n\\) 个有序数字，求有多少个下标集，对应的数字平均数是 \\(A\\) 数据范围很小，用背包计数就好了，注意枚举的上下界。 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 57#define M 5007#define B 2500ll f[N][M];int main() &#123; int n = rd(), A = rd(); f[0][B] = 1; for (int i = 1; i &lt;= n; ++i) &#123; int w = rd() - A; for (int v = max(-B, -B + w); v &lt;= min(B, B + w); ++v) f[i][v + B] = f[i - 1][v + B] + f[i - 1][v - w + B]; &#125; printf(&quot;%lld\\n&quot;, f[n][B] - 1); return 0;&#125; D - Digit Sum 给定两个数字 \\(n\\ (n\\le 10^{11})\\) 和 \\(s\\) ，求最小的进制 \\(b\\) ，使得 \\(n\\) 在 \\(b\\) 进制下的数位和等于 \\(s\\) 。 一道典型的根号讨论题目。 当 \\(b\\le \\sqrt{n}\\) 时，直接暴力验证。 当 \\(b\\ge \\sqrt{n}\\) 时，数字最多是两位数，可以写成 \\(n=pb+q,s=p+q\\) ，联立得 \\(n-s=p(b-1)\\) 注意后一种情况判断要求：\\(b\\ge \\sqrt{n},\\ 0\\le q&lt; b\\) 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt; using namespace std; using ll = long long; inline ll calc(ll n, ll b) &#123; ll ans = 0; for (; n; ans += n % b, n /= b); return ans; &#125; int main() &#123; ll n, s; cin &gt;&gt; n &gt;&gt; s; if (n &lt; s) &#123;puts(&quot;-1&quot;); return 0;&#125; if (n == s) &#123;printf(&quot;%lld\\n&quot;, n + 1); return 0;&#125; ll lim = sqrt(n); for (ll i = 2; i &lt;= lim; ++i) if (calc(n, i) == s) &#123;printf(&quot;%lld\\n&quot;, i); return 0;&#125; n -= s; ll ans = 1e18; for (ll i = sqrt(n); i &gt;= 1; --i) if (n % i == 0) &#123; if (i &gt;= lim &amp;&amp; s - n / i &lt; i + 1 &amp;&amp; s &gt;= n / i) ans = min(ans, i + 1); if (n / i &gt;= lim &amp;&amp; s - i &lt; n / i + 1 &amp;&amp; s &gt;= i) ans = min(ans, n / i + 1); &#125; printf(&quot;%lld\\n&quot;, ans == 1e18 ? -1 : ans); return 0; &#125; E - Tak and Hotels 给定数轴上的 \\(n\\) 个点，每次查询两个点 \\(a,b\\) ： 问从 \\(a\\) 到 \\(b\\) ，在给定的点之间跳跃，每次距离不超过 \\(L\\) ，最少多少次。 考虑倍增，设 \\(mx_{i,j}\\) 表示从 \\(i\\) 向右跳 \\(2^j\\) 步，最多能跳到哪里，组合的时候记得判一下最后一步即可。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt; using namespace std; using ll = long long; inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x; &#125; #define N 100007 int r[N][18], x[N]; int main() &#123; int n = rd(); int t = log2(n) + 1; for (int i = 1; i &lt;= n; ++i) x[i] = rd(); int l = rd(), q = rd(); for (int i = 1, rpos = 1; i &lt;= n; ++i) &#123; while (rpos &lt; n &amp;&amp; x[rpos + 1] - x[i] &lt;= l) ++rpos; r[i][0] = rpos; &#125; for (int i = 1; i &lt;= t; ++i) for (int l = 1; l &lt;= n; ++l) r[l][i] = r[r[l][i - 1]][i - 1]; for (; q; --q) &#123; int a = rd(), b = rd(); if (a &gt; b) swap(a, b); int ans = 0; for (int i = t; ~i; --i) if (r[a][i] &lt; b) &#123; ans += (1 &lt;&lt; i); a = r[a][i]; &#125; printf(&quot;%d\\n&quot;, ans + 1); &#125; return 0; &#125; F - Best Representation 定义无循环节（完整补齐）的字符串是好的。 定义将一个串划分为若干好的字符串，这个划分是好的。 定义一个划分是最优的，当且仅当划分是好的并且划分的子串数最少。 给定串 \\(S\\ (|S|\\le 5\\times 10^5)\\) 求最优划分所需的子串数和最优划分个数。 如果 \\(S\\) 自己本身无循环节，两个答案都是 \\(1\\) 如果 \\(S\\) 所有字母都相同，第一个答案是 \\(n\\) ，第二个是 \\(1\\) 如果 \\(S\\) 有循环节且所有字母都不同，第一个答案是 \\(2\\) （在任意循环节中间切开） 对于第三种情况枚举分割点计数，需要快速判断一个前缀/后缀有无循环节。 对正反两个串都做一下 kmp 就可以了，若 \\((n-nxt[n])\\ |\\ n\\) 则有循环节。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;#define N 500007char s[N];int nxt[N], nxtr[N];inline bool pre(int x) &#123; return (nxt[x] == 0) || (x % (x - nxt[x]) &gt; 0);&#125;inline bool suf(int x) &#123; return (nxtr[x] == 0) || (x % (x - nxtr[x]) &gt; 0);&#125;int main() &#123; scanf(&quot;%s&quot;, s + 1); int len = strlen(s + 1); bool fl = 0; for (int i = 2, pos; i &lt;= len; ++i) &#123; if (s[i] != s[i - 1]) fl = 1; pos = nxt[i - 1]; while (pos &amp;&amp; s[pos + 1] != s[i]) pos = nxt[pos]; if (pos != 0) nxt[i] = pos + 1; else nxt[i] = (s[1] == s[i]); &#125; if (!fl) &#123;printf(&quot;%d\\n1\\n&quot;, len); return 0;&#125; if (pre(len)) &#123;puts(&quot;1\\n1&quot;); return 0;&#125; puts(&quot;2&quot;); reverse(s + 1, s + 1 + len); for (int i = 2, pos; i &lt;= len; ++i) &#123; pos = nxtr[i - 1]; while (pos &amp;&amp; s[pos + 1] != s[i]) pos = nxtr[pos]; if (pos != 0) nxtr[i] = pos + 1; else nxtr[i] = (s[1] == s[i]); &#125; int ans = 0; for (int i = 1; i &lt; len; ++i) if (pre(i) &amp;&amp; suf(len - i)) ++ans; printf(&quot;%d\\n&quot;, ans); return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"http://blog.gyx.me/categories/Solution/"},{"name":"AtCoder","slug":"Solution/AtCoder","permalink":"http://blog.gyx.me/categories/Solution/AtCoder/"},{"name":"AtCoder Regular Contest","slug":"Solution/AtCoder/AtCoder-Regular-Contest","permalink":"http://blog.gyx.me/categories/Solution/AtCoder/AtCoder-Regular-Contest/"}],"tags":[{"name":"Greedy","slug":"Greedy","permalink":"http://blog.gyx.me/tags/Greedy/"},{"name":"Knapsack Problem","slug":"Knapsack-Problem","permalink":"http://blog.gyx.me/tags/Knapsack-Problem/"},{"name":"Threshold Optimization","slug":"Threshold-Optimization","permalink":"http://blog.gyx.me/tags/Threshold-Optimization/"},{"name":"Binary Lifting","slug":"Binary-Lifting","permalink":"http://blog.gyx.me/tags/Binary-Lifting/"},{"name":"KMP","slug":"KMP","permalink":"http://blog.gyx.me/tags/KMP/"}]},{"title":"AtCoder Regular Contest 059","slug":"Atcoder/ARC059","date":"2022-06-29T09:20:14.000Z","updated":"2022-07-02T05:51:17.347Z","comments":true,"path":"2022/06/29/Atcoder/ARC059/","link":"","permalink":"http://blog.gyx.me/2022/06/29/Atcoder/ARC059/","excerpt":"","text":"C - Be Together 直接枚举最终结果是谁就行了，C 语言题。 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 107int n, a[N];inline int sqr(int x) &#123;return x * x;&#125;inline int calc(int x) &#123; int ans = 0; for (int i = 1; i &lt;= n; ++i) ans += sqr(a[i] - x); return ans;&#125;int main() &#123; n = rd(); for (int i = 1; i &lt;= n; ++i) a[i] = rd(); int ans = 2e9; for (int w = -100; w &lt;= 100; ++w) ans = min(ans, calc(w)); printf(&quot;%d\\n&quot;, ans); return 0;&#125; D - Unbalanced 给定一个字符串，找一个不平衡子串，子串中出现次数最多的字符次数超过长度的一半。 长度为 \\(2n\\) 的不平衡串，该字符一定出现了至少 \\(n+1\\) 次，因此一定有连续两个字符相同； 长度为 \\(2n+1\\) 的不平衡串，唯一特殊的情况是形如 abacada 这种，一定存在长度为 \\(3\\) 的不平衡子串； 综上，如果存在不平衡，那么最小的长度不会超过 \\(3\\) ，直接扫描即可。 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 100007char s[N];int main() &#123; scanf(&quot;%s&quot;, s + 1); int n = strlen(s + 1); if (s[n - 1] == s[n]) &#123;printf(&quot;%d %d\\n&quot;, n - 1, n); return 0;&#125; for (int i = 1; i &lt;= n - 2; ++i) &#123; if (s[i] == s[i + 1]) &#123;printf(&quot;%d %d\\n&quot;, i, i + 1); return 0;&#125; if (s[i] == s[i + 2]) &#123;printf(&quot;%d %d\\n&quot;, i, i + 2); return 0;&#125; &#125; puts(&quot;-1 -1&quot;); return 0;&#125; E - Children and Candies \\[ \\begin{array}{l} ans &amp;= \\displaystyle\\sum_{x_1 = a_1}^{b_1}\\sum_{x_2 = a_2}^{b_2}\\cdots\\sum_{x_n = a_n}^{b_n} \\sum_{\\substack{\\sum c_i=C\\\\c_i\\ge 0}}\\prod_{i=1}^n x_i^{c_i}\\\\ &amp;\\displaystyle= \\sum_{\\substack{\\sum c_i=C\\\\c_i\\ge 0}} \\sum_{x_1 = a_1}^{b_1} x_1^{c_1}\\sum_{x_2 = a_2}^{b_2}x_2^{c_2}\\cdots\\sum_{x_n = a_n}^{b_n} x_n^{c_n}\\\\ &amp;\\displaystyle= \\sum_{\\substack{\\sum c_i=C\\\\c_i\\ge 0}}\\prod_{i=1}^n\\bigg(\\sum_{x_i = a_i}^{b_i} x_i^{c_i}\\bigg)\\\\ \\end{array} \\] 我们可以预处理出 \\(pw_{i,k} =\\sum_{x_i=a_i}^{b_i} x_i^k\\) ，有 \\[ ans = \\sum_{\\substack{\\sum c_i=C\\\\c_i\\ge 0}}\\prod_{i=1}^n\\bigg(\\sum_{x_i = a_i}^{b_i} x_i^{c_i}\\bigg) =\\displaystyle\\sum_{c_1=0}^C pw_{1,c_1}\\sum_{\\substack{c_2+\\cdots + c_n=C-c_1\\\\c_i\\ge 0}}\\prod_{i=2}^n pw_{i,c_i} \\] 按照这个思路继续拆分 \\(c_2,\\cdots, c_n\\) ，本质上就是一个背包的动态规划。 设 \\(f_{i,j}\\) 表示考虑前 \\(i\\) 个变量，指数的和是 \\(j\\) ，对 \\(ans\\) 的贡献是多少。 枚举第 \\(i\\) 个指数占用了 \\(k\\ (k\\le j)\\) ，则转移方程： \\[ f_{i,j}\\leftarrow \\sum_{k=0}^j f_{i-1,j-k}\\times pw_{i,k} \\] 时间复杂度 \\(\\mathcal{O}(n^3)\\) ，空间复杂度 \\(\\mathcal{O}(n^2)\\) 。 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 407#define mod 1000000007int a[N], b[N], pw[N][N], f[N][N];int main() &#123; int n = rd(), c = rd(); for (int i = 1; i &lt;= n; ++i) a[i] = rd(); for (int i = 1; i &lt;= n; ++i) b[i] = rd(); for (int i = 1; i &lt;= n; ++i) for (int j = a[i]; j &lt;= b[i]; ++j) for (int t = 0, nw = 1; t &lt;= c; ++t, nw = 1ll * nw * j % mod) pw[i][t] = (pw[i][t] + nw) % mod; f[0][0] = 1; for (int i = 1; i &lt;= n; ++i) for (int j = 0; j &lt;= c; ++j) for (int k = 0; k &lt;= j; ++k) f[i][j] = (f[i][j] + 1ll * f[i - 1][j - k] * pw[i][k]) % mod; printf(&quot;%d\\n&quot;, f[n][c]); return 0;&#125; F - Unhappy Hacking 求 \\(n\\) 次操作生成一个给定串 \\(s\\) 的方案数： 每次操作三选一：结尾加 \\(0\\) ，结尾加 \\(1\\) ，删除结尾一个字符（若空就什么都不做） 冷静一下这个计数和串是什么没关系，因为所有长度相同的串生成的概率相同。 设 \\(f_{i,j}\\) 表示 \\(i\\) 次操作生成长度为 \\(j\\) 的串的方案数，有： + 删除：\\(f_{i,j} \\leftarrow f_{i-1,j+1}+[j == 0]f_{i-1,j}\\) + 添加：\\([j&gt;0] f_{i,j}\\leftarrow f_{i-1,j-1}\\times 2\\) 答案就是 \\(f_{n,|s|}\\times 2^{-|s|}\\) ，复杂度为 \\(\\mathcal{O}(n^2)\\) ，感觉可能还能优化。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt; using namespace std; using ll = long long; #define N 5007 #define mod 1000000007 inline int fpow(int x, int t) &#123; int res = 1; for (; t; t &gt;&gt;= 1, x = 1ll * x * x % mod) if (t &amp; 1) res = 1ll * res * x % mod; return res; &#125; char s[N]; int f[N][N], pw[N] = &#123;1&#125;; inline void add(int &amp;a, int b) &#123;a = (a + b) % mod;&#125; int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); scanf(&quot;%s&quot;, s + 1); f[0][0] = 1; for (int i = 1; i &lt;= n; ++i) pw[i] = (pw[i - 1] &lt;&lt; 1) % mod; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 0; j &lt;= n; ++j) &#123; add(f[i][j], f[i - 1][j + 1]); if (!j) add(f[i][j], f[i - 1][j]); else add(f[i][j], (f[i - 1][j - 1] &lt;&lt; 1) % mod); &#125; &#125; int m = strlen(s + 1); int ans = 1ll * f[n][m] * fpow(pw[m], mod - 2) % mod; printf(&quot;%d\\n&quot;, ans); return 0; &#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"http://blog.gyx.me/categories/Solution/"},{"name":"AtCoder","slug":"Solution/AtCoder","permalink":"http://blog.gyx.me/categories/Solution/AtCoder/"},{"name":"AtCoder Regular Contest","slug":"Solution/AtCoder/AtCoder-Regular-Contest","permalink":"http://blog.gyx.me/categories/Solution/AtCoder/AtCoder-Regular-Contest/"}],"tags":[{"name":"Counting","slug":"Counting","permalink":"http://blog.gyx.me/tags/Counting/"},{"name":"Knapsack Problem","slug":"Knapsack-Problem","permalink":"http://blog.gyx.me/tags/Knapsack-Problem/"},{"name":"Combinatorics","slug":"Combinatorics","permalink":"http://blog.gyx.me/tags/Combinatorics/"}]},{"title":"AtCoder Beginner Contest 253","slug":"Atcoder/abc253","date":"2022-05-29T00:38:14.000Z","updated":"2022-06-01T02:38:12.695Z","comments":true,"path":"2022/05/29/Atcoder/abc253/","link":"","permalink":"http://blog.gyx.me/2022/05/29/Atcoder/abc253/","excerpt":"","text":"A, B 比较简单就不写了。 我的代码 : All Submissions - SGColin C. Max - Min Query 维护一个 multiset ，支持插入一个 \\(x\\) ，删除 \\(\\min(c_i,s.count(x))\\) 个 \\(x\\) ，查询最大值-最小值。 开始想想直接模拟复杂度是对的就写了 multiset，没想到 multiset 的 lower_bound 太慢了 T 了几个点。 Upd : 经提醒应该是 count 函数太慢了，官网描述是 \"Logarithmic in size and linear in the number of matches\" ，也就是说复杂度是 \\(\\mathcal{O}(k+\\log n)\\) ，其中 \\(k\\) 是查询数字的出现次数，所以加入 \\(10^5\\) 个点之后，多查几次就超时了。 所以改为用 map 维护一个计数器，每次某个数字新出现/消失的时候再对 set 操作。 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;map&lt;int, int&gt; cnt;set&lt;int&gt; s;int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; int op = rd(); if (op == 1) &#123; int x = rd(); ++cnt[x]; if (cnt[x] == 1) s.insert(x); &#125; else if (op == 2) &#123; int x = rd(); int t = min(rd(), cnt[x]); cnt[x] -= t; if (cnt[x] == 0) s.erase(x); &#125; else printf(&quot;%d\\n&quot;, (*--s.end()) - (*s.begin())); &#125; return 0;&#125; D. FizzBuzz Sum Hard 给定 \\(n,a,b\\) 找出 \\([1,n]\\) 内不是 \\(a\\) 或 \\(b\\) 倍数的数字的和。 简单的容斥原理，扣掉 \\(a,b\\) 的倍数，加上 \\(\\text{lcm}(a,b)\\) 的倍数。 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;int gcd(int a, int b) &#123; return b ? gcd(b, a % b) : a;&#125;int main() &#123; int n = rd(), a = rd(), b = rd(); ll sum = 1ll * n * (n + 1) / 2; int ka = n / a; int kb = n / b; sum -= 1ll * a * ka * (ka + 1) / 2; sum -= 1ll * b * kb * (kb + 1) / 2; ll lcm = 1ll * a * b / gcd(a, b); ll kl = n / lcm; sum += 1ll * lcm * kl * (kl + 1) / 2; printf(&quot;%lld\\n&quot;, sum); return 0;&#125; E. Distance Sequence 计数长度为 \\(n\\) 的序列 \\(\\{a_i\\}\\) ：(1) \\(a_i\\in[1,m]\\) ; (2) \\(\\forall i\\in[2,n], |a_i-a_{i-1}|\\ge k\\) . 直接 DP ，设 \\(f_{i,j}\\) 表示长度为 \\(i\\) 的序列，结尾是 \\(j\\) 的方案数，有： \\[ f_{i,j}=\\sum_{w\\in[1,j-k]\\cup[j+k,m]} f_{i-1,w} \\] 用一个前缀和优化即可，注意下 \\(k=0\\) 时不要算重，复杂度 \\(O(nm)\\) 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 1007#define M 5007#define mod 998244353int f[N][M], sum[N][M];inline int fpow(int x, int t) &#123; int res = 1; for (; t; t &gt;&gt;= 1, x = 1ll * x * x % mod) if (t &amp; 1) res = 1ll * res * x % mod; return res;&#125;int main() &#123; int n = rd(), m = rd(), k = rd(); if (k == 0) &#123;printf(&quot;%d\\n&quot;, fpow(m, n)); return 0;&#125; for (int i = 1; i &lt;= m; ++i) &#123; f[1][i] = 1; sum[1][i] = i; &#125; for (int i = 2; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; int l = max(0, j - k); int r = min(m, j + k - 1); f[i][j] = (sum[i - 1][m] - sum[i - 1][r] + mod) % mod; f[i][j] = (f[i][j] + sum[i - 1][l]) % mod; &#125; for (int j = 1; j &lt;= m; ++j) sum[i][j] = (sum[i][j - 1] + f[i][j]) % mod; &#125; printf(&quot;%d\\n&quot;, sum[n][m]); return 0;&#125; F. Operations on a Matrix 维护一个初始是全 \\(0\\) 的 \\(n\\times m\\ (n,m\\le 2\\ast 10^5)\\) 的矩阵，支持： 对 \\([l_i,r_i]\\) 这些列的每一个元素加 \\(x\\) 将第 \\(i\\) 行全部赋值为 \\(x\\) 查询矩阵中 \\((x_i,y_i)\\) 的值 记录每行最后一次被赋值的时间戳 \\(lst_i\\) 和赋值 \\(x_i\\) ，则答案为 \\(x_i\\) + \\([lst,now]\\) 这段操作里对 \\(y_i\\) 加的值。 在线的做法就是写一个主席树 + 标记持久化； 离线的做法就是把后面的贡献写做前缀和差分，然后两个时刻维护一下。 学到了简老师的主席树写法 OwO 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define mid ((l + r) &gt;&gt; 1)#define N 200007int tot, rttot;struct node &#123; int ls, rs; ll sum;&#125; c[N &lt;&lt; 6];int rot[N], lst[N];ll x[N];int copy(int rt) &#123; c[++tot] = c[rt]; return tot;&#125;void upd(int &amp;rt, int l, int r, int L, int R, int x) &#123; rt = copy(rt); if (L &lt;= l &amp;&amp; r &lt;= R) &#123; c[rt].sum += x; return; &#125; if (L &lt;= mid) upd(c[rt].ls, l, mid, L, R, x); if (R &gt; mid) upd(c[rt].rs, mid + 1, r, L, R, x);&#125;ll query(int rtl, int rtr, int l, int r, int p) &#123; ll res = c[rtr].sum - c[rtl].sum; if (l == r) return res; if (p &lt;= mid) res += query(c[rtl].ls, c[rtr].ls, l, mid, p); else res += query(c[rtl].rs, c[rtr].rs, mid + 1, r, p); return res;&#125;int main() &#123; int n = rd(), m = rd(), q = rd(); for (int i = 1; i &lt;= q; ++i) &#123; int op = rd(); if (op == 1) &#123; ++rttot; rot[rttot] = rot[rttot - 1]; int l = rd(), r = rd(), v = rd(); upd(rot[rttot], 1, m, l, r, v); &#125; else if (op == 2) &#123; int p = rd(); x[p] = rd(); lst[p] = rttot; &#125; else &#123; int row = rd(), col = rd(); printf(&quot;%lld\\n&quot;, x[row] + query(rot[lst[row]], rot[rttot], 1, m, col)); &#125; &#125; return 0;&#125; G. Swap Many Times 对于 \\(n\\) ，初始化一个序列 \\(a_1,\\cdots,a_n\\) ，满足 \\(a_i=i\\) 。 对于 \\(n\\) ，有 \\(\\frac{n(n+1)}{2}\\) 个形如 \\((x,y)\\) 的满足 \\(1\\le x&lt;y\\le n\\) 的数对，按照 pair 的规则排序。 给定 \\(L,R\\) ，对于这个 pair 序列的第 \\(L\\) 个到第 \\(R\\) 个，依次操作：交换 \\(a_x\\) 和 \\(a_y\\) 求最终的序列。 观察这个序列， \\(x\\) 相同的 pair 是连续出现的，考虑对于同一个 \\(x\\) 把所有操作都做掉。 假设以 \\(x\\) 为 first 的在 \\([L,R]\\) 内的操作为 \\((x,y_a),(x,y_a+1),\\cdots,(x,y_b)\\) 那么实际操作的结果就是把序列中 \\(x,y_a,y_a+1,\\cdots,y_b\\) 这些位置整体向右 shift 一个位置。 枚举 \\(x\\) ，然后只需要一个支持某个位置插入删除的数据结构就可以了。 然后昨天趁机学了一下 rope ，内核是块状链表，理论复杂度 \\(\\mathcal{O}(n\\sqrt{n})\\) ，实际表现速度很快。 只能说非常好用，可惜 Clang 编译不了，是在 Custom Test 手动调试的。 p.s. 题解的做法貌似不需要数据结构，好像很精妙 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;#include &lt;ext/rope&gt;using namespace std;using namespace __gnu_cxx;typedef long long ll;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;rope&lt;int&gt; s;int main() &#123; int n = rd(); ll L = rd(), R = rd(); ll l = 0, r = 0; for (int i = 0; i &lt;= n; ++i) s.push_back(i); for (int i = 1; i &lt;= n; ++i) &#123; l = r + 1; r = l + n - i - 1; if (L &lt;= r &amp;&amp; R &gt;= l) &#123; int ll = max(l, L), rr = min(r, R); int pl = i + 1 + ll - l; int pr = i + 1 + rr - l; int x = s[pr]; s.erase(pr, 1); s.insert(pl, s[i]); s.erase(i, 1); s.insert(i, x); &#125; &#125; for (int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, s[i]); return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"http://blog.gyx.me/categories/Solution/"},{"name":"AtCoder","slug":"Solution/AtCoder","permalink":"http://blog.gyx.me/categories/Solution/AtCoder/"},{"name":"AtCoder Beginner Contest","slug":"Solution/AtCoder/AtCoder-Beginner-Contest","permalink":"http://blog.gyx.me/categories/Solution/AtCoder/AtCoder-Beginner-Contest/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"},{"name":"STL","slug":"STL","permalink":"http://blog.gyx.me/tags/STL/"},{"name":"Persistent Data Structure","slug":"Persistent-Data-Structure","permalink":"http://blog.gyx.me/tags/Persistent-Data-Structure/"}]},{"title":"Two Identical Machines Scheduling with Agreement Graphs","slug":"machine-scheduling-with-agreement-graph","date":"2022-05-25T14:03:18.000Z","updated":"2022-06-01T03:01:36.705Z","comments":true,"path":"2022/05/25/machine-scheduling-with-agreement-graph/","link":"","permalink":"http://blog.gyx.me/2022/05/25/machine-scheduling-with-agreement-graph/","excerpt":"","text":"New results in two identical machines scheduling with agreement graphs 收录于 TCS 2019 的一篇文章，基于许可图的独立双机流水安排问题的一些新进展。 问题模型 有 \\(n\\) 个任务，第 \\(i\\) 个任务需要的时间是 \\(p_i\\) 。 一共有两台机器，每个任务都需要被连续地安排到某一个机器上完成。 将任务抽象成点，给定一个许可图，两个任务有边则可以分别在两个机器上同时执行。 求一个安排方案，最小化最后一个被做完的任务完成时间。 现有结论： 许可图是树的情况下，此问题是 NP-Hard 的 许可图是毛毛虫的情况下，存在 \\(\\mathcal{O}(n)\\) 求最优解的方法 毛毛虫 毛毛虫是一种特殊的树，由一个核心路径和若干到路径距离为 \\(1\\) 的点构成。 Notation Meaning Notation Processing time \\(p\\) Maximum weighted independent set of the agreement graph \\(G\\) \\(I_p(G)\\) Weight of \\(I_p(G)\\) (a lower bound on the optimal makespan) \\(\\overline{I_p}(G) =\\sum_{j\\in I_p(G)} p_j\\) Set of neighbors of a job \\(j\\) (generalized for a subset \\(J&#39;\\)) \\(N(j)/N(J&#39;)\\) Set of leaves connected to job \\(j\\) \\(Lv(j)\\) Starting time of a job \\(j\\) \\(t_j\\) Minimum starting time of a subset \\(J&#39;\\) \\(t_j(J&#39;)=\\min_{k\\in J&#39;}\\{t_k\\}\\) Algorithm 见原文 [4.2] Caterpillar scheduling algorithm。 Polynomiality and Optimality Proof 为了简单描述，我们称在 MWIS 里的点为黑点，其余点为白点。 可以发现断掉白点之间的所有边后，这个新的图的性质是所有的边都是黑-白边。 Claim 1. 对于每个新的连通块 \\(CAT_i\\) ，其内的黑点集 \\(S_i^*\\) 仍然是 \\(CAT_i\\) 的 MWIS 假设存在其他的 MWIS \\(I_p(CAT_i)\\) 使得 \\(\\overline{I_p}(CAT_i) &gt; \\sum_{j\\in S_i^*} p_j\\) ，那么我们考虑将 \\(CAT_i\\) 这一部分的 MWIS 换成这个新的集合，其他部分的 MWIS 不变，那么还原回仍是原图的一个 IS，而这个新的 IS 比原来的 MWIS 权值还大，所以矛盾了。 \\[ \\sum_{j \\in S^{\\prime}} p_{j}=\\overline{I_{p}}(C A T)-\\sum_{j \\in S_{i}^{*}} p_{j}+\\overline{I_{p}}\\left(C A T_{i}\\right)&gt;\\overline{I_{p}}(C A T) \\] Claim 2. 对于每个新的连通块 \\(CAT_i\\) 的点集 \\(J_i\\) ，其内任何一个白点子集的点权和不会超过其邻居黑点的点权和 假设存在这样的一个白点集 \\(W\\) 满足 \\(\\sum_{j \\in W} p_{j} &gt; \\sum_{j \\in N(W)} p_{j}\\) ，那么考虑将 \\(S_i^*\\) 换成 \\(S&#39;= (S_i^*\\setminus N(W))\\cup W\\) ，易证\\(S&#39;\\) 也是一个独立集，且比 \\(S_i^*\\) 权值和还要大，矛盾。 \\[ \\sum_{j \\in S^{\\prime}} p_{j}=\\sum_{j \\in S_{i}^{*}} p_{j}-\\sum_{j \\in N(W)} p_{j}+\\sum_{j \\in W} p_{j}&gt;\\sum_{j \\in S_{i}^{*}} p_{j} \\] Claim 3. 对于任意白点 \\(\\beta\\) ，其邻居黑点都会被连续地安排在第一个机器上 分类讨论一下，如果是叶子显然；如果不是叶子，假设链上的顺序是 \\(\\alpha-\\beta-\\gamma\\) ，那么黑点顺序显然是 \\(\\alpha-(\\beta\\) 的叶子 \\()-\\gamma\\) Claim 4. 对于任意两个白点 \\(\\alpha,\\beta\\) ，如果他们被连续地安排在了某一个机器上，那么他们一定有公共邻居。 同样分类讨论 \\(\\alpha\\) 和 \\(\\beta\\) 的位置关系（分别是主干/叶子）即可。 Claim 5. 对于任意连续安排的白点集，其邻居一定是被连续安排在一个区间内的 前两条的自然结果，当然也需要第二条辅助理解一下，证明黑色一定是连续的。 Lemma 1. 每一个白点都会被安排在邻居对应的区间里 反证法，不符合的就两种情况： \\(t_\\beta &lt; t(N(\\beta ))\\) ：这种情况不存在，因为算法中每个黑点是连续安排的，如果出现该情况，这个白点会与非邻接的黑点重合，与许可图的要求相冲突。 \\(t_\\beta+p_\\beta &gt; t(N(\\beta )) + \\sum_{j\\in N(\\beta)} p_j\\) ：这种情况不存在，考虑从 \\(\\beta\\) 往前的第一个满足 \\(t_\\alpha=t_{N(\\alpha)}\\) 的任务 \\(\\alpha\\) ，那么从 \\(\\alpha\\) 到 \\(\\beta\\) 这一段是连续安排的，由事实 \\(5\\) ，连续安排的白点集，其邻居一定是被连续安排在一个区间内的，因此白点的区间就是 \\([t_\\alpha,t_\\alpha+\\sum_{j\\in[\\alpha,\\beta]} p_j]\\) ，黑点的区间就是 \\([t(N([\\alpha,\\beta])),t(N([\\alpha,\\beta])) + \\sum_{j\\in N([\\alpha,\\beta])} p_j]\\) ; 又由事实 \\(2\\) ，对于 \\(J_i\\) 内任何一个白点子集，其点权和不会超过其邻居黑点的点权和，因此有 \\(t_\\alpha+\\sum_{j\\in[\\alpha,\\beta]} p_j \\le \\sum_{j\\in N([\\alpha,\\beta])} p_j\\) ，因此 \\([\\alpha, \\beta]\\) 这一段的白点终止时间不超过黑点，因此作为最后一个完成的白点 \\(\\beta\\) ，有 \\(t_\\beta+p_\\beta \\le t(N(\\beta )) + \\sum_{j\\in N(\\beta)} p_j\\) Theorithm 2. 本算法求出的安排方案为最优解。 由引理 \\(1\\) ，每个 \\(\\sigma_i\\) 所需要的时间就是其中黑点所需的时间，即 \\(\\overline{I_p}(CAT_i)\\) ，因此总方案 \\(\\sigma\\) 所需的时间 \\(\\sum_{i} \\overline{I_p}(CAT_i) = \\overline{I_p}(CAT)\\) ，即答案下界。 总结 最后放一个 pdf 版的总结：","categories":[{"name":"Summary","slug":"Summary","permalink":"http://blog.gyx.me/categories/Summary/"},{"name":"Paper Notes","slug":"Summary/Paper-Notes","permalink":"http://blog.gyx.me/categories/Summary/Paper-Notes/"}],"tags":[{"name":"Scheduling","slug":"Scheduling","permalink":"http://blog.gyx.me/tags/Scheduling/"},{"name":"Greedy","slug":"Greedy","permalink":"http://blog.gyx.me/tags/Greedy/"},{"name":"Graphs","slug":"Graphs","permalink":"http://blog.gyx.me/tags/Graphs/"}]},{"title":"Codeforces Round #787 (Div. 3)","slug":"Codeforces/cf787","date":"2022-05-06T12:01:00.000Z","updated":"2022-06-01T02:57:47.757Z","comments":true,"path":"2022/05/06/Codeforces/cf787/","link":"","permalink":"http://blog.gyx.me/2022/05/06/Codeforces/cf787/","excerpt":"","text":"A. Food for Animals \\(a\\) 个狗粮，\\(b\\) 个猫粮，\\(c\\) 个通用粮（都能吃），能不能保证 \\(n\\) 个狗 \\(m\\) 个猫都有的吃？ 每个都先减掉专用的食物，剩下的看通用的够不够分即可。 12345inline void work() &#123; int a = rd(), b = rd(), c = rd(); int n = max(0, rd() - a), m = max(0, rd() - b); puts(n + m &gt; c ? &quot;NO&quot; : &quot;YES&quot;);&#125; B. Make It Increasing 给一个数列，每次操作把一个位置整除 \\(2\\) ，最少操作多少次使得数列严格递增？ 从后往前倒推，答案是固定的，一直做到符合要求即可。 1234567891011int a[57];inline void work() &#123; int n = rd(), ans = 0; for (int i = 1; i &lt;= n; ++i) a[i] = rd(); for (int i = n - 1; i; --i) if (a[i] &gt;= a[i + 1]) &#123; if (a[i + 1] == 0) &#123;puts(&quot;-1&quot;); return;&#125; while (a[i] &gt;= a[i + 1]) &#123;++ans; a[i] = a[i] / 2;&#125; &#125; printf(&quot;%d\\n&quot;, ans);&#125; C. Detective Task 有一幅画， \\(n\\) 个人看，中间某一时刻被某一个人偷走了。 问每个人他看的时候画还在不在，答案可能是有 (1) / 无 (0) / 忘记了 (?)。 好人会说实话/忘记了，偷走的人会随机选一个答案，求有多少个嫌疑人。 最后一个说有（1）的人，前面的人都不会是嫌疑人：如果前面的人是嫌疑人，那么他进去的时候应该已经被偷了，他就说谎了。 第一个说无（0）的人，后面的人都不会是嫌疑人：如果后面的人是嫌疑人，那么他进去的时候还没被偷，他就说谎了 因此答案是从最后一个说有的人到第一个说无的人这一段的人数。 1234567891011string s;inline void work() &#123; cin &gt;&gt; s; int n = s.length(); int l = 0, r = n - 1; for (int i = 0; i &lt; n; ++i) if (s[i] == &#x27;1&#x27;) l = i; for (int i = l; i &lt; n; ++i) if (s[i] == &#x27;0&#x27;) &#123;r = i; break;&#125; printf(&quot;%d\\n&quot;, r - l + 1);&#125; D. Vertical Paths 给一棵树，问最少分成多少个从上到下的链，并输出方案。 显然每个叶子都需要一个链，每个非叶子挑一个叶子挂上就行了，纯考实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 200007bool vis[N];int n, rt, f[N], cnt;vector&lt;int&gt; res[N], son[N];void dfs(int u, int bel) &#123; res[bel].push_back(u); if (son[u].empty()) &#123;++cnt; return;&#125; dfs(son[u][0], bel); for (int i = 1; i &lt; son[u].size(); ++i) dfs(son[u][i], son[u][i]);&#125;inline void work() &#123; n = rd(); cnt = 0; for (int i = 1; i &lt;= n; ++i) &#123;res[i].clear(); son[i].clear();&#125; for (int i = 1; i &lt;= n; ++i) &#123; f[i] = rd(); if (f[i] == i) rt = i; else son[f[i]].push_back(i); &#125; dfs(rt, rt); printf(&quot;%d\\n&quot;, cnt); for (int i = 1; i &lt;= n; ++i) if (!res[i].empty()) &#123; printf(&quot;%d\\n&quot;, (int)res[i].size()); for (auto j : res[i]) printf(&quot;%d &quot;, j); puts(&quot;&quot;); &#125; &#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; E. Replace With the Previous, Minimize 给一个字符串，每次操作你可以选定一个字符，并把串中的所有这个字符换成字典序前一个（a 变成 z ） 问 \\(k\\) 次操作内，字符串可能的字典序最小的结果是什么？ 首先如果 \\(k&gt;25\\) ，那么我从 z 到 b 都操作一遍就都变成 aaaaaaa 这样子了。 否则也一定不会对 a 操作，因为次数不够变回来了，因此操作是单向的，没有循环的。 因此按照字典序贪心就完事了，维护一个 \\(\\Sigma\\to \\Sigma\\) 的转移表，每次可以的话往前移动一下。 需要注意的是利用此前的结果，也就是每次做完之后记得把前缀覆盖一下。 12345678910111213141516string s;unordered_map&lt;char, char&gt; tr;inline void work() &#123; int n = rd(), k = rd(); cin &gt;&gt; s; for (char i = &#x27;a&#x27;; i &lt;= &#x27;z&#x27;; ++i) tr[i] = i; for (auto i : s) &#123; while (k &amp;&amp; tr[i] &gt; &#x27;a&#x27;) &#123; --tr[i]; --k; tr[i] = tr[tr[i]]; &#125; for (char j = i; j &gt;= tr[i]; --j) tr[j] = min(tr[j], tr[i]); if (k == 0) break; &#125; for (auto i : s) putchar(tr[i]); puts(&quot;&quot;);&#125; F. Vlad and Unfinished Business 给一棵树，树上的两个点 \\(x, y\\) ，以及一系列点 \\(a_1, a_2, \\dots,a_k\\) 求一个最短路径，从 \\(x\\) 出发，以任意顺序遍历完 \\(a_1, a_2, \\dots,a_k\\) ，最后走到 \\(y\\) 首先一个常见的套路（虚树）是，树上遍历一个点集的最短回路，就是所有点按照dfs序一次性访问。 现在考虑让树以 \\(x\\) 为根，现在需要遍历 \\(a_1,a_2,\\dots,a_k\\) 这些点，最后再走到 \\(y\\) 。 其实可以看成回路遍历点集 \\(x, a_1, a_2,\\dots, a_k,y\\) ，最后再把 \\(x\\) 到 \\(y\\) 的距离（也就是 \\(y\\) 的深度）扣掉。 所以按照 dfs 序依次访问即可，可能比较难写。 另外一种简单的写法是暴力往根跳，跳到第一个访问到的点即可，往答案里累加新增的点数 * 2 。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 200007vector&lt;int&gt; e[N], seq;bool vis[N];int n, k, x, y, f[N], ans;void dfs(int u, int fa, int dep) &#123; f[u] = fa; if (u == y) ans = -dep; for (auto v : e[u]) if (v != fa) dfs(v, u, dep + 1);&#125;inline void work() &#123; seq.clear(); n = rd(); k = rd(); x = rd(); y = rd(); for (int i = 1; i &lt;= n; ++i) vis[i] = 0, e[i].clear(); for (int i = 1; i &lt;= k; ++i) seq.push_back(rd()); seq.push_back(y); for (int i = 1; i &lt; n; ++i) &#123; int u = rd(), v = rd(); e[u].push_back(v); e[v].push_back(u); &#125; dfs(x, x, 0); vis[x] = 1; for (auto i : seq) for (int u = i; !vis[u]; u = f[u]) vis[u] = 1, ans += 2; printf(&quot;%d\\n&quot;, ans);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; G. Sorting Pancakes 给你一个序列，每次操作可以选两个相邻的两个位置一个 \\(-1\\) 一个 \\(+1\\) ，问最小操作多少次是的序列单减。 看到这种问题一般都是 dp ，就是状态设计需要好好考虑一下。 设 \\(f_{i,j}\\) 表示考虑了前 \\(i\\) 位，前缀和是 \\(j\\) 的最小操作数，那么转移就是枚举序列最终下一个位置的数字 \\(k\\) 。 即 \\(f_{i+1,j+k}=\\min\\{f_{i+1,j+k}, f_{i,j} + cost (i + 1, j+k)\\}\\) 其中 \\(cost(x, w)\\) 表示前缀 \\(x\\) 在此前基础上变成总和 \\(w\\) 的最小代价。 考虑 \\(f_{i,j}\\) 里已经包含了让前缀 \\(i\\) 合法的代价，现在其实只需要考虑新一位是 \\(k\\) 的代价。 本质上我们只需要考虑第 \\(i+1\\) 位和后面的后缀交流的多少次，即 \\(cost(i+1,j+k)=|\\sum_{p=1}^{i+1}a_p-(j+k)|\\) 那么怎么保证序列单减呢？把枚举 \\(k\\) 的循环放到最外面，从大到小，这样转移是从大到小的，比较妙。 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 257int a[N], s[N], f[N][N];int main() &#123; int n = rd(), m = rd(); for (int i = 1; i &lt;= n; ++i) s[i] = s[i - 1] + (a[i] = rd()); memset(f, 0x3f, sizeof(f)); f[0][0] = 0; for (int k = m; ~k; --k) for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt;= m - k; ++j) f[i + 1][j + k] = min(f[i + 1][j + k], f[i][j] + abs(j + k - s[i + 1])); printf(&quot;%d\\n&quot;, f[n][m]); return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"http://blog.gyx.me/categories/Solution/"},{"name":"Codeforces","slug":"Solution/Codeforces","permalink":"http://blog.gyx.me/categories/Solution/Codeforces/"},{"name":"Codeforces Round","slug":"Solution/Codeforces/Codeforces-Round","permalink":"http://blog.gyx.me/categories/Solution/Codeforces/Codeforces-Round/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"},{"name":"DFS and Similar","slug":"DFS-and-Similar","permalink":"http://blog.gyx.me/tags/DFS-and-Similar/"}]},{"title":"Dynamic Programming on Intervals","slug":"dp_interval","date":"2022-04-26T00:13:35.000Z","updated":"2022-06-01T03:26:01.320Z","comments":true,"path":"2022/04/26/dp_interval/","link":"","permalink":"http://blog.gyx.me/2022/04/26/dp_interval/","excerpt":"","text":"Normal Problems 区间动态规划的一般形式：枚举长度（阶段），枚举左端点，需要的话再枚举分割点 Unlock the Padlock Source:Google Kick Start 2022 Round B一个滚轮密码锁由 \\(n\\)个滚轮组成，每个的范围都是 \\([0, D-1]\\)（循环），初始是 \\(a_i\\) 。每次操作选取一个区间 \\(1 \\le l_i \\le r_i\\le n\\) ，将区间内所有滚轮都向上或向下拨一个位置。要求 \\([l_i,r_i]\\subseteq[l_{i+1},r_{i+1}]\\) ，问最少多少次把所有位置都变成 \\(0\\) 。 区间只能扩张不能收缩，因此任意时刻拨动的区间内的数字一定要相同。 如果 \\(D\\) 很小，可以设 \\(f[l][r][k]\\) 表示区间 \\([l,r]\\) 都调成 \\(k\\) 的最小代价，直接 \\(\\mathcal O(n^2D^2)\\) 求解。 那么什么时候区间能真的扩张？当且仅当区间内的值和 \\(a_{l-1}\\) 或 \\(a_{r+1}\\) 一样，才能向左或向右扩展一位。 因此 任意时刻操作区间的值一定和某个端点相同 ，设 \\(f[l][r][0/1]\\) 表示把 \\([l,r]\\) 都调成左/右端点的最小操作次数。 直接每次区间长度扩展 \\(1\\) 转移即可，复杂度 \\(\\mathcal O(n^2)\\) 。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 407int testcase;ll n, d, f[N][N][2], a[N];inline ll dis(ll a, ll b) &#123; ll w = abs(a - b); return min(w, d - w);&#125;inline void getmin(ll &amp;a, ll b) &#123;a = (a &lt; b ? a : b);&#125;inline void work() &#123; n = rd(); d = rd(); memset(f, 0x3f, sizeof(f)); for (int i = 1; i &lt;= n; ++i) &#123; a[i] = rd(); f[i][i][0] = f[i][i][1] = 0; &#125; for (int len = 1; len &lt; n; ++len) &#123; for (int l = 1; l &lt;= n - len + 1; ++l) &#123; int r = l + len - 1; getmin(f[l - 1][r][0], f[l][r][0] + dis(a[l], a[l - 1])); getmin(f[l - 1][r][0], f[l][r][1] + dis(a[r], a[l - 1])); getmin(f[l][r + 1][1], f[l][r][0] + dis(a[l], a[r + 1])); getmin(f[l][r + 1][1], f[l][r][1] + dis(a[r], a[r + 1])); &#125; &#125; ll ans = min(f[1][n][0] + dis(a[1], 0), f[1][n][1] + dis(a[n], 0)); printf(&quot;Case #%d: %lld\\n&quot;, ++testcase, ans);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; Sue 的小球 Source: SDOI2008有 \\(n\\) 个球往下落，初始坐标是\\(x_i\\) ，高度是 \\(h_i\\) ，下落速度 \\(v_i\\) ，可以下落到正无穷。初始坐标在 \\(x_0\\)，每秒可以向左/向右移动 \\(1\\)，经过某个球的坐标时就把这个球拿走，获得当前高度的得分。问拿到所有球的前提下，最大得分是多少。 得分 \\(=\\sum h_i-\\sum\\) 下降的高度，考虑动态规划求 \\(\\min\\sum\\) 下降的高度。 问题变为第 \\(i\\) 个位置每秒会消耗 \\(v_i\\) ，到一个位置就会停止消耗，是 关路灯 这个模型。 考虑把坐标排序之后离散化，拿走的球一定是一个连续的区间，因此我们可以让状态停在某一个端点。 状态设计比较特殊：设 \\(f[l][r][0/1]\\) 表示把 \\([l,r]\\) 全部拿走，最后停在左/右端点，从开始到这个时刻的最小总消耗 那么考虑每次扩展一个位置，那么所耗的时间就是两点距离，每一秒的代价就是 \\(\\sum_{i\\notin [l,r]} v_i\\) （所有没接到的球） 需要注意把初始坐标离散化进去。枚举区间动态规划复杂度 \\(\\mathcal O(n^2)\\) 。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;typedef double db;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 1007#define fr first#define sc secondpair&lt;int, double&gt; p[N];db ans, sum[N], f[N][N][2];inline void getmin(db &amp;a, db b) &#123;a = (a &lt; b ? a : b);&#125;int main() &#123; int n = rd(), c = rd(); for (int i = 1; i &lt;= n; ++i) p[i].fr = rd(); for (int i = 1; i &lt;= n; ++i) ans += rd() / 1000.0; for (int i = 1; i &lt;= n; ++i) p[i].sc = rd() / 1000.0; p[++n] = make_pair(c, 0); sort(p + 1, p + 1 + n); for (int l = 1; l &lt;= n; ++l) for (int r = 1; r &lt;= n; ++r) for (int k = 0; k &lt; 2; ++k) f[l][r][k] = 1e18; for (int i = 1; i &lt;= n; ++i) &#123; sum[i] = sum[i - 1] + p[i].sc; if (p[i].fr == c) f[i][i][0] = f[i][i][1] = 0; &#125; for (int len = 1; len &lt; n; ++len) for (int l = 1; l &lt;= n - len + 1; ++l) &#123; int r = l + len - 1; db rsum = sum[n] - sum[r] + sum[l - 1]; getmin(f[l - 1][r][0], f[l][r][0] + (p[l].fr - p[l - 1].fr) * rsum); getmin(f[l - 1][r][0], f[l][r][1] + (p[r].fr - p[l - 1].fr) * rsum); getmin(f[l][r + 1][1], f[l][r][0] + (p[r + 1].fr - p[l].fr) * rsum); getmin(f[l][r + 1][1], f[l][r][1] + (p[r + 1].fr - p[r].fr) * rsum); &#125; printf(&quot;%.3lf\\n&quot;, ans - min(f[1][n][0], f[1][n][1])); return 0;&#125; Cities Source: The45th ICPC Asia Kunming Regional有 \\(n\\) 个点，第 \\(i\\) 个点的颜色是 \\(c_i\\) ，保证每种颜色最多出现 \\(15\\) 次。每次操作可以把一段连续且颜色相同的点都改成某个颜色，问最少操作多少次使得所有点颜色相同。 先把同样颜色且连续的缩成一段，这样相邻两两颜色都不同，假设有 \\(m\\) 段。 如果所有的颜色都不同的话，那么答案就是 \\(m-1\\) ，因为每次只能改颜色相同的。 但是序列中依旧有颜色相同的，因此需要动态规划求，设 \\(f[l][r]\\) 表示把 \\([l,r]\\) 变成相同的所需的最少次数。 转移考虑 \\(c_l\\) 有没有单独消耗一次合并： 如果单独消耗了一次就是 \\(f[l][r] = f[l + 1][r] + 1\\) 如果不消耗，那么枚举相同的另一个是 \\(k\\) ，那么 \\(f[l][r] = f[l + 1][k - 1] + f[k][r] + 1\\) 后面这个方程成立的原因是，我们发现操作总是可以等效到把区间变成和端点颜色相同。 需要缩点的原因是，后一种方程里的 \\(+1\\) 是为了把 \\([l + 1][k - 1]\\) 变成和 \\(c_l\\) 相同的，不缩会求错。 枚举区间，再枚举相同颜色，因为题目限制每种颜色最多出现 \\(15\\) 次，复杂度 \\(O(15n^2)\\) 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;typedef double db;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;inline void getmin(int &amp;a, int b) &#123;a = (a &lt; b ? a : b);&#125;#define N 5007int a[N], f[N][N], lst[N], nxt[N];inline void work() &#123; int n = rd(), tot = 0; for (int i = 1, x; i &lt;= n; ++i) &#123; x = rd(); if (!tot || x != a[tot]) a[++tot] = x; lst[i] = n + 1; &#125; n = tot; for (int i = n; i; --i) &#123; nxt[i] = lst[a[i]]; lst[a[i]] = i; &#125; for (int len = 2; len &lt;= n; ++len) for (int l = 1; l &lt;= n - len + 1; ++l) &#123; int r = l + len - 1; f[l][r] = f[l + 1][r] + 1; for (int j = nxt[l]; j &lt;= r; j = nxt[j]) getmin(f[l][r], f[l + 1][j - 1] + f[j][r] + 1); &#125; printf(&quot;%d\\n&quot;, f[1][n]);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; Dire Wolf Source:2014 ICPC Asia Beijing Regional有 \\(n\\) 个恐狼先锋排成一排，第\\(i\\) 个有 \\(a_i\\) 初始攻击力，并且会为两侧的恐狼临时增加 \\(b_i\\)攻击力（死了就没了）每次杀掉一个需要承受他当前攻击力的伤害，问杀掉所有的狼，承受最少伤害是多少。 设 \\(f[l][r]\\) 表示把 \\([l,r]\\) 这个区间的所有狼杀掉所需的最小代价。 枚举最后一只杀掉的狼 \\(k\\) ，考虑此时他两侧的狼是谁？ 答案是 \\(l-1\\) 和 \\(r+1\\) ，考虑区间 DP 的阶段性，我只需要杀死当前枚举的区间的狼，所以两侧的狼都没有死过。 所以最后一只狼的攻击力是 \\(a_k+b_{l-1}+b_{r + 1}\\) ，枚举 \\(k\\) 更新，复杂度是 \\(\\mathcal O(n^3)\\) 的。 \\[ f[l][r] = \\min_{l\\le k\\le r} \\bigg\\{f[l][k-1]+f[k+1][r]+a_k+b_{l-1}+b_{r+1}\\bigg\\} \\] 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 207int a[N], b[N], testcase;ll f[N][N];inline void work() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) a[i] = rd(); for (int i = 1; i &lt;= n; ++i) b[i] = rd(); b[n + 1] = 0; for (int len = 1; len &lt;= n; ++len) for (int l = 1; l &lt;= n - len + 1; ++l) &#123; int r = l + len - 1; f[l][r] = 1e18; for (int p = l; p &lt;= r; ++p) f[l][r] = min(f[l][r], f[l][p - 1] + f[p + 1][r] + a[p] + b[l - 1] + b[r + 1]); &#125; printf(&quot;Case #%d: %lld\\n&quot;, ++testcase, f[1][n]);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; You Are the One Source:2012 ICPC Asia Tianjin Regional Online\\(n\\)个人排成一队依次入栈，任意时刻都可以按栈序弹出栈内的任意人数。第 \\(i\\) 个人如果是第 \\(k\\) 个出场的，代价是 \\(D_i\\ast (k-1)\\)，求所有人代价和最小可能是多少。 设 \\(f[l][r]\\) 表示序列里只有 \\([l,r]\\) 这些人（假设区间前后的人不存在），最小代价是多少。 观察这些人的出入栈的顺序，发现序列会被第一个人何时出栈划分为两个阶段。 第一个人第一个入栈，假设第 \\(k\\) 个出栈（他出栈前只压入第 \\(2\\sim k\\) 个人）那么序列表现为： 第 \\(2\\sim k\\) 个人出入栈，这些人前面没有其他人，代价是 \\(f[l+1][l+k-1]\\) 第一个人出栈，前面有 \\(k-1\\) 个人，代价是 \\(D_l\\ast(k-1)\\) 第 \\(k+1\\sim n\\) 个人出入栈，这些人前面都增加 \\(k\\) 个人，代价是 \\(f[l+k][r]+\\sum_{i=l+k+1}^rD_i\\ast k\\) 枚举 \\(k\\) 更新，复杂度是 \\(\\mathcal O(n^3)\\) 的。 \\[ f[l][r] =\\min_{1\\le k\\le r-l+1} \\bigg\\\\{f[l + 1][l + k-1]+D_l\\ast(k-1)+f[l+k][r] + \\sum_{i=l+k}^r D_i\\ast k\\bigg\\\\} \\] 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 107int testcase;ll d[N], sum[N], f[N][N];inline void getmin(ll &amp;a, ll b) &#123;a = (a &lt; b ? a : b);&#125;inline void work() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; d[i] = rd(); sum[i] = sum[i - 1] + d[i]; &#125; for (int len = 2; len &lt;= n; ++len) for (int l = 1; l &lt;= n - len + 1; ++l) &#123; int r = l + len - 1; f[l][r] = 1e18; for (int k = 1; k &lt;= len; ++k) getmin(f[l][r], f[l + 1][l + k - 1] + d[l] * (k - 1) + f[l + k][r] + (sum[r] - sum[l + k - 1]) * k); &#125; printf(&quot;Case #%d: %lld\\n&quot;, ++testcase, f[1][n]);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; 二叉查找树 Source: NOI2009给定 \\(n\\) 个节点的key,value,times ，修改一个点的 value 代价是\\(K\\) ，修改后要保证两两value 不同。然后把这些点建出一个 Treap，定义访问代价 \\(\\sum_{i} depth_i\\ast times_{i}\\)，最小化修改代价 + 访问代价。 核心点是 key 不能修改，所以中序遍历是固定的，根左侧是左子树，根右侧是右子树。 考虑在中序遍历上做区间 DP ，枚举谁做根，那么根的 value 应当比左右子树的节点 value 要小。 所以状态里我们还要记一下当前子树的最小 value 是多少。 设 \\(f[l][r][k]\\) 表示中序遍历区间 \\([l,r]\\) 内的点建树，里面的点 value 权值 \\(\\ge k\\) ，的最小代价。 如果这个点的权值不需要改（前提 \\(value_{rt}\\ge k\\) ），那么子树里的权值要比他大 \\[ f[l][r][k] = \\min_{l\\le rt\\le r}\\bigg\\{f[l][rt - 1][value_{rt}]+f[rt + 1][r][value_{rt}] + \\sum_{i=l}^r times_i\\bigg\\} \\] 如果这个点权值需要改，那么子树的权值下界也是 \\(k\\) \\[ f[l][r][k] = \\min_{l\\le rt\\le r}\\bigg\\{f[l][rt - 1][k]+f[rt + 1][r][k] + \\sum_{i=l}^r times_i + K\\bigg\\} \\] 因为初始两两节点 value 就不同，而且可以调整成任意实数，所以方程中对子树权值的约束不用修改。 答案是 \\(\\min_k f[1][n][k]\\) ，把权值离散化一下，DP 复杂度是 \\(\\mathcal O(n^4)\\) 的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;vector&lt;int&gt; s;unordered_map&lt;int, int&gt; tr;#define N 73struct node &#123;int k, v, t;&#125; c[N];ll f[N][N][N], sumt[N];inline void getmin(ll &amp;a, ll b) &#123;a = (a &lt; b ? a : b);&#125;int main() &#123; int n = rd(), w = rd(); for (int i = 1; i &lt;= n; ++i) c[i].k = rd(); for (int i = 1; i &lt;= n; ++i) s.push_back(c[i].v = rd()); for (int i = 1; i &lt;= n; ++i) c[i].t = rd(); sort(s.begin(), s.end()); int cnt = 0; for (auto i : s) tr[i] = ++cnt; for (int i = 1; i &lt;= n; ++i) c[i].v = tr[c[i].v]; sort(c + 1, c + 1 + n, [](node x, node y)&#123;return x.k &lt; y.k;&#125;); for (int i = 1; i &lt;= n; ++i) sumt[i] = sumt[i - 1] + c[i].t; for (int len = 1; len &lt;= n; ++len) for (int l = 1; l &lt;= n - len + 1; ++l) &#123; int r = l + len - 1; for (int k = 0; k &lt;= n; ++k) &#123; f[l][r][k] = 1e18; for (int rt = l; rt &lt;= r; ++rt) &#123; if (c[rt].v &gt;= k) getmin(f[l][r][k], f[l][rt - 1][c[rt].v] + f[rt + 1][r][c[rt].v]); getmin(f[l][r][k], f[l][rt - 1][k] + f[rt + 1][r][k] + w); &#125; f[l][r][k] += sumt[r] - sumt[l - 1]; &#125; &#125; ll ans = 1e18; for (int k = 0; k &lt;= n; ++k) ans = min(ans, f[1][n][k]); printf(&quot;%lld\\n&quot;, ans); return 0;&#125; Pre-Order Source :AtCoder Beginner Contest 252 G定义 dfs序：从根开始，每次选择未访问过的最小儿子访问，每个点第一次被访问时记入序列尾。现给定 dfs 序，问有多少棵树符合。 \\(n\\le500\\) 考虑多叉树转二叉树（左儿子右兄弟，这是一个双射），那么要求就变为右儿子一定要小于父节点的编号。 设 \\(f_{l, r}\\) 表示 \\([l,r]\\) 这段区间，以 \\(l\\) 为根形成这样一棵二叉树的方案数。 枚举右儿子是 \\(k\\in[l + 1, r], a[k] &gt; a[l]\\) ，有转移 \\(f_{l, r} = \\sum_k f_{l,k - 1} \\times f_{k, r}\\) 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 507#define mod 998244353ll a[N], f[N][N];int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; a[i] = rd(); f[i][i] = 1; &#125; for (int len = 2; len &lt; n; ++len) &#123; for (int l = 2; l &lt;= n - len + 1; ++l) &#123; int r = l + len - 1; f[l][r] = f[l + 1][r]; for (int k = l + 1; k &lt;= r; ++k) if (a[k] &gt; a[l]) f[l][r] = (f[l][r] + 1ll * max(1ll, f[l + 1][k - 1]) * f[k][r]) % mod; &#125; &#125; printf(&quot;%lld\\n&quot;, f[2][n]); return 0;&#125;","categories":[{"name":"Summary","slug":"Summary","permalink":"http://blog.gyx.me/categories/Summary/"},{"name":"Algorithms","slug":"Summary/Algorithms","permalink":"http://blog.gyx.me/categories/Summary/Algorithms/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"}]},{"title":"AtCoder Grand Contest 001","slug":"Atcoder/agc001","date":"2022-04-12T02:08:12.000Z","updated":"2022-06-01T03:18:33.915Z","comments":true,"path":"2022/04/12/Atcoder/agc001/","link":"","permalink":"http://blog.gyx.me/2022/04/12/Atcoder/agc001/","excerpt":"","text":"官方题解：https://img.atcoder.jp/agc001/editorial.pdf 听说多做 AGC 可以提升智力，于是来尝试提升一下智力（虽然都是抄的题解）。 A - BBQ Easy \\(2n\\) 个数，最大化两两一组分组后，每组两个数取 \\(\\min\\) 的和。 从小到大排序之后，两两组合，答案是奇数位置的和。 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;vector&lt;int&gt; a;int main() &#123; int n = (rd() &lt;&lt; 1); for (int i = 1; i &lt;= n; ++i) a.push_back(rd()); sort(a.begin(), a.end()); int ans = 0; for (int i = 0; i &lt; n; i += 2) ans += a[i]; printf(&quot;%d\\n&quot;, ans); return 0;&#125; B - Mysterious Light 边长为 \\(n\\) 的正三角形 ABC 的边 AB 上 \\(x\\) 处平行 BC 射出一条激光。 碰到边界反射，碰到此前的光线也反射，求回到起点的路径长度。 没看懂官方题解的简单做法。 首先前两段光路长度和是 \\(n\\) ，会切掉两个角，变成一个平行四边形。 对于平行四边形（边长分别为 \\(a\\) 和 \\(b\\) ），光线从一个 \\(120^\\circ\\) 角出发，沿角平分线射出距离为 \\(f(a,b)\\) 有 \\(f(a,0)=-a, f(a,b) = 2 \\ast \\displaystyle\\lfloor \\frac{a}{b}\\rfloor \\ast b +f(b, a \\% b)\\) ，也就是每次都切短边直到长短边交换，减掉最后一次多算的。 答案就是 \\(n+f(x,n-x)\\) ，递归形式和 gcd 相同，所以复杂度是 \\(\\mathcal O(\\log n)\\) 。 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;inline ll f(ll a, ll b) &#123; return b ? 2 * (a / b) * b + f(b, a % b) : -a;&#125;int main() &#123; ll n = rd(), x = rd(); printf(&quot;%lld\\n&quot;, n + f(x, n - x)); return 0;&#125; C - Shorten Diameter 给一棵树，每次可以删掉一个叶子，问最少删多少次使得直径不超过 \\(k\\) 本来想贪心每次删一个直径的端点，但是不对，因为有可能这个点会被保留到最后。 因为 \\(n\\) 只有 \\(2000\\) ，所以可以 \\(\\mathcal{O}(n^2)\\) 暴力，那么枚举中心就好了。 如果 \\(k\\) 是奇数，枚举中心的边，把树分成两棵，根就是这条边的两个端点，每棵只保留深度小于 \\(\\lfloor k/2\\rfloor\\) 的点 如果 \\(k\\) 是偶数，枚举中心的点，以这个点为根，只保留深度小于 \\(\\lfloor k/2\\rfloor\\) 的点 找到上述情况里需要删除的点最少的情况即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 2007#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;vector&lt;pii&gt; r;vector&lt;int&gt; e[N];int dep[N];void dfs(int u) &#123; for (auto v : e[u]) if (dep[v] &lt; 0) &#123;dep[v] = dep[u] + 1; dfs(v);&#125;&#125;int main() &#123; int n = rd(), k = rd(); for (int i = 1, u, v; i &lt; n; ++i) &#123; u = rd(); v = rd(); e[u].pb(v); e[v].pb(u); if (k &amp; 1) r.pb(mp(u, v)); &#125; int ans = 0; if (k &amp; 1) &#123; for (auto [u, v] : r) &#123; memset(dep, -1, sizeof(dep)); dep[u] = 0; dep[v] = 0; dfs(u); dfs(v); int tmpans = 0; for (int j = 1; j &lt;= n; ++j) tmpans += (dep[j] &lt;= k / 2); ans = max(ans, tmpans); &#125; &#125; else &#123; for (int i = 1; i &lt;= n; ++i) &#123; memset(dep, -1, sizeof(dep)); dep[i] = 0; dfs(i); int tmpans = 0; for (int j = 1; j &lt;= n; ++j) tmpans += (dep[j] &lt;= k / 2); ans = max(ans, tmpans); &#125; &#125; printf(&quot;%d\\n&quot;, n - ans); return 0;&#125; D - Arrays and Palindrome 给定序列 \\(\\{A_i\\}\\) ，满足 \\(\\sum A_i=N\\) ，需要重排 \\(\\{A_i\\}\\) ，并且构造 \\(\\{B_i\\}\\) ，满足 \\(\\sum B_i=N\\) ，且满足： 如果一个长度为 \\(N\\) 的串 \\(S\\) 满足（ \\(S[l,r]\\) 表示 \\(S[l]S[l+1]\\dots S[r]\\) 这一段子串）： \\(\\forall i,\\ S[\\sum_{j=1}^{i-1}A_j+1, \\sum_{j=1}^i A_j]\\) 是回文的（也就是按照 \\(A_i\\) 分割成若干段子串，都是回文的） \\(\\forall i,\\ S[\\sum_{j=1}^{i-1}B_j+1, \\sum_{j=1}^i B_j]\\) 是回文的（也就是按照 \\(B_i\\) 分割成若干段子串，都是回文的） 那么 一定能推出 \\(S\\) 中全部字符都相同。 好有意思的题目啊！！建议先看官方题解。 假如我们确定了 \\(\\{A\\}\\) 的顺序，那么 \\(\\{A\\}\\) 把序列分成若干段，每段对称的位置字符要相同。 我们如果把 \\(N\\) 个位置看作 \\(N\\) 个点，那么可以把 \\(A\\) 的所有要求对称的位置连一条边。 现在 \\(B\\) 相当于是要补一些边，使得所有点都连通。 假设所有的 \\(A_i\\) 均为偶数，那么令\\(|\\{B\\}|=|\\{A\\}|\\) ，先让 \\(B_i=A_i\\) ，然后 $B_1 B_1-1,B_{|{B}|}B_{|{B}|}+1 $那么（除第一段外）每一段的最后一个都和前一段的最后一个连边，连通了两段；此外每一段内的连边都是奇偶位置错开的，所以整个图是连通的。 然后考虑 \\(A_i\\) 有奇数，可以证明最多允许有两段奇数，把这两段放在两边，还是不影响答案的。 如果奇数长度段超过两个，一定无解，具体证明看官方题解，大概方法就是证明了边数凑不到 \\(n-1\\) 。 感觉这个构造真的很 useful 啊（ 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define ppb pop_back#define psb push_back#define ppf pop_front#define psf push_frontdeque&lt;int&gt; s, odd;int main() &#123; int m = rd(), n = rd(); for (int i = 1, x; i &lt;= n; ++i) &#123; x = rd(); (x &amp; 1) ? odd.psb(x) : s.psb(x); &#125; if (odd.size() &gt; 2) &#123;puts(&quot;Impossible&quot;); return 0;&#125; if (odd.size() &gt; 0) s.psf(odd[0]); if (odd.size() &gt; 1) s.psb(odd[1]); for (auto x : s) printf(&quot;%d &quot;, x); puts(&quot;&quot;); //需要注意只有一个元素和第一个元素是1的情况 if (s.size() == 1) s.psb(0); --s.front(); ++s.back(); if (s.front() == 0) s.ppf(); printf(&quot;%d\\n&quot;, s.size()); for(auto x : s) printf(&quot;%d &quot;, x); return 0;&#125; E - BBQ Hard 给定 \\(N\\) 个 \\((A_i,B_i)\\) ，求： \\[ \\sum_{i=1}^{n-1}\\sum_{j=i+1}^n {A_i+A_j+B_i+B_j\\choose A_i+A_j} \\mod 10^9+7 \\] 数据范围 \\(2\\le n\\le 2\\times 10^5,1\\le a_i,b_i\\le 2000\\) 只能往右和往上走，计数从 \\((x_0,y_0)\\) 到 \\((x_1,y_1)\\)的路径方案数，考虑哪些步是横向走，是 \\(\\displaystyle{ {x_1-x_0+y_1-y_0} \\choose {x_1-x_0}}\\) 。当然也可以用一个二维递推，令 f[x0][y0]=1 ，每次f[i][j] = f[i - 1][j] + f[i][j - 1] ，答案f[x1][y1] 。 把式中 \\(\\displaystyle{A_i+A_j+B_i+B_j\\choose A_i+A_j}\\) 变形为 \\(\\displaystyle {A_i-(-A_j)+B_i-(-B_j)\\choose A_i-(-A_j)}\\) ，可解读为从 \\((-A_j,-B_j)\\) 到 \\((A_i,B_i)\\) 的路径数。 那么把求和改一下形式，两个循环都改成从 \\(1\\) 到 \\(n\\) ，然后扣掉自己到自己的贡献，再除 \\(2\\) 就是答案。 \\[ ans = \\frac{\\sum_{i=1}^{N} \\sum_{j=1}^{N} \\displaystyle{A_{i} +B_{i}+A_{j}+B_{j} \\choose A_{i}+B_{i}}-\\sum_{i=1}^{N} {2\\ast A_{i}+2\\ast B_{i} \\choose 2 \\ast A_{i}}}{2} \\mod 10^9+7 \\] 前一半考虑用上面提到的递推方法整体一起求（加个偏移量把坐标调成正的）： 先给所有的 f[-a[i]][-b[i]] += 1 ，然后递推完查所有的 f[a[i]][b[i]] 即可。 后一半用组合数直接算就好了。总复杂度 \\(\\mathcal{O}(n+4\\ast \\max a_i\\ast \\max b_i)\\) 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define A 4007#define G 2001#define M 8007#define N 200007#define mod 1000000007#define inv2 500000004int f[A][A], fac[M], ifac[M], x[N], y[N];inline int fpow(int x, int t = mod - 2) &#123; int res = 1; for (; t; t &gt;&gt;= 1, x = 1ll * x * x % mod) if (t &amp; 1) res = 1ll * res * x % mod; return res;&#125;inline int mo(int x) &#123; for (; x &lt; 0; x += mod); for (; x &gt;= mod; x -= mod); return x;&#125;inline int C(int n, int m) &#123; if (n &lt; m) return 0; return 1ll * fac[n] * ifac[m] % mod * ifac[n - m] % mod;&#125;int main() &#123; fac[0] = ifac[0] = 1; for (int i = 1; i &lt; M; ++i) fac[i] = 1ll * fac[i - 1] * i % mod; ifac[M - 1] = fpow(fac[M - 1]); for (int i = M - 2; i; --i) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % mod; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; x[i] = rd(); y[i] = rd(); ++f[-x[i] + G][-y[i] + G]; &#125; for (int i = 1; i &lt; A; ++i) for (int j = 1; j &lt; A; ++j) f[i][j] = mo(f[i][j] + f[i - 1][j] + f[i][j - 1]); int ans = 0; for (int i = 1; i &lt;= n; ++i) ans = mo(ans + f[x[i] + G][y[i] + G] - C(2 * (x[i] + y[i]), 2 * x[i])); printf(&quot;%lld\\n&quot;, 1ll * ans * inv2 % mod); return 0;&#125; F - Wide Swap 给定一个 \\(\\{1,2,\\dots,n\\}\\) 的排列 \\(\\{P\\}\\) ，每次操作： 选取两个距离至少为 \\(k\\) 的位置 \\(i,j\\) 且 \\(|P_i-P_j|=1\\) ，交换 \\(i,j\\) 两个位置上的数。 你可以任意次数操作，问可能得到的最小字典序排列是什么。 排列求个逆（即 \\(Q_{P_i}=i\\) ），\\(Q_i\\) 的含义就是数字 \\(i\\) 的位置。 问题转化为：相邻并且差值至少为 \\(k\\) 的两个 \\(Q\\) 可以交换，\\(Q\\) 可能最小字典序是什么（小的数字位置靠前）。 如果 \\(|Q_i-Q_j|&lt;k\\) ，那么 \\(Q_i\\) 和 \\(Q_j\\)在序列里的相对顺序永远都不能改变（换到相邻就不能操作了）。反之如果两个位置差值 \\(\\ge k\\)，只要能换到相邻，就一定可以交换，如果换不到相邻，一定是上面的约束导致的。所以如果 \\(|Q_i-Q_j|\\ge k\\) ，那么\\(Q_i\\) 和 \\(Q_j\\) 在序列里的顺序没有任何要求。 只有 \" \\(a\\) 一定要在 \\(b\\) 前\" 这种约束的最小字典序排列显然可以用优先队列的拓扑排序求。 但是边的级别是 \\(\\mathcal{O}(n^2)\\) 的： \\(Q_i\\) 会向 \\(\\forall j&gt;i,Q_j\\in[Q_i-k + 1,Q_i + k-1]\\) 的所有 \\(Q_j\\) 连边。 考虑去掉一些没有意义的边：假设 \\((x,y),(y,z),(x,z)\\) 都存在，那么 \\((x,z)\\) 显然是没必要存的。 把区间拆成两块 \\([Q_i-k+1,Q_i],[Q_i,Q_i+k-1]\\) ，这两个区间内部有约束的肯定会两两连边（单向）。 因此 \\(Q_i\\) 并不需要向这里面的全部点连边，完全可以继承区间里最靠前的位置的所有边，然后让自己指向这个位置即可。 形式化的说，对于某个区间，找到 \\(pos = \\min_{Q_j\\in [\\text{interval}]} j\\) ，那么只需要连 \\(Q_i\\to Q_{pos}\\) ，其余边都间接继承 \\(Q_{pos}\\) 的。 这样边的级别（也就是拓扑排序复杂度）就是 \\(\\mathcal{O}(n)\\) 的，找 \\(pos\\) 需要单点更新查区间 \\(\\min\\) ，用线段树复杂度 \\(\\mathcal{O}(n\\log n)\\) 。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 500007#define ls (rt &lt;&lt; 1)#define rs (rt &lt;&lt; 1 | 1)#define mid ((l + r) &gt;&gt; 1)int mn[N &lt;&lt; 2];void pushup(int rt) &#123; mn[rt] = min(mn[ls], mn[rs]);&#125;void upd(int rt, int l, int r, int k, int v) &#123; if (l == r) &#123; mn[rt] = v; return; &#125; if (k &lt;= mid) upd(ls, l, mid, k, v); else upd(rs, mid + 1, r, k, v); pushup(rt);&#125;int qmn(int rt, int l, int r, int L, int R) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) return mn[rt]; int ans = 1e9; if (L &lt;= mid) ans = min(ans, qmn(ls, l, mid, L, R)); if (R &gt; mid) ans = min(ans, qmn(rs, mid + 1, r, L, R)); return ans;&#125;int p[N], q[N], deg[N];vector&lt;int&gt; e[N];#define pb push_backpriority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;que;int main() &#123; int n = rd(), k = rd(); memset(mn, 0x3f, sizeof(mn)); for (int i = 1; i &lt;= n; ++i) q[p[i] = rd()] = i; for (int i = n; i; --i) &#123; int j = qmn(1, 1, n, q[i], min(n, q[i] + k - 1)); if (j &lt;= n) &#123;e[q[i]].pb(q[j]); ++deg[q[j]];&#125; j = qmn(1, 1, n, max(1, q[i] - k + 1), q[i]); if (j &lt;= n) &#123;e[q[i]].pb(q[j]); ++deg[q[j]];&#125; upd(1, 1, n, q[i], i); &#125; for (int i = 1; i &lt;= n; ++i) if (!deg[i]) que.push(i); for (int i = 1; i &lt;= n; ++i) &#123; int u = q[i] = que.top(); que.pop(); for (auto v : e[u]) if (!(--deg[v])) que.push(v); &#125; for (int i = 1; i &lt;= n; ++i) p[q[i]] = i; for (int i = 1; i &lt;= n; ++i) printf(&quot;%d\\n&quot;, p[i]); return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"http://blog.gyx.me/categories/Solution/"},{"name":"AtCoder","slug":"Solution/AtCoder","permalink":"http://blog.gyx.me/categories/Solution/AtCoder/"},{"name":"AtCoder Grand Contest","slug":"Solution/AtCoder/AtCoder-Grand-Contest","permalink":"http://blog.gyx.me/categories/Solution/AtCoder/AtCoder-Grand-Contest/"}],"tags":[{"name":"Constructive Algorithm","slug":"Constructive-Algorithm","permalink":"http://blog.gyx.me/tags/Constructive-Algorithm/"}]},{"title":"AtCoder Beginner Contest 244","slug":"Atcoder/abc224","date":"2022-03-29T07:46:14.000Z","updated":"2022-05-29T00:47:40.554Z","comments":true,"path":"2022/03/29/Atcoder/abc224/","link":"","permalink":"http://blog.gyx.me/2022/03/29/Atcoder/abc224/","excerpt":"","text":"A, B, C 比较简单就不写了。 我的代码 : All Submissions - SGColin D. Swap Hats 给定两个 \"RGB\" 这个字符串的排列 \\(A,B\\) ，每次操作可以交换两个位置。 问能否正好操作 \\(10^{18}\\) 把 \\(A\\) 变成 \\(B\\) 。 假设 R=1,G=2,B=3 ，我们可以通过逆序数奇/偶把所有排列分两类。 因为只有三个位置，可以发现转换关系的连边是个完全二分图。 所以根据 \\(A\\) 和 \\(B\\) 不同的位数 \\(cnt\\) 即可判定是哪种情况。 \\(cnt=0\\) 完全相同，一直交换某两位即可。 \\(cnt=2\\) 逆序数相同，但排列不同，不可能通过偶数次交换得到。 \\(cnt=3\\) 逆序数不同，因为是完全二分图，一定可以通过两次操作把 \\(A\\) 变成 \\(B\\) ，后面参考 \\(cnt=0\\) 操作即可。 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;char a[3], b[3];inline char gc() &#123; char c = getchar(); while (!isalpha(c)) c = getchar(); return c;&#125;int main() &#123; for (int i = 0; i &lt; 3; ++i) a[i] = gc(); for (int i = 0; i &lt; 3; ++i) b[i] = gc(); int cnt = 0; for (int i = 0; i &lt; 3; ++i) cnt += (a[i] != b[i]); puts((cnt == 0 || cnt == 3) ? &quot;Yes&quot; : &quot;No&quot;); return 0;&#125; E. King Bombee 定义无向图 \\(G=(V,E)\\) 的一个长度为 \\(K\\) 的路径序列 \\(\\{A\\}\\) ： 由 \\(K+1\\) 个点编号 \\(A_0,\\dots,A_K\\in V\\) 构成，\\(A_0\\) 是起点，\\(A_K\\) 是终点，且 \\(\\forall 0\\le i &lt; K, (A_i, A_{i+1})\\in E\\) 给定无向图 \\(G\\ (|V|\\le 2000,|E|\\le 2000)\\) 求有多少个长度为 \\(K\\ (K\\le 2000)\\) 的路径序列，满足： 起点为 \\(S\\) ，终点为 \\(T\\) ，且点 \\(X\\) 在序列中出现偶数次（可以为 \\(0\\) ) 。 感觉最近 ABC 每场都会有一道比较暴力的 DP，就看敢不敢写（ 设 f[i][u][0/1] 表示当前考虑长度为 \\(i\\) 的路径，起点是 \\(S\\) ，终点是 \\(u\\) ，当前节点 \\(X\\) 在其中出现偶数/奇数次的方案数。 初始状态 f[0][S][S==X] = 1 ，答案 f[K][T][0] 。 转移暴力做就可以了，枚举下一步走哪里（ \\(u\\to v\\) ） ：f[i+1][v][k^(v == X)] += f[i][u][k] 。 这个题的核心在复杂度计算，外层枚举 \\(i\\) 是 \\(\\mathcal O(n)\\) 的，内层枚举 \\(u\\) 是 \\(\\mathcal O(n)\\) 的，枚举 \\(v\\) 复杂度怎么算？ 把后两个的复杂度放到一起考虑，就是 \\(\\sum_{u=1}^n deg(u) = \\mathcal O(m)\\) 所以总复杂度是 \\(\\mathcal O(nm)\\) 的。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 2007#define mod 998244353#define add(a, b) (a) = ((a) + (b)) % modvector&lt;int&gt; e[N];int f[N][N][2];int main() &#123; int n = rd(), m = rd(); int k = rd(), s = rd(), t = rd(), x = rd(); for (int i = 1; i &lt;= m; ++i) &#123; int u = rd(), v = rd(); e[u].push_back(v); e[v].push_back(u); &#125; f[0][s][x == s] = 1; for (int i = 0; i &lt; k; ++i) for (int u = 1; u &lt;= n; ++u) for (int k = 0; k &lt;= 1; ++k) &#123; if (!f[i][u][k]) continue; for (auto v : e[u]) &#123; int tar = (k ^ (v == x)); add(f[i + 1][v][tar], f[i][u][k]); &#125; &#125; printf(&quot;%d\\n&quot;, f[k][t][0]); return 0;&#125; F. Shortest Good Path 题意比较复杂，我简单描述一下。 定义无向图 \\(G=(V,E)\\) 的一个长度为 \\(K+1\\) 的路径序列 \\(\\{A\\}\\) ： 由 \\(K+1\\) 个点编号 \\(A_0,\\dots,A_K\\in V\\) 构成，\\(A_0\\) 是起点，\\(A_K\\) 是终点，且 \\(\\forall 0\\le i &lt; K, (A_i, A_{i+1})\\in E\\) 定义路径序列 \\(\\{A\\}\\) 符合要求序列 \\(S\\ (|S| = n, S_i = 0/1)\\) ，当且仅当： 若 \\(S_u = 0\\) ，则 \\(u\\) 在 \\(\\{A\\}\\) 中出现了偶数次（可以为 \\(0\\) ） 若 \\(S_u = 1\\) ，则 \\(u\\) 在 \\(\\{A\\}\\) 中出现了奇数次 那么对于所有的 \\(S=0,\\cdots,2^n-1\\) ，都会存在一个路径序列满足 \\(S\\) 的要求。 记满足 \\(S\\) 要求的路径序列最短为 \\(f(S)\\) ，求 \\(\\sum_{S=0}^{2^n-1}f(S)\\) 看到 ABC 出 \\(n\\le 17\\) 就是状压或者超级暴力了。 考虑路径之间互相更新转移，那么状态之间需要区分的，除了当前每个点出现奇数/偶数次以外，还有最后一个点的编号。 定义符合序列 \\(S\\) 且最后一个点是 \\(u\\) 的状态集编号为 sta[S][u] 。 那么对于每一个 \\(u\\to v\\) ，对所有的 \\(S\\) 连边 sta[S][u] -&gt; sta[S ^ (1 &lt;&lt; v)][v] 最后补上初始状态的连边 source -&gt; sta[1 &lt;&lt; u][u] 那么跑 BFS 就可以求出来每个状态所需的最小长度了（从 source 出发的距离） 那么 \\(f(S) = \\min_{u} dis[sta[S][u]]\\) 即可，复杂度即状态数乘转移数 \\(\\mathcal O(n^2\\ast 2^n)\\) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 17#define M 5000007#define pb push_backint id[1 &lt;&lt; N][N], cnt, dis[M];vector&lt;int&gt; e[M];queue&lt;int&gt; q;int main() &#123; int n = rd(), m = rd(); int S = (1 &lt;&lt; n) - 1; for (int s = 0; s &lt;= S; ++s) for (int u = 0; u &lt; n; ++u) id[s][u] = ++cnt; for (int i = 1; i &lt;= m; ++i) &#123; int u = rd() - 1, v = rd() - 1; for (int s = 0; s &lt;= S; ++s) &#123; e[id[s][u]].pb(id[s ^ (1 &lt;&lt; v)][v]); e[id[s][v]].pb(id[s ^ (1 &lt;&lt; u)][u]); &#125; &#125; for (int i = 0; i &lt; n; ++i) e[0].pb(id[1 &lt;&lt; i][i]); memset(dis, 0x3f, sizeof(dis)); dis[0] = 0; q.push(0); while (!q.empty()) &#123; int u = q.front(); q.pop(); for (auto v : e[u]) if (dis[v] &gt; dis[u] + 1) &#123;dis[v] = dis[u] + 1; q.push(v);&#125; &#125; ll ans = 0; for (int s = 1, tmp; s &lt;= S; ++s) &#123; tmp = 1e9; for (int u = 0; u &lt; n; ++u) &#123; tmp = min(tmp, dis[id[s][u]]); &#125; ans += tmp; &#125; printf(&quot;%lld\\n&quot;, ans); return 0;&#125; G. Construct Good Path 定义无向图 \\(G=(V,E)\\) 的一个长度为 \\(K+1\\) 的路径序列 \\(\\{A\\}\\) ： 由 \\(K+1\\) 个点编号 \\(A_0,\\dots,A_K\\in V\\) 构成，\\(A_0\\) 是起点，\\(A_K\\) 是终点，且 \\(\\forall 0\\le i &lt; K, (A_i, A_{i+1})\\in E\\) 定义路径序列 \\(\\{A\\}\\) 符合要求序列 \\(S\\ (|S| = n, S_i = 0/1)\\) ，当且仅当： 若 \\(S_u = 0\\) ，则 \\(u\\) 在 \\(\\{A\\}\\) 中出现了偶数次（可以为 \\(0\\) ） 若 \\(S_u = 1\\) ，则 \\(u\\) 在 \\(\\{A\\}\\) 中出现了奇数次 给定连通无向图 \\(G\\) 和要求序列 \\(S\\) ，构造一个长度不超过 \\(4\\ast |V|\\) 的序列符合 \\(S\\) 图只有连通的性质，那么可以考虑树怎么解决，其他情况找一棵生成树就可以了。 设 \\(A_u\\) 为 \\(u\\) 子树的合法序列：满足 \\(u\\) 子树内，除了 \\(u\\) 以外其他点都符合要求的一个序列。 强制叶子 \\(v\\) 对应的 \\(A_v=(v)\\) 。 其他情况如果令 \\(A_u=(u)+A_{son1}+(u)+A_{son2}+\\cdots+(u)\\) ，那么只有 \\(son\\) 这些节点会不合法。 那么对于每个导致不合法的 \\(son\\) ，给序列最后接上一个 \\((son,u)\\) 就可以保证 \\(son\\) 合法。 用数学归纳法做正确性证明：\\(|A_u|\\le 4 \\astsize_u-3\\) ，其中 \\(size_u\\) 为\\(u\\) 子树大小。对于叶子，\\(|A_u|=1=4\\ast1-3\\)假设对于一个点 \\(u\\)，所有儿子节点 \\(son\\)都符合，那么这个点的序列：必须添加 \\(cntson + 1\\) 个 \\((u)\\) ，还有所有的 \\(A_{son}\\)，其余的每个补充会增加两个点。\\[\\begin{array}{ll}|A_u| &amp; \\le \\sum_{son} A_{son} + cntson + 1 + 2 \\ast cntson\\\\\\\\\\ &amp; \\le \\sum_{son} (4 \\ast size_{son} - 3) + 3\\ast cntson +1\\\\\\\\\\ &amp; = 4 \\ast \\sum_{son} size_{son} - 3\\ast cntson + 3\\ast cntson+ 1\\\\\\\\\\ &amp; = 4 \\ast (size_u - 1) + 1\\\\\\\\\\ &amp; = 4 \\ast size_u - 3\\end{array}\\] 这样就证明了，最后根的序列大小不超过 \\(4N - 3\\) 。 最后序列中如果根节点奇偶性不对，那么随便找一个根节点的儿子 \\(son\\) ，补一个 \\((son,u,son)\\) 即可修正。 这样子序列长度的上限刚好是 \\(4N\\) ，复杂度 \\(\\mathcal{O}(n)\\)。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;inline bool gn() &#123; char c = getchar(); for (; !isdigit(c); c = getchar()); return c - &#x27;0&#x27;;&#125;#define N 100007#define pb push_backvector&lt;int&gt; e[N], res;bool vis[N], s[N];void add(int x) &#123; s[x] ^= 1; res.pb(x);&#125;void dfs(int u) &#123; vis[u] = 1; add(u); for (auto v : e[u]) if (!vis[v]) &#123; //当前点没在树里出现过 dfs(v); add(u); if (s[v]) &#123;add(v); add(u);&#125; &#125;&#125;int main() &#123; int n = rd(), m = rd(); for (int i = 1; i &lt;= m; ++i) &#123; int u = rd(), v = rd(); e[u].pb(v); e[v].pb(u); &#125; for (int i = 1; i &lt;= n; ++i) s[i] = gn(); dfs(1); if (s[1]) &#123; int son = e[1][0]; add(son); add(1); add(son); &#125; printf(&quot;%d\\n&quot;, (int)res.size()); for (auto x : res) printf(&quot;%d &quot;, x); return 0;&#125; Ex. Linear Maximization 维护一个二维向量集，支持： 插入一个二维向量 \\((x, y)\\) 查询集合中和给定向量 \\((u, v)\\) 点积的最大值 [SDOI2014]向量集 弱化版，线段树维护凸包即可。","categories":[{"name":"Solution","slug":"Solution","permalink":"http://blog.gyx.me/categories/Solution/"},{"name":"AtCoder","slug":"Solution/AtCoder","permalink":"http://blog.gyx.me/categories/Solution/AtCoder/"},{"name":"AtCoder Beginner Contest","slug":"Solution/AtCoder/AtCoder-Beginner-Contest","permalink":"http://blog.gyx.me/categories/Solution/AtCoder/AtCoder-Beginner-Contest/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"},{"name":"Constructive Algorithm","slug":"Constructive-Algorithm","permalink":"http://blog.gyx.me/tags/Constructive-Algorithm/"},{"name":"Bitmask","slug":"Bitmask","permalink":"http://blog.gyx.me/tags/Bitmask/"}]},{"title":"Google Code Jam to I/O for Women 2022","slug":"Google/codejamio2022","date":"2022-03-27T16:00:00.000Z","updated":"2022-08-11T14:34:05.313Z","comments":true,"path":"2022/03/28/Google/codejamio2022/","link":"","permalink":"http://blog.gyx.me/2022/03/28/Google/codejamio2022/","excerpt":"","text":"A. Inversions Organize 给你一个 \\(2n\\times 2n\\) 的 01 矩阵，问你最少反转多少个位置，能够做到上下两半1的个数相同，左右两半1的个数相同。 以中点为原点，设最后四个象限的 1 的个数分别为 \\(a,b,c,d\\) 。 需要满足：\\(a+b=b+c=c+d=d+a\\) ，可以推出 \\(a=c,b=d\\) 。 因此把一三象限 1 的个数调整到相同、二四象限 1 的个数调整到相同即可。 答案就是 \\(|cnt_1-cnt_3|+|cnt_2-cnt_4|\\) ，复杂度 \\(\\mathcal O(n^2)\\)。 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;inline int gc() &#123; char c = getchar(); while (!isalpha(c)) c = getchar(); return c == &#x27;I&#x27;;&#125;int testcase;inline void work() &#123; printf(&quot;Case #%d: &quot;, ++testcase); int n; cin &gt;&gt; n; int m = n * 2; int a = 0, b = 0; for (int i = 1; i &lt;= m; ++i) for (int j = 1; j &lt;= m; ++j) &#123; int x = gc(); if (i &lt;= n &amp;&amp; j &lt;= n) a += x; else if (i &lt;= n &amp;&amp; j &gt; n) b += x; else if (i &gt; n &amp;&amp; j &lt;= n) b -= x; else a -= x; &#125; printf(&quot;%d\\n&quot;, abs(a) + abs(b));&#125;int main() &#123; int t; cin &gt;&gt; t; for (; t; t--) work(); return 0;&#125; B. Ingredient Optimization 有 \\(n\\) 批货物，第 \\(i\\) 批货物有 \\(L_i\\) 个，\\(M_i\\) 时刻送达，\\(M_i+E_i\\) 时刻起就不能再用了。 有 \\(q\\) 个订单，第 \\(i\\) 个在 \\(O_i\\) 时刻 \\((O_{i-1}&lt;O_i)\\) ，需要 \\(U\\) 个货物制作。 某一次做不了商店就倒闭了（后面订单都不做），问最优策略下能完成多少个订单。 贪心即可，扫描订单，每次先把当前可用的集合用一个堆维护一下。 然后优先取用最早过保质期的商品即可，处理需要一些细节，复杂度 \\(\\mathcal{O}((n+q)\\log n)\\)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 107#define fr first#define sc second#define pb push_back#define mp make_pair#define pii pair&lt;int, int&gt;vector&lt;pii&gt; q;int testcase, a[N], b[N];struct node &#123; int id; inline bool operator &lt; (const node &amp;obj) const&#123; return b[id] &gt; b[obj.id]; &#125;&#125;;priority_queue&lt;node&gt; s;inline void work() &#123; q.clear(); while (!s.empty()) s.pop(); printf(&quot;Case #%d: &quot;, ++testcase); int n = rd(), m = rd(), u = rd(); for (int i = 1; i &lt;= n; ++i) &#123; int t = rd(); a[i] = rd(); b[i] = t + rd(); q.pb(mp(t, i)); q.pb(mp(b[i], -i)); &#125; sort(q.begin(), q.end()); int ans = 0, fl = 1; for (int i = 1, ptr = 0; i &lt;= m; ++i) &#123; int t = rd(); while (ptr &lt; 2 * m &amp;&amp; q[ptr].fr &lt;= t) &#123; if (q[ptr].sc &lt; 0) a[-q[ptr].sc] = 0; else s.push((node)&#123;q[ptr].sc&#125;); ++ptr; &#125; int tmp = u; while (tmp &amp;&amp; !s.empty()) &#123; int id = s.top().id; int del = min(a[id], tmp); tmp -= del; a[id] -= del; if (a[id] == 0) s.pop(); &#125; if (tmp) fl = 0; ans += fl; &#125; printf(&quot;%d\\n&quot;, ans);&#125;int main() &#123; int t; cin &gt;&gt; t; for (; t; t--) work(); return 0;&#125; C. Interesting Outing 给一棵树，有边权，求一个最短的路径，使得所有点都至少被访问到一次。 定义 \\(f_{i,0/1}\\) 表示 \\(i\\) 的子树全部访问完，回到 / 不回到 \\(i\\) 的最短路径长度，答案就是 \\(f_{root,1}\\) 转移方程：设 \\(w_{i, son}\\) 表示 \\(i\\) 和儿子 \\(son\\) 之间的边权。 \\(f_{i,0}=\\sum_{son}(f_{son,0}+w_{i, son})\\) ， \\(f_{i,1}=f_{i,0}-\\max_{son}(f_{son,0}-f_{son,1} + w_{i,son})\\) 复杂度 \\(\\mathcal{O}(n)\\) 。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 1007int testcase, hd[N], tot;struct edge &#123;int to, nxt, w;&#125;e[N &lt;&lt; 1];ll f[N][2];void dfs(int u, int fa) &#123; ll mx = 0; for (int i = hd[u], v; i; i = e[i].nxt) if ((v = e[i].to) != fa) &#123; dfs(v, u); f[u][0] += f[v][0] + 2 * e[i].w; mx = max(mx, f[v][0] - f[v][1] + e[i].w); &#125; f[u][1] = f[u][0] - mx;&#125;inline void work() &#123; printf(&quot;Case #%d: &quot;, ++testcase); tot = 0; memset(hd, 0, sizeof(hd)); int n = rd(); for (int i = 1; i &lt; n; ++i) &#123; int u = rd(), v = rd(), w = rd(); e[++tot].to = v; e[tot].w = w; e[tot].nxt = hd[u]; hd[u] = tot; e[++tot].to = u; e[tot].w = w; e[tot].nxt = hd[v]; hd[v] = tot; &#125; ll ans = 1e18; for (int i = 1; i &lt;= n; ++i) &#123; memset(f, 0, sizeof(f)); dfs(i, i); ans = min(ans, min(f[i][0], f[i][1])); &#125; printf(&quot;%lld\\n&quot;, ans);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; D. Inventor Outlasting 给定一个 \\(R\\times C\\) 的地图，上面有黄色和绿色的点。 两个人博弈，每次可以选择一个黄色的点操作，不能操作的人输。 操作就是把这个点染黑，然后从个点按照 X 形发散染黑。具体的，就是从这个点开始按照四个 \\(45^\\circ\\) 方向扩展把所有点染黑，直到碰到边界，或当前要染的格子已经被染黑后，不继续往这个方向扩展。 问先手第一步有多少种不同的下法保证必胜。 首先观察这个地图可以拆成两张，按照 \\((\\) 行号+列号 \\()\\) 的奇偶性可以把图分开，互不影响。 进一步的，如果把坐标系转 \\(45^\\circ\\) ，可以发现每次操作就相当于把一个以黑色为边界的矩形横竖各切一刀。 所以其实是把当前的游戏转化成了四个子游戏的并，根据 SG 引理，当前状态的 SG 值就是四个子游戏的 SG 值的异或。 本质不同的游戏数取决于当前“矩形”在原地图中的位置，所以有 \\(O(R^2\\times C^2)\\) 个。 每次枚举下一个操作的是哪个位置，复杂度 \\(\\mathcal{O}(R\\times C)\\) ，所以记忆化搜索 SG 函数总复杂度 \\(\\mathcal{O}(R^3\\times C^3)\\) 。 需要注意第一次的选择的时候，是把游戏划分为五种情况的并，除了四个子矩形，还有另外一张图（奇偶性不同）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;inline int gc() &#123; char c = getchar(); for (; c != &#x27;.&#x27; &amp;&amp; c != &#x27;X&#x27;; c = getchar()); return c == &#x27;X&#x27;;&#125;#define N 107#define pb push_backbool a[2][N][N];int testcase;unordered_map&lt;ll, int&gt; sg;inline ll hash_scope(ll id, ll a, ll b, ll c, ll d) &#123; return (((a * 200 + b) * 200 + c) * 200 + d) * 2 + id;&#125;int dp(int id, int lx, int rx, int ly, int ry) &#123; if (lx &gt; rx || ly &gt; ry) return 0; ll h = hash_scope(id, lx, rx, ly, ry); if (sg.find(h) != sg.end()) return sg[h]; vector&lt;int&gt; nxt; nxt.clear(); for (int x = lx; x &lt;= rx; ++x) for (int y = ly; y &lt;= ry; ++y) if (a[id][x][y]) &#123; int a = dp(id, lx, x - 1, ly, y - 1); int b = dp(id, lx, x - 1, y + 1, ry); int c = dp(id, x + 1, rx, ly, y - 1); int d = dp(id, x + 1, rx, y + 1, ry); nxt.pb(a ^ b ^ c ^ d); &#125; sort(nxt.begin(), nxt.end()); for (int i = 0, ptr = 0; ; ++i) &#123; if (ptr &gt;= nxt.size() || nxt[ptr] &gt; i) return sg[h] = i; for (; ptr &lt; nxt.size() &amp;&amp; nxt[ptr] == i; ++ptr); &#125;&#125;inline void work() &#123; sg.clear(); memset(a, 0, sizeof(a)); int r = rd(), c = rd(); int lx = 1e9, ly = 1e9; int rx = -1e9, ry = -1e9; for (int i = 1; i &lt;= r; ++i) for (int j = 1; j &lt;= c; ++j) &#123; int id = ((i + j) &amp; 1); int x = (i + j) / 2; int y = (i - j + 100) / 2; if ((a[id][x][y] = gc())) &#123; lx = min(lx, x); rx = max(rx, x); ly = min(ly, y); ry = max(ry, y); &#125; &#125; int ans = 0; for (int id = 0; id &lt;= 1; ++id) for (int x = lx; x &lt;= rx; ++x) for (int y = ly; y &lt;= ry; ++y) if (a[id][x][y]) &#123; int a = dp(id, lx, x - 1, ly, y - 1); int b = dp(id, lx, x - 1, y + 1, ry); int c = dp(id, x + 1, rx, ly, y - 1); int d = dp(id, x + 1, rx, y + 1, ry); ans += ((a ^ b ^ c ^ d ^ dp(id ^ 1, lx, rx, ly, ry)) == 0); &#125; printf(&quot;Case #%d: %d\\n&quot;, ++testcase, ans);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"http://blog.gyx.me/categories/Solution/"},{"name":"Google","slug":"Solution/Google","permalink":"http://blog.gyx.me/categories/Solution/Google/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"},{"name":"Greedy","slug":"Greedy","permalink":"http://blog.gyx.me/tags/Greedy/"},{"name":"Game Theory","slug":"Game-Theory","permalink":"http://blog.gyx.me/tags/Game-Theory/"}]},{"title":"Codeforces Round #777 (Div. 2)","slug":"Codeforces/cf777","date":"2022-03-18T16:00:00.000Z","updated":"2022-05-19T01:11:58.678Z","comments":true,"path":"2022/03/19/Codeforces/cf777/","link":"","permalink":"http://blog.gyx.me/2022/03/19/Codeforces/cf777/","excerpt":"","text":"A 和 B 比较简单就不写了。 C. Madoka and Childish Pranks 一个初始是全白的矩阵，每次可以选一个子矩阵染成棋盘（左上角是白色） 构造一个不超过 \\(n*m\\) 次的方法把矩阵染成目标样子，或输出无解。 Key ：每次染一个 \\(1\\ast 2\\) 的，可以把右侧的变黑，\\(2\\ast 1\\) 的可以把下侧的变黑。 因此对于每一行，我又可以从右往左依次染 \\(1\\ast 2\\) ，除第一列任何位置都可以染黑。 对于第一列从下往上依次染 \\(2\\ast 1\\) ，除 \\((1,1)\\) 位置外都可以染黑。 所以只要 \\((1,1)\\) 不是黑色的就都有解。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;inline int gn() &#123; char c = getchar(); for (; !isdigit(c); c = getchar()); return c - &#x27;0&#x27;;&#125;#define N 107#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;int a[N][N];vector&lt;pair&lt;pii,pii&gt;&gt; s;inline void work() &#123; s.clear(); int n = rd(), m = rd(); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) a[i][j] = gn(); if (a[1][1]) &#123;puts(&quot;-1&quot;); return;&#125; for (int i = 1; i &lt;= n; ++i) for (int j = m; j &gt; 1; --j) if (a[i][j]) s.pb(mp(mp(i,j - 1), mp(i, j))); for (int i = n; i &gt; 1; --i) if (a[i][1]) s.pb(mp(mp(i - 1, 1), mp(i, 1))); printf(&quot;%d\\n&quot;, (int)s.size()); for (auto x : s) printf(&quot;%d %d %d %d\\n&quot;, x.fr.fr, x.fr.sc, x.sc.fr, x.sc.sc);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; D. Madoka and the Best School in Russia 定义一个数字 \\(x\\) 是好的，当且仅当 \\(x\\) 是 \\(d\\) 的倍数。 定义一个数字 \\(x\\) 是漂亮的，当且仅当他不能被拆分成两个好的数的乘积（也就是只含有一个 \\(d\\) ） 给你一个好的数 \\(x\\) ，问你是否有至少两种不同的方法，把 \\(x\\) 拆成若干个漂亮的数的乘积。 方法不同即拆分得到的数集不同。 因为每个漂亮数有且仅有一个 \\(d\\) ，因此 \\(x\\) 里有几个 \\(d\\) ，就至多要拆成几个漂亮数。 先考虑把 \\(x\\) 里的 \\(d\\) 都去掉，剩下的数是 \\(y\\) ，我们至少得到一种方案是 \\(d,d,\\dots,d,d\\ast y\\) 如果 \\(y\\) 可以拆分（不是素数），那么就肯定有解； 如果 \\(y\\) 不可拆分： 如果 \\(d\\) 不可拆分，肯定无解（没有可拆的了） 如果 \\(x\\) 里只有两个 \\(d\\) ，肯定无解（没有可拆的了） 如果 \\(x\\) 里有超过三个 \\(d\\) ，肯定有解（把 \\(y\\) 和 \\(d\\) 拆分得到的三个数，分配给另外三个 \\(d\\) ） 如果 \\(x\\) 里正好有三个 \\(d\\) ，需要检验一下把 \\(d\\) 拆出来的两部分某一部分分给 \\(y\\) 会不会形成新的 \\(d\\) 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 107inline void work() &#123; int x = rd(), d = rd(); if (x % d != 0) &#123;puts(&quot;NO&quot;); return;&#125; if (x / d % d != 0) &#123;puts(&quot;NO&quot;); return;&#125; int cnt = 0; for (; x % d == 0; x /= d, ++cnt); int lim = sqrt(x); for (int i = 2; i &lt;= lim; ++i) if (x % i == 0) &#123;puts(&quot;YES&quot;); return;&#125; if (cnt == 2) &#123;puts(&quot;NO&quot;); return;&#125; lim = sqrt(d); for (int i = 2; i &lt;= lim; ++i) if (d % i == 0) &#123; if (cnt &gt; 3) &#123;puts(&quot;YES&quot;); return;&#125; if (1ll * i * x % d != 0 || 1ll * d / i * x % d != 0) &#123;puts(&quot;YES&quot;); return;&#125; &#125; puts(&quot;NO&quot;);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; E. Madoka and the Sixth-graders 题意太复杂，我简单说一下，不清楚的看原题。 给定一个共 \\(n\\) 个点的内向基环树森林，开始每个点上有一个数（是 \\(n\\) 的排列）。 每一个时刻所有点按照所在边移动一次，如果某一时刻某个点上有很多数，只保留最小的。 如果某一时刻某个点上没数了（叶子），那么按照节点编号从小到大依次往里面塞 \\(n+1,n+2,\\dots\\) 现在给出森林的形态，和经过若干时刻后每个点上的数字 \\(a_1,\\dots,a_n\\) 。 请你还原出来一个字典序最小的初始状态，保证有解。 Key 1 ：假设已知经过的时间是 \\(t\\) ，那么每个点按照边移动 \\(t\\) 步以后的位置上的数字一定是不超过 \\(n\\) 的。 证明：如果是树的部分，那么 \\(n\\) 以后的数字永远追不上；如果是环的部分，因为 \\(n\\) 以后的数字比 \\(n\\) 大，所以都会被舍弃。 Key 2 ：两个点如果在某一步之后同时移动到了同一个点，那么后面的路径都相同（因为每个点只有一个出边）。 找出经过的时间 \\(t\\) ：假设叶子个数是 \\(cnt\\) ，序列里最大是 \\(mx\\) ，那么 \\(t=\\frac{mx - n}{cnt}\\) （每一次移动会引进 \\(cnt\\) 个数）。 每个位置可能会放哪个数？ 根据前面提到的 Key，假设 \\(u\\) 走 \\(t\\) 步之后到达的点是 \\(v\\) ，那么 \\(u\\) 上开始的数字要么是 \\(a_v\\) ，要么比 \\(a_v\\) 大，在移动的过程中某一步被挤掉了。 也就是说，如果一个点集 \\(S\\) 里所有点走 \\(t\\) 步以后到达的点都是 \\(v\\) ，那么这些点初始状态里有一个必定是 \\(a_v\\) ，其他都比 \\(a_v\\) 大。 怎么找 \\(v\\) ：因为每个点都只有一条出边，因此可以直接倍增找 怎么贪心？ 我们先令结果序列 \\(b_u=a_v\\) ，也就是假设每个点的初始状态就是走 \\(t\\) 步以后的位置上的值。 设 \\(S_x=\\\\{u|b_u=x\\\\}\\) ，考虑从小到大放数字 \\(x\\) ： 如果 \\(S_x\\ne \\emptyset\\) ，那么就把 \\(x\\) 放到 \\(S_x\\) 中位置最靠前的 如果 \\(S_x=\\emptyset\\) ，那么就把 \\(x\\) 放到 \\(S_1\\cup S_2\\cup\\dots\\cup S_{x-1}\\) 中未使用的最靠前的位置里。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 100007int f[N][40], a[N], res[N];bool vis[N];queue&lt;int&gt; s[N];set&lt;int&gt; S;inline void work() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; f[i][0] = rd(); vis[f[i][0]] = 1; &#125; for (int j = 1; j &lt; 40; ++j) for (int i = 1; i &lt;= n; ++i) f[i][j] = f[f[i][j - 1]][j - 1]; int mx = 0, cnt = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (!vis[i]) ++cnt; a[i] = rd(); mx = max(mx, a[i]); &#125; cnt = (mx - n) / cnt; memset(vis, 0, sizeof(vis)); for (int i = 1; i &lt;= n; ++i) &#123; int u = i; for (int k = 30; k &gt;= 0; --k) if (cnt &amp; (1 &lt;&lt; k)) u = f[u][k]; res[i] = a[u]; s[res[i]].push(i); vis[res[i]] = 1; //Sx不空 &#125; for (int i = 1; i &lt;= n; ++i) if (vis[i]) s[i].pop(); //把i放到Si最靠前的位置 int nw = 0; for (int i = 1; i &lt;= n; ++i) if (!vis[i]) &#123; while (nw &lt;= i) &#123; while (s[nw].size()) &#123; S.insert(s[nw].front()); s[nw].pop(); &#125; ++nw; &#125; res[*S.begin()] = i; S.erase(S.begin()); &#125; for (int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, res[i]);&#125;int main() &#123; for (int t = 1; t; --t) work(); return 0;&#125; F. Madoka and Laziness 给定一个没有重复数值的数列 \\(\\{a_i\\}\\) ，问有多少种方式将数列划分为两个峰序列（严格单增再单减）。 两种划分不同，当且仅当至少某一个峰序列的峰值不同（认为 &lt;a,b&gt; 和 &lt;b,a&gt; 相同）。 Key ：最大值一定是其中一个峰的峰值。 这个观察有什么用呢？因为一个峰值固定，我们可以得到答案是 O(n) 的。 也就是说，我们只需要去检验，其他的每一个值是否有可能成为峰值即可。 怎么检验呢？只需要判断是否存在一种拆分方式，使得到每个位置之前是升的，过了这个位置之后是降的，并且没给这个序列的元素扔给最大值所在的序列都合法。 我们可以假设另一个峰值（峰值B）在最大值（峰值A）的右侧，然后把序列翻过来再做一遍即可。 这样就有三个阶段： 到峰值A前：两个序列都上升 这一阶段序列A里只要单调递增，放多大的都可以。 我们为了后面序列B还要增的考虑，应该尽量减少序列B在这一部分的最大值。 设 \\(f_i\\) 为考虑前缀 \\(i\\) ，则 \\(a_i\\) 必定为某一个序列结尾，则另一个序列结尾最小值是多少。 转移很简单，接在 \\(a_{i-1}\\) 后，或接在 \\(f_{i-1}\\) 后。 12if (a[i] &gt; a[i - 1]) f[i] = min(f[i], f[i - 1]);if (a[i] &gt; f[i - 1]) f[i] = min(f[i], a[i - 1]); 峰值A后，峰值B前：序列A下降，序列B上升 这一阶段因为两个序列单调性不同，所以贪心策略也不同。 设 \\(g_{i,0}\\) 表示第 \\(i\\) 个元素放到序列A里，另一个序列（正在上升的序列B）末尾最小是多少。 设 \\(g_{i,1}\\) 表示第 \\(i\\) 个元素放到序列B里，另一个序列（正在下降的序列A）末尾最大是多少。 转移也很简单，讨论一下接在谁后面就好了。 1234if (a[i] &lt; a[i - 1]) g[i][0] = min(g[i][0], g[i - 1][0]);if (a[i] &lt; g[i - 1][1]) g[i][0] = min(g[i][0], a[i - 1]);if (a[i] &gt; a[i - 1]) g[i][1] = max(g[i][1], g[i - 1][1]);if (a[i] &gt; g[i - 1][0]) g[i][1] = max(g[i][1], a[i - 1]); 峰值B后：两个序列都下降 倒着考虑，变成单增的，那么在保证峰值B跟着的序列合法的前提下，另一个序列（留给峰值A的）的最大值要尽可能小。 因此处理方法同第一个阶段（设为 \\(h\\) 数组）。 那么怎么判断是否合法嘞？把 \\(a_i\\) 放到序列B里，另一个序列合法（ 也就是满足 g[i][1] &gt; h[i] ） 就可以啦～ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 500007#define inf 1e9 + 7int n, a[N], f[N], g[N][2];inline int calc() &#123; int p = 0; //maxpos for (int i = 1; i &lt;= n; ++i) &#123; f[i] = g[i][0] = inf; g[i][1] = -1; if (a[i] &gt; a[p]) p = i; &#125; for (int i = 1; i &lt;= p; ++i) &#123; if (a[i] &gt; a[i - 1]) f[i] = min(f[i], f[i - 1]); if (a[i] &gt; f[i - 1]) f[i] = min(f[i], a[i - 1]); &#125; g[p][0] = f[p]; //承接第一阶段的最宽松约束 for (int i = p + 1; i &lt;= n; ++i) &#123; if (a[i] &lt; a[i - 1]) g[i][0] = min(g[i][0], g[i - 1][0]); if (a[i] &lt; g[i - 1][1]) g[i][0] = min(g[i][0], a[i - 1]); if (a[i] &gt; a[i - 1]) g[i][1] = max(g[i][1], g[i - 1][1]); if (a[i] &gt; g[i - 1][0]) g[i][1] = max(g[i][1], a[i - 1]); &#125; int ans = 0; for (int i = n; i &gt; p; --i) &#123; if (a[i] &gt; a[i + 1]) f[i] = min(f[i], f[i + 1]); if (a[i] &gt; f[i + 1]) f[i] = min(f[i], a[i + 1]); if (g[i][1] &gt; f[i]) ++ans; &#125; return ans;&#125;int main() &#123; n = rd(); for (int i = 1; i &lt;= n; ++i) a[i] = rd(); int ans = calc(); reverse(a + 1, a + 1 + n); printf(&quot;%d\\n&quot;, ans + calc()); return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"http://blog.gyx.me/categories/Solution/"},{"name":"Codeforces","slug":"Solution/Codeforces","permalink":"http://blog.gyx.me/categories/Solution/Codeforces/"},{"name":"Codeforces Round","slug":"Solution/Codeforces/Codeforces-Round","permalink":"http://blog.gyx.me/categories/Solution/Codeforces/Codeforces-Round/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"},{"name":"Constructive Algorithm","slug":"Constructive-Algorithm","permalink":"http://blog.gyx.me/tags/Constructive-Algorithm/"}]},{"title":"Programming Ability Test Autumn 2021","slug":"pat2021","date":"2021-09-11T09:43:27.000Z","updated":"2021-10-11T09:43:27.000Z","comments":true,"path":"2021/09/11/pat2021/","link":"","permalink":"http://blog.gyx.me/2021/09/11/pat2021/","excerpt":"","text":"Background 某天心血来潮拉上 Eva 同学一起报名了 PAT ～ 开学前在 官方题库 里刷了两道题热身！其实是想刷完但是太鸽了 然后就到考试时间啦！借着考试翘掉了半天的军训！好耶！ Solution ( Top Level ) 代码写的赶时间，比较丑。 A. Sorted Cartesian tree 给定 \\(n\\) 个pair&lt;priority, key&gt; ，构建一棵 \\(n\\) 个节点的二叉树，满足：节点 priority 关键字满足堆的性质，即priority 父节点小于子节点节点 key 关键字满足二叉搜索树的性质，即中序遍历key 单调不降把树建出来，输出 priority 和 key 的Level-order traversal 序列 模拟题意 dfs 建树，传一个 set&lt;node&gt; 即可。 求层序遍历一个 bfs 就够了 考场上写了个dfn+dep双关键字排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;#define N 37using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125; struct node &#123;int k, p, id;&#125; c[N];inline bool operator &lt; (const node &amp;a, const node &amp;b) &#123; if (a.p != b.p) return a.p &lt; b.p; if (a.k != b.k) return a.k &lt; b.k; return a.id &lt; b.id;&#125;int ls[N], rs[N], k[N], p[N];set&lt;node&gt; S;int dfs(set&lt;node&gt; s) &#123; if (s.empty()) return 0; node nw = *s.begin(); s.erase(nw); set&lt;node&gt; l, r; for (auto t : s) &#123; if (t.k &lt;= nw.k) l.insert(t); else r.insert(t); &#125; ls[nw.id] = dfs(l); rs[nw.id] = dfs(r); return nw.id;&#125;queue&lt;int&gt; q;int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; c[i].id = i; c[i].k = rd(); c[i].p = rd(); S.insert(c[i]); &#125; int ptr = 0, rt = dfs(S); q.push(rt); while (!q.empty()) &#123; int u = q.front(); q.pop(); if (ls[u]) q.push(ls[u]); if (rs[u]) q.push(rs[u]); k[++ptr] = c[u].k; p[ptr] = c[u].p; &#125; for (int i = 1; i &lt; n; ++i) printf(&quot;%d &quot;, k[i]); printf(&quot;%d\\n&quot;, k[n]); for (int i = 1; i &lt; n; ++i) printf(&quot;%d &quot;, p[i]); printf(&quot;%d&quot;, p[n]); return 0;&#125; B. Unity is Strength 给一张有权无向图，以及若干条可以花 \\(w_i\\) 连接 \\(u_i,v_i\\) 的无向边。先输出每个联通块的 \"块内最小编号 - 块内最小边权\"，按照块大小-最小边权-最小点编号的顺序排序然后计算把整个图联通的最小代价，除给定边外，任意两点之间都可以花\\(10^4\\) 的代价连接一条边。 并查集模拟题意即可，第一步求出来每个集合的若干信息，然后排序一下。 之后就是最小生成树，考虑给定边不一定能让整个图联通，最后答案加上（联通块数 \\(-1\\) ）\\(\\times 10^4\\) 即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;#define N 100007#define inf 1e9using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125; int f[N], mn[N], mnid[N], sz[N], totr, totc;struct road &#123; int u, v, w;&#125;r[N]; inline bool cmp2(road a, road b) &#123; return a.w &lt; b.w;&#125; inline int find(int x) &#123; return x == f[x] ? x : f[x] = find(f[x]);&#125;inline void merge(int a, int b, int w) &#123; a = find(a); b = find(b); if (a == b) &#123; mn[a] = min(mn[a], w); return; &#125; f[a] = b; sz[b] += sz[a]; mnid[b] = min(mnid[b], mnid[a]); mn[b] = min(mn[b], min(mn[a], w));&#125;struct node &#123; int mnid, sz, str;&#125;c[N]; inline bool cmp1(node a, node b) &#123; if (a.str != b.str) return a.str &gt; b.str; if (a.sz != b.sz) return a.sz &gt; b.sz; return a.mnid &lt; b.mnid;&#125;int main() &#123; int n = rd(); int m = rd(); for (int i = 1; i &lt;= n; ++i) &#123; f[i] = i; mn[i] = inf; mnid[i] = i; sz[i] = 1; &#125; for (int i = 1, u, v, w; i &lt;= m; ++i) &#123; u = rd(); v = rd(); w = rd(); if (w &gt; 0) merge(u, v, w); else r[++totr] = (road)&#123;u, v, -w&#125;; &#125; for (int i = 1; i &lt;= n; ++i) if (f[i] == i) c[++totc] = (node)&#123;mnid[i], sz[i], (mn[i] == inf ? 0 : mn[i])&#125;; sort(c + 1, c + 1 + totc, cmp1); for (int i = 1; i &lt; totc; ++i) printf(&quot;%d-%d &quot;, c[i].mnid, c[i].str); printf(&quot;%d-%d\\n&quot;, c[totc].mnid, c[totc].str); int ans = 0; sort(r + 1, r + 1 + totr, cmp2); for (int i = 1; i &lt;= totr; ++i) &#123; int u = find(r[i].u); int v = find(r[i].v); if (u != v) &#123;merge(u, v, r[i].w); ans += r[i].w;&#125; &#125; int cnt = 0; for (int i = 1; i &lt;= n; ++i) cnt += (f[i] == i); ans += (cnt - 1) * 10000; printf(&quot;%d&quot;, ans); return 0;&#125; C. Manhattan 给定一个序列 \\(\\{ a_i \\}\\ (1\\le a_i\\le3)\\)，两个人玩（开始双方均为 \\(0\\) 分），每次某个人取走最靠前的 \\(a_i\\) 加到当前的得分里。要求每个人拿完之后，当前的得分不得少于对方，问有多少种划分方案，答案\\(\\mod 10^ 9 + 7\\) 裸的 DP 就是 f[i][j] 表示当前考虑前 \\(i\\) 个数，第一个人比第二个人多 \\(j\\) 的方案数。 因为 \\(a_i\\le 3\\) ，所以如果某个人比另一个人多了超过 \\(3\\) 分，对手就无法满足要求，之后就只能是这个人拿了。 所以 j 可以把特殊的状态放到一起，范围就只有 \\(9\\) 了，复杂度 \\(O (9n)\\) ，转移要注意条件。 实现的时候整体偏移了 \\(5\\) ，也就是 \\(j=5\\) 时两个人得分一样。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;#define N 100007#define mod 1000000007using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125; int f[N][10];#define add(a,b) a = (a + b) % modint main() &#123; f[0][5] = 1; int n = rd(); for (int i = 1, x; i &lt;= n; ++i) &#123; x = rd(); for (int j = 1; j &lt;= 9; ++j) &#123; if (j - x &lt;= 1) add(f[i][1], f[i - 1][j]); if (j + x &gt;= 9) add(f[i][9], f[i - 1][j]); &#125; for (int j = 2; j &lt;= 8; ++j) &#123; if (j - x &gt; 1 &amp;&amp; j - x &lt;= 5) add(f[i][j - x], f[i - 1][j]); if (j + x &lt; 9 &amp;&amp; j + x &gt;= 5) add(f[i][j + x], f[i - 1][j]); &#125; &#125; int ans = 0; for (int i = 1; i &lt;= 9; ++i) add(ans, f[n][i]); printf(&quot;%d&quot;, ans); return 0;&#125; Summary 比赛之前比较焦虑（毕竟军训一周都没碰键盘），到考场发现左边坐的是学长。 开场把三个题都开了， 题目描述都十分迷惑（英语太差），结合样例枚举题意读题。 分不清：Preorder 先序；Inorder 中序；Postorder 后序；Level-order traversal 层序遍历 过题顺序 T2 - T1 - T3 ，看榜应该是 Rank 2，所有题都是一次过非常舒适。 然后就提前跑路了！因为 Eva 同学还在奋战，我就开始快乐的浙传半日游～ 浙传的校园就比较有感觉，总觉得杭电的楼都是一个样子的，缺点大学的气息... 井盖上超级可爱的小王子和狐狸～","categories":[{"name":"Solution","slug":"Solution","permalink":"http://blog.gyx.me/categories/Solution/"},{"name":"Others","slug":"Solution/Others","permalink":"http://blog.gyx.me/categories/Solution/Others/"}],"tags":[{"name":"DFS and Similar","slug":"DFS-and-Similar","permalink":"http://blog.gyx.me/tags/DFS-and-Similar/"},{"name":"Union-Find Set","slug":"Union-Find-Set","permalink":"http://blog.gyx.me/tags/Union-Find-Set/"},{"name":"Counting","slug":"Counting","permalink":"http://blog.gyx.me/tags/Counting/"}]},{"title":"AtCoder Beginner Contest 216","slug":"Atcoder/abc216","date":"2021-08-29T13:37:14.000Z","updated":"2022-05-19T01:11:38.805Z","comments":true,"path":"2021/08/29/Atcoder/abc216/","link":"","permalink":"http://blog.gyx.me/2021/08/29/Atcoder/abc216/","excerpt":"","text":"E. Amusement Park 给定 \\(n\\) 个数，最多 \\(k\\) 次操作，每次可以拿走某个数 \\(a_i\\) 加入得分，然后把 \\(a_i-1\\) 放回，问得分最大值，\\(k,a_i\\le 2\\times 10^9\\) 二分最后剩下的所有数里的最大值为 \\(x\\) ，答案是把所有数都拿到 \\(x\\) 的得分，然后加上剩下次数个 \\(x\\) 的得分。 需要注意二分上界 \\(r = 2\\times 10^9\\) ，所以二分 mid = (l + r) / 2 的时候可能会爆 int 。坑死我了 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;#define N 200007using namespace std;typedef long long ll;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for(; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for(; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;ll n, k, a[N];inline bool valid(ll x) &#123; ll cnt = 0; for (int i = 1; i &lt;= n; ++i) if (a[i] &gt; x) cnt += a[i] - x; return cnt &lt;= k;&#125;inline ll sum(ll l, ll r) &#123; return (l + r) * (r - l + 1) / 2;&#125;int main() &#123; n = rd(); k = rd(); for (int i = 1; i &lt;= n; ++i) a[i] = rd(); ll l = 0, r = 2e9; while (l &lt; r) &#123; ll mid = (l + r) / 2; valid(mid) ? r = mid : l = mid + 1; &#125; ll ans = 0; for (int i = 1; i &lt;= n; ++i) if (a[i] &gt; l) &#123; ans += sum(l + 1, a[i]); k -= a[i] - l; &#125; ans += k * l; printf(&quot;%lld\\n&quot;, ans); return 0;&#125; F. Max Sum Counting 有 \\(n\\) 个数对 \\((A_i, B_i)\\)构成一个集合，问有多少个子集，满足子集内 \\(A\\) 的最大值大于 \\(B\\) 的和。 考虑枚举最大的 \\(A\\) 是谁，将所有数对按照 \\(A\\) 从小到大排序，问题转化为选哪些 \\(B\\) 。 假设现在考虑排序后第 \\(i\\) 个数对，则 \\(B_i\\) 必选，相当于计数 \\(B_1,\\cdots,B_{i-1}\\) 中选出若干，且总和不超过 \\(A_i-B_i\\) 的方案数。 因为 \\(A\\) 的值域很小，搞一个 01 背包计数即可，复杂度 \\(O(n\\times \\max A_i)\\) 。 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;#define N 5007#define mod 998244353using namespace std;typedef long long ll;int n, f[N] = &#123;1&#125;;struct node &#123;int a, b;&#125; c[N];inline bool operator &lt; (const node &amp;a, const node &amp;b) &#123; return a.a == b.a ? a.b &lt; b.b : a.a &lt; b.a;&#125;int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;c[i].a); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;c[i].b); sort(c + 1, c + 1 + n); int ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; for (int v = 0; v &lt;= c[i].a - c[i].b; ++v) ans = (ans + f[v]) % mod; for (int v = N - 1; v &gt;= c[i].b; --v) f[v] = (f[v] + f[v - c[i].b]) % mod; &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125; G. 01Sequence 构造长度为 \\(n\\) 的 \\(01\\) 序列，满足 \\(k\\) 个形如 “ \\([l_i,r_i]\\) 内至少有 \\(x_i\\) 个 \\(1\\) ” 的条件，且 \\(1\\) 的个数最少。 将约束条件按照右端点从小到大排序，考虑每个条件当前还未满足的个数。 则对于每个 \\(1\\) ，在可行的范围内往右放的贡献不低于往左放，因此从右边界依次放过来即可。 查询未满足的个数需要维护一个树状数组，复杂度 \\(O(n\\log n)\\) 。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;#define N 200007using namespace std;typedef long long ll;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for(; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for(; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;int cur[N], vis[N];#define lowbit(x) (x &amp; -x)inline void add(int x) &#123; for (; x &lt; N; x += lowbit(x)) ++cur[x];&#125;inline int calc(int x) &#123; int res = 0; for (; x; x -= lowbit(x)) res += cur[x]; return res;&#125;struct node &#123;int l, r, k;&#125; c[N];inline bool operator &lt; (const node &amp;a, const node &amp;b) &#123;return a.r &lt; b.r;&#125;int main() &#123; int n = rd(); int m = rd(); for (int i = 1; i &lt;= m; ++i) &#123; c[i].l = rd(); c[i].r = rd(); c[i].k = rd(); &#125; sort(c + 1, c + 1 + m); for (int i = 1; i &lt;= m; ++i) &#123; int nw = calc(c[i].r) - calc(c[i].l - 1); for (int ptr = c[i].r; nw &lt; c[i].k; --ptr) if (!vis[ptr]) &#123; add(ptr); ++nw; vis[ptr] = 1; &#125; &#125; for (int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, vis[i]); return 0;&#125; H. Random Robots","categories":[{"name":"Solution","slug":"Solution","permalink":"http://blog.gyx.me/categories/Solution/"},{"name":"AtCoder","slug":"Solution/AtCoder","permalink":"http://blog.gyx.me/categories/Solution/AtCoder/"},{"name":"AtCoder Beginner Contest","slug":"Solution/AtCoder/AtCoder-Beginner-Contest","permalink":"http://blog.gyx.me/categories/Solution/AtCoder/AtCoder-Beginner-Contest/"}],"tags":[{"name":"Greedy","slug":"Greedy","permalink":"http://blog.gyx.me/tags/Greedy/"},{"name":"Knapsack Problem","slug":"Knapsack-Problem","permalink":"http://blog.gyx.me/tags/Knapsack-Problem/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"http://blog.gyx.me/tags/Binary-Search/"}]},{"title":"AtCoder Beginner Contest 214","slug":"Atcoder/abc214","date":"2021-08-14T13:58:14.000Z","updated":"2022-05-19T01:20:35.279Z","comments":true,"path":"2021/08/14/Atcoder/abc214/","link":"","permalink":"http://blog.gyx.me/2021/08/14/Atcoder/abc214/","excerpt":"","text":"D. Sum of Maximum Weights 给定一棵树，边有边权。计算所有点对路径上最大边权的权值和，范围 \\(n\\le 10^5\\) 考虑类似 Kruskal 的过程添加树边，则每一条边加入时，对于连通的两个集合间的点对，最大边即为当前边。 因此在维护并查集的同时维护集合大小即可，贡献为 w \\(\\times\\) Size(u) \\(\\times\\) Size(v) ，复杂度 \\(O(n\\log n)\\) E. Packing Under Range Regulations 有 \\(10^9\\) 个盒子，每个盒子只能放一个球。有 \\(n\\) 个球，第 \\(i\\) 个要放在 \\([l_i,r_i]\\) 的某一个盒子中，问是否有解，范围 \\(n\\le 2\\times 10^5\\) 比较经典的贪心，考虑从左往右放，最紧急的需求肯定是右端点最小的。 按照右端点排序，依次考虑每个需求，尽量往左放，相当于区间查询最靠左的未覆盖位置，然后修改这个位置的覆盖状态。 实现可以选择动态开点线段树+线段树上区间内二分，我是用的是并查集维护下一个未覆盖的位置（疯狂的馒头）。 因为序列有 \\(10^9\\) 长，使用 unordered_map 维护并查集数组，具体实现见代码，复杂度 \\(O(n\\log n)\\) 。 1234567891011121314151617181920212223242526struct node &#123;int l, r;&#125; c[N];inline bool operator &lt; (const node &amp;a, const node &amp;b) &#123; return a.r == b.r ? a.l &lt; b.l : a.r &lt; b.r;&#125;unordered_map&lt;int, int&gt; nxt;int find(int x) &#123; return nxt[x] ? nxt[x] = find(nxt[x]) : x;&#125;void work() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123;c[i].l = rd(); c[i].r = rd();&#125; sort(c + 1, c + 1 + n); for (int i = 1, pos; i &lt;= n; ++i) &#123; if (!nxt[c[i].l]) &#123; nxt[c[i].l] = c[i].l + 1; continue; &#125; pos = find(c[i].l); if (pos &gt; c[i].r) &#123;puts(&quot;No&quot;); return;&#125; nxt[pos] = pos + 1; &#125; puts(&quot;Yes&quot;);&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"http://blog.gyx.me/categories/Solution/"},{"name":"AtCoder","slug":"Solution/AtCoder","permalink":"http://blog.gyx.me/categories/Solution/AtCoder/"},{"name":"AtCoder Beginner Contest","slug":"Solution/AtCoder/AtCoder-Beginner-Contest","permalink":"http://blog.gyx.me/categories/Solution/AtCoder/AtCoder-Beginner-Contest/"}],"tags":[{"name":"Union-Find Set","slug":"Union-Find-Set","permalink":"http://blog.gyx.me/tags/Union-Find-Set/"}]},{"title":"Freshman Year","slug":"freshman","date":"2021-07-08T02:27:14.000Z","updated":"2021-07-15T02:27:14.000Z","comments":true,"path":"2021/07/08/freshman/","link":"","permalink":"http://blog.gyx.me/2021/07/08/freshman/","excerpt":"","text":"今天是 2021 年 7 月 8 日，星期四。 一年前的今天，高考最后一门刚刚考完。走出考场，回到自己的教室，拿手机，搬行李，告别。 离开学校的时候，碰到了还在梳理交通的竞赛教练，问我考的怎么样，然后约了后天要给高一的学弟们上课。 直到昨晚，暑假回本部给又一届的学弟们上完最后一天课。从二中本部的校门里走出来，回头看看。 来杭电之前 高考完就跟爸爸妈妈说我不复读，当晚就对答案，大概 645。报了南科大综评，拿到了还算不错的校考分。 然后在南校区给高一的同学讲了比较入门的概率，也是那些在一年前的暑假认识的，刚踏入二中大门学弟。 结束的时候在空空的学校里溜达，想想他们上课时候那种纯粹的热情，一代又一代，多少有一点感慨。 走之前拍了张照片，想起来一句自认为很应景的话：“雨过天青云破处，者般颜色做将来” 连着下了两三天的小雨，只剩下竞赛生的二中 出分的晚上比较坦然，提前几分钟查到了分数，比估计的低 9 分，都扣在语文上，115 / 134 / 136 / 251。 之后的几天比较迷茫，听了几个学校的招生宣讲都不尽如人意。南科大那边几度有希望，后来终究是落空。 在我想起来杭电这所学校的时候，突然感觉就是要去这里了。 可能是高二去学军培训喜欢上了杭州这个城市，也可能是对竞赛生涯结束的不甘吧。 先自己偷偷找 Claris 要到了教练的联系方式，问了读研和专业的事情，刘老师的热情的杭州话让人很舒服。 然后就是小心翼翼地和父母交流，说我自己的想法和考虑，直到最后心里十分踏实地填上了第一志愿。 录取的结果是数学系，高考分数达到了卓越学院二次选拔的报名分数线，报了卓越学院的招生考试。 之后的假期写了几个板子，打了几场 CF 恢复一点水平，参加了 HDU 的几场内部训练，搬了一套题恰烂钱。 开学之前和岳老师吃了个饭（竟然还赶上了他生日）， 让我重心不要全部放到竞赛上，要给自己留个后路。 初到杭电 有一说一假期还是过的比较随意，虽然报名了卓越学院，但是一点没准备，9 月份忐忑地就来到杭电啦。 考试之前自己很没有底气，当时觉得能进计科班就不错了。考完觉得考的还行，因为竞赛里接触过一点高数线代的知识，觉得自己英语阅读也比较会蒙。然后晚上大概九点的时候出成绩了，震惊自己竟然过了英才班的线。 晚上给爸爸妈妈很激动地打了个电话，有点担心 11 进 9 被刷掉，一直到十二点多才睡着。 第二天面试的时候其实自己比较轻松，感觉面试向来都比较稳 比较会吹 ，面试单独面，五个老师。 面试比较自然，老师们的问题基本是跟着我的自我介绍思路走，不过还是有几个问题血压拉满。 我努力地强调自己的竞赛水平，然后冯老师问：“现在让你去打区域赛能拿到什么奖项？” 我介绍了一下高中学校和班级的情况，然后另一个老师问：“你觉得二中和衡一哪个更好？” 周老师（也是现在的导师）问：“你也不能打一辈子竞赛啊。以后有什么进一步的打算？” 我说会读研，以后可能会去当大学老师。导师笑笑说要想当教授，后面得去好点的大学读书。 面试完出来觉得自己还挺稳的，但是也不敢确定，忐忑到了晚上十点多出了结果。终于还是去学计算机了。 之后的生活很顺利，见面会，正常上课，班委选举（当了学委）。 上课的时候强迫自己去提问，回答问题，意识到自己可以做一些 由自己决定的 想做什么就做什么 的事。 遇到了自己喜欢的老师，有能够舒适相处，真心相待的一帮同学，慢慢地从高三痛苦自闭的状态走出来了。 竞赛 这段话也想写给每个学竞赛过程中感到无力的同行者。 算法竞赛的魅力在于，通过努力积累或灵机一动，你能够做出越来越难的题目，是一种对自我能力的认可。 算法竞赛的危险亦在于，你学会的东西越多，认识的厉害的人越多，面对不可计数的强者，很容易陷入自我否定。 想到杭电之前，很长一段时间都觉得，大学不会再打竞赛了。 学竞赛的过程中经历的打击，不仅是比赛和上课中受到一众神仙居高临下的压迫感，更多的其实是周围人不经意的否定和安慰。对我来说，这是一种对信心很大的打击，会想要证明自己，亦或是心里感到无力而故作轻松。 在面临是否买 D 的抉择时，我放弃了。不是担心取得不了什么结果，而是觉得压力太大了。 在选学校的时候，突然想到杭电的那一刻，有种死灰复燃的感觉。 记起来 NOIP 2018 结束的时候，在存真楼下，孙校长和我们几个刚从秦皇岛回来的学生说的几句话： “学别的竞赛的，最终的发展和竞赛不一定有关系，但是算法竞赛的学生，最终往往都会选择计算机行业。” 算法竞赛会在心里埋下一颗种子。 我不是那种一帆风顺的天才，在受到打击的时候，我会感到无力。 但当我抛开名利、和他人比较、证明自己这些功利的意义之后，我发现自己还剩下些东西，还能看到初心。 是对算法的欣赏和热爱，是理解每一个算法、做出每一个题目的瞬间，精神上的享受，这就够了。 至少在我看来，从我开始接触竞赛，到做出很多重要的选择，我决策的初心从来都不是名利，因为对算法还爱着。决定最终没有买 D 类，最大的原因还是在那个时刻，竞赛带来的痛苦超过了学习的享受，被一次次的排名裹挟，被各种机会所吸引，我越来越像一个没有自我的机器，越来越被成功学牢牢锁死。而在我选择大学的时候，竞赛对我的意义不再是未来的全部了。我能够静下来，问问自己对算法还有没有那种近乎痴迷的喜爱，能够将它作为一种兴趣去发展，不需要考虑付出和回报，至少在大学，我还是有自由支配自己的权利。 我还是那个深深爱着算法的小孩，对几十行代码背后的智慧如痴如醉。 Gold Medal (30th Place) : The 45th ICPC Asia Jinan Regional Contest, 2020 Gold Medal ( 15th Place) : The 18th Zhejiang Provincial Collegiate Programming Contest, 2021 Silver Medal (28th Place) : The 45th ICPC Asia Shenyang Regional Contest, 2021 课内学习 第一个学期不会选课，修了系统默认的 25.25 个学分， 第二个学期修了 32.25 个学分。 通识选修只完成了科技发展与科学精神（2/2），大二上应该会把剩下的指标修完。 数理基础 (23) 数分 （6 * 3.5 + 5 * 4.2）、高代（3 * 5 + 2 * 5）、离散（4 * 5）、大物1（3 * 5） CS专业课 (14) 计导（2 * 5）、程设基础（5 * 5）、数据结构（4 * 4.5）、C++ 面向对象（3 * 5） 通识教育 (8) 思修法基（3 * 5）、心理健康（1 * 4.3）、大军（2 * 4.8）、ACM（2 * 5） 外语类 (8) 英语精读 A（2 * 4.4 + 2 * 4.6）、英语听说 A（1 * 4.3 + 1 * 4.7）、实用翻译（2 * 4.6） 其他 (3.5) 大学启示录（1 * 4）、形式与政策（0.5 * 5）、科研实践（1 * 5）、体育（1 * 2.1 + 1 * 1.8） 很幸运的是遇到的老师都很认真负责，老师们对课程内容非常了解，自己遇到问题也都能很好沟通。 很多课程都觉得自己做的没那么好，对给出的成绩也常常受之有愧。 数学分析和高等代数两门数学基础课的表现截然相反，让我更清楚地意识到很大程度上我是个兴趣驱动的人。 对数分的知识体系自己本身可能就不太感兴趣，加上数分课是真的提不起来精神，两个学期的数学分析成绩都不太看的过去，数分上可能要在大三重修了。老师确实想要认真教会我，可是自己确实提不起兴趣去学。经历了数分上的洗礼，数分下还是逼着自己学了学，最后的结果算是马马虎虎吧，确实对不起老师对不起自己。 很喜欢高代老师的课，很大程度驱动我去花相对比较多的时间在这门课上。两个学期最后的结果都比较好，在自己喜欢的科目上能够看到自己做了些事情，也是让自己很开心的一件事。唯一遗憾的是期末错在了最后一节课老师强调过的一个小点上（证明正定阵需先说明对称）。大二下预定了老师的近世代数。 也很喜欢 Cathy 上的英语精读，也算是第一次能让我主动提起来学英语的兴趣。 Cathy 的课有一种很轻松的气氛，不会按照课本一板一眼的去上，讲的很多东西很受用。 感谢程设和OOP（C++）的老师对我的包容，自己在这两门课上确实有过很幼稚的行为。很佩服将近退休的老师能精确把控很多细节，随手写的代码能一遍过编译什么错都没有。 离散数学和数据结构 给了我很深刻的教训。两门都是自认为了解比较多的，数据结构甚至申请了免听。考前复习的都不是很充分，等上了考场发现要开始脑补一堆一堆的概念。期末离散卷子简单，没暴露出来什么问题。数据结构觉得自己看看书就够了，最后的成绩却不尽如人意，原因只是不知道排序里的一个既定细节，只能悔不当初。 大学物理和思想道德修养与法律基础 两门课结果意外的好，其实自己认真去学一学还是可以有效果的。中学阶段一直头疼的政治在闭卷的期末考试也写了个差不多。学不会电磁在考场上也做出来了绝大多数题。考试遇到不会的题也不能太着急，多想一会没准就通了。 体育 从中考的 \\(18\\) 分保底，到大一上的体测 \\(36\\) 分，痛失两个学期的奖学金，终究还是没逃过身体素质不行这个问题。还是感谢环境逼着我去直面体育，按着体能班的要求大一下结结实实把 40 次阳光长跑跑完了，也确实让我看到耐力可以有提升，从操场跑一圈就喘不上气，到体测的时候人生第一次把 1000 米全跑下来，确实是很激动的。也终于在锻炼身体上有了动力，首先是大二下想要和 qyy 同学一起学体育舞，其次是想要恰奖学金。 我的她 只想说爱情的体验是一种很纯粹的幸福。 愿意为她牺牲自己的一切，无时无刻都会想起她的事情，找不到她会坐如针毡，什么都做不下去。 她所高兴的事情比她还高兴，她难受的时候会跟着一起哭出来，在爱情中两个人都学会了如何照顾对方。 两个人在一起呆着常常心有灵犀，做事情反应如出一辙，很多事情不用言语。 两个人在一起呆着就是最快乐的事情，能够一起学习，散步，她在我的身边就能感受到无比的踏实。 会走到一起的人终究不会分开。心里对未来有着期盼，静下心来踏踏实实做事，继续加油。","categories":[{"name":"Life","slug":"Life","permalink":"http://blog.gyx.me/categories/Life/"}],"tags":[]},{"title":"Codeforces Round #723 (Div. 2)","slug":"Codeforces/cf723","date":"2021-03-28T16:00:00.000Z","updated":"2022-05-19T01:11:51.628Z","comments":true,"path":"2021/03/29/Codeforces/cf723/","link":"","permalink":"http://blog.gyx.me/2021/03/29/Codeforces/cf723/","excerpt":"","text":"A. Mean Inequality 将 \\(2n\\) 个不同的数字排成一个循环，使得任意位置的数不是相邻两个数的平均值。 从小到大排序之后，前 \\(n\\) 个和后 \\(n\\) 个交替放。 因为数字两两不同，大的数字不可能是两个小的数字的平均数，小的同理。 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125; int a[51];inline void work() &#123; int n = rd(); int m = 2 * n; for (int i = 1; i &lt;= m; ++i) a[i] = rd(); sort(a + 1, a + 1 + m); for (int i = 1; i &lt;= n; ++i) printf(&quot;%d %d &quot;, a[i], a[i + n]); puts(&quot;&quot;);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; B. I Hate 1111 询问一个正整数 \\(x\\) 是否可以拆分成若干个 \\(11,111,1111,\\dots\\) 的和 根据 麦乐鸡定理 ，\\(11\\) 和 \\(111\\) 可以组成大于 \\(11*111-111-11=1099\\) 的任何数。 所以后面的数字都没用了， \\(x\\le 1099\\) 的部分做一下 \\(11\\) 和 \\(111\\) 的完全背包，其他情况都是 YES 。 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125; #define N 1100bool f[N];inline void work() &#123; int x = rd(); puts(x &gt;= N ? &quot;YES&quot; : (f[x] ? &quot;YES&quot; : &quot;NO&quot;));&#125;int main() &#123; f[0] = 1; for (int i = 11; i &lt; N; ++i) f[i] |= f[i - 11]; for (int i = 111; i &lt; N; ++i) f[i] |= f[i - 111]; for (int t = rd(); t; --t) work(); return 0;&#125; C. Potions 给一个数列，求一个最长的子序列，使得子序列任意前缀和都 \\(\\ge 0\\) 经典的带反悔贪心，用一个小根堆维护拿了的数字。 每次先把当前的拿了，如果当前的和是负的，就一直去掉堆顶直到合法即可。 这样子在每次结束的时候都是正的，并且去掉了最少的数。 等效的贪心是每次放进来如果变成负数就看一下能不能替换堆顶。 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125; priority_queue&lt;int&gt; q;int main() &#123; int n = rd(); int ans = 0; ll nw = 0; for (int i = 1, a; i &lt;= n; ++i) &#123; a = rd(); ++ans; nw += a; q.push(-a); while (nw &lt; 0) &#123; nw += q.top(); q.pop(); --ans; &#125; &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125; D. Kill Anton 给定一个字符集只有 'A','D','O','T' 的串，将其重排使得恢复成原来的所需操作次数最大。 操作一次可以交换两个字符的位置。 猜一下操作次数只和逆序数相关（我一直不太会这种的证明），所以一定可以把同一类字符放到一起。 记 inv[i][j] 表示字符 i 前字符j 的顺序对数，即如果结果串中字符 i 在字符 j 前，增加的逆序数。 因此枚举 \\(4!\\) 种排列，计算一下哪一种逆序数最大即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const char tc[4] = &#123;&#x27;A&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;T&#x27;&#125;;ll cnt[4], inv[4][4];inline int tr(char c) &#123; if (c == &#x27;A&#x27;) return 0; if (c == &#x27;N&#x27;) return 1; return (c == &#x27;O&#x27; ? 2 : 3);&#125;string s;inline void work() &#123; cin &gt;&gt; s; for (int i = 0; i &lt; 4; ++i) &#123; cnt[i] = 0; for (int j = 0; j &lt; 4; ++j) inv[i][j] = 0; &#125; for (auto c : s) &#123; int i = tr(c); for (int j = 0; j &lt; 4; ++j) if (j != i) inv[i][j] += cnt[j]; ++cnt[i]; &#125; ll ans = -1; int p[4] = &#123;0, 1, 2, 3&#125;, res[4]; do &#123; ll tmpans = 0; for (int i = 0; i &lt; 4; ++i) for (int j = i + 1; j &lt; 4; ++j) tmpans += inv[p[i]][p[j]]; if (tmpans &gt; ans) &#123; ans = tmpans; for (int i = 0; i &lt; 4; ++i) res[i] = p[i]; &#125; &#125; while(next_permutation(p, p + 4)); for (int i = 0; i &lt; 4; ++i) for (int j = 1; j &lt;= cnt[res[i]]; ++j) putchar(tc[res[i]]); puts(&quot;&quot;);&#125;int main() &#123; int t; for (cin &gt;&gt; t; t; --t) work(); return 0;&#125; E. Oolimry and Suffix Array 给定后缀数组，求有多少个串长为 \\(n\\) ，字符集大小为 \\(k\\) 的字符串 \\(S\\) 符合这个后缀数组 后缀数组 \\(sa_i\\) 记录的是排名第 \\(i\\) 位的后缀的开始下标。 根据字典序要求，\\(S_{sa_i}\\) 和 \\(S_{sa_{i+1}}\\) 只有两种关系：\\(S_{sa_i}&lt;S_{sa_{i+1}}\\) 或 \\(S_{sa_i}=S_{sa_{i+1}}\\) 小于一定是可以的，等于的充要条件是 \\(rank_{sa_i+1}&lt;rank_{sa_{i+1}+1}\\) ，即去掉第一个字符字典序不变。 因此我们得到了含有 \\(n-1\\) 个不等号的不等式链，假设其中有 \\(a\\) 个是 \\(\\le\\) 。 我们枚举有 \\(i\\) 个 \\(\\le\\) 实际上是 \\(&lt;\\) ，那么实际字符集大小是 \\(n-i\\) ，方案数就是 \\[ \\sum_{i=0}^a{a\\choose i}{k\\choose n-i}={a+k\\choose n} \\] 等式从组合含义理解，从 \\(a+k\\) 个里选 \\(n\\) 个，定价于枚举从前 \\(a\\) 个里选 \\(i\\) 个，剩余的从后 \\(k\\) 个里选。 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 200007#define mod 998244353inline int fpow(int x, int t = mod - 2) &#123; int res = 1; for (; t; t &gt;&gt;= 1, x = 1ll * x * x % mod) if (t &amp; 1) res = 1ll * res * x % mod; return res;&#125;int rk[N], pos[N], fac[N &lt;&lt; 1] = &#123;1&#125;;int main() &#123; int n = rd(), k = rd(); for (int i = 1; i &lt;= n; ++i) rk[pos[i] = rd()] = i; for (int i = 1; i &lt; n; ++i) k += (rk[pos[i] + 1] &lt; rk[pos[i + 1] + 1]); if (k &lt; n) &#123;puts(&quot;0&quot;); return 0;&#125; for (int i = 1; i &lt;= k; ++i) fac[i] = 1ll * fac[i - 1] * i % mod; printf(&quot;%lld\\n&quot;, 1ll * fac[k] * fpow(fac[n]) % mod * fpow(fac[k - n]) % mod); return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"http://blog.gyx.me/categories/Solution/"},{"name":"Codeforces","slug":"Solution/Codeforces","permalink":"http://blog.gyx.me/categories/Solution/Codeforces/"},{"name":"Codeforces Round","slug":"Solution/Codeforces/Codeforces-Round","permalink":"http://blog.gyx.me/categories/Solution/Codeforces/Codeforces-Round/"}],"tags":[{"name":"Greedy","slug":"Greedy","permalink":"http://blog.gyx.me/tags/Greedy/"},{"name":"Counting","slug":"Counting","permalink":"http://blog.gyx.me/tags/Counting/"},{"name":"Constructive Algorithm","slug":"Constructive-Algorithm","permalink":"http://blog.gyx.me/tags/Constructive-Algorithm/"},{"name":"Number Theory","slug":"Number-Theory","permalink":"http://blog.gyx.me/tags/Number-Theory/"}]},{"title":"Render Math Equations in Hexo","slug":"mathjax","date":"2019-05-31T16:00:00.000Z","updated":"2021-05-31T16:00:00.000Z","comments":true,"path":"2019/06/01/mathjax/","link":"","permalink":"http://blog.gyx.me/2019/06/01/mathjax/","excerpt":"","text":"\\[ f(a) = \\frac{1}{2\\pi i}\\oint_{\\gamma}\\frac{f(z)}{z-a}dz \\] Beautiful and accessible math in all browsers - MathJax This post is used to check out whether the mathjax plugin (hexo-math) still works. Inline Formula Consider the sequence of \\(n\\) distinct positive integers: \\(c_1, c_2, \\cdots, c_n\\). The child calls a vertex-weighted rooted binary tree good if and only if for every vertex \\(v\\), the weight of \\(v\\) is in the set \\(\\{c_1, c_2, \\cdots, c_n\\}\\) . Also our child thinks that the weight of a vertex-weighted tree is the sum of all vertices' weights. Given an integer \\(m\\), can you for all $s (1 s ≤ m) $ calculate the number of good vertex-weighted rooted binary trees with weight \\(s\\) ? Please, check the samples for better understanding what trees are considered different. We only want to know the answer modulo \\(998244353\\) ( \\(7 × 17 × 2^{23} + 1\\) , a prime number). Block Formula \\[ \\int \\frac{dx}{cos^2x}=\\int sec^2xdx=tan x+C\\ \\] \\[ \\int \\frac{dx}{sin^2x}=\\int csc^2xdx=-cot x+C\\ \\] \\[ \\sum\\limits_{i = 0}^{E} w[i]{M \\choose i} {N \\choose iS} \\frac{(iS)!}{(S!)^{i}} \\sum\\limits_{j = 0}^{E - i} (-1)^{j} {M - i \\choose j} {N - iS \\choose jS} \\frac{(jS)!}{(S!)^{j}} (M - i - j)^{N - iS - jS} \\] \\[ = \\sum\\limits_{i = 0}^{E} w[i]{M \\choose i} {N \\choose iS} \\frac{(iS)!}{(S!)^{i}} \\sum\\limits_{j = i}^{E} (-1)^{j - i} {M - i \\choose j - i} {N - iS \\choose jS - iS} \\frac{(jS - iS)!}{(S!)^{j - i}} (M - j)^{N - jS} \\] Matrix \\[ \\begin{bmatrix} (\\omega_n^0)^0 &amp; (\\omega_n^0)^1 &amp; \\cdots &amp; (\\omega_n^0)^{n-1}\\\\\\\\ (\\omega_n^1)^0 &amp; (\\omega_n^1)^1 &amp; \\cdots &amp; (\\omega_n^1)^{n-1}\\\\\\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\\\\\ (\\omega_n^{n-1})^0 &amp; (\\omega_n^{n-1})^1 &amp; \\cdots &amp; (\\omega_n^{n-1})^{n-1} \\end{bmatrix} \\begin{bmatrix} a_0 \\\\\\\\ a_1 \\\\\\\\ \\vdots \\\\\\\\ a_{n-1} \\end{bmatrix} = \\begin{bmatrix} A(\\omega_n^0) \\\\\\\\ A(\\omega_n^1) \\\\\\\\ \\vdots \\\\\\\\ A(\\omega_n^{n-1}) \\end{bmatrix} \\] \\[ \\begin{bmatrix} a_0 \\\\\\\\ a_1 \\\\\\\\ \\vdots \\\\\\\\ a_{n-1} \\end{bmatrix} = \\frac{1}{n} \\begin{bmatrix} (\\omega_n^{-0})^0 &amp; (\\omega_n^{-0})^1 &amp; \\cdots &amp; (\\omega_n^{-0})^{n-1} \\\\\\\\ (\\omega_n^{-1})^0 &amp; (\\omega_n^{-1})^1 &amp; \\cdots &amp; (\\omega_n^{-1})^{n-1} \\\\\\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\\\\\ (\\omega_n^{-(n-1)})^0 &amp; (\\omega_n^{-(n-1)})^1 &amp; \\cdots &amp; (\\omega_n^{-(n-1)})^{n-1} \\end{bmatrix} \\begin{bmatrix} A(\\omega_n^0) \\\\\\\\ A(\\omega_n^1) \\\\\\\\ \\vdots \\\\\\\\ A(\\omega_n^{n-1}) \\end{bmatrix} \\] To prevent escaping, you need to use \\\\\\\\ to make a new line rather than \\\\ . For more about the Mathjax symbols, refer to ：The Comprehensive LaTeX Symbol List .","categories":[{"name":"Blog","slug":"Blog","permalink":"http://blog.gyx.me/categories/Blog/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-11-28T16:00:00.000Z","updated":"2018-11-28T16:00:00.000Z","comments":true,"path":"2018/11/29/hello-world/","link":"","permalink":"http://blog.gyx.me/2018/11/29/hello-world/","excerpt":"","text":"「 Hello, the lovely world. 」 「 Stay hungry, Stay foolish. 」 12345678910111213141516171819202122&gt;&gt;&gt; import thisThe Zen of Python, by Tim PetersBeautiful is better than ugly.Explicit is better than implicit.Simple is better than complex.Complex is better than complicated.Flat is better than nested.Sparse is better than dense.Readability counts.Special cases aren&#x27;t special enough to break the rules.Although practicality beats purity.Errors should never pass silently.Unless explicitly silenced.In the face of ambiguity, refuse the temptation to guess.There should be one-- and preferably only one --obvious way to do it.Although that way may not be obvious at first unless you&#x27;re Dutch.Now is better than never.Although never is often better than *right* now.If the implementation is hard to explain, it&#x27;s a bad idea.If the implementation is easy to explain, it may be a good idea.Namespaces are one honking great idea -- let&#x27;s do more of those!","categories":[{"name":"Blog","slug":"Blog","permalink":"http://blog.gyx.me/categories/Blog/"}],"tags":[]}],"categories":[{"name":"Summary","slug":"Summary","permalink":"http://blog.gyx.me/categories/Summary/"},{"name":"Competitive Programming","slug":"Summary/Competitive-Programming","permalink":"http://blog.gyx.me/categories/Summary/Competitive-Programming/"},{"name":"Algorithms","slug":"Summary/Algorithms","permalink":"http://blog.gyx.me/categories/Summary/Algorithms/"},{"name":"Solution","slug":"Solution","permalink":"http://blog.gyx.me/categories/Solution/"},{"name":"AtCoder","slug":"Solution/AtCoder","permalink":"http://blog.gyx.me/categories/Solution/AtCoder/"},{"name":"AtCoder Beginner Contest","slug":"Solution/AtCoder/AtCoder-Beginner-Contest","permalink":"http://blog.gyx.me/categories/Solution/AtCoder/AtCoder-Beginner-Contest/"},{"name":"Others","slug":"Solution/Others","permalink":"http://blog.gyx.me/categories/Solution/Others/"},{"name":"HDU","slug":"Solution/HDU","permalink":"http://blog.gyx.me/categories/Solution/HDU/"},{"name":"Nowcoder","slug":"Solution/Nowcoder","permalink":"http://blog.gyx.me/categories/Solution/Nowcoder/"},{"name":"Life","slug":"Life","permalink":"http://blog.gyx.me/categories/Life/"},{"name":"AtCoder Regular Contest","slug":"Solution/AtCoder/AtCoder-Regular-Contest","permalink":"http://blog.gyx.me/categories/Solution/AtCoder/AtCoder-Regular-Contest/"},{"name":"Paper Notes","slug":"Summary/Paper-Notes","permalink":"http://blog.gyx.me/categories/Summary/Paper-Notes/"},{"name":"Codeforces","slug":"Solution/Codeforces","permalink":"http://blog.gyx.me/categories/Solution/Codeforces/"},{"name":"Codeforces Round","slug":"Solution/Codeforces/Codeforces-Round","permalink":"http://blog.gyx.me/categories/Solution/Codeforces/Codeforces-Round/"},{"name":"AtCoder Grand Contest","slug":"Solution/AtCoder/AtCoder-Grand-Contest","permalink":"http://blog.gyx.me/categories/Solution/AtCoder/AtCoder-Grand-Contest/"},{"name":"Google","slug":"Solution/Google","permalink":"http://blog.gyx.me/categories/Solution/Google/"},{"name":"Blog","slug":"Blog","permalink":"http://blog.gyx.me/categories/Blog/"}],"tags":[{"name":"DFS and Similar","slug":"DFS-and-Similar","permalink":"http://blog.gyx.me/tags/DFS-and-Similar/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"},{"name":"Counting","slug":"Counting","permalink":"http://blog.gyx.me/tags/Counting/"},{"name":"Fenwick Tree","slug":"Fenwick-Tree","permalink":"http://blog.gyx.me/tags/Fenwick-Tree/"},{"name":"System of Difference Constraints","slug":"System-of-Difference-Constraints","permalink":"http://blog.gyx.me/tags/System-of-Difference-Constraints/"},{"name":"Geometry","slug":"Geometry","permalink":"http://blog.gyx.me/tags/Geometry/"},{"name":"Constructive Algorithm","slug":"Constructive-Algorithm","permalink":"http://blog.gyx.me/tags/Constructive-Algorithm/"},{"name":"Game Theory","slug":"Game-Theory","permalink":"http://blog.gyx.me/tags/Game-Theory/"},{"name":"01-BFS","slug":"01-BFS","permalink":"http://blog.gyx.me/tags/01-BFS/"},{"name":"Flows","slug":"Flows","permalink":"http://blog.gyx.me/tags/Flows/"},{"name":"Minkowski Sum","slug":"Minkowski-Sum","permalink":"http://blog.gyx.me/tags/Minkowski-Sum/"},{"name":"Connectivity","slug":"Connectivity","permalink":"http://blog.gyx.me/tags/Connectivity/"},{"name":"Threshold Optimization","slug":"Threshold-Optimization","permalink":"http://blog.gyx.me/tags/Threshold-Optimization/"},{"name":"Number Theory","slug":"Number-Theory","permalink":"http://blog.gyx.me/tags/Number-Theory/"},{"name":"Combinatorics","slug":"Combinatorics","permalink":"http://blog.gyx.me/tags/Combinatorics/"},{"name":"STL","slug":"STL","permalink":"http://blog.gyx.me/tags/STL/"},{"name":"Greedy","slug":"Greedy","permalink":"http://blog.gyx.me/tags/Greedy/"},{"name":"Knapsack Problem","slug":"Knapsack-Problem","permalink":"http://blog.gyx.me/tags/Knapsack-Problem/"},{"name":"Binary Lifting","slug":"Binary-Lifting","permalink":"http://blog.gyx.me/tags/Binary-Lifting/"},{"name":"KMP","slug":"KMP","permalink":"http://blog.gyx.me/tags/KMP/"},{"name":"Persistent Data Structure","slug":"Persistent-Data-Structure","permalink":"http://blog.gyx.me/tags/Persistent-Data-Structure/"},{"name":"Scheduling","slug":"Scheduling","permalink":"http://blog.gyx.me/tags/Scheduling/"},{"name":"Graphs","slug":"Graphs","permalink":"http://blog.gyx.me/tags/Graphs/"},{"name":"Bitmask","slug":"Bitmask","permalink":"http://blog.gyx.me/tags/Bitmask/"},{"name":"Union-Find Set","slug":"Union-Find-Set","permalink":"http://blog.gyx.me/tags/Union-Find-Set/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"http://blog.gyx.me/tags/Binary-Search/"}]}