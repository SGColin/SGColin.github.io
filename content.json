{"meta":{"title":"Yixiong Gao","subtitle":"a junior interested in TCS and CP.","description":null,"author":"Colin Gao","url":"http://blog.gyx.me","root":"/"},"pages":[{"title":"","date":"2023-04-16T15:20:17.956Z","updated":"2023-04-14T05:45:24.939Z","comments":false,"path":"about/index.html","permalink":"http://blog.gyx.me/about/index.html","excerpt":"","text":""},{"title":"Colin's Diary","date":"2023-04-14T09:13:03.000Z","updated":"2023-04-16T14:29:32.870Z","comments":true,"path":"diary/index.html","permalink":"http://blog.gyx.me/diary/index.html","excerpt":"","text":"ä½ å¥½å‘€ï¼Œè¿™é‡Œæ˜¯ Colin çš„æµæ°´è´¦æ—¥è®°å’Œä¸€äº›å°æƒ³æ³•ã€‚ å¦‚æœä½ èƒ½æ‰¾åˆ°è¿™é‡Œï¼Œä¼°è®¡ä½ ç°åœ¨ä¹ŸæŒºæ— èŠçš„ï¼Œå››å¤„é€›é€›å§ï¼ç›¸ä¿¡ä½ èƒ½æ‰¾åˆ°æœ‰æ„æ€çš„äº‹æƒ…ã€‚ Link: Spring 2023"},{"title":"Colin's Diary - Spring 2023","date":"2023-04-14T09:13:03.000Z","updated":"2023-04-21T01:28:19.803Z","comments":true,"path":"diary/spring2023.html","permalink":"http://blog.gyx.me/diary/spring2023.html","excerpt":"","text":"March 2023 / 03 / 06 é™ª Eva åŒå­¦å»çœ‹è„¸ä¼¤ï¼Œå¡ç€ä¸¤ç‚¹ä¹‹åå»åƒäº†é¡¿æµ·åº•æï¼Œå­¦ç”Ÿ 69 æŠ˜è¿˜æŒºçˆ½çš„ã€‚ è·¯ä¸Šçœ‹åˆ° Bank of China ï¼Œæˆ‘è¯´æˆ‘æ˜¯ Bank of Eva ï¼ŒEva è¯´å¥¹æ˜¯ Bank of Colin : ) 2023 / 03 / 07 ä¸Šåˆè®¨è®ºç­ï¼Œè®²å®Œç»¼è¿°pptä¹‹åï¼Œå’Œè€å¸ˆè®¨è®ºå¾—å‡ºç»“è®ºï¼Œè¿™ä¸ªé—®é¢˜æˆ‘ä»¬åšä¸äº†ï¼ˆï¼‰ è€å¸ˆè¯´é‡ç‚¹åœ¨æ‰¾åˆ°è‡ªå·±æœ‰æƒ³æ³•çš„é—®é¢˜ï¼Œæ„Ÿè§‰è‡ªå·±å¯¹ç§‘ç ”èƒ½å¦æœ‰äº§å‡ºçš„ç„¦è™‘æ—¥ç›Šå¢åŠ ï¼Œåè€Œé™ä¸ä¸‹å¿ƒæ¥... 2023 / 03 / 08 å¦‡å¥³èŠ‚ åŠå¤œæ‹‰è‚šå­å¥½å‡ å›ï¼Œæ—©ä¸Šçƒ§èµ·æ¥äº†ï¼Œæ„Ÿè§‰äººæœ‰ç‚¹é£˜ï¼Œå°±å»åŒ»é™¢äº†ã€‚ åˆ°äº†å‘çƒ­é—¨è¯Šä¸€é‡ï¼Œ39.9ï¼ŒåŒ»ç”Ÿç›´æ¥è®©æˆ‘å…ˆæŠŠé€€çƒ§è¯åƒä¸Šã€‚å·®ç‚¹å°±40äº†ï¼Œè¿˜å‡†å¤‡å‘ä¸ªè¯´è¯´å‘¢ã€‚ æµæ„Ÿæ£€æµ‹é‡‡æ ·èµ°çš„æ˜¯é¼»å­ï¼Œæœ‰ç‚¹ç—›ã€‚åŒ»ç”Ÿå¬åˆ°æˆ‘æ²¡å¾—è¿‡æ–°å† çš„æ—¶å€™æ„£äº†ä¸€ä¸‹ï¼Œç„¶åç¡®è®¤äº†å¥½å‡ éã€‚ã€‚ã€‚ æŠ½å®Œè¡€ï¼Œååœ¨å¤§å…ç­‰ç»“æœï¼Œåˆå›°åˆé£˜ï¼Œè·Ÿ Eva å¼€ç©ç¬‘è¯´è¦æ˜¯æ–°å† é˜³äº†æˆ‘ä½“æµ‹ç›´æ¥ç”³è¯·å…æµ‹ : ) å‡ºæ¥ç»“æœä¸æ˜¯æµæ„Ÿï¼Œé™¤äº†ç™½ç»†èƒé«˜ä»¥å¤–åˆ«çš„æŒ‡æ ‡éƒ½è´¼å¥åº·ï¼Œç”šè‡³æ¯”æˆ‘å…¥å­¦ä½“æ£€è¿˜å¥åº·ï¼Œçœ‹æ¥æ˜¯é€ƒä¸è¿‡ä½“æµ‹äº†ã€‚ é€€çƒ§è¯èµ·æ•ˆåè§‰å¾—è‡ªå·±åˆè¡Œäº†ï¼Œä¸‹åˆç›´æ¥ VP ï¼ç„¶ååˆçƒ§èµ·æ¥äº†å¼€å§‹é£˜ï¼Œå¼€æ‘†ã€‚ æ™šä¸Šè…¹æ³»åŠ å‰§è‡ªå·±å»ä¹°äº†ç›’è’™è„±çŸ³æ•£ï¼Œæ„Ÿè§‰æ˜å¤©ä¹Ÿå¾ˆéš¾è¿‡å•Šã€‚ 2023 / 03 / 09 è…¹æ³»å‘çƒ§ï¼Œä½†æ˜¯ä¸æ˜¯æµæ„Ÿä¸æ˜¯æ–°å† ï¼Œè²Œä¼¼å°±æ˜¯æ€¥æ€§è‚ èƒƒç‚å¼•èµ·çš„ï¼Ÿï¼Ÿ ä¸‹åˆæ— å¿ƒå­¦ä¹ ï¼Œè·Ÿ Eva ä¸€èµ·æ‰“ä¸ª Div.2 æ„‰æ‚¦èº«å¿ƒï¼Œè¿æœ€çŸ­è·¯éƒ½ä¸ä¼šåšäº†ã€‚ã€‚ã€‚ EC-Final April 2023 / 04 / 01 æ„šäººèŠ‚ å»æ‰“å·¥ï¼Œæˆ‘è¯´ä»Šå¤©çš„é¢˜å¾ˆç®€å•ï¼Œå°å­©ä»¬è¯´è€å¸ˆæˆ‘ä»¬éƒ½çŸ¥é“ä»Šå¤©æ˜¯æ„šäººèŠ‚ ğŸ˜‚ 2023 / 04 / 02 ä¸‹åˆè®­ç»ƒç–¯ç‹‚æ‰‹è¯¯ç½šæ—¶çˆ†ç‚¸ï¼Œè€å¹´é€‰æ‰‹ç åŠ›æ˜¯çœŸä¸è¡Œäº†ã€‚ã€‚ æ™šä¸Šæ¥çˆ¸çˆ¸å¦ˆå¦ˆæ¥æ­å·ï¼å»é’±å¡˜æ±Ÿè¾¹ï¼ˆä¸‹æ²™æ‹è§’å¤„ï¼‰é€›äº†ä¸€åœˆï¼Œç¦»è°±çš„æ˜¯æ²³é“é‡Œç«Ÿç„¶æ²¡æ°´ï¼Ÿï¼Ÿï¼Ÿ 2023 / 04 / 03 æ˜¨å¤©æ™šé¥­åƒçš„æ¯”è¾ƒæ€§å¯’ï¼ŒåŠ ä¸Šæ±Ÿè¾¹é£å¤§åˆç»™å¹²æ€¥æ€§è‚ èƒƒç‚äº†ã€‚ã€‚ã€‚ æ—©ä¸Šèµ·æ¥ä¸Šåä¸‹æ³»ï¼Œä¸Šåˆçš„è¯¾å¹²è„†ç¿˜äº†åœ¨å¯å®¤ç¡è§‰ã€‚ä¸‹åˆç¼“è¿‡æ¥äº†å¸¦å° Eva å»è§äº†çˆ¸çˆ¸å¦ˆå¦ˆï¼ æ™šä¸Šä¸€èµ·åœ¨ in77 åƒäº†é’èŠ±æ¤’ç ‚é”…é±¼ï¼Œç„¶åç»•ç€æ¹–èµ°äº†ä¸€ä¸ªå¤šå°æ—¶å»çœ‹è¥¿æ¹–å°è±¡ï¼Œä¸å¾—ä¸è¯´è‰ºè°‹æ˜¯çœŸçš„æ‡‚æµªæ¼«ï¼ å° Eva ç¬¬ä¸€æ¬¡è§å®¶é•¿è²Œä¼¼é¡ºåˆ©å®Œæˆäº† : ) 2023 / 04 / 04 ä»Šå¤©å¸¦çˆ¸çˆ¸å¦ˆå¦ˆæŠŠæ­ç”µç®—æ˜¯å®Œæ•´çš„è½¬äº†ä¸€åœˆï¼š ä¸œå—é—¨ - æœˆé›…æ¹– - å°èŠ±å›­ - å››æ•™ - ä¸‰é¼é—®å¤© - ä¸‰æ•™ - æ“åœº - å­¦æ´» - ä¸ƒæ•™ - å…­æ•™ - å…«æ•™ï¼ˆå®éªŒå®¤ï¼‰ - ä½“è‚²é¦† - ç”Ÿæ´»åŒºæ“åœº - é£Ÿå ‚ï¼ ç¾é£ŸåŸçš„é¥­ç«Ÿç„¶èƒ½è®©çˆ¸çˆ¸æ»¡æ„ï¼Œå¼€å¿ƒ : ) 2023 / 04 / 07 å‡ºå‘å»é•¿æ²™å‚åŠ  ORSC 2023ï¼ 9:40 ä¸‹è¯¾èµ¶ 10:25 çš„é«˜é“ï¼Œåœ°é“å‡ºç«™åˆ°é«˜é“æ£€ç¥¨å£å†²åˆºäº† 5min æ¯”è·‘ 1km è¿˜ç´¯ï¼Œå¥½åœ¨èµ¶ä¸Šäº†ï¼ˆå½“å¤©å…¶ä»–ç¥¨éƒ½æ²¡äº†ï¼‰ã€‚ ä¸‹åˆæŠ¥é“å…¥ä½ä¹‹åï¼Œå››ä¸ªäººå·å·å»å®¾é¦†æ—è¾¹çš„æ¹–ç©ï¼Œç„¶åå¼€äº†èˆ¹ï¼é™¤äº†æœ‰ç‚¹å†·ä½“éªŒè‰¯å¥½ï¼Œç¬¬ä¸€æ¬¡å¼€èˆ¹éå¸¸åˆºæ¿€ã€‚ 2023 / 04 / 08 ä¸Šåˆæ˜¯åˆç…§ï¼Œç„¶åè§‚çœ‹å­¦ä¼šç»™å„ä½é™¢å£«é¢å¥–ã€‚ ä¸­åˆå®¾é¦†å¤–çš„è‰åªåœ¨ä¸¾åŠå©šç¤¼ï¼Œæ„Ÿè§‰å¾ˆæœ‰æ„æ€ï¼Œå¼€åœºæ‰€æœ‰çš„ä¼´éƒä¼´å¨˜ä¸€èµ·è·³äº†ä¸€æ”¯èˆã€‚ ä¸‹åˆå‡ºå‘çš„æ—¶å€™å‘ç°å©šç¤¼çš„è›‹ç³•æ²¡è¢«åˆ†å®Œï¼Œç›´æ¥ä¸€äººåˆ‡äº†ä¸€å—ï¼ˆæ„Ÿè°¢æ–°éƒæ–°å¨˜çš„æ— ç§é¦ˆèµ ï¼‰ã€‚ ä¸‹åˆçš„å¤§ä¼šæŠ¥å‘Šæˆ‘ç«Ÿç„¶å¬æ‡‚äº†ï¼Ÿï¼Ÿï¼Ÿè™½ç„¶åªæ˜¯å¬å‡ ä½æ•™æˆç®€å•ä»‹ç»è‡ªå·±çš„å·¥ä½œï¼Œä½†æ˜¯è¿˜æ˜¯å¾ˆå¼€å¿ƒæ²¡æœ‰ç½šåã€‚ æ™šä¸Šåœ¨å®¾é¦†å¼€æ‘†ã€‚æœ¬æ¥æ‰“ç®—æ‰“ä¸€ä¸‹åç‚¹çš„ cf ä½†æ˜¯å®åœ¨å¤ªç´¯äº†å°±ç¡äº†ã€‚ã€‚ 2023 / 04 / 09 ä¸Šåˆçš„æ–°è€è®ºå›ååˆ†æœ‰è¶£ï¼ŒæˆåŠŸçš„å‰è¾ˆä»¬éƒ½åœ¨å¼ºè°ƒå­¦æœ¯å“ä½å’Œå·¥ä½œè´¨é‡ï¼Œä½†å¹´è½»çš„è€å¸ˆä»¬éƒ½åœ¨æé—®åŸºé‡‘ç”³è¯·ç›¸å…³çš„é—®é¢˜ã€‚ã€‚ å¯¹äºå¤§å®¶ååˆ†å®é™…çš„æé—®å’Œå‰è¾ˆä»¬åœ¨å¼ºè°ƒçš„å…´è¶£å’Œå“ä½ï¼Œå¼ è€å¸ˆè¡¨ç¤ºï¼šä¸Šå²¸çš„ä¸æ‡‚è¿˜æ³¡åœ¨æ°´é‡Œçš„ç—›è‹¦ï½ æ”¶è·ï¼š1. å‰æœŸå¤šè¯»é¡¶ä¼šé¡¶åˆŠï¼Œå°½é‡é¿å…çœ‹æ°´åˆŠï¼ŒåŸ¹å…»å­¦æœ¯å“ä½ã€‚2. åšå£«æ¯•ä¸šåˆ«ç€æ€¥å…¥èŒï¼Œå¤šåšå‡ å¹´åšå£«åï¼Œè‡ªç”± + ç§¯ç´¯å®åŠ›ã€‚ ä¸‹åˆå»äº†æ©˜å­æ´²ï¼Œæ¹˜æ±Ÿä¸¤å²¸æ™¯è‰²å¾ˆå¥½ï¼Œç¯å²›èµ°äº†ä¸€ä¸ªå°å¤šå°æ—¶ç»ˆäºå’Œå¿ƒå¿ƒå¿µå¿µçš„æ¯›çˆ·çˆ·åƒåˆå½±å•¦ï¼ æ™šé¥­æ˜¯é«˜é“ä¸Šçš„éº¦å½“å½“ï¼Œå’Œå° Eva ä¸€èµ·åƒäº†ä¸€ä¸ªå¥¥åˆ©å¥¥éº¦æ—‹é£ï¼Œ2023çš„ç¬¬ä¸€ä¸ªå†°æ¿€å‡Œï½ 2023 / 04 / 10 ä¸‹åˆå›¢æ”¯éƒ¨å¤§ä¼šç»“æŸä¹‹åå•†é‡å›¢å»ºçš„äº‹æƒ…ã€‚ è§‰å¾—æœ€è¿‘å¤©æ°”ä¸é”™ï¼Œäºæ˜¯å†³å®šæ¥ä¸€åœºè¯´èµ°å°±èµ°çš„æ—…è¡Œï¼ä¸€èµ·å»åƒå²›æ¹–ï¼ è®¨è®ºäº†ä¸€ä¸‹ç›´æ¥å®šåœ¨ä¸‹å‘¨äºŒï¼Œæ™šä¸Šå°±ç›´æ¥å¼€å§‹æ”¶é›†å¤§å®¶çš„æ„å‘äº†ã€‚ è¿™å¯èƒ½å°±æ˜¯å¹´è½»çš„å¥½å¤„å§ï¼Œä¸ç”¨è€ƒè™‘å¤ªå¤šï¼Œæƒ³åˆ°äº†å°±å¯ä»¥å»åšã€‚ 2023 / 04 / 11 ä¸Šåˆçš„è®¨è®ºï¼Œå¼ è€å¸ˆæŠŠä¹‹å‰æƒ³çš„ç®—æ³•è¿‘ä¼¼æ¯”è¯å‡ºæ¥äº†ï¼Œæ„Ÿè§‰è‡ªå·±èŠ±çš„æ—¶é—´ç¡®å®æœ‰ç‚¹å°‘ã€‚ã€‚ã€‚ ä¸‹åˆè®­ç»ƒå‘ç° cf çˆ†ç‚¸äº†ï¼Œå» QOJ æ‰“äº† ICPC æ¹¾æ¹¾çœèµ›ï¼Œå„ç§æ‰‹è¯¯ååˆ†æ‹…å¿ƒçœèµ›çŠ¶æ€ã€‚ 2023 / 04 / 12 æ—©ä¸Šçš„é˜³å…‰é•¿è·‘ç»ˆäºå¯åŠ¨å•¦ï¼ å›¢å»ºæœ€ç»ˆæœ‰ 15 äººæŠ¥åï¼Œè¶…è¿‡äº†é¢„è®¡çš„ä¸€åŠï¼Œå¤§å®¶éƒ½æ„¿æ„æ¥å‚ä¸è¿˜æ˜¯å¾ˆå¼€å¿ƒçš„ã€‚ ä¸‹åˆå•†é‡å¥½äº†å»åƒå²›æ¹–å›¢å»ºçš„å…·ä½“å†…å®¹ï¼Œç»™å¤§å®¶ä¸€èµ·ä¹°äº†é«˜é“ç¥¨ï¼Œå¸Œæœ›å›¢å»ºä¸€åˆ‡é¡ºåˆ©å§ã€‚ 2023 / 04 / 13 åšå¼ˆè®ºè¯¾å¬çš„æœ‰ç‚¹è’™ï¼Œæ„Ÿè§‰å¾—æ‰¾æ—¶é—´è‡ªå·±å»çœ‹çœ‹ Tim Roughgarden çš„ç®—æ³•åšå¼ˆè®ºã€‚ æ™šä¸Šç»„ä¼šå‡†å¤‡äº†ä¸€äº›ä¸œè¥¿ï¼Œä½†æœ€åä¹Ÿæ²¡è½®åˆ°æˆ‘è®²ï¼Œå—ã€‚ã€‚ã€‚æœ€é‡è¦çš„è¿˜æ˜¯è‡ªå·±å¤šæ€»ç»“å§ã€‚ 2023 / 04 / 14 æ˜¨æ™š emo åˆ°å¤ªæ™šäº†ï¼Œç›´æ¥ç¡è¿‡äº†æ—©å…«è¯¾ï¼ˆwith Eva presentation çš„ pptï¼‰ã€‚ã€‚ã€‚ ç„¶åå° Eva ä»Šå¤©æ¥ä¾‹å‡äº†ï¼Œæ²¡ç²¾ç¥å¿ƒæƒ…å¥½åƒä¹Ÿä¸å¤ªå¥½ï¼Œä¸æ•¢æƒ¹ä¸æ•¢æƒ¹ã€‚ã€‚ã€‚ ä¸‹åˆå¬äº†ä¸€ä¸ª CCFAI å¤šæ™ºèƒ½ä½“ååŒçš„åœ¨çº¿ä¼šè®®ï¼Œæè€å¸ˆä¹Ÿåœ¨ï¼Œè®¨è®ºäº†å¾ˆå¤šå…³äºç ”ç©¶å¦‚ä½•è½åœ°çš„é—®é¢˜ã€‚ çŸ›ç›¾çš„æ˜¯ï¼Œæ„Ÿè§‰è‡ªå·±å†³å®šå»åšå­¦æœ¯æœ‰å¾ˆå¤§ä¸€éƒ¨åˆ†çš„åŸå› æ˜¯æƒ³è¿œç¦»å·¥ä¸šåœˆã€‚ã€‚ã€‚ 2023 / 04 / 15 çœèµ›æ—¥ï¼Œæ­å¸ˆå¤§å¥½å¤§ï¼Œä»è€ƒåœºåˆ°é£Ÿå ‚éª‘è½¦éƒ½è¦ååˆ†é’Ÿã€‚ é€€å½¹ä¹‹æˆ˜äº†ï¼Œä¹Ÿæ²¡å•¥å¿ƒç†å‹åŠ›ï¼Œä½†æ˜¯æ¯”èµ›ä½“éªŒå®åœ¨æ˜¯å·®ï¼Œè§ çŸ¥ä¹é“¾æ¥ ã€‚ æœ€åäºšå†›ä¹Ÿç®—æ˜¯æ¯”è¾ƒå¥½çš„ç»“å±€äº†ï¼Œä½†æ˜¯è§¦æ‰‹å¯åŠçš„æ¯ç€å®è®©æˆ‘éš¾ä»¥é‡Šæ€€ï¼ˆ ä½†æ˜¯ç®—æ³•ç«èµ›æ€»æ˜¯æœ‰é—æ†¾çš„å˜›ï¼Œäººç”Ÿä¹Ÿæ˜¯å¦‚æ­¤ï¼Œæ˜¯æ—¶å€™å‰å¾€ä¸€ä¸‹ä¸ªé˜¶æ®µäº†ã€‚ 2023 / 04 / 16 ä»Šå¤©è¢«ç¥ç§˜äººå£«å‘ŠçŸ¥æ˜¨å¤©çœèµ›çš„ J å†è°ƒä¸€è°ƒå‚æ•°æˆ‘é˜Ÿå¯èƒ½å°±è¿‡äº†ã€‚ã€‚ã€‚ å¥½ä¸å®¹æ˜“æ‰¾å›æ¥çš„å¿ƒæ€åˆå¤§ç ´é˜²äº†ä¸€æ¬¡ï¼Œéš¾é¡¶ã€‚åœ¨æ­å›¾æ‘†çƒ‚ç¡äº†ä¸€ä¸‹åˆã€‚ æœ€éš¾æ¥å—çš„æ˜¯æˆ‘éƒ½å†³å®šè¦é€€å½¹äº†åˆå‘Šè¯‰æˆ‘è¿™ç§æ¶ˆæ¯ï¼Œå¿ƒæœ‰ä¸ç”˜å•Šã€‚ã€‚ã€‚ 2023 / 04 / 18 å›¢å»ºå‡ºå‘å»åƒå²›æ¹–ï¼"}],"posts":[{"title":"We Bare Bears!","slug":"life/webarebears","date":"2023-04-15T16:00:00.000Z","updated":"2023-04-19T09:42:55.344Z","comments":true,"path":"life/webarebears/","link":"","permalink":"http://blog.gyx.me/life/webarebears/","excerpt":"","text":"æ­ç”µ 2022 - 4 é˜Ÿè®­ç»ƒè®°å½•ã€‚ ä¸ªäººé¢˜è§£ç‚¹è¡¨æ ¼ä¸­æ¯”èµ›åç§°è·³è½¬ã€‚ ç†Šç†Šä¸€å®¶å·²ç»é€€å½¹å•¦ï¼Œç¥å¤§å®¶éƒ½æœ‰å…‰æ˜çš„æœªæ¥ï½ Contests Date Contest Rank Solved Upsolved 2022/09/11 2022 CCPC Qualification Round 17 8 / 13 8 / 12 2022/09/17 2022 - 2023 ICPC Asia EC Regionals Online (I) 25 9 / 12 9 / 12 2022/11/06 2022 CCPC Weihai Site 12 8 / 13 10 / 13 2022/11/13 2022 CCPC Guangzhou Site 12 7 / 13 7 / 13 2022/11/20 2022 - 2023 ICPC Asia Hefei Regional 6 10 / 13 11 / 13 2022/12/18 2022 - 2023 ICPC Asia Nanjing Regional 13 7 / 13 8 / 13 2023/02/06 ICPC Training Camp powered by Huawei. Day 1 36 5 / 12 5 / 12 2023/02/07 ICPC Training Camp powered by Huawei. Day 2 15 7 / 11 7 / 11 2023/03/25 2022 - 2023 ICPC Asia East Continent Final 49 6 / 13 6 / 13 2023/04/15 2023 Zhejiang Provincial CPC 2 10 / 13 10 / 13 Virt. Contests Date Contest Rank Solved Upsolved 2022/07/31 2021 CCPC Finals 20 7 / 12 7 / 12 2022/08/31 2021 - 2022 ICPC Latin American Regional 21 8 / 13 8 / 13 2022/09/07 2019 - 2020 ICPC Northwestern European Regional 44 9 / 11 9 / 11 2022/09/25 XXI Open Cup, Grand Prix of Wroclaw 87 7 / 13 7 / 13 2022/10/02 2020 - 2021 ICPC Xiaomi Invitational, Finals 8 6 / 13 6 / 13 2022/10/16 2019 - 2020 ICPC Latin American Regional 45 10 / 13 11 / 13 2022/10/18 2018 CCPC Finals 26 6 / 12 7 / 12 2022/10/19 2019 ICPC World Finals 46 5 / 11 6 / 11 2022/10/26 2019 CCPC Finals 24 4 / 12 5 / 12 2022/10/29 2019 - 2020 ICPC Asia Hong Kong Regional 4 5 / 11 10 / 11 2022/10/31 2022 CCPC Guilin Site 31 7 / 13 10 / 13 2022/11/03 2018-2019 ICPC Asia Nanjing Regional 6 9 / 13 11 / 13 2022/11/08 2020-2021 ICPC Asia Yinchuan Regional 25 6 / 13 9 / 13 2022/11/14 2022-2023 ICPC North Western Russia Regional 6 9 / 14 10 / 14 2022/12/3 2022-2023 ICPC Asia Jinan Regional 16 7 / 13 9 / 13 2022/12/12 2022-2023 ICPC Asia Hangzhou Regional 18 7 / 13 10 / 13 2022/12/14 2015 ICPC Asia EC-Finals 7 7 / 13 7 / 13 2023/03/08 2017 CCPC Finals 23 6 / 11 6 / 11 2023/03/20 2022-2023 ICPC Asia Hong Kong Regional 8 7 / 12 7 / 12 2023/03/21 2022 ICPC Southeastern Europe Regional 43 8 / 14 8 / 14 2023/04/02 2018 ICPC Asia Qingdao Regional 66 8 / 13 8 / 13 2023/04/05 2020-2021 ICPC NEERC Regional 30 10 / 14 10 / 14 Multi-University Training Date Contest Rank Solved Upsolved 2022/07/23 2022 Nowcoder Multi-University Training Contest 2 40 9 / 12 10 / 12 2022/07/25 2022 Nowcoder Multi-University Training Contest 3 16 6 / 10 8 / 10 2022/07/26 2022 HDU Multi-University Training Contest 3 45 7 / 12 9 / 12 2022/07/28 2022 HDU Multi-University Training Contest 4 79 8 / 11 8 / 11 2022/07/30 2022 Nowcoder Multi-University Training Contest 4 16 10 / 14 11 / 14 2022/08/01 2022 Nowcoder Multi-University Training Contest 5 - 9 / 11 10 / 11 2022/08/02 2022 HDU Multi-University Training Contest 5 81 6 / 12 7 / 12 2022/08/04 2022 HDU Multi-University Training Contest 6 73 7 / 12 7 / 12 2022/08/06 2022 Nowcoder Multi-University Training Contest 6 65 6 / 13 8 / 13 2022/8/08 2022 Nowcoder Multi-University Training Contest 7 11 7 / 12 8 / 12 2022/08/09 2022 HDU Multi-University Training Contest 7 79 6 / 11 9 / 11 2022/08/11 2022 HDU Multi-University Training Contest 8 29 9 / 13 9 / 13 2022/08/13 2022 Nowcoder Multi-University Training Contest 8 28 3 / 12 4 / 12 2022/08/15 2022 Nowcoder Multi-University Training Contest 9 24 8 / 11 8 / 11 2022/08/16 2022 HDU Multi-University Training Contest 9 60 6 / 11 6 / 11 2022/08/17 2022 Nowcoder Multi-University Training Contest 0 29 6 / 13 6 / 13 2022/08/18 2022 HDU Multi-University Training Contest 10 14 10 / 12 10 / 12 2022/08/20 2022 Nowcoder Multi-University Training Contest 10 37 5 / 11 5 / 11","categories":[{"name":"Life & Blog","slug":"Life-Blog","permalink":"http://blog.gyx.me/categories/Life-Blog/"}],"tags":[]},{"title":"Basic Algebra I : Monoids and Groups","slug":"abstract-algebra/monoids-and-groups","date":"2023-02-02T03:21:07.000Z","updated":"2023-04-14T05:43:20.336Z","comments":true,"path":"abstract-algebra/monoids-and-groups/","link":"","permalink":"http://blog.gyx.me/abstract-algebra/monoids-and-groups/","excerpt":"","text":"Concepts from Set Theory THE POWER SET OF A SET Power Set \\(\\mathscr{P}(S)=\\{s|s\\subseteq S\\},\\ |\\mathscr{P}(S)|=2^{|S|}\\) . THE CARTESIAN PRODUCT SET. MAPS Cartesian Product Set \\(S\\times T = \\{(s,t)|s\\in S, t\\in T\\},\\ |S\\times T| = |S||T|\\) . Map of a set \\(S\\) into a set \\(T\\) ( \\(S \\stackrel{\\alpha}{\\rightarrow} T\\) ) : domain \\(S\\) , co-domain \\(T\\) , a subset \\(\\alpha\\) of \\(S\\times T\\) having properties: For any \\(s \\in S\\) there exists a \\(t \\in T\\) such that \\((s, t) \\in \\alpha\\). \"Single-valuedness\": If \\((s, t)\\) and \\(\\left(s, t^{\\prime}\\right) \\in \\alpha\\) then \\(t=t^{\\prime}\\). Composite / Product / Resultant of \\(\\alpha\\) and \\(\\beta\\) : \\((\\beta \\alpha)(s)=\\beta(\\alpha(s))\\) . Composition of maps satisfies the associative law : \\(\\gamma(\\beta\\alpha)=(\\gamma\\beta)\\alpha\\) Surjective : if im \\(\\alpha=T\\), that is, if the range coincides with the co-domain. Injective : if distinct elements of \\(S\\) have distinct images in \\(T\\), that is, if \\(s_1 \\neq s_2 \\Rightarrow \\alpha\\left(s_1\\right) \\neq \\alpha\\left(s_2\\right)\\). Bijective (a one to one correspondence) : If \\(\\alpha\\) is both injective and surjective. \\(S \\stackrel{\\alpha}{\\rightarrow} T\\) is bijective if and only if there exists a map \\(T \\stackrel{\\beta}{\\rightarrow} S\\) such that \\(\\beta \\alpha=1_S\\) and \\(\\alpha \\beta=1_T\\). Proof. Suppose \\(S \\stackrel{\\alpha}{\\rightarrow} T\\) is bijective. Consider the subset \\(\\beta\\) of \\(T \\times S\\) of elements \\((\\alpha(s), s)\\). If \\(t \\in T\\), surjectivity of \\(\\alpha\\) implies there is an \\(s\\) in \\(S\\) such that \\(\\alpha(s)=t\\). Hence condition 1 in the definition of a map from \\(T\\) to \\(S\\) holds for the set \\(\\beta\\) of pairs \\((\\alpha(s), s) \\in T \\times S\\). Condition 2 holds for \\(\\beta\\) by the injectivity of \\(\\alpha\\), since if \\(\\left(t, s_1\\right)\\) and \\(\\left(t, s_2\\right)\\) are in \\(\\beta\\), then \\(\\alpha\\left(s_1\\right)=t\\) and \\(\\alpha\\left(s_2\\right)=t\\), so \\(s_1=s_2\\). Hence we have the map \\(T \\stackrel{\\beta}{\\rightarrow} S\\). If \\(s \\in S\\), the facts that \\((s, \\alpha(s)) \\in \\alpha\\) and \\((\\alpha(s), s) \\in \\beta\\) imply that \\(\\beta(\\alpha(s))=s\\). Thus \\(\\beta \\alpha=1_s\\). If \\(t \\in T\\), we have \\(t=\\alpha(s), s \\in S\\), and \\((t, s) \\in\\) \\(\\beta\\), so \\(\\beta(t)=s \\in S\\). Hence \\(\\alpha(\\beta(t))=\\alpha(s)=t\\), so \\(\\alpha \\beta=1_T\\). Conversely, suppose \\(S \\stackrel{\\alpha}{\\rightarrow} T, T \\stackrel{\\beta}{\\rightarrow} S\\) satisfy \\(\\beta \\alpha=1_S, \\alpha \\beta=1_T\\). If \\(t \\in T\\), let \\(s=\\beta(t)\\). Then \\(\\alpha(s)=\\) \\(\\alpha(\\beta(t))=t\\); hence \\(\\alpha\\) is surjective. Next suppose \\(\\alpha\\left(s_1\\right)=\\alpha\\left(s_2\\right)\\) for \\(s_i \\in S\\). Then \\(s_1=\\) \\(\\beta\\left(\\alpha\\left(s_1\\right)\\right)=\\beta\\left(\\alpha\\left(s_2\\right)\\right)=s_2\\), and \\(\\alpha\\) is injective. Inverse with \"dressing-undressing principle\" : \\((\\beta \\alpha)^{-1}=\\alpha^{-1} \\beta^{-1}\\) . EQUIVALENCE RELATIONS. FACTORING A MAP Equivalence Relation : Reflexive property \\(aEa\\) , Symmetry \\(a E b \\Rightarrow b E a\\) , Transitivity \\(a E b\\ \\text{and}\\ b E c \\Rightarrow a E c\\) . equivalence class determined by \\(a\\) : \\(\\bar{a}_E\\) (or simply \\(\\bar{a}\\) ) \\(=\\{b \\in S \\mid b E a\\}\\). An equivalence relation is equivalent to that of a partition of a set. \\(\\pi_E =\\{\\bar{a} \\mid a \\in S\\}\\). the quotient set of \\(S\\) relative to the relation \\(E\\) : \\(S / E=\\pi=\\{\\bar{a} \\mid a \\in S\\}\\) , a subset of the power set \\(\\mathscr{P}(S)\\) of \\(S\\). natual map : \\(v: a \\rightarrow \\bar{a} .\\) Inverse Image : Construct \\(E_\\alpha\\) by map \\(S \\stackrel{\\alpha}{\\rightarrow} T\\) : \\(a E_\\alpha b\\Leftrightarrow \\alpha(a)=\\alpha(b)\\) , then \\(\\alpha^{-1}(c)=\\{a\\in S|\\alpha(a)=c\\}\\) \\(\\bar{\\alpha}:S/E_\\alpha\\to T\\) the map of \\(S/E_{\\alpha}\\) induced by \\(\\alpha\\) : \\(\\bar{\\alpha}(\\bar{a})=\\alpha(a),\\ \\bar{a}=\\alpha^{-1}(\\alpha(a))\\) , injective. Factorization of map \\(\\alpha\\) : \\(\\alpha=\\bar{\\alpha}v\\) ï¼Œwhere \\(v\\) is the natural map of \\(S\\) to \\(S/E_\\alpha\\) . è¿›å…¥æ­£é¢˜ï¼ ç ”ç©¶è§’åº¦ï¼š1. æœ¬èº«æ€§è´¨ï¼›2. å­ç»“æ„ï¼ˆå­ç¾¤ã€æ­£è§„å­ç¾¤ï¼‰ï¼›3. æ˜ å°„å…³ç³»ï¼ˆç¾¤åŒæ„ï¼Œç¾¤åŒæ€ï¼‰ Monoids of Transformations and Abstract Monoids semi-group. åŠç¾¤ï¼šå°é—­æ€§ï¼Œç»“åˆå¾‹ã€‚ monoid. å¹ºåŠç¾¤ \\((M,p,1)\\) ï¼šå°é—­æ€§ï¼Œç»“åˆå¾‹ï¼Œå•ä½å…ƒã€‚ submonoid. å­å¹ºåŠç¾¤ \\((N,p,1)\\) ï¼šé›†åˆåŒ…å« \\(N\\subseteq M\\) ï¼Œæ˜¯å¹ºåŠç¾¤ã€‚ set of transformations of S. åœ¨ \\(S\\) ä¸Šçš„å˜æ¢é›† \\(M(S)\\) ï¼šåŒ…å«æ‰€æœ‰ \\(S\\to S\\) çš„å‡½æ•°çš„é›†åˆï¼Œ\\(|M(S)|=|S|^{|S|}\\) ã€‚ monoid of transformations. å˜æ¢å¹ºåŠç¾¤ï¼š\\((M(S), \\text{æ˜ å°„å¤åˆ}, 1_S)\\) çš„å­ç¾¤ Groups of Transformations and Abstract Groups group. ç¾¤ \\((G,p,1)\\) ï¼šå°é—­æ€§ï¼Œç»“åˆå¾‹ï¼Œå•ä½å…ƒï¼Œæ‰€æœ‰å…ƒç´ å¯é€†ã€‚ subgroup. å­ç¾¤ \\((H,p,1)\\) ï¼šé›†åˆåŒ…å« \\(H\\subseteq G\\) ï¼Œæ˜¯ç¾¤ã€‚è®°ä½œ \\(H\\le G\\) ã€‚ the group of invertible elements of M. å¹ºåŠç¾¤ \\(M\\) ä¸­å¯é€†å…ƒç»„æˆçš„ç¾¤ \\(U(M)\\) ï¼šå®¹æ˜“éªŒè¯æ˜¯ä¸€ä¸ªç¾¤ã€‚ symmetric group of the set S. \\(S\\) çš„å¯¹ç§°ç¾¤ \\(\\text{Sym}\\ S=U(M(S))\\) : \\(S\\) ä¸Šçš„å¯é€†å˜æ¢æ„æˆçš„ç¾¤ï¼ˆå…¨ä½“åŒå°„ï¼‰ã€‚ group of transformations. å˜æ¢ç¾¤ï¼šå¯¹ç§°ç¾¤ \\(\\text{Sym}\\ S\\) çš„å­ç¾¤ã€‚ symmetric group on n letters. \\(n\\) å…ƒå¯¹ç§°ç¾¤ \\(S_n\\) ï¼š\\(\\{1,2,\\dots n\\}\\) çš„å…¨ä½“æ’åˆ—æ„æˆçš„ç¾¤ï¼Œ\\(|S_n|=n!\\) ã€‚ permutation group. ç½®æ¢ç¾¤ï¼šæœ‰é™å…ƒå¯¹ç§°ç¾¤ \\(S_n\\) çš„å­ç¾¤ã€‚ Isomorphism. Cayley's theorem isomorphic. å¹ºåŠç¾¤/ç¾¤åŒæ„ï¼šå­˜åœ¨åŒå°„ \\(\\eta:M\\to M&#39;\\) ï¼Œä¿è¿ç®— \\(\\eta(xy)=\\eta(x)\\eta(y)\\) ï¼Œä¸” \\(\\eta(1)=1&#39;\\) ï¼ˆå¯ç”±ä¿è¿ç®—æ¨å‡ºï¼‰ã€‚ isomorphism. åŒæ„å‡½æ•° \\(\\eta\\) ï¼Œå¯èƒ½ä¸æ­¢ä¸€ä¸ªï¼Œä¾‹å¦‚ \\((\\mathbb{R},+,0)\\) å’Œ \\((\\mathbb{R}^+,\\cdot\\ ,1)\\) çš„åŒæ„å‡½æ•°å¯ä»¥å– \\(\\eta(x)=a^x\\ (a&gt;0,a\\not= 1)\\) ã€‚ åŒæ„æ˜¯ä¸€ä¸ªç­‰ä»·å…³ç³»ï¼Œå¯ä»¥é€šè¿‡å•ä½æ˜ å°„å®ç°è‡ªåæ€§ï¼ŒåŒæ„å‡½æ•°çš„æ±‚é€†å’Œå¤åˆå®ç°å¯¹ç§°æ€§å’Œä¼ é€’æ€§ã€‚ Cayley å®šç†ï¼š (1) ä»»æ„å¹ºåŠç¾¤ \\(M\\) åŒæ„äºä¸€ä¸ªäº¤æ¢å¹ºåŠç¾¤ï¼›(2) ä»»æ„ç¾¤ \\(G\\) åŒæ„äºä¸€ä¸ªäº¤æ¢ç¾¤ã€‚ ï¼ˆ1ï¼‰å¯¹ \\(M\\) ä¸­çš„æ¯ä¸ªå…ƒç´  \\(a\\) å®šä¹‰å·¦å¹³ç§»å˜æ¢ \\(a_L:M\\to M, a_L(x)=ax\\) ï¼Œåˆ™ \\(M\\) åŒæ„äºå˜æ¢å¹ºåŠç¾¤ \\(M_L=\\{a_L|a\\in M\\}\\) ã€‚ ï¼ˆ2ï¼‰åŒç†æ„é€ ï¼Œé¢å¤–éªŒè¯å¯¹æ±‚é€†å…ƒå°é—­ï¼š\\(1_L=(a^{-1}a)_L=(a^{-1})_La_L\\) ï¼Œå³ \\(a_L\\) çš„é€†æ˜¯ \\((a^{-1})_L\\) ã€‚ æ¨è®ºï¼šä»»æ„ \\(n\\) é˜¶æœ‰é™ç¾¤åŒæ„äºä¸€ä¸ª \\(n\\) å…ƒç½®æ¢ç¾¤ã€‚ Generalized Associativity. Commutativity å¹¿ä¹‰ç»“åˆå¾‹ï¼š ç”±ç»“åˆå¾‹å¯å¯¼å‡º \\((\\prod_{i=1}^na_i)(\\prod_{j=1}^m a_{j+n})=\\prod_{i=1}^{n+m} a_k\\) ï¼Œè¿›ä¸€æ­¥å¯å®šä¹‰æ•´æ•°æ¬¡å¹‚è¿ç®— \\(a^n\\) å’Œ \\(a^{-n}=(a^{-1})^n\\) commute. ç§° \\(a,b\\in M\\) æ˜¯å¯äº¤æ¢çš„ï¼Œå½“ä¸”ä»…å½“ \\(ab=ba\\) ã€‚å¯¹äºä¸€ç»„å¯äº¤æ¢çš„å…ƒç´ è¿ä¹˜ï¼Œè¿ç®—çš„é¡ºåºå¹¶ä¸é‡è¦ã€‚ commutative monoid. äº¤æ¢å¹ºåŠç¾¤ï¼šå¹ºåŠç¾¤ \\(M\\) ï¼Œä»»æ„ä¸¤å…ƒç´  \\(a,b\\) å‡å¯äº¤æ¢ã€‚ abelian groups (commutative groups). é˜¿è´å°”ç¾¤ï¼ˆäº¤æ¢ç¾¤ï¼‰ï¼šç¾¤ \\(G\\) ï¼Œä»»æ„ä¸¤å…ƒç´  \\(a,b\\) å‡å¯äº¤æ¢ã€‚ centralizer of a. \\(a\\) çš„ä¸­å¿ƒåŒ–å­ \\(C(a)\\) ï¼š \\(M\\) ä¸­ä¸ \\(a\\) å¯äº¤æ¢çš„å…ƒç´ é›†ã€‚æ˜“è¯ \\(C(a)\\) æ˜¯ \\(M\\) çš„å­å¹ºåŠç¾¤ï¼Œå®šä¹‰åŒæ ·é€‚ç”¨äºç¾¤ã€‚ å¼•ç†ï¼šå¹ºåŠç¾¤ \\(M\\) çš„è‹¥å¹²ä¸ªå­å¹ºåŠç¾¤çš„äº¤ä»ç„¶æ˜¯å¹ºåŠç¾¤ï¼Œç¾¤ \\(G\\) çš„è‹¥å¹²ä¸ªå­ç¾¤çš„äº¤ä»ç„¶æ˜¯ç¾¤ã€‚ å°†ä¸­å¿ƒåŒ–å­çš„å®šä¹‰æ‰©å±•åˆ°é›†åˆï¼Œå®šä¹‰é›†åˆ \\(A\\) çš„ä¸­å¿ƒåŒ–å­ \\(C(A) = \\cap_{a\\in A} C(a)\\) ï¼Œç”±å¼•ç† \\(C(A)\\) æ˜¯å­å¹ºåŠç¾¤ï¼ˆå­ç¾¤ï¼‰ã€‚ the center of M. \\(M\\) çš„ä¸­å¿ƒ \\(C(M)\\) ï¼šå«ä¹‰æ˜¯ \\(M\\) ä¸­å¯ä»¥ä¸æ‰€æœ‰å…ƒç´ äº¤æ¢çš„å…ƒç´ é›†ï¼Œæ˜¾ç„¶åŒ…å« \\(1\\) ã€‚ åœ¨äº¤æ¢å¹ºåŠç¾¤/äº¤æ¢ç¾¤ä¸­æˆ‘ä»¬å¸¸ç”¨åŠ å·æ¥ä»£æ›¿ä¹˜å·æ¥è¡¨ç¤ºå¯¹åº”è¿ç®—ï¼Œç”¨ \\(0\\) ä»£æ›¿ \\(1\\) æ¥è¡¨ç¤ºå•ä½å…ƒã€‚ Submonoids and Subgroups Generated by a Subset. Cyclic Groups the submonoid generated by S. ç”± \\(S\\) ç”Ÿæˆçš„å­å¹ºåŠç¾¤ \\(\\langle S\\rangle\\) ï¼šå¯¹äº \\(S\\subseteq M\\) ï¼Œ \\(M\\) ä¸­åŒ…å« \\(S\\) çš„æœ€å°çš„å­å¹ºåŠç¾¤ã€‚ æŠ½è±¡åˆ»ç”»ï¼ˆå­˜åœ¨æ€§ï¼‰ï¼šå–æ‰€æœ‰åŒ…å« \\(S\\) çš„å­ç¾¤æ±‚äº¤å³ä¸º \\(\\langle S\\rangle\\) ï¼Œä¸” \\(\\langle S\\rangle\\) æ˜¯ä»»æ„åŒ…å« \\(S\\) çš„å­ç¾¤çš„å­ç¾¤ï¼› æ„é€ æ€§è¯æ˜ï¼š\\(\\langle S\\rangle=\\{1,s_1s_2\\cdots s_r|s_i\\in S, r \\text{ä¸ºæœ‰ç©·æ­£æ•´æ•°}\\}\\) ï¼Œé¦–å…ˆå³ä¾§æ˜¯ä¸ªå¹ºåŠç¾¤ï¼Œç„¶åè¯äº’ç›¸åŒ…å«ï¼š ç”±å¹ºåŠç¾¤çš„è¿ç®—å°é—­æ€§ï¼Œ \\(\\langle S\\rangle\\) åŒ…å«å³ä¾§æ„æˆçš„å¹ºåŠç¾¤ï¼› å³ä¾§çš„é›†åˆåŒ…å« \\(S\\) ï¼ˆå– \\(r=1\\) ) ï¼Œç”±å­˜åœ¨æ€§å¼•ç†ï¼Œè¿›ä¸€æ­¥çš„å³ä¾§çš„å¹ºåŠç¾¤åŒ…å« \\(\\langle S\\rangle\\) ã€‚ the subgroup generated by S. ç”± \\(S\\) ç”Ÿæˆçš„å­ç¾¤ \\(\\langle S \\rangle\\) ï¼šå®šä¹‰åŒä¸Šè¿°ï¼Œ\\(\\langle S\\rangle=\\{1,s_1s_2\\cdots s_r|s_i\\ \\text{or}\\ s_i^{-1}\\in S, r \\text{ä¸ºæœ‰ç©·æ­£æ•´æ•°}\\}\\) cyclic group. å¾ªç¯ç¾¤ï¼šç”±ä¸€ä¸ªå…ƒç´ çš„é›†åˆç”Ÿæˆçš„ç¾¤ \\(G=\\langle a\\rangle=\\{a^k|k\\in \\mathbb{Z}\\}\\) ï¼Œæ˜¾ç„¶æ˜¯ä¸€ä¸ªé˜¿è´å°”ç¾¤ï¼ˆå¯äº¤æ¢ï¼‰ã€‚ ä»»æ„æ— é™å¾ªç¯ç¾¤éƒ½ä¸ \\((\\mathbb{Z},+,0)=\\langle1\\rangle\\) åŒæ„ï¼Œé€šè¿‡æ˜ å°„ \\(n\\to a^n\\) ã€‚ ä»»æ„æœ‰é™é˜¶ï¼ˆ\\(n\\) é˜¶ï¼‰å¾ªç¯ç¾¤éƒ½ä¸ \\(n\\) æ¬¡å•ä½æ ¹ç”Ÿæˆçš„å¾ªç¯ç¾¤ \\(U_n=\\{x|x^n=1\\}\\) åŒæ„ã€‚ å¾ªç¯ç¾¤çš„å­ç¾¤æ˜¯å¾ªç¯ç¾¤ï¼› æ— é™å¾ªç¯ç¾¤ \\(\\langle a\\rangle\\) çš„å­ç¾¤éƒ½æ˜¯æ— é™çš„ï¼Œä¸” \\(s\\to \\langle a^s\\rangle\\) æ˜¯ \\(\\mathbb{N}\\) åˆ° \\(\\langle a\\rangle\\) çš„å…¨ä½“å­ç¾¤çš„åŒå°„ï¼ˆ \\(a\\) ä»»æ„æ¬¡å¹‚ç”Ÿæˆçš„ç¾¤ä¸¤ä¸¤ä¸åŒï¼‰ï¼› \\(n\\) é˜¶å¾ªç¯ç¾¤ \\(\\langle a\\rangle\\) çš„å­ç¾¤çš„é˜¶éƒ½æ˜¯ \\(n\\) çš„å› æ•°ï¼Œä¸”å¯¹äº \\(n\\) çš„æ¯ä¸ªå› æ•° \\(q\\) ï¼Œæœ‰ä¸”ä»…æœ‰ä¸€ä¸ª \\(\\langle a\\rangle\\) çš„å­ç¾¤é˜¶ä¸º \\(q\\) ã€‚ è¿™ä¸ª \\(q\\) é˜¶å­ç¾¤å¯ä»¥è¢«æ„é€ æ€§çš„åˆ»ç”»ï¼š\\(H=\\{b|b\\in \\langle a\\rangle,b^q=1\\}\\) ã€‚ the order of a å…ƒç´  \\(a\\) çš„é˜¶ \\(o(a)\\) ï¼šè‹¥ \\(\\langle a \\rangle\\) æ˜¯æ— é™ç¾¤ \\(\\langle a \\rangle=+\\infty\\) ï¼›å¦åˆ™ \\(o(a)=|\\langle a\\rangle|=r\\) ï¼Œå…¶ä¸­ \\(r\\) æ˜¯æ»¡è¶³ \\(a^r=1\\) çš„æœ€å°æ­£æ•´æ•°ã€‚ è‹¥ \\(a^m=1\\) ï¼Œåˆ™ \\(o(a) | m\\) ã€‚ è‹¥ \\(o(a)=r&lt;+\\infty\\) ï¼Œåˆ™ \\(o(a^k)=[r,k]/k=r/(r,k)\\) ï¼Œå› æ­¤ \\(o(a^k)|r\\) ã€‚ exponent of a finite group G. æœ‰é™ç¾¤ \\(G\\) çš„æ–¹æ¬¡æ•° \\(\\text{exp}\\ G=\\) æœ€å°çš„æ­£æ•´æ•° \\(e\\) ï¼Œæ»¡è¶³ \\(\\forall x \\in G,\\ x^e=1\\) ã€‚ å®šç†ï¼šæœ‰é™äº¤æ¢ç¾¤æ˜¯å¾ªç¯ç¾¤çš„å……è¦æ¡ä»¶ä¸ºæ–¹æ¬¡æ•°ç­‰äºé˜¶æ•°ï¼ˆ \\(\\text{exp}\\ G = |G|\\) ï¼‰ã€‚ å¼•ç† 1. è®¾ \\(G\\) ä¸ºæœ‰é™äº¤æ¢ç¾¤ï¼Œè®¾ \\(g,h\\in G\\) ä¸” \\(o(g)=m,o(h)=n,(m,n)=1\\) ï¼Œåˆ™ \\(o(gh)=mn\\) ã€‚ \\((gh)^{mn}=g^{mn}h^{mn}=(g^m)^n(h^n)^m=1\\) ã€‚ å‡è®¾ \\((gh)^r=1\\) ï¼Œè®¾ \\(k=g^r=h^{-r}\\in\\langle g\\rangle \\cap \\langle h\\rangle\\) ï¼Œæœ‰ \\(o(k)|m,o(k)|n\\Rightarrow o(k)|(m,n)\\Rightarrow o(k)=1\\) å› æ­¤ \\(g^r=k=1\\Rightarrow (gh)^r=g^rh^r=h^r=1\\) å› æ­¤ \\(m|r,n|r\\Rightarrow [m,n]|r\\) åˆ \\((m,n)=1\\) æœ‰ \\(mn|r\\) ã€‚ å¼•ç† 2. è®¾ \\(G\\) ä¸ºæœ‰é™äº¤æ¢ç¾¤ï¼Œè®¾ \\(g=\\arg\\max_{g\\in G} o(g)\\) ï¼Œåˆ™ \\(\\text{exp}\\ G=o(g)\\) ã€‚ æ ‡å‡†åˆ†è§£ \\(o(g)=p_1^{e_1}p_2^{e_2}\\dots p_s^{e_s},o(h)=p_1^{f_1}p_2^{f_2}\\dots p_s^{f_s}\\ (e_i,f_i\\ge 0)\\) åè¯ï¼šè‹¥ \\(h\\in G, h^{o(g)}\\not =1\\) ï¼Œåˆ™ä¸€å®šå­˜åœ¨æŸä¸ª \\(f_i&gt; e_i\\) ï¼Œä¸å¦¨è®¾ \\(f_1&gt;e_1\\) ã€‚ æ¥ä¸‹æ¥æˆ‘ä»¬æ„é€ ä¸€ä¸ªä¸ \\(\\arg\\max\\) å†²çªçš„å…ƒç´ ï¼šè®¾ \\(g&#39;=g^{p_1^{e_1}},h&#39;=h^{p_2^{f_2}\\dots p_s^{f_s}}\\) ï¼Œ äºæ˜¯æœ‰ \\(o(g&#39;)=p_2^{e_2}\\dots p_s^{e_s},o(h&#39;)=p_1^{f_1}\\) ï¼Œé‚£ä¹ˆç”±å¼•ç† 1ï¼Œ \\(o(g&#39;h&#39;)=p_1^{f_1}p_2^{e_2}\\dots p_s^{e_s}&gt;o(g)\\) çŸ›ç›¾ã€‚ \" \\(\\Rightarrow\\) \" è¯æ˜ï¼šç”±äºæ˜¯å¾ªç¯ç¾¤ \\(G=\\langle g\\rangle\\) ï¼Œ\\(|G|=|\\langle g\\rangle|=o(g)=\\text{exp}\\ G\\) ã€‚ \" \\(\\Leftarrow\\) \" è¯æ˜ï¼šç”±å¼•ç† 2ï¼Œå­˜åœ¨ \\(g\\) ä½¿å¾— \\(\\text{exp}\\ G=o(g)\\) ï¼Œåˆç”±äºäº¤æ¢ç¾¤ \\(G\\) æ»¡è¶³ \\(\\text{exp}\\ G=|G|\\) ï¼Œå› æ­¤ \\(|G|=o(g)=|\\langle g\\rangle|\\) ã€‚ Cycle Decomposition of Permutations r-cycle \\(r\\) - å¾ªç¯ï¼šè‹¥ç½®æ¢ \\(\\gamma\\) æ»¡è¶³å»æ‰ç¨³å®šç‚¹åï¼Œæ»¡è¶³ç½®æ¢æ•ˆæœæ˜¯å¾ªç¯ï¼Œå³å¯¹äºæ‰€æœ‰ä¸æ˜¯ç¨³å®šç‚¹çš„ä¸‹æ ‡ \\(i_1,i_2,\\dots,i_r, (r&gt;1)\\) ï¼š \\[ \\gamma(i_1)=i_2,\\gamma(i_2)=i_3,\\dots,\\gamma(i_{r-1})=i_r,\\gamma(i_r)=i_1 \\] æ­¤æ—¶æˆ‘ä»¬ç§°è¿™ç»„æ•°æ˜¯ä¸€ä¸ª \\(r\\) - å¾ªç¯ï¼Œè®°ä½œ \\(\\gamma=(i_1i_2\\dots i_r)\\) ï¼Œå³æ¯ä¸ªç‚¹éƒ½ä¼šæ¢æˆå³ä¾§çš„ï¼ŒåŒç†å¯ä»¥è®°ä½œ \\(\\gamma=(i_2i_3\\dots i_ri_1)\\) ç­‰ç­‰ã€‚ ç”¨æ’åˆ—çš„å¤åˆå¯å¾— \\(\\gamma^k(i_j)=i_{j+k}\\) (ä¸‹æ ‡æ¯ \\(r\\) å¾ªç¯)ã€‚æ˜æ˜¾ \\(\\gamma^r=1\\) ä¸” \\(\\gamma^k \\not = 1,1\\le k&lt;r\\) ï¼Œæ‰€ä»¥ \\(\\gamma\\) çš„é˜¶ï¼ˆorderï¼‰ä¸º \\(r\\) ã€‚ disjoint è‹¥ä¸¤ä¸ªå¾ªç¯åŒ…å«çš„å…ƒç´ æ— äº¤ï¼Œåˆ™ç§°ä¸¤ä¸ªå¾ªç¯ä¸ç›¸äº¤ï¼Œå¯¹åº”çš„æ’åˆ—å¤åˆç­‰åŒäºåˆ†åˆ«è¿ç®—ï¼Œæ­¤æ—¶æ’åˆ—å¤åˆæ˜¯å¯äº¤æ¢çš„ã€‚ è€ƒè™‘ä¸€ç»„å¾ªç¯ï¼ˆå¯¹åº”ç½®æ¢ï¼‰çš„è¿ä¹˜ç§¯ \\(\\alpha=(i_1i_2\\dots i_{n_1})(j_1j_2\\dots j_{n_2})\\dots(l_1l_2\\dots l_{n_k})\\) ï¼Œé‚£ä¹ˆ \\(o(\\alpha)=[n_1,n_2,\\dots,n_m]\\) ã€‚ è‹¥æˆ‘ä»¬å¼•å…¥ \\(1\\) - å¾ªç¯ï¼Œåˆ™å¾ˆå®¹æ˜“å¾—åˆ°ç½®æ¢å”¯ä¸€åˆ†è§£ä¸ºä¸ç›¸äº¤çš„å¾ªç¯çš„æ–¹æ³•ï¼Œæ¯æ¬¡ä»æœ€å°æœªä½¿ç”¨çš„å…ƒç´ æ‰¾åˆ°ä¸€ä¸ªå¾ªç¯ã€‚ transposition å¯¹æ¢ï¼šä¸€ä¸ª \\(2\\) - å¾ªç¯ï¼Œå³ \\((ab)\\) çš„å½¢å¼ã€‚ä»»ä½•ä¸€ä¸ª \\(r\\) - å¾ªç¯éƒ½å¯ä»¥æ‹†æˆ \\(r-1\\) ä¸ªå¯¹æ¢çš„ä¹˜ç§¯ï¼Œå³ï¼š \\[ (i_1i_2\\dots i_r)=(i_1i_r)\\dots (i_1i_3)(i_1i_2) \\] å› æ­¤ä¸€ä¸ªç½®æ¢ \\(\\alpha\\) å¯ä»¥æ‹†æˆ \\(N(\\alpha)=\\sum (n_i-1)\\) ä¸ªå¯¹æ¢çš„ä¹˜ç§¯ã€‚ ä¸€ä¸ªç½®æ¢çš„å¯¹æ¢åˆ†è§£ä¸æ˜¯å”¯ä¸€çš„ï¼ˆåœ¨æœ€ç®€å•çš„å¯¹æ¢åˆ†è§£åŸºç¡€ä¸Šå¯ä»¥å¼•å…¥å¾ˆå¤šé¢å¤–çš„å¯¹æ¢ï¼‰ï¼Œä½†å…±æ€§æ˜¯å¯¹æ¢ä¸ªæ•°çš„å¥‡å¶æ€§ç›¸åŒã€‚ å¯¹æ¢è¯±å¯¼åˆ†è£‚å…¬å¼ï¼š\\((ab)(ac_1\\dots c_hbd_1\\dots d_k)=(bd_1\\dots d_k)(ac_1\\dots c_h)\\) ã€‚ å¯¹æ¢è¯±å¯¼åˆå¹¶å…¬å¼ï¼š\\((ab)(bd_1\\dots d_k)(ac_1\\dots c_h)=(ac_1\\dots c_hbd_1\\dots d_k)\\) è‹¥ \\(N(\\alpha)\\) ä¸ºå¥‡æ•°ï¼ˆå¶æ•°ï¼‰åˆ™ç§°ä¹‹ä¸ºå¥‡ï¼ˆå¶ï¼‰æ’åˆ—ï¼Œåˆ™å¥‡å¶æ’åˆ—åˆ†åˆ«æ„æˆäº† \\(S_n\\) çš„ä¸€ä¸ªå­ç¾¤ï¼Œä¸”å¤§å°ç›¸åŒå‡ä¸º \\(n!/2\\) ã€‚ Orbits. Coset of a Subgroup G-equivalent å¯¹äºé›†åˆ \\(S\\) ä¸Šçš„å˜æ¢ç¾¤ \\(G\\) å’Œä¸¤å…ƒç´  \\(x,y\\) ï¼Œè‹¥å­˜åœ¨ \\(\\alpha\\in G\\) ä½¿å¾— \\(y=\\alpha(x)\\) åˆ™ç§°ä¸¤å…ƒç´  \\(G\\) - ç­‰ä»· \\(x\\sim_G y\\) ã€‚ ç”±äº \\(G\\) æ˜¯å˜æ¢ç¾¤ï¼Œå®¹æ˜“éªŒè¯æ˜¯ç­‰ä»·å…³ç³»ï¼šè‡ªåæœ‰ \\(1_S\\in G\\) ï¼Œå¯¹ç§°æœ‰ \\(\\alpha^{-1}\\in G\\) ï¼Œä¼ é€’æ˜¯ç¾¤çš„å°é—­æ€§ã€‚ G-orbit \\(G\\) - è½¨é“ï¼šç”± \\(G\\) - ç­‰ä»·å…³ç³»å¯¼å‡ºç­‰ä»·ç±» \\(Gx=\\{\\alpha(x)|\\alpha\\in G\\}\\) transitive group ä¼ é€’ç¾¤ï¼šè‹¥ \\(G\\) - è½¨é“åªæœ‰ä¸€ä¸ªï¼ˆ \\(S\\) ä¸­å…¨ä½“å…ƒç´ ç­‰ä»·ï¼‰åˆ™ç§° \\(G\\) æ˜¯ \\(S\\) çš„ä¼ é€’ç¾¤ã€‚ left (right) translations å®šä¹‰å·¦å¹³ç§» \\(g_L: x\\to gx\\) ï¼Œå³å¹³ç§» \\(g_R:x\\to xg\\) ã€‚ å®šä¹‰å˜æ¢ç¾¤ \\(G_L=\\{g_L|g\\in G\\},G_R=\\{g_R|g\\in G\\}\\) ï¼Œç”±äº \\(y=gx\\) å’Œ \\(y=xg\\) éƒ½æ˜¯å¯è§£çš„ï¼Œæ‰€ä»¥ä¸¤è€…éƒ½æ˜¯ä¼ é€’ç¾¤ã€‚ å‡è®¾ \\(H\\) æ˜¯ \\(G\\) çš„ä¸€ä¸ªå­ç¾¤ï¼Œå®šä¹‰ \\(H_L(G)=\\{h_L|h\\in H\\}\\) ï¼ˆ \\(h_L\\) è¿˜æ˜¯å®šä¹‰åœ¨ \\(G\\) ä¸Šçš„ï¼‰ï¼Œ\\(H_L(G)\\) ä¹Ÿæ˜¯ä¸€ä¸ªå˜æ¢ç¾¤ï¼ˆ \\(g\\to g_L\\) æ˜¯åŒæ„æ˜ å°„ï¼‰ã€‚ åˆ™ \\(H_L\\) å¯¼å‡ºçš„è½¨é“ \\(Hx=\\{hx|h\\in H\\}\\) ç§°ä½œ \\(x\\) å…³äº \\(H\\) çš„å³é™ªé›†ï¼Œæ˜“è¯ä»»æ„å³é™ªé›†å¤§å°ç›¸åŒï¼Œå› æ­¤ \\(|Hx|=|H1|=|H|\\) ã€‚ å‡è®¾ \\(G\\) æ˜¯æœ‰é™ç¾¤ï¼Œä¸” \\(|G|=n,|H|=m\\) ï¼Œç”¨ \\(H_L(G)\\) - è½¨é“å°† \\(G\\) åˆ’åˆ†ä¸º \\(G=Hx_1\\cup Hx_2\\cup\\dots\\cup Hx_r\\) ã€‚ ç§° \\(r\\) ä¸º \\(H\\) åœ¨ \\(G\\) ä¸­çš„æŒ‡æ•°ï¼ˆindexï¼‰è®°ä½œ \\([G:H]\\) ã€‚æ­¤æ—¶æœ‰ï¼š1.åˆ’åˆ†ä»»æ„ä¸¤ä¸ªé›†åˆæ— äº¤ï¼› 2. \\(|Hx_i|=|H|=m\\) ã€‚å¯ä»¥å¾—å‡º \\(n=mr\\) ã€‚ è¿™æ ·å°±è¯æ˜äº† æ‹‰æ ¼æœ—æ—¥å®šç† ï¼šå¯¹äºæœ‰é™ç¾¤ \\(G\\) çš„ä»»æ„å­ç¾¤ \\(H\\) ï¼Œæœ‰ \\(|G|=|H|[G:H]\\) ã€‚ è¿›ä¸€æ­¥çš„ï¼Œæœ‰æ¨è®ºï¼šè‹¥ \\(|G|=n\\) ï¼Œåˆ™å¯¹ä»»æ„ \\(x\\in G\\) éƒ½æœ‰ \\(x^n=1\\) ã€‚ è¯æ˜ï¼šå‡è®¾ \\(|\\langle x\\rangle |=m\\) ï¼Œç”¨æ‹‰æ ¼æœ—æ—¥å®šç†æœ‰ \\(n=mr\\) ä¸” \\(x^m=1\\) ï¼Œ æ•… \\(x^n=(x^m)^r=1\\) ã€‚ ç»“åˆæ­¤å‰å¾ªç¯ç¾¤å……è¦æ¡ä»¶ï¼Œèƒ½å¾—åˆ°éå¾ªç¯ç¾¤æ»¡è¶³ \\(\\text{exp}\\ G&lt;n\\) ã€‚ Congruences. Quotient Monoids and Groups congruence relation åŒä½™å…³ç³» \\(\\equiv\\) ï¼šå¯ä¹˜çš„ç­‰ä»·å…³ç³»ã€‚å¯¹äºå¹ºåŠç¾¤ \\(M\\) ï¼Œè‹¥ \\(a\\equiv a&#39;,b\\equiv b&#39;\\) ï¼Œåˆ™æœ‰ \\(ab\\equiv a&#39;b&#39;\\) ã€‚ è€ƒè™‘å•†é›† \\(\\overline{M}=M/\\equiv\\) ï¼ŒåŒ…å«äº†æ‰€æœ‰ç”±åŒä½™å…³ç³»å¯¼å‡ºçš„ç­‰ä»·ç±» \\(\\overline{a} = \\{b\\in M|b\\equiv a\\}\\) ã€‚ é‚£ä¹ˆå¯¹äº \\(\\overline{M}\\) ä¸­çš„ç­‰ä»·ç±» \\(\\overline{a},\\overline{a&#39;},\\overline{b}, \\overline{b&#39;}\\) ï¼Œæœ‰ \\(\\overline{a}=\\overline{a&#39;},\\overline{b}=\\overline{b&#39;}\\) ï¼Œç”±äº \\(ab\\equiv a&#39;b&#39;\\) ï¼Œæœ‰ \\(\\overline{ab}=\\overline{a&#39;b&#39;}\\) ã€‚ è¿™æ ·æˆ‘ä»¬å°±è·å¾—äº†ä¸€ä¸ª \\(\\overline{M}\\) ä¸Šè‰¯å®šä¹‰çš„ä¹˜æ³•æ˜ å°„ \\(\\overline{M}\\times \\overline{M}\\to \\overline{M}\\) ï¼š\\((\\overline{a},\\overline{b})\\to \\overline{ab}\\) ï¼Œè®°ä½œ \\(\\cdot\\) ï¼Œæ˜“è¯ \\((\\overline{M},\\cdot,\\overline{1})\\) æ˜¯ä¸€ä¸ªå¹ºåŠç¾¤ã€‚ æˆ‘ä»¬ç§° \\((M/\\equiv, \\cdot, \\overline{1})\\) ä¸º \\(M\\) å…³äº \\(\\equiv\\) çš„å•†å¹ºåŠç¾¤ã€‚åŒæ ·ç§° \\((G/\\equiv, \\cdot, \\overline{1})\\) ä¸ºå•†ç¾¤çš„å®šä¹‰ä¹Ÿæ˜¯æ­£ç¡®çš„ã€‚ normal subgroups æ­£è§„å­ç¾¤ \\(K\\unlhd G\\) ï¼šæ»¡è¶³ \\(\\forall g\\in G, k\\in K, g^{-1}kg\\in K\\) ã€‚ å®¹æ˜“å‘ç°é˜¿è´å°”ç¾¤çš„ä»»æ„å­ç¾¤éƒ½æ˜¯æ­£è§„å­ç¾¤ï¼Œå› ä¸ºå¯äº¤æ¢ \\(g^{-1}kg=kg^{-1}g=k\\) ã€‚ åŒä½™å…³ç³»å’Œæ­£è§„å­ç¾¤çš„è”ç³»ï¼š åŒä½™ç­‰ä»·ç±» \\(K=\\overline{1}\\) æ˜¯ \\(G\\) çš„æ­£è§„å­ç¾¤ï¼Œä¸”å¯¹äºä»»æ„ \\(g\\in G\\) ï¼Œæœ‰ \\(\\overline{g}=gK=Kg\\) ã€‚ å¯¹äºä»»æ„æ­£è§„å­ç¾¤ \\(K\\) ï¼Œå¯ä»¥ç”± \\(K\\) å¯¼å‡ºåŒä½™å…³ç³»ï¼š\\(a\\equiv b\\pmod k\\ \\ \\text{if}\\ \\ a^{-1}b\\in K\\) ã€‚ åœ¨æ­¤åŒä½™å…³ç³»ä¸‹ï¼ŒåŒä½™ç­‰ä»·ç±»çš„å½¢å¼ä¸º \\(gK\\) ã€‚ quotient group å•†ç¾¤ï¼šç”±æ­£è§„å­ç¾¤ \\(K\\) å®šä¹‰çš„åŒä½™å…³ç³»å¯¼å‡ºçš„å•†ç¾¤ \\(\\overline{G}=G/\\equiv \\pmod k\\) å•†ç¾¤ä¸­çš„å…ƒç´ æ˜¯ç­‰ä»·ç±»ï¼Œå½¢å¼å‡ä¸º \\(\\overline{g}=gK\\) ï¼Œå› æ­¤ä¹˜æ³• \\(\\overline{g}\\overline{h}=\\overline{gh}\\) å¯ä»¥è¿›ä¸€æ­¥çš„å†™ä½œ \\((gK)(hK)=ghK\\) ã€‚ å•ä½å…ƒ \\(K=\\overline{1}=1K\\) ï¼Œé€†å…ƒ \\((\\overline{g})^{-1}=\\overline{g^{-1}}=g^{-1}K\\) ã€‚ å®šä¹‰å­ï¼ˆå¹ºåŠï¼‰ç¾¤çš„ä¹˜æ³•ï¼š\\(\\forall A,B\\le G, AB=\\{ab|a\\in A, b\\in B\\}\\) ã€‚è¿™æ · \\((\\mathscr{P}(G),\\cdot,\\{1\\})\\) å°±æ„æˆäº†ä¸€ä¸ªå¹ºåŠç¾¤ã€‚ é›†åˆçš„ä¹˜æ³•å¯¹åº”äº†å•†ç¾¤ä¸­çš„ä¹˜æ³• \\((gK)(hK)=g(Kh)K=ghK^2=ghK\\) æ­£è§„å­ç¾¤çš„ç­‰ä»·åˆ¤å®šæ¡ä»¶ï¼Œ\\(\\forall g\\in G\\) æ»¡è¶³ï¼šï¼ˆ1ï¼‰\\(g^{-1}Kg\\subset K\\) ï¼ˆ2ï¼‰\\(Kg=gK\\) simple group å•ç¾¤ï¼šåªæœ‰ \\(G\\) å’Œ \\(1\\) ä¸¤ä¸ªæ­£è§„å­ç¾¤çš„ç¾¤ \\(G\\ (G\\not = 1)\\) ï¼Œå¯¹åº”çš„åŒä½™å…³ç³»æ˜¯ \\(=\\) å’Œå…¨éƒ¨ç›¸åŒã€‚ äº¤æ¢çš„å•ç¾¤ï¼ˆé˜¿è´å°”å•ç¾¤ï¼‰åªæœ‰ç´ æ•°é˜¶å¾ªç¯ç¾¤ã€‚ ç¾¤ \\(G\\) çš„ä¸­å¿ƒ \\(C(G)\\) çš„ä»»æ„å­ç¾¤æ˜¾ç„¶éƒ½æ˜¯æ­£è§„å­ç¾¤ï¼ˆå¯äº¤æ¢ï¼‰ã€‚ Homomorphisms homomorphism åŒæ€æ˜ å°„ \\(\\eta\\) ï¼š\\(\\eta(ab)=\\eta(a)\\eta(b),\\eta(1)=1&#39;, \\forall a,b\\in M\\) epimorphiscm æ»¡åŒæ€ï¼šæ»¡å°„çš„åŒæ€æ˜ å°„ï¼› monomorphism å•åŒæ€ï¼šå•å°„çš„åŒæ€æ˜ å°„ã€‚ Sylow's Theorems Sylow I ï¼šå‡è®¾ \\(|G|\\) æœ‰é™ï¼Œè´¨æ•° \\(p\\) æ»¡è¶³ \\(p^k||G|\\) ï¼Œé‚£ä¹ˆå­˜åœ¨å­ç¾¤ \\(H\\le G\\) ä¸” \\(|H|=p^k\\) å¯¹ \\(|G|\\) ä»å°åˆ°å¤§å½’çº³ã€‚\\(|G|=1\\) æ—¶æ˜¾ç„¶æˆç«‹ã€‚ç°åœ¨å‡è®¾ç»“è®ºå¯¹ \\(|G&#39;|&lt;|G|\\) çš„æ‰€æœ‰ \\(G&#39;\\) éƒ½æˆç«‹ã€‚ è€ƒè™‘ \\(G\\) åˆ°è‡ªå·±çš„å…±è½­ä½œç”¨ï¼Œæœ‰ç±»æ–¹ç¨‹ï¼š\\(|G|=|C|+\\sum_{y_i\\in G,y_i\\not\\in C(G)} [G:C(y_i)]\\) å½“ \\(|C|\\) ä¸æ˜¯ \\(p\\) çš„å€æ•°æ—¶ï¼Œç”±äºå’Œæ˜¯ \\(p\\) çš„å€æ•°ï¼Œå› æ­¤å¿…ç„¶å­˜åœ¨ \\(j\\) ï¼Œä½¿å¾— \\([G:C(y_j)]=\\frac{|G|}{|C(y_j)|}\\) ä¹Ÿä¸æ˜¯ \\(p\\) çš„å€æ•°ã€‚é‚£ä¹ˆ \\(|C(y_j)|\\) å°±ä¸€å®šæ˜¯ \\(p^k\\) çš„å€æ•°ï¼Œè€Œä¸”å› ä¸º \\(C(y_j)\\not = G\\) ï¼Œæœ‰ \\(C(y_j)\\le G\\) ï¼Œé‚£ä¹ˆæ ¹æ®å‡è®¾ï¼Œå­˜åœ¨ \\(H\\le C(y_j)\\le G\\) ï¼Œæ»¡è¶³ \\(|H|=p^k\\) ã€‚ Cauchy å¼•ç†ï¼Œå¯¹äºæœ‰é™äº¤æ¢ç¾¤ \\(G\\) ï¼Œå¦‚æœè´¨æ•° \\(p||G|\\) ï¼Œé‚£ä¹ˆå­˜åœ¨ \\(a\\in G, |\\langle a\\rangle|=p\\) å¦åˆ™ \\(|C|\\) æ˜¯ \\(p\\) çš„å€æ•°ã€‚å› ä¸º \\(C\\) æ˜¯æœ‰é™äº¤æ¢ç¾¤ï¼Œå› æ­¤è·Ÿå» Cauchy å®šç†ï¼Œ\\(\\exists c\\in C,|\\langle c\\rangle|=p\\) ã€‚è€Œä¸” \\(\\langle c\\rangle \\le C\\unlhd G\\) ï¼Œæ˜¯ \\(G\\) çš„æ­£è§„å­ç¾¤ã€‚è€ƒè™‘ \\(G/\\langle c\\rangle\\) è¿™ä¸ªå•†ç¾¤ï¼Œ\\(|G/\\langle c\\rangle|&lt;|G|\\) ä¸”èƒ½è¢« \\(p^{k-1}\\) æ•´é™¤ã€‚ç”±å½’çº³å‡è®¾å­˜åœ¨ \\(K\\le G/\\langle c\\rangle,|K|=p^{k-1}\\) ã€‚é‚£ä¹ˆ \\(K\\) çš„å½¢å¼ä¸º \\(H/\\langle c\\rangle\\) ä¸” \\(H\\) æ˜¯ \\(G\\) ä¸­ä¸€ä¸ªåŒ…å« \\(\\langle c\\rangle\\) çš„å­ç¾¤ã€‚é‚£ä¹ˆæœ‰ \\[ |H|=[H:\\langle c\\rangle]|\\langle c\\rangle|=p^{k-1}p=p^k \\]","categories":[{"name":"Summary","slug":"Summary","permalink":"http://blog.gyx.me/categories/Summary/"}],"tags":[{"name":"Algebra","slug":"Algebra","permalink":"http://blog.gyx.me/tags/Algebra/"}]},{"title":"Codeforces Round #848 (Div. 2)","slug":"codeforces/1778","date":"2023-02-01T16:56:00.000Z","updated":"2023-03-20T16:26:10.161Z","comments":true,"path":"codeforces/1778/","link":"","permalink":"http://blog.gyx.me/codeforces/1778/","excerpt":"","text":"A. Flip Flop Sum æšä¸¾ä¿®æ”¹çš„ä½ç½®ã€‚å¤æ‚åº¦ \\(O(n)\\) ã€‚ 123456789int a[N];inline void work() &#123; int n = rd(), sum = 0, dlt = -4; for (int i = 1; i &lt;= n; ++i) &#123; a[i] = rd(); sum += a[i]; if (i &gt; 1) dlt = max(dlt, -2 * (a[i] + a[i - 1])); &#125; printf(&quot;%d\\n&quot;, sum + dlt);&#125; B. The Forbidden Permutation æšä¸¾ä¸ç¬¦åˆè¦æ±‚çš„ä½ç½®ï¼Œç§»åŠ¨æœ‰ä¸¤ç§ç­–ç•¥ï¼š ä½¿ \\(pos(a_i)\\ge pos(a_{i + 1})\\) ï¼Œæ“ä½œæ¬¡æ•° \\(pos(a_{i+1})-pos(a_i)\\) ä½¿ \\(pos(a_{i+1})&gt;pos(a_i)+d\\) ï¼Œéœ€è¦ä¿è¯ \\(d+2\\le n\\) ï¼Œæ“ä½œæ¬¡æ•° \\(pos(a_i)+d-pos(a_{i+1}) + 1\\) å¤æ‚åº¦ \\(O(n)\\) ã€‚ 12345678910111213int p[N], a[N];inline void work() &#123; int n = rd(), m = rd(), d = rd(), ans = 1e9; rep(i, 1, n) p[rd()] = i; rep(i, 1, m) a[i] = rd(); rep(i, 2, m) &#123; if (p[a[i]] &gt; p[a[i - 1]] &amp;&amp; p[a[i]] &lt;= p[a[i - 1]] + d) &#123; ans = min(ans, p[a[i]] - p[a[i - 1]]); if (d + 2 &lt;= n)ans = min(ans, d - (p[a[i]] - p[a[i - 1]]) + 1); &#125; else &#123;puts(&quot;0&quot;); return;&#125; &#125; printf(&quot;%d\\n&quot;, ans);&#125; C. Flexible String æšä¸¾ä¿®æ”¹çš„å­—ç¬¦é›†ï¼Œæœ‰ \\({10\\choose k}\\) ç§æ–¹æ¡ˆï¼Œç„¶å \\(O(n)\\) è®¡ç®—åœ¨è¿™äº›å­—ç¬¦å˜æˆé€šé…ç¬¦çš„æƒ…å†µä¸‹ç­”æ¡ˆçš„å€¼ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839#define N 100007char s[N], t[N];int a[N], n, k, tot;map&lt;char, int&gt; id;inline void work() &#123; n = rd(); k = rd(); tot = 0; id.clear(); scanf(&quot;%s&quot;, s + 1); scanf(&quot;%s&quot;, t + 1); rep(i, 1, n) &#123; if (!id[s[i]]) id[s[i]] = ++tot; a[i] = id[s[i]] - 1; &#125; if (tot &lt;= k) &#123; printf(&quot;%lld\\n&quot;, 1ll * n * (n + 1) / 2); return; &#125; ll ans = 0; vector&lt;int&gt; ok(tot, 0); rep(i, 1, k) ok[tot - i] = 1; do &#123; int len = 0; ll tmpans = 0; rep(i, 1, n) if (ok[a[i]] || s[i] == t[i]) ++len; else &#123; tmpans += 1ll * len * (len + 1) / 2; len = 0; &#125; tmpans += 1ll * len * (len + 1) / 2; ans = max(ans, tmpans); &#125; while(next_permutation(all(ok))); printf(&quot;%lld\\n&quot;, ans);&#125; D. Flexible String Revisit é¦–å…ˆä¸€æ¬¡æ“ä½œåªä¼šè®©ä¸åŒçš„ä¸ªæ•° \\(+1/-1\\) ï¼Œæ‰€ä»¥åªè·Ÿä¸åŒçš„ä¸ªæ•°æœ‰å…³ï¼Œç»å…¸çš„ Markov é“¾ï¼Œæ±‚é¦–è®¿æ—¶é—´ã€‚ è®¾ \\(t[i]\\) è¡¨ç¤ºæœ‰ \\(i\\) ä¸ªä¸åŒçš„çŠ¶æ€é¦–æ¬¡åˆ°è¾¾ \\(0\\) çŠ¶æ€çš„æœŸæœ›æ­¥æ•°ï¼Œæœ‰ï¼š \\[ t[0]=0\\\\ t[i]=1+\\frac{i}{n}\\times t[i - 1] + \\frac{n-i}{n}\\times t[i+1],\\ 1&lt;i\\le n \\] ç”±äº \\(t[0]=0\\) å·²çŸ¥ï¼Œæ‰€ä»¥å…ˆæŒ‰ç…§ \\(i=0\\dots n\\) çš„é¡ºåºæ‰«æï¼ŒæŠŠ \\(t[i]\\) æ•´ç†æˆåªå’Œ \\(t[i+1]\\) æœ‰å…³çš„å½¢å¼ã€‚ ç„¶åç”±äº \\(t[n]\\) ä¸­åˆ° \\(t[n+1]\\) çš„ç³»æ•° \\(\\frac{n-i}{n}=0\\) ï¼Œæ‰€ä»¥ \\(t[n]\\) çš„å€¼å·²ç»æ±‚å¾—ï¼Œå†é€†ç€æ‰«å›æ¥å³å¯ã€‚ ç­”æ¡ˆå°±æ˜¯ \\(t[\\text{ä¸¤å­—ç¬¦ä¸²åˆå§‹ä¸åŒçš„ä½ç½®æ•°}]\\) ï¼Œå¤æ‚åº¦ \\(O(n)\\) ã€‚ 123456789101112131415161718192021222324252627282930313233#define N 1000007#define mod 998244353 inline int fpow(int x, int t = mod - 2) &#123; int res = 1; for (; t; t &gt;&gt;= 1, x = 1ll * x * x % mod) if (t &amp; 1) res = 1ll * res * x % mod; return res;&#125; char s[N], t[N]; int f[N], dlt[N], k[N]; inline void calc(int n) &#123; int bs = fpow(n); rep(i, 1, n) &#123; int l = 1ll * i * bs % mod, r = 1ll * (n - i) * bs % mod; int cof = fpow((mod + 1 - 1ll * l * k[i - 1] % mod) % mod); dlt[i] = (1ll * dlt[i - 1] * l + 1) % mod * cof % mod; k[i] = 1ll * r * cof % mod; &#125; f[n] = dlt[n]; per(i, n - 1, 1) f[i] = (dlt[i] + 1ll * f[i + 1] * k[i]) % mod;&#125; inline void work() &#123; int n = rd(); calc(n); scanf(&quot;%s&quot;, s + 1); scanf(&quot;%s&quot;, t + 1); int cnt = 0; rep(i, 1, n) cnt += (s[i] != t[i]); printf(&quot;%d\\n&quot;, f[cnt]);&#125; E. The Tree Has Fallen! ç»™ä¸€æ£µæ ‘ \\((n\\le 2\\times 10^5)\\) ï¼Œæ¯ä¸ªç‚¹æœ‰ç‚¹æƒ \\(a_u\\ (a_u\\le 10^9)\\) ï¼Œ\\(q\\ (q\\le 2\\times 10^5)\\) æ¬¡è¯¢é—®ï¼š æ ‘ä»¥ \\(r_i\\) ä¸ºæ ¹æ—¶ï¼ŒèŠ‚ç‚¹ \\(v_i\\) å­æ ‘å†…ä»»é€‰ä¸€äº›èŠ‚ç‚¹ï¼Œç‚¹æƒå¼‚æˆ–æœ€å¤§å€¼æ˜¯å¤šå°‘ï¼Ÿ çœ‹åˆ°è¯¢é—®è‚¯å®šçº¿æ€§åŸºäº†ï¼Œå…ˆä»¥ \\(1\\) ä¸ºæ ¹ï¼Œå¤„ç†å‡ºæ¥æ¯ä¸ªç‚¹å­æ ‘çš„çº¿æ€§åŸº \\(subtree_u\\) ã€‚ è¯¢é—®è®¨è®ºä¸€ä¸‹ \\(r_i\\) å’Œ \\(v_i\\) çš„å…³ç³»ï¼š \\(r_i=v_i\\) ï¼ŒæŸ¥è¯¢é›†åˆä¸ºå…¨éƒ¨ç‚¹æƒï¼Œç­”æ¡ˆä¸º \\(subtree_1\\) çš„è¡¨å‡ºæœ€å¤§å€¼ã€‚ \\(r_i\\) ä¸åœ¨ \\(v_i\\) å­æ ‘å†…ï¼Œ\\(v_i\\) å­æ ‘ä¸å˜ï¼Œåˆ™ç­”æ¡ˆä¸º \\(subtree_{v_i}\\) çš„è¡¨å‡ºæœ€å¤§å€¼ã€‚ \\(r_i\\) åœ¨ \\(v_i\\) å­æ ‘å†…ï¼Œåˆ™æŸ¥è¯¢é›†åˆä¸ºæ‰€æœ‰ç‚¹åˆ æ‰ \\(v_i\\) çš„åŒ…å« \\(r_i\\) çš„å„¿å­çš„å­æ ‘ã€‚ å› æ­¤éœ€è¦å®Œæˆï¼š æŸ¥è¯¢ \\(v_i\\) å„¿å­ä¸­ï¼ŒåŒ…å« \\(r_i\\) çš„æ˜¯è°ã€‚ å¤„ç† \\(out_u\\) è¡¨ç¤ºåˆ æ‰ \\(u\\) å­æ ‘çš„çº¿æ€§åŸºã€‚ è¿™ä¸¤ä¸ªé—®é¢˜æ±‚ dfs åºåéƒ½å¯ä»¥è§£å†³ï¼Œç”±äºå­æ ‘ dfs åºè¿ç»­ï¼š ç¬¬ä¸€ä¸ªå¯¹æ¯ä¸ªç‚¹è®°å½•æ‰€æœ‰å„¿å­çš„ dfn ï¼Œç„¶ååœ¨é‡Œé¢äºŒåˆ†æŸ¥æ‰¾ \\(\\le dfn[r_i]\\) çš„æœ€å¤§çš„ã€‚ ç¬¬äºŒä¸ªå¤„ç†æŒ‰ dfs åºçš„å‰åç¼€çº¿æ€§åŸºï¼Œå†å·¦å³åˆå¹¶å³å¯ã€‚ å¤æ‚åº¦ \\(O(n\\log^2(\\max a_u))\\) ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#define N 200007struct linear_base &#123; #define D 31 int b[D]; void clear() &#123;memset(b, 0, sizeof(b));&#125; void insert(int x) &#123; for (int i = 30; ~i; --i) if ((x &gt;&gt; i) &amp; 1) &#123; if (b[i]) x ^= b[i]; else &#123;b[i] = x; break;&#125; &#125; &#125; int max_xor() &#123; int ans = 0; for (int i = 30; ~i; --i) if (b[i] &amp;&amp; !((ans &gt;&gt; i) &amp; 1)) ans ^= b[i]; return ans; &#125; linear_base operator + (const linear_base &amp;obj) const &#123; linear_base ret = obj; for (int i = 30; ~i; --i) if (b[i]) ret.insert(b[i]); return ret; &#125;&#125; pre[N], suf[N], subtree[N], out[N];int dfn[N], id[N], lst[N], a[N], tot;vector&lt;int&gt; e[N], sondfn[N];void dfs(int u, int fa) &#123; sondfn[u].clear(); subtree[u].clear(); subtree[u].insert(a[u]); id[dfn[u] = ++tot] = u; for (auto v : e[u]) if (v != fa) &#123; dfs(v, u); subtree[u] = subtree[u] + subtree[v]; sondfn[u].pb(dfn[v]); &#125; lst[u] = tot;&#125;inline void work() &#123; tot = 0; int n = rd(); rep(i, 1, n) &#123;a[i] = rd(); e[i].clear();&#125; rep(i, 2, n) &#123;int u = rd(), v = rd(); e[u].pb(v); e[v].pb(u);&#125; dfs(1, 1); pre[0].clear(); suf[n + 1].clear(); rep(i, 1, n) &#123;pre[i] = pre[i - 1]; pre[i].insert(a[id[i]]);&#125; per(i, n, 1) &#123;suf[i] = suf[i + 1]; suf[i].insert(a[id[i]]);&#125; rep(i, 1, n) out[i] = pre[dfn[i] - 1] + suf[lst[i] + 1]; per(i, rd(), 1) &#123; int r = rd(), v = rd(); if (r == v) printf(&quot;%d\\n&quot;, subtree[1].max_xor()); else if (dfn[v] &lt; dfn[r] &amp;&amp; dfn[r] &lt;= lst[v]) &#123; int son = id[*--upper_bound(all(sondfn[v]), dfn[r])]; printf(&quot;%d\\n&quot;, out[son].max_xor()); &#125; else printf(&quot;%d\\n&quot;, subtree[v].max_xor()); &#125;&#125; F. Maximizing Root ä»¥ \\(1\\) ä¸ºæ ¹çš„æ ‘ï¼Œæ¯ä¸ªèŠ‚ç‚¹æœ‰ç‚¹æƒ \\(a_u\\ (a_u\\le 10^3)\\) ï¼Œæœ€å¤š \\(k\\ (0\\le k\\le n\\le 10^5)\\) æ¬¡æ“ä½œï¼Œæ¯æ¬¡æ“ä½œï¼š é€‰ä¸€ä¸ªæ­¤å‰æœªé€‰è¿‡çš„ç‚¹ \\(v\\) ï¼Œ é€‰æ‹©ä¸€ä¸ª \\(v\\) å­æ ‘å†…æ‰€æœ‰ç‚¹æƒçš„å…¬å› æ•° \\(x\\) ï¼Œä»¤ \\(v\\) å­æ ‘å†…æ‰€æœ‰ç‚¹æƒ \\(\\times x\\) ã€‚ é—®æœ€ç»ˆ \\(1\\) å·ç‚¹ç‚¹æƒå¯èƒ½çš„æœ€å¤§å€¼ã€‚ é¦–å…ˆæ¯ä¸ªç‚¹åªèƒ½æ“ä½œä¸€æ¬¡ï¼Œæ‰€ä»¥ \\(a_1\\) æœ€ç»ˆæœ€å¤§å˜æˆ \\(a_1^2\\) ã€‚ æ‰€ä»¥æˆ‘ä»¬åªéœ€è¦è€ƒè™‘æ¯ä¸ªç‚¹çš„å­æ ‘ï¼Œåœ¨ç¥–å…ˆèŠ‚ç‚¹æ“ä½œæ—¶ï¼Œä¿è¯å­æ ‘å†…èƒ½æä¾› \\(x\\ (x\\le 1000)\\) æ‰€éœ€çš„æœ€å°æ¬¡æ•°ã€‚ å› æ­¤è®¾ \\(f[u][x]\\) è¡¨ç¤ºèŠ‚ç‚¹ \\(u\\) å­æ ‘å†…ï¼Œåç»­ç¥–å…ˆæ“ä½œæ—¶ï¼Œä¿è¯ \\(u\\) å­æ ‘å†…èƒ½æä¾› \\(x\\) çš„æœ€å°æ“ä½œæ¬¡æ•°ã€‚ è‹¥ä¸æ“ä½œ \\(u\\) ï¼Œåˆ™éœ€è¦ä¿è¯ \\(x|a[u]\\) ï¼Œæ­¤æ—¶æ–¹ç¨‹ä¸º \\(f[u][x] = \\sum f[son][x]\\) ã€‚ è‹¥æ“ä½œ \\(u\\) ï¼Œæ­¤æ—¶éœ€è¦æ‰¾åˆ°æŸä¸ªæœ€å°çš„ \\(y\\) ï¼Œä½¿å¾— \\(x|y^2\\) ï¼Œä¹Ÿå°±æ˜¯å­æ ‘é‡Œæ¯ä¸ªç‚¹éƒ½åŒ…å« \\(y\\) çš„æƒ…å†µä¸‹ï¼Œæ“ä½œä¸€æ¬¡ \\(u\\) è¶³ä»¥è®©æ•´ä¸ªå­æ ‘éƒ½åŒ…å« \\(x\\) ï¼Œè¿™ä¸ªé¢„å¤„ç†å³å¯ï¼Œç§° \\(y\\) ä¸º \\(mn[x]\\) ï¼Œæ–¹ç¨‹ä¸º \\(f[u][x]=1+\\sum f[son][mn[x]]\\) ã€‚ æ­¤å¤–ï¼Œå¦‚æœ \\(mn[x]\\) ä¸æ˜¯ \\(a[u]\\) çš„å› æ•°ï¼Œåˆ™ \\(f[u][x]\\) ä¸åˆæ³•ã€‚ æœ€åæšä¸¾ \\(1\\) å·ç‚¹æ“ä½œæ—¶å¯¹åº”çš„ \\(x\\) æ˜¯å‡ å³å¯ï¼Œå¤æ‚åº¦ \\(O(n\\max a_u)\\) è®¡ç®—é‡çº¦ \\(10^8\\) ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#define N 100007int f[N][1001], a[N], G, n, k, inf = 1e9; vector&lt;int&gt; e[N]; int gcd(int a, int b) &#123;return b ? gcd(b, a % b) : a;&#125; inline void getmin(int &amp;a, int b) &#123;a = (a &gt; b ? b : a);&#125; int mn[1001]; void dfs(int u, int fa) &#123; for (auto v : e[u]) if (v != fa) dfs(v, u); f[u][1] = 0; rep(i, 2, 1000) &#123; if (a[u] % i == 0) &#123; f[u][i] = 0; for (auto v : e[u]) if (v != fa) &#123;f[u][i] += f[v][i]; getmin(f[u][i], inf);&#125; int tmp = 1, tar = mn[i]; for (auto v : e[u]) if (v != fa) &#123;tmp += f[v][tar]; getmin(tmp, inf);&#125; getmin(f[u][i], tmp); &#125; else if (a[u] % mn[i] == 0) &#123; f[u][i] = 1; int tar = mn[i]; for (auto v : e[u]) if (v != fa) &#123;f[u][i] += f[v][tar]; getmin(f[u][i], inf);&#125; &#125; else f[u][i] = inf; &#125;&#125; inline void work() &#123; int n = rd(), k = rd(); G = 0; rep(i, 1, n) &#123;a[i] = rd(); G = gcd(G, a[i]); e[i].clear();&#125; rep(i, 2, n) &#123;int u = rd(), v = rd(); e[u].pb(v); e[v].pb(u);&#125; if (k == 0 || G == 1) &#123;printf(&quot;%d\\n&quot;, a[1]); return;&#125; if (k == 1) &#123;printf(&quot;%d\\n&quot;, a[1] * G); return;&#125; dfs(1, 1); per(i, a[1], 1) if (a[1] % i == 0) &#123; int cnt = 0; for (auto v : e[1]) &#123; cnt += f[v][i]; getmin(cnt, inf); &#125; if (cnt &lt; k) &#123;printf(&quot;%d\\n&quot;, a[1] * i); return;&#125; &#125;&#125; int main() &#123; rep(i, 1, 1000) rep(j, 1, 1000) if (j * j % i == 0) &#123;mn[i] = j; break;&#125; for (int t = rd(); t; --t) work(); return 0;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://blog.gyx.me/categories/Codeforces/"},{"name":"Codeforces Round","slug":"Codeforces/Codeforces-Round","permalink":"http://blog.gyx.me/categories/Codeforces/Codeforces-Round/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"},{"name":"DFS and Similar","slug":"DFS-and-Similar","permalink":"http://blog.gyx.me/tags/DFS-and-Similar/"},{"name":"Markov Chains","slug":"Markov-Chains","permalink":"http://blog.gyx.me/tags/Markov-Chains/"},{"name":"Linear Basis","slug":"Linear-Basis","permalink":"http://blog.gyx.me/tags/Linear-Basis/"}]},{"title":"AtCoder Beginner Contest 287","slug":"atcoder/abc287","date":"2023-01-28T15:47:14.000Z","updated":"2023-03-20T16:28:29.793Z","comments":true,"path":"atcoder/abc287/","link":"","permalink":"http://blog.gyx.me/atcoder/abc287/","excerpt":"","text":"ABCD æ¯”è¾ƒç®€å•å°±ä¸å†™äº†ã€‚ E - Karuta ç»™ \\(n\\) ä¸ªå­—ç¬¦ä¸² \\(S_i\\ (\\sum |S_i|\\le 10^5)\\) ï¼Œé—®æ¯ä¸ªä¸²å’Œå…¶ä»–æ‰€æœ‰ä¸²çš„ LCP çš„æœ€å¤§å€¼ã€‚ å…ˆæŠŠæ‰€æœ‰ä¸²å»º Trie ï¼Œå†æŸ¥ä¸€éï¼Œèµ°åˆ°è®¡æ•°å™¨åªæœ‰ \\(1\\) çš„æ—¶å€™å°±åœã€‚å¤æ‚åº¦ \\(O(n+\\sum |S_i|)\\) ã€‚ 1234567891011121314151617181920212223242526272829303132333435int tot;struct node &#123;int cnt, son[26];&#125; c[500007];inline void insert(string &amp;s) &#123; int rt = 0; for (auto x : s) &#123; x -= &#x27;a&#x27;; if (!c[rt].son[x]) c[rt].son[x] = ++tot; rt = c[rt].son[x]; ++c[rt].cnt; &#125;&#125;inline int calc(string &amp;s) &#123; int ans = 0, rt = 0; for (auto x : s) &#123; x -= &#x27;a&#x27;; rt = c[rt].son[x]; if (c[rt].cnt == 1) return ans; ++ans; &#125; return ans;&#125;string str;vector&lt;string&gt; s;int main() &#123; int n; cin &gt;&gt; n; rep(i, 1, n) &#123;cin &gt;&gt; str; s.pb(str); insert(str);&#125; for (auto &amp;st : s) printf(&quot;%d\\n&quot;, calc(st)); return 0;&#125; F - Components ç»™ä¸€æ£µæ ‘ \\((n\\le 5000)\\) ï¼Œé—®æœ‰å¤šå°‘ä¸ªç‚¹é›†çš„å¯¼å‡ºå­å›¾æ°å¥½æœ‰ \\(x=0,1,\\dots,n\\) ä¸ªè”é€šåˆ†é‡ï¼ˆå®šä¹‰å«æå¤§æ€§ï¼‰ã€‚ æ ‘å½¢èƒŒåŒ…è®¡æ•°ï¼ŒåŠ ä¸€ç»´ \\(0/1\\) è¡¨ç¤ºå½“å‰ç‚¹é€‰/ä¸é€‰ï¼Œå¦‚æœçˆ¶å­ä¸¤ä¸ªéƒ½ä¸Šé€‰ä¼šåˆå¹¶ä¸€ä¸ªè”é€šå—ã€‚å¤æ‚åº¦ \\(O(n^2)\\) ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839#define N 5007#define mod 998244353inline int add(int x, int y) &#123;return (x + y &gt;= mod ? x + y - mod : x + y);&#125;inline int mul(int x, int y) &#123;return 1ll * x * y % mod;&#125;int f[N][N][2], sz[N], n, g[N][2];vector&lt;int&gt; e[N];void dfs(int u, int fa) &#123; sz[u] = 1; f[u][0][0] = f[u][1][1] = 1; for (auto v : e[u]) if (v != fa) &#123; dfs(v, u); for (int j = 0; j &lt;= sz[u] + sz[v]; ++j) &#123; g[j][0] = f[u][j][0]; g[j][1] = f[u][j][1]; f[u][j][0] = f[u][j][1] = 0; &#125; for (int j = sz[u] + sz[v]; j &gt;= 0; --j) for (int k = max(0, j - sz[u]); k &lt;= min(j, sz[v]); ++k) &#123; f[u][j][0] = add(f[u][j][0], mul(g[j - k][0], add(f[v][k][0], f[v][k][1]))); f[u][j][1] = add(f[u][j][1], add(mul(g[j - k][1], f[v][k][0]), mul(g[j - k][1], f[v][k + 1][1]))); &#125; sz[u] += sz[v]; &#125;&#125;int main() &#123; n = rd(); for (int i = 1; i &lt; n; ++i) &#123; int u = rd(), v = rd(); e[u].pb(v); e[v].pb(u); &#125; dfs(1, 1); for (int i = 1; i &lt;= n; ++i) printf(&quot;%d\\n&quot;, add(f[1][i][0], f[1][i][1])); return 0;&#125; G - Balance Update Query æœ‰ \\(n\\ (n\\le 2\\times 10^5)\\) ç»„æ•°ï¼Œå¼€å§‹ç¬¬ \\(i\\) ç»„æœ‰ \\(b_i\\ (b_i\\le 10^4)\\) ä¸ª \\(a_i\\ (a_i\\le 10^9)\\) ï¼Œæ¥ä¸‹æ¥ \\(q\\) æ¬¡æ“ä½œï¼š 1 x y æŠŠ \\(a_x\\) ä¿®æ”¹ä¸º \\(y\\ (y\\le 10^9)\\) 2 x y æŠŠ \\(b_x\\) ä¿®æ”¹ä¸º \\(y\\ (y\\le 10^4)\\) 3 x æŸ¥è¯¢æ‰€æœ‰æ•°å­—çš„å‰ \\(x\\ (x\\le 10^9)\\) å¤§å’Œã€‚ ç¦»çº¿ï¼Œç¦»æ•£åŒ–å…¨éƒ¨åšè¿‡ \\(a_i\\) çš„å€¼ï¼Œä»¥æ­¤ä¸ºä¸‹æ ‡å»ºç«‹çº¿æ®µæ ‘ã€‚ èŠ‚ç‚¹ç»´æŠ¤ä»·å€¼åŒºé—´å†…æ•°å­—ä¸ªæ•°å’Œ \\(\\sum\\) ä¸ªæ•° \\(\\times\\) ä»·å€¼ ï¼ŒæŸ¥è¯¢åœ¨çº¿æ®µæ ‘ä¸ŠäºŒåˆ†å³å¯ã€‚å¤æ‚åº¦ \\(O(n\\log n)\\) ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#define N 300007#define ls (rt &lt;&lt; 1)#define rs (rt &lt;&lt; 1 | 1)#define mid ((l + r) &gt;&gt; 1)vector&lt;int&gt; w;int a[N], b[N];vector&lt;tii&gt; work;int cnt[N &lt;&lt; 2];ll sum[N &lt;&lt; 2];inline void pushup(int rt) &#123; cnt[rt] = cnt[ls] + cnt[rs]; sum[rt] = sum[ls] + sum[rs]; &#125;void upd(int rt, int l, int r, int p, int dlt) &#123; if (l == r) &#123; cnt[rt] += dlt; sum[rt] += 1ll * dlt * w[l]; return; &#125; p &lt;= mid ? upd(ls, l, mid, p, dlt) : upd(rs, mid + 1, r, p, dlt); pushup(rt);&#125;ll query(int rt, int l, int r, int tot) &#123; if (cnt[rt] &lt; tot) return -1; if (l == r) return 1ll * tot * w[l]; if (cnt[rs] &gt;= tot) return query(rs, mid + 1, r, tot); else return query(ls, l, mid, tot - cnt[rs]) + sum[rs];&#125;int main() &#123; int n = rd(); rep(i, 1, n) &#123;a[i] = rd(); b[i] = rd(); w.pb(a[i]);&#125; int q = rd(); rep(i, 1, q) &#123; int op = rd(), x = rd(); if (op == 1) &#123;int y = rd(); w.pb(y); work.eb(op, x, y);&#125; else if (op == 2) work.eb(op, x, rd()); else work.eb(op, x, 0); &#125; w.pb(-1); sort(all(w)); w.erase(unique(all(w)), w.end()); auto getw = [&amp;](int x) &#123;return lower_bound(all(w), x) - w.begin();&#125;; int m = w.size(); rep(i, 1, n) &#123;a[i] = getw(a[i]); upd(1, 1, m, a[i], b[i]);&#125; for (auto [op, x, y] : work) if (op == 3) printf(&quot;%lld\\n&quot;, query(1, 1, m, x)); else &#123; upd(1, 1, m, a[x], -b[x]); op == 1 ? a[x] = getw(y) : b[x] = y; upd(1, 1, m, a[x], b[x]); &#125; return 0;&#125; Ex - Directed Graph and Query ç»™å®šä¸€ä¸ª \\(n\\ (n\\le 2000)\\) ä¸ªç‚¹çš„æœ‰å‘å›¾ï¼Œ\\(q\\ (q\\le 10^4)\\) æ¬¡è¯¢é—®ä» \\(s_i\\) åˆ° \\(t_i\\) ç»è¿‡çš„èŠ‚ç‚¹ç¼–å·æœ€å¤§å€¼çš„æœ€å°å€¼ã€‚ Floyd æœ€å¤–å±‚æšä¸¾åˆ° \\(k\\) çš„å«ä¹‰å°±æ˜¯åªç»è¿‡ç¼–å·ä¸º \\(1\\dots k\\) çš„èŠ‚ç‚¹çš„æœ€çŸ­è·¯ã€‚ å› æ­¤ bitset ç»´æŠ¤ä¼ é€’é—­åŒ…ï¼Œæ¯æ¬¡æ›´æ–°å®Œä¸€ä¸ª \\(k\\) å°±æ‰«æå…¨éƒ¨è¯¢é—®ï¼Œçœ‹çœ‹æœ‰æ²¡æœ‰å·²æ»¡è¶³çš„å³å¯ã€‚ å¤æ‚åº¦ \\(O(\\frac{n^3}{64} + nq)\\) ã€‚ 1234567891011121314151617181920#define N 2007#define M 10007int ans[M], s[M], t[M];bitset&lt;N&gt; adj[N];int main() &#123; int n = rd(), m = rd(); rep(u, 1, n) adj[u][u] = true; rep(i, 1, m) &#123;int u = rd(), v = rd(); adj[u][v] = true;&#125; int q = rd(); rep(i, 1, q) &#123;s[i] = rd(); t[i] = rd(); ans[i] = -1;&#125; rep(v, 1, n) &#123; rep(u, 1, n) if (adj[u][v]) adj[u] |= adj[v]; rep(i, 1, q) if (ans[i] == -1 &amp;&amp; adj[s[i]][t[i]]) ans[i] = v; &#125; rep(i, 1, q) printf(&quot;%d\\n&quot;, ans[i] == -1 ? -1 : max(&#123;ans[i], s[i], t[i]&#125;)); return 0;&#125;","categories":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://blog.gyx.me/categories/AtCoder/"},{"name":"AtCoder Beginner Contest","slug":"AtCoder/AtCoder-Beginner-Contest","permalink":"http://blog.gyx.me/categories/AtCoder/AtCoder-Beginner-Contest/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"},{"name":"STL","slug":"STL","permalink":"http://blog.gyx.me/tags/STL/"},{"name":"Shortest Path","slug":"Shortest-Path","permalink":"http://blog.gyx.me/tags/Shortest-Path/"},{"name":"Counting","slug":"Counting","permalink":"http://blog.gyx.me/tags/Counting/"},{"name":"Segment Tree","slug":"Segment-Tree","permalink":"http://blog.gyx.me/tags/Segment-Tree/"}]},{"title":"2022-2023 ICPC Asia Nanjing Regional","slug":"official/icpc/22-nanjing","date":"2023-01-26T09:02:00.000Z","updated":"2023-03-20T16:36:14.520Z","comments":true,"path":"official/icpc/22-nanjing/","link":"","permalink":"http://blog.gyx.me/official/icpc/22-nanjing/","excerpt":"","text":"Summary æ¯”èµ›åœ°å€ ï¼šCodeforces Gym 104128 å®˜æ–¹é¢˜è§£ ï¼šSUA Wiki è¿˜æ²¡è¡¥å®Œï¼šCEFHKL éš¾åº¦ï¼šIDGM - ABEJ - CHKL + F(??) A - Stop, Yesterday Please No More B - Ropeway C - Fabulous Fungus Frenzy D - Chat Program ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º \\(n\\) çš„æ•´æ•°åºåˆ— \\(a_1, a_2, Â· Â· Â· , a_n\\) å’Œå¦å¤–å››ä¸ªæ•´æ•° \\(k,m,c,d\\) ï¼Œæœ€å¤§åŒ–åºåˆ—ä¸­ç¬¬ \\(k\\) å¤§çš„å€¼ã€‚ æ“ä½œè‡³å¤šä¸€æ¬¡ï¼šé€‰æ‹©ä¸€ä¸ªé•¿åº¦æ°ä¸º \\(m\\) çš„åŒºé—´ï¼Œå¹¶å°†ä¸€ä¸ªé•¿åº¦ä¸º \\(m\\)ï¼Œé¦–é¡¹ä¸º \\(c\\)ï¼Œå…¬å·®ä¸º \\(d\\) çš„ç­‰å·®åºåˆ—åŠ åˆ°å¯¹åº”ä½ç½®ä¸Šã€‚ äºŒåˆ†ç­”æ¡ˆç¬¬ \\(k\\) å¤§å€¼ä¸º \\(x\\) ï¼Œé‚£ä¹ˆæ¯ä¸ªä½ç½®å¦‚æœè¦ä¿®æ”¹ä¸º \\(\\ge x\\) ï¼Œåˆæ³•çš„æ“ä½œèµ·ç‚¹ä¸€å®šåœ¨ä¸€ä¸ªåŒºé—´èŒƒå›´å†…ã€‚ æ‰€ä»¥æ‰¾å‡ºèƒ½è®©æœ€å¤šçš„æ•°å­—åˆæ³•çš„ä½ç½®å¼€å§‹æ“ä½œå³å¯ï¼ŒåŒºé—´åŠ  \\(1\\) æœ€åæ±‚æœ€å¤§å€¼ï¼Œå·®åˆ†å³å¯ï¼Œå¤æ‚åº¦ \\(O(n\\log (a+c+md))\\) ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 200007int n, k, m, dlt[N];ll c, d, a[N];inline bool valid(ll x) &#123; for (int i = 1; i &lt;= n; ++i) dlt[i] = 0; auto add = [&amp;](ll l, ll r) &#123; l = max(l, 1ll); r = min(r, n - m + 1ll); if (r &lt; l) return; ++dlt[l]; --dlt[r + 1]; &#125;; for (int i = 1; i &lt;= n; ++i) &#123; if (a[i] &gt;= x) ++dlt[1]; else &#123; if (x - a[i] &lt;= c) add(i - m + 1, i); else if (d != 0) add(i - m + 1, i - ((x - a[i] - c + d - 1) / d)); &#125; &#125; int mx = 0; for (int i = 1; i &lt;= n; ++i) &#123; dlt[i] += dlt[i - 1]; mx = max(mx, dlt[i]); &#125; return mx &gt;= k;&#125;int main() &#123; n = rd(), k = rd(), m = rd(); c = rd(), d = rd(); for (int i = 1; i &lt;= n; ++i) a[i] = rd(); ll l = 0, r = 1e18; while (l &lt; r) &#123; ll mid = (l + r + 1) / 2; valid(mid) ? l = mid : r = mid - 1; &#125; printf(&quot;%lld\\n&quot;, l); return 0;&#125; E - Color the Tree F - Triangles G - Inscryption æœ€åç­”æ¡ˆå°±æ˜¯åŠ å…¥æ¬¡æ•° / å‰©ä½™ä¸ªæ•°ï¼Œæ˜¾ç„¶å‡å°‘å‰©ä½™ä¸ªæ•°ä¼˜å…ˆçº§æ›´é«˜ã€‚ å› æ­¤èƒ½å‡å°±å‡ï¼Œæ­¤å¤–ç»´æŠ¤å¯åæ‚”çš„æœºä¼šæ¬¡æ•°ï¼Œä¸å¤Ÿå‡å°‘åˆå¿…é¡»å‡å°‘ï¼Œå³éœ€è¦åæ‚”çš„æ—¶å€™åæ‚”å³å¯ï¼Œå¤æ‚åº¦ \\(O(n)\\) ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;int gcd(int a, int b) &#123;return b ? gcd(b, a % b) : a;&#125;inline void work() &#123; bool fl = false; int n = rd(), cnt = 1, sum = 1, reg = 0; for (int i = 1; i &lt;= n; ++i) &#123; int x = rd(); if (x == 1) &#123;++cnt; ++sum;&#125; else if (x == -1) &#123; --cnt; if (!cnt) &#123; if (reg) &#123;--reg; cnt += 2; sum += 1;&#125; else fl = true; &#125; &#125; else &#123; if (cnt &gt; 1) &#123;--cnt; ++reg;&#125; else &#123;++cnt; ++sum;&#125; &#125; &#125; if (fl) &#123;puts(&quot;-1&quot;); return;&#125; int g = gcd(sum, cnt); printf(&quot;%d %d\\n&quot;, sum / g, cnt / g);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; ï¼ˆèµ›æ—¶è„‘å­æŠ½äº†è¿˜å†™äº†ä¸ªdpç»´æŠ¤åç¼€å…è®¸çš„æœ€å¤šå‡æ³•æ¬¡æ•°ã€‚ã€‚ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 1000007int f[N], a[N];int gcd(int a, int b) &#123;return b ? gcd(b, a % b) : a;&#125;inline void work() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) a[i] = rd(); f[n + 1] = 0; for (int i = n; i; --i) if (a[i] == 0) f[i] = f[i + 1]; else if (a[i] == -1) f[i] = f[i + 1] + 1; else f[i] = max(0, f[i + 1] - 1); int nw = 1, sum = 1; for (int i = 1; i &lt;= n; ++i) if (a[i] == -1) &#123;--nw; if (!nw) &#123;puts(&quot;-1&quot;); return;&#125;&#125; else if (a[i] == 1) &#123;++nw; ++sum;&#125; else &#123; if (nw &lt;= f[i] + 1) &#123;++nw; ++sum;&#125; else --nw; &#125; int g = gcd(nw, sum); printf(&quot;%d %d\\n&quot;, sum / g, nw / g);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; H - Factories Once More I - Perfect Palindrome ç”±å®šä¹‰æ‰€æœ‰å­—ç¬¦å¿…é¡»éƒ½ç›¸åŒï¼Œä¿ç•™å‡ºç°æ¬¡æ•°æœ€å¤šçš„å­—ç¬¦ï¼Œå¤æ‚åº¦ \\(O(n)\\) ã€‚ 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;int cnt[27];char s[100007];inline void work() &#123; scanf(&quot;%s&quot;, s + 1); for (int i = strlen(s + 1); i; --i) ++cnt[s[i] - &#x27;a&#x27;]; int ans = 0; for (int i = 0; i &lt; 26; ++i) &#123; ans = max(ans, cnt[i]); cnt[i] = 0; &#125; printf(&quot;%d\\n&quot;, (int)strlen(s + 1) - ans);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; *J - Perfect Matching ç»™å®š \\(n\\) ä¸ªæ•° \\(a_1, a_2, \\dots, a_n\\) å¦‚æœ \\(|a_i-a_j| =|i-j|\\) é‚£ä¹ˆ \\(i\\) å’Œ \\(j\\) å°±å¯ä»¥åŒ¹é…ã€‚ æ¯ä¸ªç‚¹åªèƒ½ç”¨æ¥åŒ¹é…ä¸€æ¬¡ï¼Œé—®æ˜¯å¦å­˜åœ¨å®Œç¾åŒ¹é…ï¼ˆå…¨éƒ¨ç”¨ä¸Šï¼‰ã€‚ æ•´ç†ç»å¯¹å€¼å¾—åˆ° \\(a_i+i=a_j+j\\) æˆ– \\(a_i-i=a_j-j\\) ï¼Œé‚£ä¹ˆå¯ä»¥æ„é€ ä¸€ä¸ªäºŒåˆ†å›¾ã€‚ å·¦ä¾§çš„ç‚¹ä»£è¡¨æ‰€æœ‰çš„ \\(a_i+i\\) ï¼Œå³ä¾§ä»£è¡¨ \\(a_i-i\\) ï¼Œå¦‚æœä¸¤ä¸ªä½ç½®æŸä¸€ä¾§å…±ç”¨åŒä¸€ä¸ªç‚¹å³å¯åŒ¹é…ã€‚ å› æ­¤å°±æ˜¯ä¸€ä¸ªè¾¹åŒ¹é…ï¼Œä¹Ÿå°±æ˜¯çº¿å›¾æ˜¯å¦å­˜åœ¨å®Œç¾åŒ¹é…ã€‚çº¿å›¾çš„æœ€å¤§åŒ¹é…ç®—æ³•æ˜¯ç»å…¸çš„ï¼Œå¤æ‚åº¦ \\(O(n)\\) ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define T int typedef pair&lt;T, T&gt; pii;typedef tuple&lt;T, T, T&gt; tii;#define fr first#define sc second#define mp make_pair#define mt make_tuple#define pb push_back#define eb emplace_back#define lowbit(x) ((x) &amp; -(x))#define all(x) (x).begin(), (x).end()#define rep(i, x, y) for (int i = (x); i &lt;= (y); ++i)#define per(i, x, y) for (int i = (x); i &gt;= (y); --i)inline T rd() &#123; T x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 200007int tot, hd[N], a[N];struct edge &#123;int to, nxt;&#125; e[N];inline void add(int u, int v) &#123; e[++tot] = &#123;v, hd[u]&#125;; hd[u] = tot; e[++tot] = &#123;u, hd[v]&#125;; hd[v] = tot;&#125;bool vis[N], used[N];vector&lt;pii&gt; ans;void dfs(int u, int fa) &#123; vis[u] = true; int faid = 0; for (int i = hd[u], v; i; i = e[i].nxt) if (!vis[v = e[i].to]) dfs(v, u); else if (v == fa) faid = (i &gt;&gt; 1); int lst = 0; for (int i = hd[u], v, id; i; i = e[i].nxt) if ((v = e[i].to) != fa &amp;&amp; !used[id = (i &gt;&gt; 1)]) &#123; if (lst) &#123; used[lst] = used[id] = true; ans.eb(lst, id); lst = 0; &#125; else lst = id; &#125; if (lst &amp;&amp; faid) &#123; used[lst] = used[faid] = true; ans.eb(lst, faid); &#125;&#125;vector&lt;int&gt; L, R;inline void work() &#123; int m = rd(); L.clear(); R.clear(); ans.clear(); rep (i, 1, m) &#123;a[i] = rd(); L.pb(a[i] + i); R.pb(a[i] - i);&#125; sort(all(L)); L.erase(unique(all(L)), L.end()); sort(all(R)); R.erase(unique(all(R)), R.end()); auto lid = [&amp;](int x) &#123;return lower_bound(all(L), x) - L.begin() + 1;&#125;; auto rid = [&amp;](int x) &#123;return lower_bound(all(R), x) - R.begin() + 1 + L.size();&#125;; tot = 1; int n = L.size() + R.size(); rep(i, 1, n) &#123;hd[i] = 0; vis[i] = false;&#125; rep(i, 1, m) &#123;used[i] = false; add(lid(a[i] + i), rid(a[i] - i));&#125; rep(i, 1, n) if (!vis[i]) dfs(i, i); if (ans.size() * 2 != m) &#123;puts(&quot;No&quot;); return;&#125; puts(&quot;Yes&quot;); for (auto [x, y] : ans) printf(&quot;%d %d\\n&quot;, x, y);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; K - NaN in a Heap L - Proposition Composition *M - Drain the Water Tank ç»™ä¸€ä¸ªç®€å•å¤šè¾¹å½¢æ°´ç®±ï¼Œé—®æŠŠå†…éƒ¨çš„æ°´å…¨éƒ¨æ”¾å¹²æœ€å°‘éœ€è¦åœ¨å¤šå°‘ä¸ªé¡¶ç‚¹å¼€å£ï¼ˆé‡åŠ›æ²¿ \\(y\\) è½´å‘ä¸‹ï¼‰ã€‚ æ˜¾ç„¶æ¯ä¸ªä¸‹è¡¨é¢æœ€ä½å¤„éƒ½è¦å¼€ä¸€ä¸ªå£ï¼ˆå³ä¸¤ä¾§éƒ½å‘ä¸Šï¼‰ã€‚ å› æ­¤å°±éœ€è¦æ‰¾å‡ºæ¥å·¦å³éƒ½æ¯”å½“å‰é«˜çš„ç‚¹ï¼ˆåŒ…æ‹¬ä¸€æ®µå¹³å°ï¼‰ï¼Œç„¶ååˆ¤æ–­æ˜¯å¦æ˜¯æ°´ç®±çš„ä¸‹è¡¨é¢ã€‚ å¦‚æœæ˜¯ä¸€ä¸ªå•ç‚¹ï¼Œå¯ä»¥ç”¨ä¸¤ä¸ªå‘é‡çš„å‰ç§¯ç¬¦å·åˆ¤æ–­ã€‚ å¦‚æœæ˜¯ä¸€æ®µå¹³å°ï¼Œåªéœ€ç”¨å¹³å°å†…ç‚¹çš„æ–¹å‘å³å¯ï¼ˆç»™å‡ºç‚¹æŒ‰é€†æ—¶é’ˆï¼Œå› æ­¤ä¸‹è¡¨é¢åº”å½“ä»å·¦åˆ°å³å‡ºç°ï¼‰ å¤æ‚åº¦ \\(O(n)\\) ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define T int inline T rd() &#123; T x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define letp const P // P for Pointstruct P &#123; T x, y; P (T x = 0, T y = 0) : x(x), y(y) &#123;&#125; P operator - (letp &amp;p) const &#123;return &#123;x - p.x, y - p.y&#125;;&#125; T operator | (letp &amp;p) const &#123;return x * p.x + y * p.y;&#125; // dot T operator ^ (letp &amp;p) const &#123;return x * p.y - y * p.x;&#125; // cross // left(counterclockwise) = 1 | on = 0 | right(clockwise) = -1 int ori(letp &amp;p) const &#123;T t = (*this) ^ p; return (t &gt; 0) - (t &lt; 0);&#125;&#125;;int main() &#123; int n = rd(); vector&lt;P&gt; p(n); for (int i = 0; i &lt; n; ++i) &#123;p[i].x = rd(); p[i].y = rd();&#125; auto nxt = [&amp;](const int i) &#123;return i == p.size() - 1 ? 0 : i + 1;&#125;; auto pre = [&amp;](const int i) &#123;return i == 0 ? p.size() - 1 : i - 1;&#125;; int l, r, L = 0, ans = 0; for (; p[L].y == p[pre(L)].y; L = pre(L)); l = r = L; do &#123; while (p[r].y == p[nxt(r)].y) r = nxt(r); if (p[pre(l)].y &gt; p[l].y &amp;&amp; p[nxt(r)].y &gt; p[r].y) &#123; if (l == r) ans += ((p[l] - p[pre(l)]).ori(p[nxt(l)] - p[l]) &gt; 0); else ans += (p[nxt(l)].x &gt; p[l].x); &#125; l = r = nxt(r); &#125; while (l != L); printf(&quot;%d\\n&quot;, ans); return 0;&#125; ä¸ºä»€ä¹ˆæ•°æ®èŒƒå›´è¦ç»™å¯ä»¥æƒ³ \\(n^2\\) çš„åšæ³•å‘¢ã€‚ã€‚ã€‚ å½“æ—¶ä¸€çœ¼ä»¥ä¸ºåˆ¤æ–­ä¸Šä¸‹è¡¨é¢è¦ç”¨ç‚¹åœ¨å¤šè¾¹å½¢å†…ï¼Œå¤æ‚åº¦æ°å¥½æ˜¯ \\(n^2\\) ï¼Œå„ç§çˆ†ç²¾åº¦æŒ‚äº† \\(4\\) å‘æ‰è¿‡ã€‚ã€‚ã€‚","categories":[{"name":"Official Contests","slug":"Official-Contests","permalink":"http://blog.gyx.me/categories/Official-Contests/"}],"tags":[{"name":"Graphs","slug":"Graphs","permalink":"http://blog.gyx.me/tags/Graphs/"},{"name":"Geometry","slug":"Geometry","permalink":"http://blog.gyx.me/tags/Geometry/"}]},{"title":"Educational Codeforces Round 142 (Rated for Div. 2)","slug":"codeforces/1792","date":"2023-01-25T13:22:00.000Z","updated":"2023-03-20T16:26:53.104Z","comments":true,"path":"codeforces/1792/","link":"","permalink":"http://blog.gyx.me/codeforces/1792/","excerpt":"","text":"A. GamingForces æ¯æ¬¡æ‰“ä¸¤ä¸ªçš„æŠ€èƒ½åªå¯¹ä¸¤ä¸ª \\(1\\) æœ‰æ•ˆã€‚ 123int n = rd(), cnt = 0;for (int i = 1; i &lt;= n; ++i) cnt += (rd() == 1);printf(&quot;%d\\n&quot;, n - cnt + cnt / 2 + cnt % 2); B. Stand-up Comedian å…ˆ a å†è½®æµ bc æœ€å d ã€‚ 123int a = rd(), b = rd(), c = rd(), d = rd();if (b &lt; c) swap(b, c);printf(&quot;%d\\n&quot;, a ? a + c * 2 + min(a + 1, b - c + d) : 1); C. Min Max Sort ä¸€ä¸ªæ’åˆ—ï¼Œæ¯æ¬¡å¯ä»¥é€‰ä¸¤ä¸ªæ•° \\(x,y\\) ï¼Œå°†ä¸¤è€…è¾ƒå°çš„ç§»åˆ°å¼€å¤´ï¼Œè¾ƒå¤§çš„ç§»åˆ°ç»“å°¾ã€‚ é—®æ’æˆå¢åºæ‰€éœ€æœ€å°æ“ä½œæ¬¡æ•°ã€‚ å€’ç€è€ƒè™‘ï¼Œå¦‚æœæœ€åç»“æŸçš„æ—¶å€™å¼€å¤´ä¸æ˜¯ \\(1\\) ï¼Œç»“å°¾ä¸æ˜¯ \\(n\\) ï¼Œå°±ä¸€å®šè¦é€‰ä¸€æ¬¡ \\((1, n)\\) ã€‚ ä»¥æ­¤ç±»æ¨ï¼Œæ¯æ¬¡æŠŠæœ€å°å’Œæœ€å¤§ä¸¤ä¸ªæ•°åˆ é™¤ï¼Œç›´åˆ°å‰©ä½™åºåˆ—æ˜¯æ’åºå¥½çš„ä¸ºæ­¢ã€‚æ‡’åˆ é™¤å¤æ‚åº¦ \\(O(n)\\) ã€‚ 12345678910111213141516#define N 200007 int a[N];bool vis[N];inline void work() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123;vis[i] = false; a[i] = rd();&#125; int ans = 0; for (int i = 1, l = 1, r = n; l &lt; r; ++i) &#123; while (vis[a[l]]) ++l; while (vis[a[r]]) --r; if (l &gt;= r) break; if (a[l] != i || a[r] != n - i + 1) ans = i; vis[i] = vis[n - i + 1] = true; &#125; printf(&quot;%d\\n&quot;, ans);&#125; D. Fixed Prefix Permutations åæ¼”ä¸€ä¸‹ï¼Œè€ƒè™‘ \\(a_j\\) èƒ½å¯¹æ¯ä¸ª \\(a_i\\) äº§ç”Ÿå¤šå°‘è´¡çŒ®ï¼Œå®¹æ˜“å‘ç°æ˜¯ \\(a_j\\) çš„é€†å’Œ \\(a_i\\) çš„æœ€é•¿å…¬å…±å‰ç¼€ã€‚ æŠŠæ‰€æœ‰ \\(a_j\\) çš„é€†å»ºä¸€æ£µ Trie ï¼Œç„¶åç­”æ¡ˆå°±æ˜¯ \\(a_i\\) åœ¨ Trie ä¸Šèƒ½è·‘åˆ°çš„æœ€æ·±çš„æ·±åº¦ã€‚å¤æ‚åº¦ \\(O(nm)\\) ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define T int typedef pair&lt;T, T&gt; pii;typedef tuple&lt;T, T, T&gt; tii;#define fr first#define sc second#define mp make_pair#define mt make_tuple#define pb push_back#define eb emplace_back#define all(x) (x).begin(), (x).end()inline T rd() &#123; T x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;int n, m, tot;struct node &#123; int son[10]; void clear() &#123;for (int i = 0; i &lt; 10; ++i) son[i] = 0;&#125;&#125; c[1000007];inline void insert(vector&lt;int&gt; &amp;s) &#123; // build trie int rt = 0; for (int j = 0; j &lt; m; ++j) &#123; if (!c[rt].son[s[j]]) c[rt].son[s[j]] = ++tot; rt = c[rt].son[s[j]]; &#125;&#125;inline int search(vector&lt;int&gt; &amp;s) &#123; // find the max depth s could reach int rt = 0; for (int j = 0; j &lt; m; ++j) &#123; if (!c[rt].son[s[j]]) return j; rt = c[rt].son[s[j]]; &#125; return m;&#125;vector&lt;int&gt; a[50007], rev;inline void work() &#123; n = rd(); m = rd(); rev.resize(m); for (int i = 0; i &lt; n; ++i) &#123; a[i].clear(); for (int j = 0; j &lt; m; ++j) &#123; int x = rd() - 1; rev[x] = j; a[i].push_back(x); &#125; insert(rev); &#125; for (int i = 0; i &lt; n; ++i) printf(&quot;%d &quot;, search(a[i])); puts(&quot;&quot;); for (int i = 0; i &lt;= tot; ++i) c[i].clear(); tot = 0;&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; E. Divisors and Table ç»™å®š \\(m_1, m_2\\ (m_1,m_2\\le 10^9)\\) ï¼Œé—® \\(m_1\\times m_2\\) æœ‰å¤šå°‘ä¸ªå› å­å‡ºç°åœ¨äº† \\(n\\times n\\) çš„ä¹˜æ³•è¡¨é‡Œã€‚ æ­¤å¤–ï¼Œå¯¹äºæ‰€æœ‰å‡ºç°å› å­ï¼Œæ±‚å‡ºæ¥è¯¥å› å­å‡ºç°çš„æœ€å°çš„è¡Œæ•°ã€‚è¾“å‡ºè¿™äº›è¡Œæ•°çš„å¼‚æˆ–å’Œã€‚ \\(m_1m_2\\le 10^{18}\\) ï¼Œè‡³å¤š \\(10^6\\) ä¸ªå› å­ï¼Œ\\(15\\) ä¸ªè´¨å› å­ï¼Œåˆ†å¼€ç»™çš„ç›®çš„åº”è¯¥æ˜¯ä¸ç”¨ pollard rhoã€‚ é‚£ä¹ˆå¯¹äºæ¯ä¸ªå› å­ \\(x\\) ï¼Œä¿è¯åˆ—åˆæ³•ï¼Œæ‰¾åˆ°å…¶ä¸è¶…è¿‡ \\(n\\) çš„æœ€å¤§çš„å› å­ \\(y\\) ï¼Œé‚£ä¹ˆæœ€å°çš„è¡Œå°±æ˜¯ \\(x/y\\) ã€‚ å‡è®¾è¿™æ ·çš„ \\(y\\) å« \\(mx[x]\\) ï¼Œä½¿ç”¨æœç´¢çš„æ–¹æ³•ç”Ÿæˆå› å­ \\(x\\) ï¼Œé‚£ä¹ˆ \\(mx[x]\\) è¿™ä¸ªæ•°ç»„æ˜¯å¯ä»¥é€’æ¨çš„ã€‚ ï¼ˆå¯¹äºæŸä¸ª \\(x\\) å’Œ \\(x\\) åŒ…å«çš„è´¨å› å­ \\(p_i\\) ï¼Œ \\(mx[x]\\) å¯èƒ½çš„æ¥æºåªæœ‰ \\(mx[x/p_i]\\) æˆ– \\(mx[x/p_i] * p_i\\) ï¼‰ æœç´¢çš„è®¡ç®—é‡æ˜¯ \\(\\sum_{x|m_1m_2}\\) \\(x\\) çš„è´¨å› å­ä¸ªæ•°ï¼Œå› æ­¤ä¸ä¼šè¶…è¿‡ \\(15\\times 10^6\\) å¯ä»¥æ¥å—ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define T int typedef pair&lt;T, T&gt; pii;typedef tuple&lt;T, T, T&gt; tii;#define fr first#define sc second#define mp make_pair#define mt make_tuple#define pb push_back#define eb emplace_back#define all(x) (x).begin(), (x).end()inline T rd() &#123; T x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 5007vector&lt;int&gt; d, fac; // fac : prime factors of nwvector&lt;pii&gt; s; // prime factors of m1m2unordered_map&lt;ll, ll&gt; mx; // maximum divisor &lt;= nint n, tot, ans;void dfs(ll nw, int step) &#123; if (step == s.size()) return; dfs(nw, step + 1); auto [p, t] = s[step]; fac.push_back(p); for (; t; --t) &#123; nw *= p; for (auto x : fac) &#123; ll y = mx[nw / x]; mx[nw] = max(mx[nw], (y * x &lt;= n ? y * x : y)); &#125; if (nw / mx[nw] &lt;= n) &#123;++tot; ans ^= nw / mx[nw];&#125; else break; dfs(nw, step + 1); &#125; fac.pop_back();&#125;inline void work() &#123; n = rd(); mx.clear(); d.clear(); s.clear(); mx[1] = 1; tot = ans = 1; auto getd = [&amp;](int x) &#123; int lim = sqrt(x); for (int i = 2; i &lt;= lim &amp;&amp; i &lt;= x; ++i) while (x % i == 0) &#123;d.pb(i); x /= i;&#125; if (x &gt; 1) d.pb(x); &#125;; getd(rd()); getd(rd()); sort(all(d)); int lst = 0, cnt = 0; for (auto x : d) if (x != lst) &#123; if (lst) s.eb(lst, cnt); lst = x; cnt = 1; &#125; else ++cnt; s.eb(lst, cnt); dfs(1, 0); printf(&quot;%d %d\\n&quot;, tot, ans);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; F. Graph Coloring ç»™ \\(n\\) ä¸ªç‚¹çš„å®Œå…¨å›¾çš„è¾¹çº¢è“æŸ“è‰²ï¼Œæ±‚æŸ“è‰²æ–¹æ¡ˆæ•°æ¨¡ \\(998244353\\) ï¼Œæ»¡è¶³ï¼š è‡³å°‘æœ‰ä¸€æ¡çº¢è¾¹ï¼Œè‡³å°‘æœ‰ä¸€æ¡è“è¾¹ å¯¹äºä»»ä½•ä¸€ä¸ªå¤§äº \\(2\\) çš„ç‚¹é›†ï¼Œå…¶å¯¼å‡ºå­å›¾æ˜¯çº¢è¿é€šæˆ–è“è¿é€šçš„ï¼Œä½†ä¸åŒæ—¶æˆç«‹ã€‚ ç»“è®ºï¼šè‹¥ä¸€å¹…å›¾ä¸è¿é€šï¼Œåˆ™å…¶è¡¥å›¾è¿é€šã€‚ å½’çº³è¯æ˜ï¼Œé¦–å…ˆ \\(1\\) ä¸ªç‚¹çš„æ—¶å€™æˆç«‹ã€‚å‡è®¾ \\(k\\) ä¸ªç‚¹æˆç«‹ï¼Œé‚£ä¹ˆå¯¹äºæ–°å¢çš„ä¸€ä¸ªç‚¹ï¼š ä¸ \\(k\\) ä¸ªç‚¹éƒ½è¿é€šï¼Œé‚£ä¹ˆå›¾ä¸­è¯¥ç‚¹è¿é€šäº†æ‰€æœ‰ç‚¹ã€‚ ä¸ \\(k\\) ä¸ªç‚¹éƒ½ä¸è¿é€šï¼Œé‚£ä¹ˆè¡¥å›¾ä¸­è¯¥ç‚¹è¿é€šäº†æ‰€æœ‰ç‚¹ã€‚ ä¸ä¸€äº›ç‚¹æœ‰è¾¹ä¸€äº›ç‚¹æ— è¾¹ï¼Œåˆ™åŸå›¾è¿é€šå³å¯è¿ä¸Šè¯¥ç‚¹ï¼ŒåŸå›¾ä¸è¿é€šåˆ™è¡¥å›¾å³å¯è¿ä¸Šè¯¥ç‚¹ã€‚ æ‰€ä»¥è®¡æ•°æ—¶åªéœ€è¦ä¿è¯çº¢è“ä¸åŒæ—¶è¿é€šå³å¯ã€‚ å‡è®¾ \\(n\\) ä¸ªç‚¹çš„ç­”æ¡ˆä¸º \\(A_n\\) ï¼Œå¯¹äºä»»æ„ä¸€ä¸ªè§£è¾¹é¢œè‰²å–åä»ç„¶æ˜¯ä¸€ä¸ªè§£ã€‚ å› æ­¤æˆ‘ä»¬è®¡æ•° \\(n\\) ä¸ªç‚¹ï¼Œå…¨é›†åªè¢«è“è‰²è¿é€šçš„æ–¹æ¡ˆæ•° \\(B_n\\) ï¼Œæœ‰ \\(A_n=2\\times B_n\\) ï¼ˆç‰¹æ®Š \\(A_1=B_1=1\\) ï¼‰ã€‚ é€’æ¨è€ƒè™‘ \\(1\\) å·ç‚¹è¢«åŠ å…¥çš„æƒ…å†µã€‚ å¯¹äº \\(1\\) å·ç‚¹æ‰€åœ¨çš„çº¢è‰²è¿é€šåˆ†é‡ï¼ˆæå¤§ï¼‰ï¼Œç”±å®šä¹‰æ¯ä¸ªç‚¹å’Œåˆ†é‡å¤–çš„ç‚¹çš„è¾¹éƒ½æ˜¯è“è‰²ã€‚ è¿™æ—¶æƒ³è¦æŠŠ \\(1\\) å·ç‚¹è“è¿é€šåŠ å…¥ï¼Œåˆ™å¿…å®šè¦é€‰åˆ†é‡å†…çš„ç‚¹å’Œåˆ†é‡å¤–çš„ç‚¹çš„è¾¹ã€‚ æ— è®ºåˆ†é‡å¤–çš„ç‚¹ä¹‹é—´çš„è¾¹å¦‚ä½•æŸ“è‰²ï¼Œè¿™å¹…å›¾çš„ç”Ÿæˆæ ‘å¿…å®šåŒ…å«è“è‰²çš„è¾¹ï¼Œç”±å¼€å§‹çš„ç»“è®ºè¿™å¹…å›¾åªèƒ½æ˜¯è“è¿é€šã€‚ å› æ­¤é€’æ¨æšä¸¾çº¢è‰²è¿é€šåˆ†é‡çš„å¤§å° \\(k\\) ï¼Œåˆ™åˆ†é‡å†…æ–¹æ¡ˆæ•° \\(B_k\\) ï¼Œåˆ†é‡å¤–æ–¹æ¡ˆæ•° \\(A_{n-k}\\) ï¼Œæœ‰ï¼š \\[ B_n =\\sum_{k=1}^{n-1} {n - 1\\choose k - 1} B_k A_{n-k},\\ n&gt;1 \\] é€’æ¨å¤æ‚åº¦ \\(O(n^2)\\) ã€‚ 123456789101112131415161718192021222324252627282930313233#define N 5007#define mod 998244353int fac[N], ifac[N]; inline int fpow(int x, int t = mod - 2) &#123; int res = 1; for (; t; t &gt;&gt;= 1, x = 1ll * x * x % mod) if (t &amp; 1) res = 1ll * res * x % mod; return res;&#125; inline ll C(int n, int m) &#123; if (n &lt; m) return 0; return 1ll * fac[n] * ifac[m] % mod * ifac[n - m] % mod;&#125;int b[N] = &#123;0, 1&#125;, a[N] = &#123;0, 1&#125;;int main() &#123; int n = rd(); fac[0] = ifac[0] = 1; rep(i, 1, n) fac[i] = 1ll * fac[i - 1] * i % mod; ifac[n] = fpow(fac[n]); per(i, n - 1, 1) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % mod; rep(i, 2, n) &#123; rep(j, 1, i - 1) b[i] = (b[i] + C(i - 1, j - 1) * b[j] % mod * a[i - j]) % mod; a[i] = 2 * b[i] % mod; &#125; printf(&quot;%d\\n&quot;, (a[n] + mod - 2) % mod); // å»æ‰å…¨çº¢/è“çš„æƒ…å†µ return 0;&#125; æ•´ç†ç³»æ•°ä¹‹åå°±å¯ä»¥åˆ†æ²» NTT è®¡ç®—äº†ã€‚å¤æ‚åº¦ \\(O(n\\log ^2 n)\\) ã€‚","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://blog.gyx.me/categories/Codeforces/"},{"name":"Educational Codeforces Round","slug":"Codeforces/Educational-Codeforces-Round","permalink":"http://blog.gyx.me/categories/Codeforces/Educational-Codeforces-Round/"}],"tags":[{"name":"Graphs","slug":"Graphs","permalink":"http://blog.gyx.me/tags/Graphs/"},{"name":"Number Theory","slug":"Number-Theory","permalink":"http://blog.gyx.me/tags/Number-Theory/"},{"name":"Counting","slug":"Counting","permalink":"http://blog.gyx.me/tags/Counting/"}]},{"title":"Codeforces Round #844 (Div. 1 + Div. 2)","slug":"codeforces/1782","date":"2023-01-16T02:01:00.000Z","updated":"2023-03-20T16:26:16.675Z","comments":true,"path":"codeforces/1782/","link":"","permalink":"http://blog.gyx.me/codeforces/1782/","excerpt":"","text":"A. Parallel Projection æšä¸¾ä¸€ä¸‹é€‰æ‹©çš„è¾¹ç•Œç‚¹å³å¯ã€‚å¤æ‚åº¦ \\(O(t(w+d))\\) ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define T int typedef pair&lt;T, T&gt; pii;typedef tuple&lt;T, T, T&gt; tii;#define mp make_pair#define pb push_back#define mt make_tuple#define all(x) (x).begin(), (x).end()#define lowbit(x) ((x) &amp; -(x))inline T rd() &#123; T x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 100007inline void work() &#123; int w = rd(), d = rd(), h = rd(); int a = rd(), b = rd(), f = rd(), g = rd(); int ans = 1e9; auto calc = [&amp;](int x, int y) &#123; ans = min(ans, h + abs(a - x) + abs(b - y) + abs(f - x) + abs(g - y)); &#125;; for (int i = 0; i &lt;= d; ++i) &#123;calc(0, i); calc(w, i);&#125; for (int i = 0; i &lt;= w; ++i) &#123;calc(i, 0); calc(i, d);&#125; printf(&quot;%d\\n&quot;, ans);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; B. Going to the Cinema \\(a_i\\) å‡åºæ’åºï¼Œæ˜¾ç„¶å»çš„äººä¼šæ˜¯ä¸€ä¸ªå‰ç¼€ã€‚ æšä¸¾å»äº† \\(k\\) ä¸ªï¼Œåªéœ€è¦æ£€æŸ¥ç¬¬ \\(k\\) ä¸ªäººå’Œç¬¬ \\(k+1\\) ä¸ªäººã€‚å¤æ‚åº¦ \\(O(n\\log n)\\) ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define T int typedef pair&lt;T, T&gt; pii;typedef tuple&lt;T, T, T&gt; tii;#define mp make_pair#define pb push_back#define mt make_tuple#define all(x) (x).begin(), (x).end()#define lowbit(x) ((x) &amp; -(x))inline T rd() &#123; T x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 200007int a[N];inline void work() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) a[i] = rd(); sort(a + 1, a + 1 + n); a[n + 1] = 1e9; int ans = (a[1] &gt; 0); for (int i = 1; i &lt;= n; ++i) &#123; if (i &gt; a[i] &amp;&amp; i &lt; a[i + 1]) ++ans; &#125; printf(&quot;%d\\n&quot;, ans);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; C. Equal Frequencies æšä¸¾ç”¨äº†å¤šå°‘ä¸ªå­—ç¬¦ï¼Œç„¶åé€‰å‡ºç°æ¬¡æ•°æœ€å¤šçš„é‚£å‡ ä¸ªå³å¯ã€‚å¥½ä¸€ç‚¹çš„å®ç°å¯ä»¥å¤æ‚åº¦ \\(O(n)\\) ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define T int typedef pair&lt;T, T&gt; pii;typedef tuple&lt;T, T, T&gt; tii;#define mp make_pair#define pb push_back#define mt make_tuple#define all(x) (x).begin(), (x).end()#define lowbit(x) ((x) &amp; -(x))inline T rd() &#123; T x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 200007char s[N], t[N];int n, cnt[26], rem[26], id[26];vector&lt;char&gt; add;inline int calc(int m) &#123; int ret = n; for (int i = 0; i &lt; m; ++i) ret -= min(n / m, cnt[i]); return ret;&#125;inline void work() &#123; n = rd(); scanf(&quot;%s&quot;, s + 1); for (int i = 0; i &lt; 26; ++i) cnt[i] = rem[i] = 0; for (int i = 1; i &lt;= n; ++i) ++cnt[s[i] - &#x27;a&#x27;]; for (int i = 0; i &lt; 26; ++i) id[i] = i; sort(id, id + 26, [&amp;](int a, int b) &#123;return cnt[a] &gt; cnt[b];&#125;); sort(cnt, cnt + 26, [&amp;](int a, int b) &#123;return a &gt; b;&#125;); int ans = 1e9, res = 1; for (int i = 1; i &lt;= 26; ++i) if (n % i == 0) &#123; int ret = calc(i); if (ret &lt; ans) &#123;ans = ret; res = i;&#125; &#125; for (int i = 0; i &lt; res; ++i) rem[id[i]] = n / res; printf(&quot;%d\\n&quot;, ans); for (int i = 1; i &lt;= n; ++i) &#123; if (rem[s[i] - &#x27;a&#x27;]) &#123;--rem[s[i] - &#x27;a&#x27;]; t[i] = s[i];&#125; else t[i] = 0; &#125; add.clear(); for (int i = 0; i &lt; res; ++i) if (rem[id[i]]) for (int j = 1; j &lt;= rem[id[i]]; ++j) add.push_back(id[i] + &#x27;a&#x27;); for (int i = 1; i &lt;= n; ++i) if (t[i] == 0) &#123;t[i] = add.back(); add.pop_back();&#125; t[n + 1] = &#x27;\\0&#x27;; puts(t + 1);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; D. Many Perfect Squares ç»™å®š \\(n\\ (n\\le 50)\\) ä¸ªæ•° \\(a_1,\\dots,a_n\\) ï¼Œæ±‚ï¼š \\[ \\max_{0\\le x\\le 10^{18}} \\sum_{i=1}^n [ \\exists t \\in \\mathbb{N}, x+a_i=t^2] \\] ç­”æ¡ˆè‡³å°‘ä¸º \\(1\\) ï¼Œè€ƒè™‘ç­”æ¡ˆ \\(\\ge 2\\) æ—¶ï¼Œæšä¸¾ç­”æ¡ˆåŒ…å«çš„æŸä¸¤ä¸ª \\(a_i,a_j\\ (a_i\\le a_j)\\) ï¼Œåˆ™ \\(x\\) è¦æ»¡è¶³ï¼š \\[ \\left\\{ \\begin{array}{l} x+a_i=t_1^2 \\\\ x+a_j=t_2^2 \\end{array} \\right. \\Rightarrow a_j-a_i=t_2^2-t_1^2=(t_2+t_1)(t_2-t_1) \\] å¯¹äºä¸€ç»„ \\((a_i,a_j)\\) åªæœ‰å› æ•°ä¸ªæ•°çº§åˆ«çš„å¯èƒ½ï¼Œå› æ­¤æ€»å…±éœ€å°è¯•çš„ \\(x\\) åªæœ‰ \\(O(n^2 \\sqrt[3]{\\max a_i-a_j})\\) ä¸ªæ•°ã€‚ å¤æ‚åº¦ \\(O(n^2\\sqrt{\\max \\Delta}+n^3\\sqrt[3]{\\max \\Delta})\\) ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define T int typedef pair&lt;T, T&gt; pii;typedef tuple&lt;T, T, T&gt; tii;#define mp make_pair#define pb push_back#define mt make_tuple#define all(x) (x).begin(), (x).end()#define lowbit(x) ((x) &amp; -(x))inline T rd() &#123; T x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 57int a[N], ans;unordered_map&lt;ll, bool&gt; vis; inline void work() &#123; int n = rd(); ans = 1; vis.clear(); for (int i = 1; i &lt;= n; ++i) a[i] = rd(); auto issqr = [&amp;](ll x) &#123; ll rt = sqrt(x); for (ll i = rt - 2; i &lt;= rt + 2; ++i) if (i * i == x) return true; return false; &#125;; auto test = [&amp;](ll x) &#123; int cnt = 0; for (int i = 1; i &lt;= n; ++i) cnt += issqr(a[i] + x); return cnt; &#125;; for (int i = 1; i &lt; n; ++i) for (int j = i + 1; j &lt;= n; ++j) &#123; int x = a[j] - a[i]; int lim = sqrt(x); for (int d = 1; d &lt;= lim; ++d) if (x % d == 0) &#123; int t = x / d - d; if (t &amp; 1) continue; t &gt;&gt;= 1; ll tar = 1ll * t * t - a[i]; if (tar &lt; 0) break; if (vis[tar]) continue; vis[tar] = true; ans = max(ans, test(tar)); &#125; &#125; printf(&quot;%d\\n&quot;, ans);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; E. Rectangle Shrinking åªæœ‰ä¸€è¡Œåˆ™é¢ç§¯ä¸ä¼šå˜å°ï¼šæŒ‰ç…§å·¦ç«¯ç‚¹æ’åºï¼Œä¾æ¬¡å¤„ç†ï¼Œå°†å·¦ç«¯ç‚¹å¢å¤§åˆ°æ­¤å‰åŒºé—´æœ€é å³çš„ä½ç½®ä¹‹åå³å¯ã€‚ å¯¹äºä¸¤è¡Œï¼Œå…ˆæŠŠé«˜åº¦æ˜¯ \\(2\\) çš„çŸ©å½¢æŒ‰ç…§ä¸Šè¿°æ–¹æ³•å¤„ç†åï¼Œä¸å†æœ‰äº¤ã€‚ ç„¶åä¸¤è¡Œåˆ†åˆ«è€ƒè™‘ï¼Œæ‰¾å‡ºæ¥æ‰€æœ‰è¯¥è¡Œæœ‰è¦†ç›–çš„çŸ©å½¢ï¼ŒæŒ‰ç…§å·¦ç«¯ç‚¹æ’åºï¼Œç„¶åæ‰«æï¼š å¦‚æœå½“å‰å— \\([l_i,r_i]\\) æ˜¯ä¸¤è¡Œçš„ï¼š å¦‚æœåœ¨è¿™ä¸€è¡Œè¢«å®Œå…¨åŒ…å«ï¼Œåˆ™åˆ æ‰å½“å‰å—è¿™ä¸€è¡Œçš„éƒ¨åˆ†å³å¯ã€‚ å¦åˆ™å°†å‰é¢çš„æ‰€æœ‰åŒºé—´å³ç«¯ç‚¹æ”¹ä¸º \\(&lt;l_i\\) ã€‚å› ä¸ºå‰é¢çš„æ“ä½œä¿è¯é«˜åº¦æ˜¯ \\(2\\) çš„ä¸äº¤ï¼Œæ‰€ä»¥åªä¼šæ”¹é«˜åº¦æ˜¯ \\(1\\) çš„ï¼Œè€Œæ¯ä¸ªå—æ˜¾ç„¶è‡³å¤šåªä¼šå› ä¸ºè¿™ä¸ªæ“ä½œè¢«ä¿®æ”¹ä¸€æ¬¡ï¼Œæ‰€ä»¥å¤æ‚åº¦æ²¡é—®é¢˜ã€‚ å¦‚æœå½“å‰å— \\([l_i,r_i]\\) æ˜¯ä¸€è¡Œçš„ï¼š å¦‚æœè¢«å®Œå…¨åŒ…å«ï¼Œç›´æ¥åˆ æ‰ã€‚ å¦åˆ™å°†å·¦ç«¯ç‚¹å¢å¤§åˆ°æ­¤å‰åŒºé—´æœ€é å³çš„ä½ç½®ä¹‹åã€‚ å¾ˆå®¹æ˜“å‘ç°é¢ç§¯ä¸ä¼šå˜å°ï¼Œéƒ½ä¿®æ”¹å®Œä¹‹åç®—é¢ç§¯å³å¯ã€‚ å¤æ‚åº¦ \\(O(n\\log n)\\) ã€‚å…¶å®ä»£ç å¤§æ®µå¤åˆ¶ç²˜è´´ä¹Ÿä¸éš¾å†™ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define T int typedef pair&lt;T, T&gt; pii;typedef tuple&lt;T, T, T&gt; tii;#define mp make_pair#define pb push_back#define mt make_tuple#define all(x) (x).begin(), (x).end()#define lowbit(x) ((x) &amp; -(x))inline T rd() &#123; T x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 200007vector&lt;int&gt; s;struct node &#123;int u, d, l, r;&#125; c[N];inline void work() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; c[i].u = rd(); c[i].l = rd(); c[i].d = rd(); c[i].r = rd(); &#125; // u = 1 &amp;&amp; d = 2 s.clear(); for (int i = 1; i &lt;= n; ++i) if (c[i].u == 1 &amp;&amp; c[i].d == 2) s.pb(i); sort(all(s), [&amp;](int a, int b)&#123;return c[a].l == c[b].l ? c[a].r &lt; c[b].r : c[a].l &lt; c[b].l;&#125;); int r = 0; for (auto x : s) &#123; if (c[x].r &lt;= r) c[x] = (node)&#123;0, 0, 0, 0&#125;; else &#123;c[x].l = max(c[x].l, r + 1); r = c[x].r;&#125; &#125; // u = 1 s.clear(); for (int i = 1; i &lt;= n; ++i) if (c[i].u == 1) s.pb(i); sort(all(s), [&amp;](int a, int b)&#123;return c[a].l == c[b].l ? c[a].r &lt; c[b].r : c[a].l &lt; c[b].l;&#125;); r = 0; for (int i = 0, lim = (int)s.size(), ptr = 0; i &lt; lim; ++i) &#123; int x = s[i]; if (c[x].d == 2) &#123; if (r &gt;= c[x].r) c[x].u = 2; else &#123; for (; ptr &lt; i; ++ptr) if (c[s[ptr]].r &gt;= c[x].l) c[s[ptr]].r = c[x].l - 1; r = c[x].r; &#125; &#125; else &#123; if (c[x].r &lt;= r) c[x] = (node)&#123;0, 0, 0, 0&#125;; else &#123;c[x].l = max(c[x].l, r + 1); r = c[x].r;&#125; &#125; &#125; // d = 2 s.clear(); for (int i = 1; i &lt;= n; ++i) if (c[i].d == 2) s.pb(i); sort(all(s), [&amp;](int a, int b)&#123;return c[a].l == c[b].l ? c[a].r &lt; c[b].r : c[a].l &lt; c[b].l;&#125;); r = 0; for (int i = 0, lim = (int)s.size(), ptr = 0; i &lt; lim; ++i) &#123; int x = s[i]; if (c[x].u == 1) &#123; if (r &gt;= c[x].r) c[x].d = 1; else &#123; for (; ptr &lt; i; ++ptr) if (c[s[ptr]].r &gt;= c[x].l) c[s[ptr]].r = c[x].l - 1; r = c[x].r; &#125; &#125; else &#123; if (c[x].r &lt;= r) c[x] = (node)&#123;0, 0, 0, 0&#125;; else &#123;c[x].l = max(c[x].l, r + 1); r = c[x].r;&#125; &#125; &#125; int tot = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (c[i].u &gt; c[i].d || c[i].l &gt; c[i].r) c[i] = (node)&#123;0, 0, 0, 0&#125;; if (c[i].u) tot += (c[i].d - c[i].u + 1) * (c[i].r - c[i].l + 1); &#125; printf(&quot;%d\\n&quot;, tot); for (int i = 1; i &lt;= n; ++i) printf(&quot;%d %d %d %d\\n&quot;, c[i].u, c[i].l, c[i].d, c[i].r);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://blog.gyx.me/categories/Codeforces/"},{"name":"Codeforces Round","slug":"Codeforces/Codeforces-Round","permalink":"http://blog.gyx.me/categories/Codeforces/Codeforces-Round/"}],"tags":[]},{"title":"AtCoder Regular Contest 153","slug":"atcoder/arc153","date":"2023-01-14T14:20:11.000Z","updated":"2023-03-20T16:28:57.860Z","comments":true,"path":"atcoder/arc153/","link":"","permalink":"http://blog.gyx.me/atcoder/arc153/","excerpt":"","text":"A. AABCDDEFE æ‰¾å½¢å¦‚ AABCDDEFE çš„ç¬¬ \\(k\\) å¤§æ•°ã€‚ ä¸ªæ•°åªæœ‰ \\(10^6\\) ä¸ªï¼Œæšä¸¾ï¼ˆç”šè‡³å¯ä»¥æ’åºï¼‰æ‰¾ç¬¬ \\(k\\) å¤§ã€‚ 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;vector&lt;int&gt; s;int main() &#123; for (int i = 1, x = 0; i &lt;= 9; ++i) &#123; x = i * 110000000; s.push_back(x); for (int j = 0; j &lt;= 99; ++j) &#123; if (j) &#123;x = x / 100000 * 100000 + 100000; s.push_back(x);&#125; for (int k = 0; k &lt;= 9; ++k) &#123; if (k) &#123;x = x / 100000 * 100000 + k * 11000; s.push_back(x);&#125; for (int l = 0; l &lt;= 9; ++l) &#123; if (l) &#123;x = x / 1000 * 1000 + l * 101; s.push_back(x);&#125; for (int r = 1; r &lt;= 9; ++r) if (r) &#123;x += 10; s.push_back(x);&#125; &#125; &#125; &#125; &#125; sort(s.begin(), s.end()); s.erase(unique(s.begin(), s.end()), s.end()); int n = rd(); printf(&quot;%d\\n&quot;, s[n - 1]); return 0;&#125; B. Grid Rotations ä¸€ä¸ªå­—ç¬¦çŸ©é˜µ \\((W\\times H\\le 5\\times 10^5)\\) ï¼Œ \\(n\\ (n\\le 2\\times 10^5)\\) æ¬¡æ“ä½œï¼Œæœ€åè¾“å‡ºæ•´ä¸ªçŸ©é˜µã€‚ æ¯æ¬¡æ“ä½œç»™ä¸€ä¸ªç‚¹ï¼ŒæŠŠçŸ©é˜µåˆ’åˆ†æˆå››ä¸ªçŸ©å½¢ï¼Œå°†å››ä¸ªçŸ©å½¢å„è‡ªæ—‹è½¬ \\(180^\\circ\\) ï¼ˆæ”¾åœ¨åŸä½ï¼‰ã€‚ å®¹æ˜“å‘ç°äº¤æ¢ä¸ä¼šæ”¹å˜åŒè¡ŒåŒåˆ—å…³ç³»ï¼Œå› æ­¤å¯ä»¥å¯¹è¡Œåˆ—åæ ‡åˆ†åˆ«ç»´æŠ¤å¯¹åº”çš„å˜åŒ–ï¼Œæ¯æ¬¡ç¿»è½¬æŸç‚¹åˆ†å¼€çš„å‰åä¸¤ä¸ªåŒºé—´ã€‚ ç›´æ¥å¹³è¡¡æ ‘æ˜¾ç„¶æ˜¯å¯ä»¥åšçš„ï¼Œèµ›ä¸­å°±ç”¨ rope æ°´è¿‡å»äº†ï¼ˆåŒæ—¶ç»´æŠ¤æ­£åä¸¤ä¸ªé“¾è¡¨ï¼‰ã€‚ 12345inline void inv(int p) &#123; // reverse first p elements and last n - p elements tmp = s; s = r.substr(n - p, p) + r.substr(0, n - p); r = tmp.substr(p, n - p) + tmp.substr(0, p); // reversed sequence&#125; æ­£ç»ç»“è®ºæ˜¯ï¼šå¦‚æœæŠŠæ’åˆ—çœ‹æˆç¯ï¼Œé‚£ä¹ˆæ¯æ¬¡æ“ä½œä¸ä¼šæ”¹å˜ä»»æ„ä¸¤æ•°ä¹‹é—´çš„ç›¸é‚»å…³ç³»ã€‚ æ‰€ä»¥æœ€å¤šåªæœ‰ \\(2n\\) ä¸ªæ’åˆ—ï¼ˆåŸå§‹æ­£å + shiftï¼‰ï¼Œæ¯æ¬¡ç›´æ¥æ‰¾æ˜¯å“ªä¸ªå°±è¡Œäº†ï¼Œå¯ä»¥ç”¨ 1 å’Œ 2 çš„ä½ç½®ç¡®å®šã€‚ æœ€ç»ˆå¤æ‚åº¦ \\(O(HW + n)\\) ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;int main() &#123; int H = rd(), W = rd(); vector&lt;int&gt; r(H, 0), c(W, 0); vector&lt;vector&lt;char&gt;&gt; a(H, vector&lt;char&gt;(W)); for (int i = 0; i &lt; H; ++i) for (int j = 0; j &lt; W; ++j) &#123; char c = getchar(); while (!isalpha(c)) c = getchar(); a[i][j] = c; &#125; int n = rd(), r0 = 0, r1 = 1, c0 = 0, c1 = 1; auto upd = [&amp;](int &amp;pos, int m, int p) &#123;pos = (pos &gt; p) * m + p - pos;&#125;; for (int i = 1; i &lt;= n; ++i) &#123; int x = rd() - 1, y = rd() - 1; upd(r1, H, x); upd(r0, H, x); upd(c1, W, y); upd(c0, W, y); &#125; if (r1 == (r0 + 1) % H) for (int i = 0; i &lt; H; ++i) r[(r0 + i) % H] = i; else for (int i = 0; i &lt; H; ++i) r[(r0 + H - i) % H] = i; if (c1 == (c0 + 1) % W) for (int i = 0; i &lt; W; ++i) c[(c0 + i) % W] = i; else for (int i = 0; i &lt; W; ++i) c[(c0 + W - i) % W] = i; for (int i = 0; i &lt; H; ++i) &#123; for (int j = 0; j &lt; W; ++j) putchar(a[r[i]][c[j]]); puts(&quot;&quot;); &#125; return 0;&#125; D. cf ä¸Šæœ‰ä¸€ä¸ªäºŒå…ƒç‰ˆæœ¬ https://codeforces.com/contest/1188/problem/D","categories":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://blog.gyx.me/categories/AtCoder/"},{"name":"AtCoder Regular Contest","slug":"AtCoder/AtCoder-Regular-Contest","permalink":"http://blog.gyx.me/categories/AtCoder/AtCoder-Regular-Contest/"}],"tags":[{"name":"Constructive Algorithm","slug":"Constructive-Algorithm","permalink":"http://blog.gyx.me/tags/Constructive-Algorithm/"}]},{"title":"Line Graph","slug":"algorithms/line-graph","date":"2022-12-24T10:42:01.000Z","updated":"2023-04-14T05:43:18.623Z","comments":true,"path":"algorithms/line-graph/","link":"","permalink":"http://blog.gyx.me/algorithms/line-graph/","excerpt":"","text":"Definition Maximum Matching è¾¹æ•°æ˜¯å¶æ•°çš„å›¾çš„çº¿å›¾å…·æœ‰å®Œç¾åŒ¹é…ï¼›å¥‡æ•°åˆ™å­˜åœ¨åªæœ‰ä¸€æ¡è¾¹æ²¡æœ‰åŒ¹é…çš„æ–¹æ¡ˆã€‚ å…ˆéšä¾¿æ‰¾ä¸€æ£µ dfs æ ‘ï¼Œç„¶åä»æ·±åˆ°æµ…è€ƒè™‘æ¯ä¸€ä¸ªç‚¹ã€‚ æ‰¾åˆ°æ‰€æœ‰å’Œå®ƒç›¸è¿çš„æœªè¢«åŒ¹é…çš„è¾¹ï¼Œé™¤äº†å®ƒè¿å‘çˆ¶äº²çš„è¾¹ï¼ˆè¿™æ¡è¾¹æ˜¾ç„¶æœªè¢«åŒ¹é…ï¼‰ã€‚ å¦‚æœè¾¹æ˜¯å¶æ•°æ¡ï¼Œä¸¤ä¸¤åŒ¹é…å³å¯ï¼Œè¿å‘çˆ¶äº²çš„è¾¹ä¼šåœ¨å¤„ç†çˆ¶äº²æ—¶è¢«åŒ¹é…ä¸Šã€‚å¦‚æœè¾¹æ˜¯å¥‡æ•°æ¡ï¼Œå°±æŠŠè¿å‘çˆ¶äº²çš„è¾¹ä¹ŸåŠ å…¥åŒ¹é…ã€‚ å½“é€’å½’å›åˆ°æ ¹èŠ‚ç‚¹æ—¶ï¼Œæ­¤æ—¶ dfs æ ‘ä¸ŠæœªåŒ¹é…çš„è¾¹éƒ½æ˜¯ä»æ ¹èŠ‚ç‚¹è¿å‘ç›´æ¥å­èŠ‚ç‚¹çš„è¾¹ã€‚ å› æ­¤å¶æ•°æ¡è¾¹æ—¶éƒ½å¯ä»¥åŒ¹é…ä¸Šï¼Œå¦åˆ™æœ€å¤šå‰©ä¸‹ä¸€æ¡ã€‚ä¸€é“ä¾‹é¢˜ 1234567891011121314151617181920212223242526272829303132333435363738#define N 200007int hd[N], tot = 1;bool vis[N], used[N];struct edge &#123;int to, nxt;&#125; e[N &lt;&lt; 1];vector&lt;tii&gt; ans;void dfs(int u, int fa) &#123; vis[u] = true; int faid = 0; for (int i = hd[u], v; i; i = e[i].nxt) if (!vis[v = e[i].to]) dfs(v, u); else if (v == fa) faid = (i &gt;&gt; 1); int lstid = 0, lstv = 0; for (int i = hd[u], v, id; i; i = e[i].nxt) if ((v = e[i].to) != fa &amp;&amp; !used[id = (i &gt;&gt; 1)]) &#123; if (lstid) &#123; used[lstid] = used[id] = true; ans.eb(lstv, u, v); lstid = lstv = 0; &#125; else &#123;lstid = id; lstv = v;&#125; &#125; if (lstid &amp;&amp; faid) &#123; used[lstid] = used[faid] = true; ans.eb(lstv, u, fa); &#125;&#125;int main() &#123; int n = rd(), m = rd(); for (int i = 1; i &lt;= m; ++i) &#123; int u = rd(), v = rd(); e[++tot].to = v; e[tot].nxt = hd[u]; hd[u] = tot; e[++tot].to = u; e[tot].nxt = hd[v]; hd[v] = tot; &#125; for (int i = 1; i &lt;= n; ++i) if (!vis[i]) dfs(i, i); printf(&quot;%d\\n&quot;, (int)ans.size()); for (auto [u, v, w] : ans) printf(&quot;%d %d %d\\n&quot;, u, v, w); return 0;&#125; ä¸€äº›ç®€å•å˜å¼ï¼šEdge Pairing , Perfect Matching , Line Graph Matching","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://blog.gyx.me/categories/Algorithms/"}],"tags":[{"name":"Graphs","slug":"Graphs","permalink":"http://blog.gyx.me/tags/Graphs/"}]},{"title":"Codeforces Round #383 (Div. 1)","slug":"codeforces/741","date":"2022-11-29T16:00:00.000Z","updated":"2023-03-20T16:25:37.585Z","comments":true,"path":"codeforces/741/","link":"","permalink":"http://blog.gyx.me/codeforces/741/","excerpt":"","text":"Div. 2 çš„ AB æ¯”è¾ƒæ°´å°±ä¸è®°å½•äº†ã€‚ A - Arpa's loud Owf and Mehrdad's evil plan å¦‚æœä¸æ˜¯æ’åˆ—å¯„ã€‚å¦åˆ™ç­”æ¡ˆå¿…é¡»æ˜¯å¥‡ç¯ç¯é•¿çš„å€æ•°ï¼Œå¶ç¯ç¯é•¿ä¸€åŠçš„å€æ•°ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125; #define N 107ll gcd(ll a, ll b) &#123;return b ? gcd(b, a % b) : a;&#125;bool vis[N];int a[N], deg[N];int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) ++deg[a[i] = rd()]; ll ans = 1; for (int i = 1; i &lt;= n; ++i) &#123; if (!deg[i]) &#123;puts(&quot;-1&quot;); return 0;&#125; if (!vis[i]) &#123; int len = 0; for (int p = i; !vis[p]; p = a[p], ++len) vis[p] = true; if (!(len &amp; 1)) len /= 2; ans = ans / gcd(ans, len) * len; &#125; &#125; printf(&quot;%lld\\n&quot;, ans); return 0;&#125; B - Arpa's weak amphitheater and Mehrdad's valuable Hoses å¹¶æŸ¥é›†æ±‚å‡ºæ¥æ¯ä¸ªå°å›¢ä½“ã€‚å¯¹äºæ¯ä¸ªå°å›¢ä½“ï¼Œå¯é€‰çš„è½¬ç§»æ–¹å¼ä¸ºå•äºº/å…¨é€‰ã€‚ èƒŒåŒ…å…ˆç”¨å¦ä¸€ä¸ªæ•°ç»„ \\(g\\) è®°å½• \\(f\\) ç»è¿‡æ‰€æœ‰å¯èƒ½çš„è½¬ç§»çš„ \\(\\max\\) ï¼Œå†èµ‹å€¼å› \\(f\\) æ›´æ–°ï¼Œå¤æ‚åº¦ \\(O(nw)\\)ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125; #define N 1007struct DSU &#123; int f[N]; inline void reset(int n) &#123;for (int i = 1; i &lt;= n; ++i) f[i] = i;&#125; int find(int x) &#123;return x == f[x] ? x : f[x] = find(f[x]);&#125; inline bool merge(int x, int y) &#123; x = find(x); y = find(y); return x == y ? false : (f[x] = y, true); &#125;&#125; dsu;int w[N], v[N], f[N], g[N];vector&lt;int&gt; s[N];int main() &#123; int n = rd(), m = rd(), tot = rd(); dsu.reset(n); for (int i = 1; i &lt;= n; ++i) w[i] = rd(); for (int i = 1; i &lt;= n; ++i) v[i] = rd(); for (int i = 1; i &lt;= m; ++i) dsu.merge(rd(), rd()); for (int i = 1; i &lt;= n; ++i) s[dsu.find(i)].push_back(i); auto upd = [&amp;](int W, int V) &#123; for (int i = W; i &lt;= tot; ++i) g[i] = max(g[i], f[i - W] + V); &#125;; for (int i = 1; i &lt;= n; ++i) &#123; if (s[i].empty()) continue; int sumw = 0, sumv = 0; for (auto x : s[i]) &#123; sumw += w[x]; sumv += v[x]; upd(w[x], v[x]); &#125; upd(sumw, sumv); for (int i = 1; i &lt;= tot; ++i) f[i] = max(f[i], g[i]); &#125; printf(&quot;%d\\n&quot;, f[tot]); return 0; &#125; C - Arpaâ€™s overnight party and Mehrdadâ€™s silent entering \\(2\\times n\\) ä¸ªäººï¼ˆ \\(n\\) ä¸ªæƒ…ä¾£ï¼‰åæˆä¸€ä¸ªç¯ï¼Œé»‘ç™½æŸ“è‰²ï¼Œè¦æ±‚æƒ…ä¾£é¢œè‰²ä¸åŒï¼Œç›¸é‚»ä¸‰ä¸ªä¸­è‡³å°‘æœ‰ä¸¤ä¸ªé¢œè‰²ã€‚ æœ‰æ„æ€çš„æ„é€ é¢˜ã€‚çœ‹åˆ°é»‘ç™½æŸ“è‰²å°±ä¸¤ç§å¯èƒ½ï¼Œ2-SAT å’Œ äºŒåˆ†å›¾ï¼Œç›¸é‚»ä¸‰ä¸ªçš„è¦æ±‚å†™ä¸æˆ 2-SAT çš„çº¦æŸã€‚ æ‰€ä»¥å°±æƒ³åŠæ³•æ„é€ äºŒåˆ†å›¾ï¼Œå³æ„é€ ä¸€ä¸ªå›¾æ²¡æœ‰å¥‡ç¯ã€‚ æ¯ä¸ªäººåªæœ‰ä¸€ä¸ªå›ºå®šçš„æƒ…ä¾£ï¼Œè¿™å¯ç¤ºæˆ‘ä»¬ä¹Ÿè¦æ‰¾ä¸€ç±»è¾¹ï¼Œä½¿å¾—æ¯ä¸ªç‚¹åªæœ‰ä¸€ä¸ªè¿™æ ·çš„å‡ºè¾¹ï¼Œè¿™æ ·ä¸€å®šæ˜¯å¶ç¯ï¼ˆä¸¤ç±»è¾¹äº¤æ›¿ï¼‰ã€‚ å®¹æ˜“å‘ç°è®© \\(2i-1\\) å’Œ \\(2i\\) è¿è¾¹å³å¯ä¿è¯ç›¸é‚»ä¸‰ä¸ªé¢œè‰²ä¸éƒ½ç›¸åŒï¼Œä¸”ç¬¦åˆä¸Šè¿°æ„é€ è¦æ±‚ã€‚äºŒåˆ†å›¾æŸ“è‰²ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125; #define N 200007#define pb push_backint ty[N], a[N], b[N];vector&lt;int&gt; e[N];void dfs(int u) &#123; for (auto v : e[u]) if (!ty[v])&#123;ty[v] = 3 - ty[u]; dfs(v);&#125;&#125;int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; a[i] = rd(); b[i] = rd(); e[a[i]].pb(b[i]); e[b[i]].pb(a[i]); int u = i * 2, v = i * 2 - 1; e[u].pb(v); e[v].pb(u); &#125; for (int i = 1; i &lt;= n * 2; ++i) if (!ty[i]) &#123;ty[i] = 1; dfs(i);&#125; for (int i = 1; i &lt;= n; ++i) printf(&quot;%d %d\\n&quot;, ty[a[i]], ty[b[i]]); return 0; &#125; D - Arpaâ€™s letter-marked tree and Mehrdadâ€™s Dokhtar-kosh paths ä¸€æ£µæ ‘æ¯æ¡è¾¹ä¸Šæœ‰ä¸€ä¸ªå­—ç¬¦ (a - v) ï¼Œæ¯æ¬¡è¯¢é—® \\(u_i\\) å­æ ‘å†…æœ€é•¿çš„ç®€å•è·¯å¾„ï¼Œæ»¡è¶³å…¶ä¸Šçš„å­—ç¬¦é‡æ’å¯å½¢æˆå›æ–‡ä¸²ã€‚ \\((u,v)\\) è·¯å¾„ä¿¡æ¯ \\(=u\\) åˆ°æ ¹ä¿¡æ¯ \\(+v\\) åˆ°æ ¹ä¿¡æ¯ \\(-2*lca(u,v)\\) åˆ°æ ¹ä¿¡æ¯ã€‚ å­—ç¬¦é›†åªæœ‰ \\(22\\) ï¼ŒçŠ¶å‹ \\(u\\) åˆ°æ ¹æ¯ä¸ªå­—ç¬¦çš„å¥‡å¶æ€§ \\(s_u\\) ï¼Œè·¯å¾„ä¿¡æ¯å³ä¸º \\(s_u\\oplus s_v\\) ï¼ˆlca ä¿¡æ¯å› ä¸ºå¼‚æˆ–ä¸¤æ¬¡æ¶ˆæ‰äº†ï¼‰ è€ƒè™‘è·¯å¾„åˆå¹¶ï¼Œæ¯ä¸ªç‚¹å¯èƒ½çš„é…å¯¹æ–¹æ¡ˆåªæœ‰ \\(23\\) ç§ï¼ˆå¼‚æˆ–åä¸º \\(0\\) æˆ– \\(2\\) çš„å¹‚æ¬¡ï¼Œå³æœ€å¤šå…è®¸ä¸€ä¸ªå­—ç¬¦å‡ºç°å¥‡æ•°æ¬¡ï¼‰ DSU on Treeï¼Œç»Ÿè®¡æ­¤å‰å­æ ‘çš„ä¿¡æ¯ï¼Œç»´æŠ¤æ¯ä¸ªçŠ¶å‹å€¼çš„æœ€æ·±æ·±åº¦ï¼Œä¿è¯ lca æ˜¯å½“å‰ç‚¹éœ€æ•´ä¸ªå­æ ‘å…ˆæŸ¥è¯¢åæ’å…¥ã€‚ å‘ï¼š1. å­æ ‘å†…æœ€é•¿è¦å’Œå„¿å­çš„ ans å– \\(\\max\\) ï¼›2.æšä¸¾é…å¯¹çš„çŠ¶æ€æ—¶ï¼Œå¾—ä¿è¯å­˜åœ¨å†æ›´æ–°ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;#define pic pair&lt;int, char&gt;#define lowbit(x) ((x) &amp; -(x))#define N 500007int ch[N], sta[N], mxd[1 &lt;&lt; 22], ans[N], res;int sz[N], mxs[N], dep[N];vector&lt;int&gt; son[N];void dfs(int u, int fa, int S) &#123; sz[u] = 1; dep[u] = dep[fa] + 1; if (u != 1) S ^= (1 &lt;&lt; ch[u]); sta[u] = S; for (auto v : son[u]) &#123; dfs(v, u, S); sz[u] += sz[v]; if (sz[v] &gt; sz[mxs[u]]) mxs[u] = v; &#125;&#125;inline void upd(int u) &#123; // adding information of u into data structures mxd[sta[u]] = max(mxd[sta[u]], dep[u]);&#125;inline void del(int u) &#123; // deleting information of u from data structures mxd[sta[u]] = 0; res = 0;&#125;void upd(int u, int fa) &#123; upd(u); for (auto v : son[u]) if (v != fa) upd(v, u);&#125;void del(int u, int fa) &#123; del(u); for (auto v : son[u]) if (v != fa) del(v, u);&#125;void updans(int u, int del) &#123; // æšä¸¾é…å¯¹çš„çŠ¶æ€éœ€è¦ä¿è¯å­˜åœ¨ï¼ï¼ï¼ if (mxd[sta[u]]) res = max(res, dep[u] + mxd[sta[u]] - 2 * del); for (int i = 0; i &lt; 22; ++i) if (mxd[sta[u] ^ (1 &lt;&lt; i)]) res = max(res, dep[u] + mxd[sta[u] ^ (1 &lt;&lt; i)] - 2 * del);&#125;void getans(int u, int del) &#123; updans(u, del); for (auto v : son[u]) getans(v, del);&#125;void dsu(int u, int fa) &#123; for (auto v : son[u]) if (v != fa &amp;&amp; v != mxs[u]) &#123;dsu(v, u); del(v, u);&#125; if (mxs[u]) dsu(mxs[u], u); updans(u, dep[u]); upd(u); for (auto v : son[u]) if (v != fa &amp;&amp; v != mxs[u]) &#123; getans(v, dep[u]); res = max(res, ans[v]); upd(v, u); &#125; ans[u] = res;&#125;int main() &#123; int n = rd(); for (int i = 2; i &lt;= n; ++i) &#123; son[rd()].pb(i); char c = getchar(); while (!isalpha(c)) c = getchar(); ch[i] = (c - &#x27;a&#x27;); &#125; dfs(1, 1, 0); dsu(1, 1); for (int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, ans[i]); return 0;&#125; E - Arpaâ€™s abnormal DNA and Mehrdadâ€™s deep interest","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://blog.gyx.me/categories/Codeforces/"},{"name":"Codeforces Round","slug":"Codeforces/Codeforces-Round","permalink":"http://blog.gyx.me/categories/Codeforces/Codeforces-Round/"}],"tags":[{"name":"Knapsack Problem","slug":"Knapsack-Problem","permalink":"http://blog.gyx.me/tags/Knapsack-Problem/"},{"name":"Constructive Algorithm","slug":"Constructive-Algorithm","permalink":"http://blog.gyx.me/tags/Constructive-Algorithm/"},{"name":"Graphs","slug":"Graphs","permalink":"http://blog.gyx.me/tags/Graphs/"},{"name":"DFS and Similar","slug":"DFS-and-Similar","permalink":"http://blog.gyx.me/tags/DFS-and-Similar/"},{"name":"String Suffix Structures","slug":"String-Suffix-Structures","permalink":"http://blog.gyx.me/tags/String-Suffix-Structures/"}]},{"title":"2022-2023 ICPC Southern and Volga Russian Regional","slug":"official/icpc/22-southern-and-volga-russian","date":"2022-11-28T13:27:07.000Z","updated":"2023-03-20T16:36:24.453Z","comments":true,"path":"official/icpc/22-southern-and-volga-russian/","link":"","permalink":"http://blog.gyx.me/official/icpc/22-southern-and-volga-russian/","excerpt":"","text":"æ¯”èµ›åœ°å€ ï¼šCodeforces Contest 1765 å¾…è¡¥ï¼šCGIJ A - Access Levels å®šä¹‰ \\(S_i\\) ä¸ºå¯ä»¥çœ‹ç¬¬ \\(i\\) ä¸ªæ–‡æ¡£çš„äººçš„é›†åˆï¼Œå¦‚æœ \\(S_i\\subseteq S_j\\) ï¼Œé‚£ä¹ˆ \\(i\\) å’Œ \\(j\\) å¯ä»¥æ”¾åˆ°ä¸€ç»„ã€‚ æœ€å°é“¾è¦†ç›–ï¼Œè½¬æ¢æˆäºŒåˆ†å›¾åŒ¹é…ï¼Œç„¶åæŒ‰ç…§é“¾çš„é¡ºåºä¾æ¬¡æ„é€ å³å¯ã€‚æ³¨æ„éœ€è¦å»é‡ï¼ˆæˆ– \\(S\\) ç›¸åŒçš„å®šåºï¼‰ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;const int maxn=500;int n,m,K,ID[maxn+5],val[maxn+5],ans[maxn+5][maxn+5];char pic[maxn+5][maxn+5];vector&lt;int&gt; e[maxn+5];int ti,vis[maxn+5],who[maxn+5];#define ID(x,y) (((x)&lt;&lt;1)-(y))bool check(int i,int j)&#123; bool fl=true; for (int k=1;k&lt;=n;k++) if (pic[k][i]!=pic[k][j]) &#123;fl=false;break;&#125; if (fl) return i&lt;j; for (int k=1;k&lt;=n;k++) if (pic[k][i]&lt;pic[k][j]) return false; return true;&#125;bool Find(int x)&#123; if (vis[x]==ti) return false; vis[x]=ti; for (auto y:e[x]) if (!who[y] || Find(who[y])) &#123;who[y]=x;return true;&#125; return false;&#125;void DFS(int i)&#123; ID[i]=ID[0];val[i]=++val[0]; if (who[i])&#123; for (int j=1;j&lt;=n;j++) if (pic[j][i]&gt;pic[j][who[i]]) ans[j][ID[0]]=val[i]; DFS(who[i]); &#125; else &#123; for (int j=1;j&lt;=n;j++) if (pic[j][i]==&#x27;1&#x27;) ans[j][ID[0]]=val[i]; &#125;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for (int i=1;i&lt;=n;i++) scanf(&quot;%s&quot;,pic[i]+1); for (int i=1;i&lt;=m;i++) for (int j=1;j&lt;=m;j++) if (check(i,j)) e[j].push_back(i); K=m; for (int i=1;i&lt;=m;i++) ti++,K-=Find(i); ti++; for (int i=1;i&lt;=m;i++) vis[who[i]]=ti; printf(&quot;%d\\n&quot;,K); for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=K;j++) ans[i][j]=1; for (int i=1;i&lt;=m;i++) if (vis[i]&lt;ti) ID[0]++,val[0]=1,DFS(i); for (int i=1;i&lt;=m;i++) printf(&quot;%d&quot;,ID[i]),i&lt;m?putchar(&#x27; &#x27;):puts(&quot;&quot;); for (int i=1;i&lt;=m;i++) printf(&quot;%d&quot;,val[i]),i&lt;m?putchar(&#x27; &#x27;):puts(&quot;&quot;); for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=K;j++) printf(&quot;%d&quot;,ans[i][j]),j&lt;K?putchar(&#x27; &#x27;):puts(&quot;&quot;); return 0;&#125; B - Broken Keyboard ç­¾åˆ°ã€‚ 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 1007char s[N];inline void work() &#123; int n = rd(); scanf(&quot;%s&quot;, s + 1); for (int t = 1, i = 1; i &lt;= n; ++t) &#123; if (t &amp; 1) ++i; else &#123; if (s[i] != s[i + 1]) &#123;puts(&quot;NO&quot;); return;&#125; i += 2; &#125; &#125; puts(&quot;YES&quot;);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; *C - Card Guessing D - Watch the Videos æœ‰ \\(n\\) ä¸ª \\(a_i\\) ï¼Œæ€»ä»·æ ¼æ˜¯ \\(\\sum (a_i+1)\\) ï¼Œå°†ä»–ä»¬æ’åºï¼Œå¦‚æœç›¸é‚»çš„ä¸¤ä¸ª \\(a_i+a_j\\le m\\) ï¼Œç­”æ¡ˆå‡å°‘ \\(1\\) ã€‚é—®ç­”æ¡ˆæœ€å°å¤šå°‘ã€‚ å¾ˆå¥‡æ€ªçš„è´ªå¿ƒé¢˜ã€‚åŒæŒ‡é’ˆç»´æŠ¤ï¼Œå°½é‡ä¿è¯å°çš„æ•°å­—ä¸¤ä¾§éƒ½è¢«ç”¨åˆ°å³å¯ï¼Œå¤§çš„ç»„åˆä¸ä¸Šå°±ä¸ç”¨ç®¡äº†ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 200007int a[N];inline void work() &#123; int n = rd(), m = rd(); for (int i = 1; i &lt;= n; ++i) a[i] = rd(); sort(a + 1, a + 1 + n); ll ans = 0; int l = 1, r = n; for (; l &lt; r; ++l) &#123; while (a[r] + a[l] &gt; m &amp;&amp; r &gt; l) &#123;ans += a[r] + 1; --r;&#125; if (r &gt; l) ans += a[r--]; else break; ans += a[l] + 1; while (a[r] + a[l] &gt; m &amp;&amp; r &gt; l) &#123;ans += a[r] + 1; --r;&#125; if (r &gt; l) --ans; else &#123;++l; break;&#125; &#125; if (l &lt;= r) ans += a[l] + 1; printf(&quot;%lld\\n&quot;, ans);&#125;int main() &#123; work(); return 0;&#125; E - Exchange ç­¾åˆ°ã€‚ 12345678910111213#include&lt;cstdio&gt;using namespace std;int te,A,B,C;int main()&#123; for (scanf(&quot;%d&quot;,&amp;te);te;te--)&#123; scanf(&quot;%d%d%d&quot;,&amp;A,&amp;B,&amp;C); if (B&lt;=C) printf(&quot;%d\\n&quot;,(A+B-1)/B); else puts(&quot;1&quot;); &#125; return 0;&#125; *F - Chemistry Lab å‡è®¾å·²ç»é€‰å¥½äº†æ–¹æ¡ˆï¼Œé‚£ä¹ˆæŒ‰ç…§ \\((x_i,c_i)\\) å»ºç«‹å‡¸åŒ…ï¼Œæƒ³è¦å…‘å‡ºæœ€è´µçš„ç™¾åˆ†æ¯”ä¸º \\(x\\) çš„è¯æ°´ï¼Œä¸€å®šå–åœ¨ä¸Šå‡¸å£³ä¸Šã€‚ ç”±äºå‡åŒ€åˆ†å¸ƒè¿›è¡Œéšæœºï¼Œå› æ­¤ä¸Šå‡¸å£³å’Œ \\(x\\) è½´å¤¹ä½çš„åŒºåŸŸé¢ç§¯å† \\(\\times k\\) å°±æ˜¯ç­”æ¡ˆï¼Œdp ä¸Šå‡¸å£³å³å¯ã€‚ å°†ç‚¹æŒ‰ç…§ \\(x\\) ä»å°åˆ°å¤§æ’åºï¼Œåˆ†æ®µç®—è´¡çŒ®ï¼ˆæ¢¯å½¢é¢ç§¯ï¼‰ï¼Œæ³¨æ„ç¬¬ä¸€æ¬¡é€‰å–ç‰¹æ®Šï¼Œåªæœ‰ä¹°çš„ä»£ä»·ï¼Œæ²¡æœ‰æ”¶ç›Šã€‚ 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 5007struct node &#123;double x, w, c;&#125; sol[N];double f[N], ans;int main() &#123; int n = rd(), k = rd(); for (int i = 1; i &lt;= n; ++i) &#123;sol[i].x = rd(); sol[i].w = rd(); sol[i].c = rd();&#125; sort(sol + 1, sol + 1 + n, [&amp;](const node &amp;a, const node &amp;b)&#123;return a.x &lt; b.x;&#125;); for (int i = 1; i &lt;= n; ++i) &#123; f[i] = -sol[i].w; // the first one for (int j = 1; j &lt; i; ++j) // the previous one is j f[i] = max(f[i], f[j] + (sol[i].c + sol[j].c) * (sol[i].x - sol[j].x) * k / 200.0 - sol[i].w); ans = max(ans, f[i]); &#125; printf(&quot;%.15lf\\n&quot;, ans); return 0;&#125; *G - Guess the String *H - Hospital Queue å°† \\(n\\) ä¸ªäººæ’é˜Ÿï¼Œç¬¬ \\(i\\) ä¸ªäººä¸€å®šè¦ç«™åœ¨å‰ \\(p_i\\) ä¸ªä½ç½®ï¼Œè¿˜æœ‰è‹¥å¹²é™åˆ¶å½¢å¦‚ \\(a_i\\) ç«™åœ¨ \\(b_i\\) ä¹‹å‰ã€‚ ç°åœ¨å¯¹äºæ¯ä¸ªäººè¯¢é—®ï¼Œå¦‚æœåªè¦æ±‚å…¶ä»–äººä½ç½®åˆæ³•ï¼Œè¿™ä¸ªäººèƒ½ç«™åˆ°æœ€é å‰çš„ä½ç½®æ˜¯å“ªé‡Œã€‚ä¿è¯å­˜åœ¨ä¸€ä¸ªåˆæ³•æ–¹æ¡ˆã€‚ å…ˆè€ƒè™‘å¦‚ä½•æ±‚å‡ºä¸€ä¸ªåˆæ³•æ–¹æ¡ˆï¼šç”¨å †ä»£æ›¿é˜Ÿåˆ—è¿›è¡Œæ‹“æ‰‘æ’åºï¼Œ\\(p_i\\) å°çš„ä¼˜å…ˆã€‚ ä½†å¯¹äºæ¯ä¸ªäººæ±‚æœ€ä¼˜æ–¹æ¡ˆæ—¶ï¼Œå¾ˆéš¾æƒ³åŠæ³•ç¡®å®š \\(i\\) çš„ä¼˜å…ˆçº§ã€‚å› æ­¤è€ƒè™‘ä»åå¾€å‰æ”¾ã€‚ å»ºå›¾ \\(b_i\\to a_i\\) ï¼Œç„¶åç”¨å †ä»£æ›¿é˜Ÿåˆ—è¿›è¡Œæ‹“æ‰‘æ’åºï¼Œ\\(p_i\\) å¤§çš„ä¼˜å…ˆï¼Œä»åå¾€å‰æ”¾ã€‚ å¯¹äºè¯¢é—®ç¬¬ \\(i\\) ä¸ªäººï¼Œè€ƒè™‘å¼ºåˆ¶ä¸è®© \\(i\\) è¿›é˜Ÿï¼Œåˆ™æŸä¸ªä½ç½®åˆ«äººéƒ½æ”¾ä¸äº†çš„æ—¶å€™å°±å¿…é¡»æ”¾ \\(i\\) äº†ï¼Œå¤æ‚åº¦ \\(O(n^2\\log n)\\) ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 2007int deg[N], Deg[N], p[N];vector&lt;int&gt; e[N];priority_queue&lt;pii&gt; q;int main() &#123; int n = rd(), m = rd(); for (int i = 1; i &lt;= n; ++i) p[i] = rd(); for (int i = 1; i &lt;= m; ++i) &#123; int a = rd(), b = rd(); ++Deg[a]; e[b].push_back(a); &#125; for (int i = 1; i &lt;= n; ++i) &#123; while (!q.empty()) q.pop(); for (int j = 1; j &lt;= n; ++j) &#123; deg[j] = Deg[j]; if (!deg[j] &amp;&amp; j != i) q.push(&#123;p[j], j&#125;); &#125; int res = n; while (!q.empty()) &#123; int u = q.top().second; q.pop(); if (p[u] &lt; res) break; --res; for (auto v : e[u]) &#123; --deg[v]; if (!deg[v] &amp;&amp; v != i) q.push(&#123;p[v], v&#125;); &#125; &#125; printf(&quot;%d &quot;, res); &#125; return 0;&#125; *I - Infinite Chess *J - Hero to Zero K - Torus Path æ‰‹ç©ä¸€ä¸‹å‘ç°è·¯å¾„ä¸€å®šä¼šæ¼æ‰ä¸€ä¸ªå‰¯å¯¹è§’çº¿ä¸Šçš„æ ¼å­ï¼Œä¸”å¯ä»¥åšåˆ°åªæ¼æ‰ä»»æ„ä¸€ä¸ªï¼Œç­”æ¡ˆå°±æ˜¯å…¨éƒ¨çš„å’Œå‡å»å‰¯å¯¹è§’çº¿æœ€å°å€¼ã€‚ 1234567891011121314151617181920#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn=200;int n;LL ans;int main()&#123; scanf(&quot;%d&quot;,&amp;n); int MIN=2e9; for (int i=1;i&lt;=n;i++) for (int j=1,x;j&lt;=n;j++)&#123; scanf(&quot;%d&quot;,&amp;x); ans+=x; if (i+j==n+1) MIN=min(MIN,x); &#125; printf(&quot;%lld\\n&quot;,ans-MIN); return 0;&#125; L - Project Manager STL å°æ¸…æ–°æ¨¡æ‹Ÿé¢˜ï¼Œæ³¨æ„ä¸€å®šè¦ç»´æŠ¤å‡ºæ¯å¤©ä¸Šç­ä¸”å½“å‰æœ‰ä»»åŠ¡è¦åšçš„é›†åˆï¼Œå¦åˆ™ä¸€å®šå¯ä»¥å¡æ‰ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 200007inline int trans() &#123; static char s[20]; scanf(&quot;%s&quot;, s + 1); if (s[1] == &#x27;M&#x27;) return 0; if (s[1] == &#x27;T&#x27; &amp;&amp; s[2] == &#x27;u&#x27;) return 1; if (s[1] == &#x27;W&#x27;) return 2; if (s[1] == &#x27;T&#x27; &amp;&amp; s[2] == &#x27;h&#x27;) return 3; if (s[1] == &#x27;F&#x27;) return 4; return (s[2] == &#x27;a&#x27; ? 5 : 6);&#125;queue&lt;int&gt; holiday, order[N];vector&lt;int&gt; workday[N];set&lt;int&gt; s[7], add[7], del[7];priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; work[N];vector&lt;pii&gt; addwork;int ans[N];int main() &#123; int n = rd(), m = rd(), k = rd(); for (int i = 1; i &lt;= n; ++i) for (int t = rd(); t; --t) workday[i].push_back(trans()); for (int i = 1; i &lt;= m; ++i) holiday.push(rd()); for (int i = 1; i &lt;= k; ++i) &#123; for (int t = rd(); t; --t) order[i].push(rd()); int u = order[i].front(); order[i].pop(); work[u].push(i); for (auto d : workday[u]) s[d].insert(u); &#125; for (int i = 0, cnt = 1, K = k; K; ++cnt, i = (i == 6 ? 0 : i + 1)) &#123; if (!holiday.empty() &amp;&amp; cnt == holiday.front()) &#123;holiday.pop(); continue;&#125; addwork.clear(); for (int j = 0; j &lt; 7; ++j) &#123;add[j].clear(); del[j].clear();&#125; for (auto x : s[i]) &#123; int id = work[x].top(); work[x].pop(); if (work[x].empty()) for (auto d : workday[x]) del[d].insert(x); if (order[id].empty()) &#123;--K; ans[id] = cnt;&#125; else &#123; int nxt = order[id].front(); order[id].pop(); addwork.push_back(make_pair(nxt, id)); for (auto d : workday[nxt]) add[d].insert(nxt); &#125; &#125; for (int j = 0; j &lt; 7; ++j) for (auto x : del[j]) s[j].erase(x); for (int j = 0; j &lt; 7; ++j) for (auto x : add[j]) s[j].insert(x); for (auto [x, id] : addwork) work[x].push(id); &#125; for (int i = 1; i &lt;= k; ++i) printf(&quot;%d &quot;, ans[i]); return 0;&#125; M - Minimum LCM ç»™å®š \\(n\\) ï¼Œæ‰¾ä¸€å¯¹ \\(a+b=n\\) ï¼Œæœ€å°åŒ– \\(\\text{lcm}(a, b)\\) çŒœæµ‹ \\(a\\) æ˜¯ \\(b\\) çš„å€æ•°æ—¶æœ€ä¼˜ï¼Œæ‰€ä»¥æ£€æŸ¥ \\(n\\) çš„æ‰€æœ‰å› æ•°å³å¯ã€‚ 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 1007char s[N];inline void work() &#123; int n = rd(); int ans = 1e9; int lim = sqrt(n); for (int i = 1; i &lt;= lim; ++i) if (n % i == 0) &#123; if (n / i &gt; 1) ans = min(ans, i * (n / i - 1)); if (i &gt; 1) ans = min(ans, (n / i) * (i - 1)); &#125; printf(&quot;%d %d\\n&quot;, ans, n - ans);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; N - Number Reduction ä¸€ä¸ªå¾ˆé•¿çš„æ•° \\(x\\)ï¼ˆä¿è¯ä»¥é \\(0\\) å¼€å¤´ï¼‰ï¼Œåˆ æ‰æ°å¥½ \\(k\\ (k&lt; \\lfloor \\log_{10} x\\rfloor)\\) ä½ï¼Œä½¿å¾—å‰©ä¸‹çš„æ•°å€¼æœ€å°ï¼Œä¸”æ²¡æœ‰å‰å¯¼é›¶ã€‚ å¦‚æœæ²¡æœ‰ \\(0\\) å°±æ˜¯ä¸€ä¸ªå¸¸è€ƒé¢è¯•é¢˜ï¼Œä»å‰å¾€åæ‰«ï¼Œé‡åˆ° \\(x_i&gt;x_{i+1}\\) å³å‰é¢çš„æ•°ä½æ¯”åé¢å¤§ï¼Œå°±æŠŠå‰é¢çš„åˆ æ‰å³å¯ã€‚ ä½†æ˜¯ \\(0\\) çš„æ•°ä½ä¸€å®šä¸èƒ½åˆ å—ï¼Ÿå½¢å¦‚ \\(x000y....\\) çš„æ•°å­—ï¼Œå¦‚æœ \\(x&gt;y\\) ï¼Œä¸” \\(k\\) è¶³å¤Ÿçš„æ—¶å€™ï¼Œæ˜¯åº”è¯¥æŠŠå‰ç¼€ \\(x000\\) åˆ æ‰çš„ã€‚ æ‰€ä»¥æ¯æ¬¡å½“å‰ä½ç½®é \\(0\\) ä¸”å‰ä¸€ä¸ªä½ç½®æ˜¯ \\(0\\) çš„æ—¶å€™ï¼Œç‰¹åˆ¤ä¸€ä¸‹æ˜¯å¦åº”è¯¥ï¼ˆä¸”èƒ½å¤Ÿï¼‰æŠŠå‰ç¼€åˆ æ‰ã€‚ æœ€åå¤šä½™çš„æ¬¡æ•°ä»åå¾€å‰åˆ å³å¯ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 500007#define pb push_backchar s[N];deque&lt;int&gt; a;inline void work() &#123; a.clear(); scanf(&quot;%s&quot;, s + 1); int n = strlen(s + 1); int k = rd(); a.pb(s[1] - &#x27;0&#x27;); for (int i = 2; i &lt;= n; ++i) &#123; int x = s[i] - &#x27;0&#x27;; if (!k) &#123;a.pb(x); continue;&#125; if (x) &#123; while (!a.empty() &amp;&amp; k &amp;&amp; a.back() &gt; x) &#123;a.pop_back(); --k;&#125; if (!a.empty() &amp;&amp; a.back() == 0 &amp;&amp; k &gt;= a.size() &amp;&amp; x &lt; a.front()) &#123;k -= a.size(); a.clear();&#125; a.push_back(x); &#125; else &#123; while (a.size() &gt; 1 &amp;&amp; k &amp;&amp; a.back() &gt; 0) &#123;a.pop_back(); --k;&#125; a.push_back(x); &#125; &#125; for (; k; --k) a.pop_back(); for (auto x : a) printf(&quot;%d&quot;, x); puts(&quot;&quot;);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125;","categories":[{"name":"Official Contests","slug":"Official-Contests","permalink":"http://blog.gyx.me/categories/Official-Contests/"}],"tags":[{"name":"Greedy","slug":"Greedy","permalink":"http://blog.gyx.me/tags/Greedy/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"},{"name":"STL","slug":"STL","permalink":"http://blog.gyx.me/tags/STL/"},{"name":"Graphs","slug":"Graphs","permalink":"http://blog.gyx.me/tags/Graphs/"},{"name":"Geometry","slug":"Geometry","permalink":"http://blog.gyx.me/tags/Geometry/"}]},{"title":"Circle Inversion","slug":"algorithms/circle-inversion","date":"2022-11-21T02:30:16.000Z","updated":"2023-03-20T16:50:21.790Z","comments":true,"path":"algorithms/circle-inversion/","link":"","permalink":"http://blog.gyx.me/algorithms/circle-inversion/","excerpt":"","text":"Analysis äºŒç»´å¹³é¢ä¸Šï¼Œç»™å®šåæ¼”ä¸­å¿ƒ \\(O\\) å’ŒåŠå¾„ \\(r\\) ï¼Œå®šä¹‰ç‚¹ \\(P\\) åŸºäºåœ† \\((O,r)\\) çš„åæ¼”å˜æ¢ï¼š\\(P\\mapsto P&#39; : |OP||OP&#39;|=r^2\\) ã€‚ åœ†å†…ç‚¹åæ¼”å®Œåœ¨åœ†å¤–ï¼Œåœ†å¤–ç‚¹åæ¼”å®Œåœ¨åœ†å†…ï¼Œåœ†ä¸Šç‚¹æ˜¯åæ¼”å˜æ¢çš„ä¸åŠ¨ç‚¹ã€‚ è¿›ä¸€æ­¥çš„æˆ‘ä»¬å¯ä»¥å®šä¹‰å›¾å½¢åŸºäºåœ† \\(O\\) çš„åæ¼”ï¼ˆå³å˜æ¢åçš„ç‚¹é›†ï¼‰ï¼Œå®¹æ˜“å‘ç°ä¸€äº›ç»“è®ºï¼š ä¸è¿‡ \\(O\\) çš„åœ† \\(\\Leftrightarrow\\) ä¸è¿‡ \\(O\\) çš„åœ†ï¼ˆå…ˆæ±‚å‡ºåœ¨ \\(O\\) ä¸åœ†å¿ƒè¿çº¿ä¸Šç›´å¾„ä¸¤ä¸ªç«¯ç‚¹çš„åæ¼”ç‚¹å†æ¢å¤ï¼Œæ³¨æ„åœ†å¿ƒåæ¼”åä¸æ˜¯åœ†å¿ƒï¼ï¼ï¼‰ è¿‡ \\(O\\) çš„ç›´çº¿ \\(\\Leftrightarrow\\) è¿‡ \\(O\\) çš„ç›´çº¿ï¼ˆä¸”æ˜¯åŒä¸€æ¡ç›´çº¿ï¼Œä¸ä¼šæœ‰å˜åŒ–ï¼‰ è¿‡ \\(O\\) çš„åœ† \\(\\Leftrightarrow\\) ä¸è¿‡ \\(O\\) çš„ç›´çº¿ï¼ˆå…ˆæ±‚å‡º \\(O\\) å¯¹åº”ç›´å¾„çš„å¦ä¸€ä¸ªç«¯ç‚¹çš„åæ¼”ç‚¹ï¼Œå†æ±‚å‚ç›´äº \\(O\\) ä¸åæ¼”ç‚¹è¿çº¿çš„ç›´çº¿ï¼‰ åœ†å†…åŒºåŸŸåæ¼”å®Œä¹‹åæ˜¯åæ¼”ç›´çº¿çš„ä¸åŒ…å« \\(O\\) çš„åŠå¹³é¢ åæ¼”å‰ä¸¤å›¾å½¢çš„ç›¸å¯¹å…³ç³»ï¼Œåæ¼”åä¸å˜ï¼ˆåæ¼”å‰ç›¸åˆ‡ï¼Œåæ¼”åä¹Ÿç›¸åˆ‡ï¼›ç›¸äº¤ç­‰ä»¥æ­¤ç±»æ¨ï¼‰ ç‰¹æ®Šçš„ï¼Œä¸¤åˆ‡äº \\(O\\) çš„åœ†åæ¼”åæ˜¯ä¸¤å¹³è¡Œç›´çº¿ï¼ˆåˆ‡ç‚¹ \\(O\\) åæ¼”ååœ¨æ— ç©·è¿œå¤„ï¼Œå³ä¸¤å¹³è¡Œç›´çº¿äº¤äºæ— ç©·è¿œå¤„ï¼‰ åæ¼”åŠå¾„ä¸€èˆ¬é€‰å–ç‚¹åˆ°ä¸­å¿ƒè·ç¦»çš„å‡ ä½•å¹³å‡ã€‚å®Œæ•´è®¡ç®—å‡ ä½•æ¨¡ç‰ˆè§è¿™é‡Œã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940struct C &#123; P c; double r; C(letp &amp;c = zero, double r = 0.0) : c(c), r(r) &#123;&#125; bool operator == (letc &amp;a) const &#123;return c == a.c &amp;&amp; z(r - a.r);&#125; // ç‚¹ä¸åœ†çš„å…³ç³» : -1 åœ†ä¸Š | 0 åœ†å¤– | 1 åœ†å†… int is_in(letp &amp;p) const &#123;double d = p.dis(c); return z(d - r) ? -1 : d &lt; r - eps;&#125; P inverse(letp &amp;p) const &#123; assert(p != c); const P dlt = p - c; return c + dlt * (r * r / dlt.norm()); &#125; tuple&lt;int, C, L&gt; inverse(letl &amp;l) const &#123; letc null_c = C(zero, 0.0); letl null_l = L(zero, zero); if (l.ori(c) == 0) return mt(2, null_c, l); letp v = (l.ori(c) == 1 ? P&#123;l.v.y, -l.v.x&#125; : P&#123;-l.v.y, l.v.x&#125;); const double d = r * r / l.dis(c); letp p = c + unit(v) * d; return mt(1, C&#123;(c + p) / 2, d / 2&#125;, null_l); &#125; tuple&lt;int, C, L&gt; inverse(letc &amp;a) const &#123; letc null_c = C(zero, 0.0); letl null_l = L(zero, zero); letp v = a.c - c; if (a.is_in(c) == -1) &#123; const double d = r * r / (a.r + a.r); return mt(2, null_c, L&#123;c + unit(v) * d, &#123;-v.y, v.x&#125;&#125;); &#125; if (c == a.c) return mt(1, C&#123;c, r * r / a.r&#125;, null_l); const double dis = abs(v); const double k1 = r * r / (dis - a.r), k2 = r * r / (dis + a.r); const double d = (k1 + k2) / 2, rad = (k1 - k2) / 2; return mt(1, C&#123;c + v * (d / dis), rad&#125;, null_l); &#125;&#125;; CF 77 E - Martian Food ç»™å®šä¸¤ä¸ªå†…åˆ‡çš„åœ†ï¼Œç¬¬ä¸‰ä¸ªåœ†ä½äºä¸¤åœ†å¿ƒè¿çº¿ä¸”ä¸ä¸¤åœ†ç›¸åˆ‡ï¼Œç¬¬å››ä¸ªåœ†å¼€å§‹å’Œå‰ä¸‰ä¸ªåœ†ç›¸åˆ‡ï¼Œä»¥æ­¤ç±»æ¨ã€‚ æ±‚ç¬¬ \\(k\\) ä¸ªåœ†çš„åŠå¾„ã€‚å¤šç»„ \\(t\\le 10^4,r,R\\le 10^4,k\\le 10^4\\) ã€‚ ä»¥ä¸¤åœ†åˆ‡ç‚¹åæ¼”ï¼Œå‰ä¸¤ä¸ªåœ†å˜æˆå¹³è¡Œç›´çº¿ï¼Œåé¢çš„åœ†éƒ½ä¸ä¸¤å¹³è¡Œçº¿ç›¸åˆ‡ï¼Œç¬¬ä¸‰ä¸ªåœ†å¿ƒåæ¼”åä½äºå‰ä¸¤åœ†å¿ƒè¿çº¿ã€‚ ç„¶åæœä¸€ä¾§æ‰¾åˆ°ç¬¬ \\(k\\) ä¸ªåœ†ï¼Œå†åæ¼”å›æ¥å³å¾—åˆ°äº†ç­”æ¡ˆã€‚æ³¨æ„ä¸èƒ½åæ¼”åœ†å¿ƒï¼Œåœ†å¿ƒåæ¼”å®Œä¸æ˜¯åœ†å¿ƒï¼ 12345678inline void work() &#123; static C O = C(zero, 20000); double r1 = rd(), r2 = rd(); L l1 = get&lt;2&gt;(O.inverse(C(P(r1, 0), r1))); L l2 = get&lt;2&gt;(O.inverse(C(P(r2, 0), r2))); C res = C(P((l1.p.x + l2.p.x) / 2, l1.dis(l2) * rd()), l1.dis(l2) / 2); printf(&quot;%.10lf\\n&quot;, get&lt;1&gt;(O.inverse(res)).r);&#125; HDU 6158 - The Designer æ±‚ç±»ä¼¼ä¸Šä¸€é¢˜å›¾çš„å‰ \\(n\\ (n\\le 10^7)\\) ä¸ªåœ†çš„é¢ç§¯å’Œï¼Œå¤šç»„ \\((t\\le 10^3)\\) ã€‚ åˆ¤ä¸€ä¸‹å¦‚æœå‰©ä¸‹çš„åœ†é¢ç§¯å’Œè¶³å¤Ÿå°å°±ä¸ç”¨åšäº†ï¼Œæ³¨æ„ä¸æ˜¯é¢ç§¯è¶³å¤Ÿå°ï¼Œè€Œæ˜¯é¢ç§¯å’Œã€‚ 123456789101112131415inline void work() &#123; static C O = C(zero, 200); double r1 = rd(), r2 = rd(); L l1 = get&lt;2&gt;(O.inverse(C(P(r1, 0), r1))); L l2 = get&lt;2&gt;(O.inverse(C(P(r2, 0), r2))); double dlt = l1.dis(l2); C res = C((l1.p + l2.p) / 2, dlt / 2); double ans = get&lt;1&gt;(O.inverse(res)).area(); for (int i = 1, t = 0, n = rd(); i &lt; n; ++i) &#123; (i &amp; 1) ? ++t, res.c.y = t * dlt : res.c.y = -t * dlt; double add = get&lt;1&gt;(O.inverse(res)).area(); if (add * (n - i) &lt; 1e-7) break; ans += add; &#125; printf(&quot;%.5lf\\n&quot;, ans);&#125; 2017 ICPC Nanning Online - Finding the Radius for an Inserted Circle ä¸‰ä¸ªåŠå¾„ä¸º \\(R\\) çš„åœ†äº’ç›¸åˆ‡ï¼Œåœ¨ä¸­é—´çš„å¼§å½¢è¾¹ä¸‰è§’å½¢ä¸­å¡å°åœ†ï¼Œç„¶åæœç€ä¸€ä¸ªè§’å¡ï¼Œé—®ç¬¬ \\(k\\) ä¸ªçš„åŠå¾„ã€‚ åæ¼”ç‚¹å°±æ˜¯ä¼šå¾€é‚£ä¸ªè§’é‡Œå¡å°åœ†çš„ä¸¤ä¸ªåœ†çš„åˆ‡ç‚¹ã€‚ ä¸‰ä¸ªåœ†å˜æˆä¸€å¯¹å¹³è¡Œç›´çº¿+ä¸€ä¸ªå¤¹ä¸­é—´çš„åœ†ï¼Œç„¶åæœåæ–¹å‘æ‰¾ç¬¬ \\(k\\) ä¸ªåœ†å³å¯ã€‚ 12345678910int ans[11];int main() &#123; int t; double r; scanf(&quot;%d%lf&quot;, &amp;t, &amp;r); C O = C(zero, r * 2); C c = get&lt;1&gt;(O.inverse(C(P(0, -sqrt(3) * r), r))); for (int i = 1; i &lt;= 10; ++i) &#123;c.c.y -= r * 4; ans[i] = floor(get&lt;1&gt;(O.inverse(c)).r + 1e-8);&#125; for (int i = 1, n; i &lt;= t; ++i) &#123;scanf(&quot;%d&quot;, &amp;n); printf(&quot;%d %d\\n&quot;, n, ans[n]);&#125; return 0;&#125; 2013 ICPC Hangzhou - Problem of Apollonius æ±‚è¿‡æŒ‡å®šç‚¹ä¸”ä¸ç»™å®šä¸¤ä¸ªåœ†ç›¸å¤–åˆ‡çš„æ‰€æœ‰çš„åœ†ã€‚ å…³äºæŒ‡å®šç‚¹åæ¼”ï¼Œæ‰€æ±‚ç­”æ¡ˆå°±æ˜¯ä¸¤ä¸ªåœ†çš„å…¬åˆ‡çº¿ã€‚ 12345678910111213inline void work() &#123; C c1; c1.c.x = rd(); c1.c.y = rd(); c1.r = rd(); C c2; c2.c.x = rd(); c2.c.y = rd(); c2.r = rd(); C O; O.c.x = rd(); O.c.y = rd(); O.r = 100; vector&lt;L&gt; s = get&lt;1&gt;(O.inverse(c1)).tangent(get&lt;1&gt;(O.inverse(c2))); vector&lt;C&gt; ans; for (auto x : s) &#123; C inv = get&lt;1&gt;(O.inverse(x)); if (inv.relation(c1) == 1 &amp;&amp; inv.relation(c2) == 1) ans.push_back(inv); &#125; printf(&quot;%d\\n&quot;, (int)ans.size()); for (auto x : ans) printf(&quot;%.10lf %.10lf %.10lf\\n&quot;, x.c.x, x.c.y, x.r);&#125; CF 372 E - Drawing Circles is Fun ç»™å®šäºŒç»´å¹³é¢å†… \\(n\\) ä¸ªç‚¹, å…¶ä¸­ä»»æ„ä¸¤ç‚¹æ‰€åœ¨çš„ç›´çº¿ä¸Šéƒ½ä¸åŒ…å«åŸç‚¹ \\(O\\) ã€‚ æ±‚é›†åˆ \\(\\{\\left(P_1, P_2\\right)\\left(P_3, P_4\\right) \\ldots\\left(P_{2 k-1}, P_{2 k}\\right)\\}\\) çš„ä¸ªæ•°ï¼ˆ\\(P_i\\) å–è‡ªç»™å®šçš„ \\(n\\) ä¸ªç‚¹ï¼‰ï¼Œæ»¡è¶³: ä¸å­˜åœ¨ \\(i \\neq j, P_i=P_j\\). å¯¹äºä»»æ„ \\(i \\neq j,\\left(P_{2 i-1}, P_{2 i}\\right)\\left(P_{2 j-1}, P_{2 j}\\right)\\) æ»¡è¶³ï¼š åœ† \\(O P_{2 i-1} P_{2 j-1}\\) å’Œåœ† \\(O P_{2 i} P_{2 j}\\) åªæœ‰ä¸€ä¸ªäº¤ç‚¹, åœ† \\(O P_{2 i-1} P_{2 j}\\) å’Œåœ† \\(O P_{2 i} P_{2 j-1}\\) åªæœ‰ä¸€ä¸ªäº¤ç‚¹ã€‚ æ‰€æœ‰åœ†éƒ½è¿‡ \\(O\\) ä¸”åªæœ‰ä¸€ä¸ªäº¤ç‚¹ï¼Œæ‰€ä»¥éƒ½ç›¸åˆ‡åœ¨ \\(O\\) ã€‚ åæ¼”ä¹‹åå°±æ˜¯å¹³è¡Œç›´çº¿ï¼Œå³è¦æ±‚ \\(P_{2 i-1} P_{2 j-1}\\parallel P_{2 i} P_{2 j},\\ P_{2 i-1} P_{2 j}\\parallel P_{2 i} P_{2 j-1}\\) ï¼Œå³ \\(P_{2 i-1} P_{2 j-1}P_{2 i} P_{2 j}\\) æ˜¯å¹³è¡Œå››è¾¹å½¢ã€‚ å¹³è¡Œå››è¾¹å½¢çš„ç­‰ä»·æ¡ä»¶æ˜¯å¯¹è§’ä¸­ç‚¹é‡åˆä¸”è¾¹ä¸é‡åˆï¼Œæ¢è¨€ä¹‹ï¼Œè®¡æ•°é€‰å‡ºè‹¥å¹²ç‚¹å¯¹ï¼Œåæ¼”åä¸­ç‚¹é‡åˆåœ¨åŒä¸€ä¸ªç‚¹ï¼Œä¸”ä¸èƒ½é‡åˆã€‚ å¤„ç†å‡ºæ¥ \\(n^2\\) ä¸ªçº¿æ®µçš„ä¸­ç‚¹ã€‚å¯¹æ¯ä¸ªä¸­ç‚¹ï¼Œå¤„ç†å‡ºæ¥åŒè§’åº¦çš„æ¯ä¸ªæ–¹å‘æœ‰å¤šå°‘ä¸ªï¼ˆå³é‡åˆï¼‰ã€‚ ç›¸å½“äº \\(n\\) ä¸ªé›†åˆé‡ŒæŒ‘è‹¥å¹²ä¸ªï¼ˆå¤šäºä¸€ä¸ªï¼‰ï¼Œæ¯ä¸ªé›†åˆé‡Œåªèƒ½æ‹¿è‡³å¤šä¸€ä¸ªçš„æ–¹æ¡ˆæ•°ï¼Œå³ \\(\\prod (size_i+1) - \\sum size_i - 1\\) ã€‚ å‘1ï¼š å®ç°ç”¨ pair(ä¸­ç‚¹ï¼Œæ–¹å‘å‘é‡ï¼‰ä¿å­˜ä¿¡æ¯ï¼Œä¸ºäº†ä¿è¯æ’åºæ­£ç¡®ï¼ˆä¸­ç‚¹ç›¸åŒçš„æŒ¨åœ¨ä¸€èµ·ï¼Œç›¸åŒä¸­ç‚¹æŒ‰ç…§æ–¹å‘æè§’åºï¼‰ï¼Œä¸èƒ½å‡ºç°åå‘çš„æ–¹å‘å‘é‡ï¼ˆå…±çº¿çš„å¿…é¡»åŒä¸€æ–¹å‘ï¼‰ï¼Œæ‰€ä»¥ \\(x\\) ä¸ºè´Ÿçš„æ—¶å€™å–åï¼Œ\\(x=0\\) ä¸” \\(y&lt;0\\) çš„æ—¶å€™å–å ã€‚ å‘2ï¼š ç²¾åº¦è¦æ±‚é«˜ï¼Œåæ ‡èŒƒå›´ \\([\\frac{1}{50},50]\\) ï¼Œåæ¼”åŠå¾„æœ€å¥½å–å‡ ä½•å¹³å‡ \\(1\\) ã€‚ å‘3ï¼š æœ€åå¯¹é›†åˆè¿˜è¦ count ä¸€æ¬¡ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243#define mod 1000000007#define ppp pair&lt;P, P&gt;int main() &#123; int n = rd(); vector&lt;P&gt; p(n); vector&lt;ppp&gt; s; for (int i = 0; i &lt; n; ++i) &#123; double a = rd(), b = rd(), c = rd(), d = rd(); p[i].x = a / b; p[i].y = c / d; p[i] = p[i] / p[i].norm(); &#125; for (int i = 0 ; i &lt; n; ++i) for (int j = i + 1; j &lt; n; ++j) &#123; P u = p[i], v = p[j]; P mid = (u + v) / 2, dir = u - v; if (z(dir.x)) &#123;if (dir.y &lt; 0) dir = -dir;&#125; else if (dir.x &lt; -eps) dir = -dir; s.push_back(mp(mid, dir)); &#125; sort(s.begin(), s.end(), [&amp;](ppp &amp;a, ppp &amp;b) &#123; return (a.fr != b.fr) ? a.fr &lt; b.fr : argcmp()(a.sc, b.sc); &#125;); int ans = 0; vector&lt;int&gt; cnt; auto count = [&amp;]() &#123; int prod = 1, sum = 0; for (auto x : cnt) &#123; prod = 1ll * prod * (x + 1) % mod; sum = (sum + x) % mod; &#125; int res = (prod + mod - sum - 1) % mod; ans = (ans + res) % mod; cnt.clear(); &#125;; for (size_t i = 0; i &lt; s.size(); ++i) if (i &gt; 0 &amp;&amp; s[i].fr == s[i - 1].fr) &#123; if (para(s[i].sc, s[i - 1].sc)) ++cnt.back(); else cnt.push_back(1); &#125; else &#123;count(); cnt.push_back(1);&#125; count(); printf(&quot;%d\\n&quot;, ans); return 0;&#125; 2022 ICPC Hefei F - Rescue ç»™å®š \\(n\\le 10^6\\) ä¸ªåœ†ï¼Œä¿è¯æ‰€æœ‰åœ†éƒ½ç»è¿‡åŸç‚¹ã€‚ é—® \\(n\\) ä¸ªåœ†çš„äº¤æ˜¯å¦ä¸ºç©ºï¼Œè‹¥ä¸ä¸ºç©ºï¼Œåˆ™æ±‚å‡ºäº¤åŒºåŸŸå†…çš„ç‚¹ç¦»åŸç‚¹æœ€è¿œçš„è·ç¦»ã€‚ å…³äºåŸç‚¹åæ¼”ï¼Œæ¯ä¸ªåœ†å°±å˜æˆäº†ä¸€ä¸ªåŠå¹³é¢ï¼Œæ±‚å‡ºæ¥åŠå¹³é¢äº¤ï¼Œé—®é¢˜å˜æˆäº†ç‚¹åˆ°å‡¸åŒ…çš„æœ€è¿‘è·ç¦»ã€‚","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://blog.gyx.me/categories/Algorithms/"}],"tags":[{"name":"Geometry","slug":"Geometry","permalink":"http://blog.gyx.me/tags/Geometry/"}]},{"title":"2017-2018 ICPC Asia Tsukuba Regional","slug":"official/icpc/17-tsukuba","date":"2022-11-16T16:00:00.000Z","updated":"2023-03-20T16:35:40.358Z","comments":true,"path":"official/icpc/17-tsukuba/","link":"","permalink":"http://blog.gyx.me/official/icpc/17-tsukuba/","excerpt":"","text":"æ¯”èµ›åœ°å€ ï¼šCodeforces Gym 101986 è¿˜æ²¡è¡¥å®Œï¼šDK A - Secret of Chocolate Poles é™¤äº†æœ€ä¸‹é¢ä¸€å—é»‘ï¼Œæ¯å—é»‘å’Œä¸‹é¢çš„ç™½ç»„æˆä¸€å—ï¼Œç®€å•è®¡æ•°ã€‚ 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 200007 ll f[N], ans;int main() &#123; int l = rd(), k = rd(); f[1] = f[k] = 1; ++k; for (int i = 3; i &lt;= l; ++i) &#123; f[i] += f[i - 2]; if (i &gt; k) f[i] += f[i - k]; &#125; for (int i = 1; i &lt;= l; ++i) ans += f[i]; printf(&quot;%lld\\n&quot;, ans); return 0;&#125; B - Parallel Lines ç»™å®š \\(m\\ (m\\le 16,\\) å¶æ•°\\()\\) ä¸ªç‚¹ï¼Œä¸¤ä¸¤é…å¯¹ï¼Œé—®å¾—åˆ°çš„çº¿æ®µå¹³è¡Œå…³ç³»æœ€å¤šæœ‰å¤šå°‘ç»„ã€‚ æ³¨æ„è¦æ±‚å…¨éƒ¨ç‚¹éƒ½ç”¨ä¸Šï¼Œæ‰€ä»¥æœç´¢ä¸¤ä¸¤é…å¯¹çš„æ–¹æ¡ˆï¼Œå¯ä»¥å˜æˆæ¯æ¬¡ç»™ç¼–å·æœ€å°çš„é‚£ä¸ªç‚¹æ‰¾é…å¯¹ç‚¹ï¼Œå¤æ‚åº¦å˜æˆ \\(\\mathcal{O}((m-1)!!)\\) ã€‚ ç„¶åæ•°ç›¸åŒçš„æ–¹å‘å‘é‡çš„ä¸ªæ•°ï¼Œå¯¹æ¯ä¸ªæ–¹å‘å‘é‡ç»´æŠ¤ä¸€ä¸ªè®¡æ•°å™¨å³å¯ï¼Œå¤æ‚åº¦ \\(\\mathcal{O}((m-1)!!)\\) ã€‚è®¡ç®—é‡çº¦ä¸º \\(2\\times 10^6\\) ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 17#define M 1007 #define fr first#define sc secondmap&lt;pii, int&gt; f;int gcd(int a, int b) &#123;return b ? gcd(b, a % b) : a;&#125;pii operator - (const pii &amp;a, const pii &amp;b) &#123;return &#123;a.fr - b.fr, a.sc - b.sc&#125;;&#125;pii operator / (const pii &amp;a, const int &amp;k) &#123;return &#123;a.fr / k, a.sc / k&#125;;&#125;pii a[N];bool vis[N];int s[N][N], cnt[M];int n, idcnt, ans, res;inline int c2(int x) &#123;return x * (x - 1) / 2;&#125;inline void add(int x) &#123;res -= c2(cnt[x]); ++cnt[x]; res += c2(cnt[x]);&#125;inline void del(int x) &#123;res -= c2(cnt[x]); --cnt[x]; res += c2(cnt[x]);&#125;// (m - 1)!! = 2027025 void dfs(int p) &#123; if (p == n / 2) &#123;ans = max(ans, res); return;&#125; int A = 0; for (int i = 1; i &lt;= n; ++i) if (!vis[i]) &#123;vis[i] = true; A = i; break;&#125; for (int i = A + 1; i &lt;= n; ++i) if (!vis[i]) &#123; vis[i] = true; add(s[A][i]); dfs(p + 1); vis[i] = false; del(s[A][i]); &#125; vis[A] = false;&#125;int main() &#123; n = rd(); for (int i = 1; i &lt;= n; ++i) &#123;a[i].fr = rd(); a[i].sc = rd();&#125; for (int i = 1; i &lt;= n; ++i) for (int j = i + 1; j &lt;= n; ++j) &#123; pii tmp = (a[i] &lt; a[j] ? a[j] - a[i] : a[i] - a[j]); tmp = tmp / gcd(abs(tmp.fr), abs(tmp.sc)); if (!f[tmp]) f[tmp] = ++idcnt; s[i][j] = f[tmp]; &#125; dfs(0); printf(&quot;%d\\n&quot;, ans); return 0;&#125; *C - Medical Checkup \\(n\\) ä¸ªäººå»ä¾æ¬¡åšæ£€æŸ¥ï¼Œç¬¬ \\(i\\) ä¸ªäººæ£€æŸ¥æ¯ä¸ªé¡¹ç›®éƒ½éœ€è¦ \\(t_i\\) åˆ†é’Ÿï¼Œå¿…é¡»ä¸¥æ ¼æŒ‰ç…§ \\(1\\dots \\infty\\) çš„é¡ºåºåšæ£€æŸ¥ã€‚ é—® \\(T\\) æ—¶åˆ»æ¯ä¸ªäººéƒ½åœ¨åšæˆ–ç­‰å¾…åšç¬¬å‡ ä¸ªæ£€æŸ¥ã€‚ è§‚å¯Ÿå‘ç°å¯¹äºæ¯ä¸ªäººï¼Œä»ä»–å‰é¢çš„ \\(\\max t_i\\) é‚£ä¸ªäººå¼€å§‹ï¼Œåšæ£€æŸ¥çš„æ—¶é—´æ˜¯è¿ç»­çš„æ²¡æœ‰é—´éš”äº†ã€‚ å¯ä»¥å½“ä½œä» \\(\\arg\\max t_i\\) å¼€å§‹çš„ç«è½¦ï¼Œæ¯èŠ‚é•¿åº¦ä¸º \\(t_i\\) ï¼Œä»æŸæ—¶åˆ»è¿›å…¥ä¸€ä¸ªéš§é“æ¯ç§’å‰è¿›ä¸€ï¼Œéš§é“æ¯ \\(\\max t_i\\) ä¸€ä¸ªå…³å¡ã€‚ æ¢å¥è¯è¯´ï¼Œé™¤äº†ç¬¬ä¸€ä¸ªæ£€æŸ¥ï¼Œåé¢çš„æ¯ä¸ªæ£€æŸ¥éƒ½éœ€è¦ \\(\\max t_i\\) çš„æ—¶é—´è¿›è¡Œï¼Œæ‰€ä»¥ç­”æ¡ˆå°±æ˜¯ \\(\\displaystyle \\lfloor\\frac{T - \\sum_{j=1}^i t_j}{\\max t_i}\\rfloor + 2\\) ã€‚ 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;int main() &#123; int n = rd(), t = rd(), mx = 0; for (int i = 1; i &lt;= n; ++i) &#123; int nw = rd(); mx = max(mx, nw); if (t &gt;= 0) t -= nw; // t is the starting time of the second check printf(&quot;%d\\n&quot;, t &lt; 0 ? 1 : t / mx + 2); &#125; return 0;&#125; *E - Black or White ç»™ä¸¤ä¸ªé•¿åº¦ä¸º \\(n\\) çš„ \\(01\\) åºåˆ— \\(S,T\\) ï¼Œæ¯æ¬¡å¯ä»¥æŠŠç¬¬ä¸€ä¸ªåºåˆ—è¿ç»­è‡³å¤š \\(k\\) ä¸ªä½ç½®åˆ·æˆ \\(0\\) æˆ– \\(1\\) ã€‚ é—®æŠŠç¬¬ä¸€ä¸ªåºåˆ—æ”¹æˆç¬¬äºŒä¸ªæœ€å°‘æ“ä½œå¤šå°‘æ¬¡ã€‚ è®¾ \\(f[i]\\) è¡¨ç¤ºæŠŠå‰ \\(i\\) ä¸ªåˆ·æˆæ­£ç¡®çš„æœ€å°æ“ä½œæ¬¡æ•°ã€‚ \\(S[i]=T[i],\\ f[i] \\leftarrow f[i - 1]\\) æšä¸¾åˆ· \\(i\\) çš„é‚£ä¸€åˆ·æ˜¯ä»ç¬¬ \\(j\\) ä¸ªå¼€å§‹çš„ï¼Œ\\(f[i]\\leftarrow \\min\\{f[j]+cost(j+1,i)\\}\\) è€ƒè™‘æŠŠä¸€ä¸ªé•¿åº¦ä¸è¶…è¿‡ \\(k\\) çš„åºåˆ—åˆ·å‡ºæ¥çš„æœ€å°ä»£ä»·ï¼Œå‘ç°æ˜¯æ¯æ¬¡æŠŠå·¦å³ä¸¤ä¸ªä¸€èµ·åˆ·ï¼Œä»£ä»·å³ æ®µæ•° \\(/2 + 1\\) ã€‚ \\(f[i] = f[j] + (sum[i] - sum[j + 1] + 1) / 2 + 1\\) æŒ‰ç…§ \\(2 * f[j] - sum[j + 1]\\) å†³ç­–å•è°ƒæ€§ï¼Œå•è°ƒé˜Ÿåˆ—ä¼˜åŒ–ä¸€ä¸‹ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 500007char s[N], t[N];int sum[N], f[N];deque&lt;int&gt; pos;int main() &#123; pos.push_back(0); int n = rd(), m = rd(); scanf(&quot;%s&quot;, s + 1); scanf(&quot;%s&quot;, t + 1); for (int i = 1; i &lt;= n; ++i) sum[i] = sum[i - 1] + (t[i] != t[i - 1]); // the number of segments in [l, r] : sum[r] - sum[l + 1] + 1 auto val = [&amp;](int p) &#123;return 2 * f[p] - sum[p + 1];&#125;; for (int i = 1; i &lt;= n; ++i) &#123; if (s[i] == t[i]) f[i] = f[i - 1]; else &#123; while (i - pos.front() &gt; m) pos.pop_front(); f[i] = f[pos.front()] + (sum[i] - sum[pos.front() + 1] + 1) / 2 + 1; &#125; while (!pos.empty() &amp;&amp; val(pos.back()) &gt;= val(i)) pos.pop_back(); pos.push_back(i); &#125; printf(&quot;%d\\n&quot;, f[n]); return 0;&#125; *F - Pizza Delivery ç»™å®šä¸€å¼ æœ‰å‘å›¾ï¼Œé—®æŠŠæ¯æ¡è¾¹ç¿»è½¬åï¼ˆä¸´æ—¶ä¿®æ”¹ï¼‰ï¼Œ\\(1\\) åˆ° \\(2\\) æœ€çŸ­è·¯æ˜¯å¦å˜é•¿ / ä¸å˜ / å˜çŸ­ã€‚ åŸå›¾è·‘å‡ºæ¥ \\(1\\) çš„å•æºæœ€çŸ­è·¯ \\(dis[1][u]\\) ï¼Œåå›¾è·‘å‡ºæ¥ \\(2\\) çš„å•æºæœ€çŸ­è·¯ \\(dis[2][u]\\) ã€‚ åŸå›¾æœ€çŸ­è·¯æ˜¯ \\(dis[1][2]\\) ï¼Œç¿»è½¬ \\((u\\to v,w)\\) åç»è¿‡è¿™æ¡è¾¹çš„æœ€çŸ­è·¯æ˜¯ \\(dis[1][v] + dis[2][u] + w\\) ã€‚ å˜çŸ­å¯ä»¥ç›´æ¥åˆ¤æ–­ã€‚ç„¶åå¦‚æœä¸æ˜¯æ‰€æœ‰æœ€çŸ­è·¯éƒ½å¿…é¡»ç»è¿‡åŸæ¥çš„ \\((u\\to v,w)\\) ï¼Œé‚£ä¹ˆæœ€çŸ­è·¯ä¸å˜ï¼Œå¦åˆ™æ˜¯å˜é•¿ã€‚ æ±‚æœ€çŸ­è·¯åŒæ—¶æ±‚å‡º \\(cnt[1][u]\\) è¡¨ç¤ºåŸå›¾ \\(1\\) åˆ° \\(u\\) çš„æœ€çŸ­è·¯æ¡æ•°ï¼Œ\\(cnt[2][u]\\) è¡¨ç¤ºåå›¾ \\(2\\) åˆ° \\(u\\) çš„æœ€çŸ­è·¯æ¡æ•°ã€‚ åˆ¤æ–­æœ€çŸ­è·¯å¿…ç»è¾¹å¯ä»¥å“ˆå¸Œï¼ˆå–æ¨¡ï¼‰æœ€çŸ­è·¯è®¡æ•°ã€‚æœ€çŸ­è·¯å¿…ç»è¾¹çš„æ¡ä»¶ï¼š åœ¨æœ€çŸ­è·¯ä¸Šï¼š \\(dis[1][u]+dis[2][v] + w == dis[1][2]\\) æ‰€æœ‰æœ€çŸ­è·¯éƒ½ç»è¿‡ï¼š\\(cnt[1][u]\\times cnt[2][v] \\equiv cnt[1][2]\\pmod {a\\ prime\\ number}\\) æœ€åè€ƒè™‘ä¸€ä¸‹å¤šæ¡å®Œå…¨ç›¸åŒä¸”åœ¨æœ€çŸ­è·¯ä¸Šçš„é‡è¾¹æ˜¯å¦ä¼šæœ‰é—®é¢˜ï¼ˆå³è®¤ä¸ºæ¯æ¡éƒ½æ˜¯å¿…ç»è¾¹ï¼‰ï¼Ÿ ç­”æ¡ˆæ˜¯ä¸ä¼šæœ‰é—®é¢˜ï¼Œå› ä¸ºæœ€çŸ­è·¯æ¡æ•°æ˜¯ \\(cnt[1][u]\\times cnt[2][v]\\times k\\) ï¼Œå¯ä»¥ç†è§£ä¸ºä¹˜æ³•åŸç†ã€‚ updï¼šå½“ç„¶ç¬¬äºŒé—®ä¹Ÿå¯ä»¥åªä¿ç•™ \\(1\\) åˆ° \\(2\\) æœ€çŸ­è·¯ä¸­çš„è¾¹ï¼Œç„¶åå»ºå›¾æ±‚æ¡¥ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;template&lt;typename T&gt;inline bool getmin(T &amp;a, T b) &#123;return a &gt; b ? (a = b, true) : false;&#125;#define mp make_pair#define N 100007int n, m, tot, hd[N], hdr[N];struct edge&#123;int to, nxt, w;&#125; e[N &lt;&lt; 1];void add(int u, int v, int w) &#123; e[++tot] = &#123;v, hd[u], w&#125;; hd[u] = tot; e[++tot] = &#123;u, hdr[v], w&#125;; hdr[v] = tot;&#125;#define mod 1000000007inline void add(int &amp;a, int b) &#123;a = (a + b &gt;= mod ? a + b - mod : a + b);&#125;bool use[N];int cnt[2][N];ll dis[2][N];typedef pair&lt;ll, int&gt; cur;priority_queue&lt;cur, vector&lt;cur&gt;, greater&lt;cur&gt;&gt; q;inline void dij(int u, int *h, int id) &#123; memset(use, 0, sizeof(use)); dis[id][u] = 0; cnt[id][u] = 1; q.push(mp(0, u)); while (!q.empty()) &#123; int u = q.top().second; q.pop(); if (use[u]) continue; use[u] = true; for (int i = h[u], v; i; i = e[i].nxt) if (getmin(dis[id][v = e[i].to], dis[id][u] + e[i].w)) &#123; cnt[id][v] = cnt[id][u]; q.push(mp(dis[id][v], v)); &#125; else if (dis[id][v] == dis[id][u] + e[i].w) add(cnt[id][v], cnt[id][u]); &#125;&#125; int main() &#123; int n = rd(), m = rd(); for (int i = 1; i &lt;= m; ++i) &#123; int u = rd(), v = rd(), w = rd(); add(u, v, w); &#125; memset(dis, 0x3f, sizeof(dis)); dij(1, hd, 0); dij(2, hdr, 1); ll mnd = dis[0][2]; for (int i = 1; i &lt;= m; ++i) &#123; int u = e[i * 2].to, v = e[i * 2 - 1].to, w = e[i * 2].w; if (dis[0][v] + dis[1][u] + w &lt; mnd) puts(&quot;HAPPY&quot;); else if (dis[0][u] + dis[1][v] + w == mnd &amp;&amp; 1ll * cnt[0][u] * cnt[1][v] % mod == cnt[0][2]) puts(&quot;SAD&quot;); else puts(&quot;SOSO&quot;); &#125; return 0;&#125; UPDï¼šçœ‹äº†ä¸‹ jiangly çš„ä»£ç ï¼Œå‘ç°äº†ä¸€ä¸ªç¥å¥‡çš„æ–¹æ³•æ±‚æœ€çŸ­è·¯å¿…ç»è¾¹ï¼Œå°è¯•æè¿°ä¸€ä¸‹åŸç†ï¼š å¯¹äºæœ€çŸ­è·¯å›¾ä¸Šçš„æ¯æ¡è¾¹å·®åˆ†ï¼Œèµ·ç‚¹ç‚¹æƒ \\(+1\\) ï¼Œç»ˆç‚¹ç‚¹æƒ \\(-1\\) ï¼Œç„¶åæŒ‰ç…§ Dijkstra çš„é¡ºåºæ±‚å‰ç¼€å’Œã€‚ é‚£ä¹ˆå¦‚æœä¸€æ¡è¾¹ \\((u,v,w)\\) åœ¨ \\(1\\) åˆ° \\(2\\) æœ€çŸ­è·¯ä¸Š ä¸” \\(val[u]=1\\) ï¼Œé‚£ä¹ˆè¿™æ¡è¾¹æ˜¯æœ€çŸ­è·¯å¿…ç»è¾¹ã€‚ \\(val[u]\\) çš„å«ä¹‰æ˜¯åªè€ƒè™‘ Dijkstra é¡ºåºä¸­åœ¨ \\(u\\) ä¹‹å‰çš„æ‰€æœ‰ç‚¹ï¼Œå»¶ä¼¸å‡ºçš„æœ€çŸ­è·¯å½“å‰æ”¶æ•›åˆ°äº†å¤šå°‘æ¡ã€‚ ä¹Ÿå°±æ˜¯å½“å‰æœ€çŸ­è·¯èƒ½èµ°å°±èµ°ï¼Œåªèµ° Dijkstra é¡ºåºä¸­åœ¨ \\(u\\) ä¹‹å‰çš„ç‚¹ï¼Œç„¶åæœ€ç»ˆæœ‰å¤šå°‘æ¡è¾¹å¯ä»¥ç»§ç»­å¾€ä¸‹èµ°ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;template&lt;typename T&gt;inline bool getmin(T &amp;a, T b) &#123;return a &gt; b ? (a = b, true) : false;&#125;#define mp make_pair#define N 100007int n, m, tot, hd[N], hdr[N];struct edge&#123;int to, nxt, w;&#125; e[N &lt;&lt; 1];void add(int u, int v, int w) &#123; e[++tot] = &#123;v, hd[u], w&#125;; hd[u] = tot; e[++tot] = &#123;u, hdr[v], w&#125;; hdr[v] = tot;&#125;bool use[N];int pos[N], sum[N];ll dis[2][N];typedef pair&lt;ll, int&gt; cur;priority_queue&lt;cur, vector&lt;cur&gt;, greater&lt;cur&gt;&gt; q;inline void dij(int u, int *h, int id) &#123; memset(use, 0, sizeof(use)); dis[id][u] = 0; q.push(mp(0, u)); while (!q.empty()) &#123; int u = q.top().second; q.pop(); if (use[u]) continue; use[u] = true; if (!id) pos[u] = ++pos[0]; for (int i = h[u], v; i; i = e[i].nxt) if (getmin(dis[id][v = e[i].to], dis[id][u] + e[i].w)) q.push(mp(dis[id][v], v)); &#125;&#125; int main() &#123; int n = rd(), m = rd(); for (int i = 1; i &lt;= m; ++i) &#123; int u = rd(), v = rd(), w = rd(); add(u, v, w); &#125; memset(dis, 0x3f, sizeof(dis)); dij(1, hd, 0); dij(2, hdr, 1); ll mnd = dis[0][2]; for (int u = 1; u &lt;= n; ++u) for (int i = hd[u], v; i; i = e[i].nxt) if (dis[0][u] + e[i].w + dis[1][v = e[i].to] == mnd) &#123;++sum[pos[u]]; --sum[pos[v]];&#125; for (int i = 1; i &lt;= n; ++i) sum[i] += sum[i - 1]; for (int i = 1; i &lt;= m; ++i) &#123; int u = e[i * 2].to, v = e[i * 2 - 1].to, w = e[i * 2].w; if (dis[0][v] + dis[1][u] + w &lt; mnd) puts(&quot;HAPPY&quot;); else if (dis[0][u] + dis[1][v] + w == mnd &amp;&amp; sum[pos[u]] == 1) puts(&quot;SAD&quot;); else puts(&quot;SOSO&quot;); &#125; return 0;&#125; G - Rendezvous on a Tetrahedron ä¸¤åªèš‚èšä»æ­£å››é¢ä½“ä¸€ä¸ªé¡¶ç‚¹å¼€å§‹çˆ¬ï¼Œç»™å®šåˆå§‹é¢ã€æ–¹å‘ã€é•¿åº¦ã€‚ çˆ¬è¡Œè·¯å¾„è¿‡ç¨‹ä¸­ä¿è¯å’Œè¾¹è§’åº¦ä¸å˜ï¼Œä¿è¯é™¤äº†å¼€å§‹ä¸ä¼šç»è¿‡ä»»ä½•é¡¶ç‚¹ã€‚é—®æœ€åä¸¤åªèš‚èšæ˜¯å¦åœ¨åŒä¸€ä¸ªé¢ã€‚ è§’åº¦ä¸å˜ç›¸å½“äºåœ¨å››é¢ä½“å±•å¼€çš„å›¾å½¢ä¸Šèµ°ç›´çº¿ï¼Œæ¨¡æ‹Ÿå³å¯ã€‚æ¯æ¬¡æ–°èµ°åˆ°çš„é¢éƒ½å¯ä»¥ç”¨ä¸Šä¸€ä¸ªé¢çš„ä¸‰ä¸ªç‚¹åˆ¤æ–­å¾—å‡ºã€‚ è®¨è®ºæ¯”è¾ƒç¹çï¼Œè§£ä¸‰è§’å½¢éœ€è¦çµæ´»è¿ç”¨ä¸€ä¸‹ä¸‰è§’å‡½æ•°å…¬å¼ã€‚\\([0,\\pi]\\) æ±‚è§’åº¦ç”¨ \\(\\arccos\\) ä¸è¦ç”¨ \\(\\arcsin\\) ã€‚ æ„Ÿè§‰ä¸‰è§’å‡½æ•°é€’å½’å¥—èµ·æ¥ç²¾åº¦ç‚¸é£äº†ã€‚ä¸çŸ¥é“æ€ä¹ˆè¿‡çš„ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;const double pi = 3.141592653589793;const double sin60 = sqrt(3) / 2.0;// A = 0 | B = 1 | C = 2 | D = 3 || sum = 6vector&lt;int&gt; simulate(int x, int y, int tar, double pos, double ang, double rem) &#123; //printf(&quot;%d %d %d %.3lf %.3lf %.3lf\\n&quot;, x, y, tar, pos, ang, rem); double angtar = acos((2 * pos - 1) / 2.0 / sqrt(pos * pos + 1 - pos)); if (ang &lt; angtar) &#123; double len = pos * sin60 / sin(pi * 2 / 3 - ang); if (rem &lt;= len) return vector&lt;int&gt;&#123;x, y, tar&#125;; return simulate(x, tar, 6 - x - y - tar, sin(ang) / sin(pi * 2 / 3 - ang) * pos, pi / 3 + ang, rem - len); &#125; else &#123; double len = (1 - pos) * sin60 / sin(ang - pi / 3); if (rem &lt;= len) return vector&lt;int&gt;&#123;x, y, tar&#125;; return simulate(tar, y, 6 - x - y - tar, 1 - sin(ang) / sin(ang - pi / 3) * (1 - pos), ang - pi / 3, rem - len); &#125;&#125;int main() &#123; auto rdv = [&amp;]() &#123; char c = getchar(); while (!isalpha(c)) c = getchar(); return c - &#x27;A&#x27;; &#125;; auto getpos = [&amp;]() &#123; int x = rdv(), y = rdv(); double ang = rd() * pi / 180, l = rd(); double step1 = sin60 / sin(pi * 2 / 3 - ang); // The Law of Sines if (step1 &gt;= l) return vector&lt;int&gt;&#123;0, x, y&#125;; else return simulate(x, y, 6 - x - y, sin(ang) / sin(pi * 2 / 3 - ang), pi / 3 + ang, l - step1); &#125;; vector&lt;int&gt; pos1 = getpos(); sort(pos1.begin(), pos1.end()); vector&lt;int&gt; pos2 = getpos(); sort(pos2.begin(), pos2.end()); puts(pos1 == pos2 ? &quot;YES&quot; : &quot;NO&quot;); return 0;&#125; *H - Homework \\(n\\) ä¸ªä½œä¸šï¼Œæ¯ä¸ªä½œä¸šæœ‰é‡Šæ”¾æ—¶é—´ \\(r_i\\) æˆªæ­¢æ—¶é—´ \\(d_i\\) ç§ç±» \\(A/B\\) ã€‚ æ¯å¤© \\(x\\) å…ˆé€‰æ‹©ä¸€ä¸ªç±»åˆ«ï¼Œç„¶åå¦‚æœè¯¥ç±»è¿˜æœ‰æ²¡å®Œæˆä¸”å¯ä»¥å®Œæˆçš„ä»»åŠ¡ï¼ˆ \\(x\\in [r_i,d_i]\\) ï¼‰ï¼Œé‚£ä¹ˆåšæ‰ \\(d_i\\) æœ€å°ä¸”ç¼–å·æœ€å°çš„ã€‚ é—®æœ€å¤š / æœ€å°‘èƒ½å®Œæˆå¤šå°‘ä¸ªä½œä¸šã€‚ æ³¨æ„åˆ° â€œåšæ‰ \\(d_i\\) æœ€å°ä¸”ç¼–å·æœ€å°çš„â€ æ˜¯æ­£ç¡®çš„è´ªå¿ƒç»“æ„ï¼ˆæ˜¯éšä¾¿é€‰çš„æ–¹æ¡ˆé‡Œçš„æœ€ä¼˜è§£ï¼‰ã€‚ æœ€å¤šå°±æ˜¯åšä¸€ä¸ªäºŒåˆ†å›¾åŒ¹é…ã€‚æ¯å¤© \\(x\\) å¯ä»¥åŒ¹é… \\(x\\in [r_i,d_i]\\) çš„æ‰€æœ‰ \\(i\\) ã€‚ æœ€å°‘è€ƒè™‘å¼€æ‘†çš„ç­–ç•¥ï¼šå¦‚æœé‚£å¤©å­˜åœ¨ä¸€ç±»ä½œä¸šå½“å¤©éƒ½åšå®Œäº†ï¼Œé‚£æˆ‘è‡ªç„¶é€‰æ‹©è¿™ä¸€ç±»ä»»åŠ¡ï¼›å¦åˆ™å°±æ˜¯æŒ‘æŸä¸€ç±»åšæ‰ä¸€ä¸ªã€‚ ç”¨æœ€å°å‰²æè¿°è¿™ä¸ªè´ªå¿ƒï¼Œå‰²çš„å«ä¹‰å°±æ˜¯å®Œæˆè¿™ä¸ªä»»åŠ¡ï¼š æ¯å¤©æœ€å¤šå®Œæˆä¸€ä¸ªä½œä¸šï¼Œæ‹†ç‚¹ \\((x_l\\to x_r,1)\\) ã€‚ æ¯ä¸ª \\(A\\) ç±»ä»»åŠ¡ï¼š\\((S\\to task_i, 1);\\ \\forall x\\in [r_i,d_i],(task_i\\to x_l,1)\\) æ¯ä¸ª \\(B\\) ç±»ä»»åŠ¡ï¼š\\(\\forall x\\in [r_i,d_i],(x_r\\to task_i,1);\\ (task_i\\to T, 1)\\) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;inline bool getmin(int &amp;a, int b) &#123;return (a &gt; b ? (a = b, true) : false);&#125;inline bool getmax(int &amp;a, int b) &#123;return (a &lt; b ? (a = b, true) : false);&#125; // F is the type of flowtemplate&lt;const int V, const int E, class F, const F flowInf&gt;struct Flow &#123; int tot = 1, S, T, hd[V], cur[V], dis[V]; struct edge&#123;int to, nxt; F cap;&#125; e[E &lt;&lt; 1]; void clear() &#123;tot = 1; memset(hd, 0, sizeof(hd));&#125; void add(int u, int v, F w) &#123; e[++tot].nxt = hd[u], hd[u] = tot, e[tot].to = v, e[tot].cap = w; e[++tot].nxt = hd[v], hd[v] = tot, e[tot].to = u, e[tot].cap = 0; &#125; inline bool bfs() &#123; static int q[V], qhd, qtl; memcpy(cur, hd, sizeof(hd)); memset(dis, -1, sizeof(dis)); q[qhd = qtl = 1] = S; dis[S] = 0; while (qhd &lt;= qtl) &#123; int u = q[qhd++]; for (int i = hd[u], v; i; i = e[i].nxt) if (dis[v = e[i].to] == -1 &amp;&amp; e[i].cap != 0) &#123; dis[v] = dis[u] + 1; q[++qtl] = v; &#125; &#125; return dis[T] != -1; &#125; F dfs(int u, F rem) &#123; if (u == T) return rem; F flow = 0; for (int i = cur[u], v; i &amp;&amp; rem; i = e[i].nxt) &#123; cur[u] = i; v = e[i].to; F nw = min(rem, e[i].cap); if (nw != 0 &amp;&amp; dis[v] == dis[u] + 1) &#123; int ret = dfs(v, nw); flow += ret; rem -= ret; e[i].cap -= ret; e[i ^ 1].cap += ret; &#125; &#125; if (flow == 0) dis[u] = -1; return flow; &#125; F dinic(int source, int sink) &#123; S = source; T = sink; F flow = 0; while (bfs()) flow += dfs(S, flowInf); return flow; &#125;&#125;;#define N 1207#define M 1000007Flow&lt;N, M, int, 1000000000&gt; f;int l[N], r[N];int main() &#123; int n = rd(), m = rd(); int S = N - 1, T = N - 2; for (int i = 1; i &lt;= 400; ++i) f.add(S, i, 1); for (int i = 1; i &lt;= n; ++i) &#123; l[i] = rd(); r[i] = rd(); f.add(400 + i, T, 1); for (int j = l[i]; j &lt;= r[i]; ++j) f.add(j, 400 + i, 1); &#125; printf(&quot;%d\\n&quot;, f.dinic(S, T)); f.clear(); for (int i = 1; i &lt;= 400; ++i) f.add(i, 400 + i, 1); for (int i = 1; i &lt;= m; ++i) &#123; f.add(S, 800 + i, 1); for (int j = l[i]; j &lt;= r[i]; ++j) f.add(800 + i, j, 1); &#125; for (int i = m + 1; i &lt;= n; ++i) &#123; f.add(800 + i, T, 1); for (int j = l[i]; j &lt;= r[i]; ++j) f.add(400 + j, 800 + i, 1); &#125; printf(&quot;%d\\n&quot;, f.dinic(S, T)); return 0;&#125; UPDï¼š ç½‘ç»œæµæ„Ÿè§‰ç†è®ºå¤æ‚åº¦ä¸å¯¹ï¼Œçœ‹äº†ä¸‹ jiangly çš„ä»£ç æœç„¶æœ‰å¤æ‚åº¦æ­£ç¡®çš„ dp åšæ³•ã€‚ I - Starting a Scenic Railroad Service ç­–ç•¥ 1 å°±æ˜¯å†²çªæœ€å¤§çš„äººçš„å†²çªæ¬¡æ•° \\(+1\\) ï¼Œæ’åºç»´æŠ¤ä¸€ä¸‹å³å¯ï¼›ç­–ç•¥ 2 å°±æ˜¯ä»»æ„æ—¶åˆ»ä¸Šè½¦çš„æœ€å¤šäººæ•°ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;template&lt;typename T&gt;inline bool getmin(T &amp;a, T b) &#123;return a &gt; b ? (a = b, true) : false;&#125;#define N 200007int sum[N];pii s[N];priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; int l = rd(), r = rd() - 1; s[i] = make_pair(l, r); ++sum[l]; --sum[r + 1]; &#125; sort(s + 1, s + 1 + n); int ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; int l = i, r = n; while (!q.empty() &amp;&amp; q.top() &lt; s[i].first) q.pop(); while (l &lt; r) &#123; int mid = (l + r + 1) / 2; s[mid].first &lt;= s[i].second ? l = mid : r = mid - 1; &#125; q.push(s[i].second); ans = max(ans, r - i + (int)q.size()); &#125; printf(&quot;%d &quot;, ans); ans = 0; for (int i = 1; i &lt; N; ++i) &#123;sum[i] += sum[i - 1]; ans = max(ans, sum[i]);&#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125; *J - String Puzzle ä¸€ä¸ªé•¿åº¦ä¸º \\(n\\ (n\\le 10^9)\\) çš„æœªçŸ¥ä¸²ï¼Œç»™å®š \\(a\\) ä¸ªä½ç½®ä¸Šçš„å­—ç¬¦ï¼Œ\\(b\\) ä¸ªä¿¡æ¯ï¼Œ\\(q\\) æ¬¡è¯¢é—®æ˜¯å¦èƒ½çŸ¥é“æŸä¸ªä½ç½®çš„å€¼ã€‚ ä¸€æ¡ä¿¡æ¯ï¼š\\(1\\le h &lt; l\\le r\\le n\\) ï¼Œè¡¨ç¤º \\(S[h,h+(r-l)] = S[l,r]\\) ï¼Œä¸”æ‰€æœ‰ä¿¡æ¯çš„ \\([l,r]\\) æ— äº¤ã€‚ é¦–å…ˆè‚¯å®šæƒ³å…ˆæŠŠæ‰€æœ‰åº”è¯¥ç›¸åŒçš„ä½ç½®éƒ½æ‰¾å‡ºæ¥ï¼Œä½†ä½ç½®å¤ªå¤šäº†ï¼Œå¦‚æœ border å¤ªçŸ­å¯èƒ½æ•´ä¸ªä¸²éƒ½è¦å¤„ç†ã€‚ é‚£ä¹ˆä¸€ä¸ªç»å…¸çš„æ€è·¯å°±æ˜¯æŠŠä¿¡æ¯è®°å½•åœ¨æŸä¸ªç‰¹å®šçš„ä½ç½®ï¼Œæ‰€æœ‰ç­‰ä»·ä½ç½®éƒ½å¯ä»¥æ‰¾åˆ°è¿™ä¸ªä½ç½®ï¼Œç„¶åæ‰“æ ‡è®°/æŸ¥è¯¢ã€‚ ä¸å¦¨æŠŠè¿™ä¸ªä½ç½®å®šä¸ºå¯èƒ½çš„æœ€é å‰çš„ä½ç½®ã€‚é‚£ä¹ˆç”±äº \\([l,r]\\) æ— äº¤ï¼Œæ¯ä¸ªä½ç½®åˆ©ç”¨å“ªæ¡ä¿¡æ¯è·³æ˜¯ç¡®å®šçš„ã€‚ å¯ä»¥å‘ç° \\(S[h,l-1]\\) æ˜¯ \\(S[h,r]\\) å¤©ç„¶çš„ border ï¼Œæˆ‘ä»¬ç›´æ¥æŠŠ \\(p\\in[l,r]\\) è·³åˆ° \\(h+(p-h)\\mod (l-h)\\) ã€‚ å¯ä»¥å‘ç°è¿™æ ·æ¯ä¸ªä¿¡æ¯æœ€å¤šç”¨åˆ°ä¸€æ¬¡ï¼ŒæŸ¥è¯¢æœ€é å‰çš„ç­‰ä»·ä½ç½®å¤æ‚åº¦å°±æ˜¯ \\(O(b)\\) çš„ã€‚æ¨¡æ‹Ÿå³å¯ã€‚ ï¼ˆå½“ç„¶ä¹Ÿå¯ä»¥ç”¨ set ç»´æŠ¤ä¿¡æ¯ï¼Œæ¯æ¬¡ lower_bound æ‰¾åˆ° \\(p\\in[l,r]\\) é‚£ä¸ªä¿¡æ¯ï¼Œä½†æ˜¯å¤æ‚åº¦ä¸ä¼šå˜å¥½å°±æ²¡ç”¨ï¼‰ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 1007pair&lt;int, char&gt; hint[N];int y[N], h[N], tot;struct segpair&#123;int l, r, h;&#125; s[N];map&lt;int, char&gt; f;int main() &#123; int n = rd(), a = rd(), b = rd(), q = rd(); for (int i = 1; i &lt;= a; ++i) &#123; int p = rd(); char c = getchar(); while (!isalpha(c)) c = getchar(); hint[i] = &#123;p, c&#125;; &#125; for (int i = 1; i &lt;= b; ++i) &#123;y[i] = rd(); h[i] = rd();&#125; y[b + 1] = n + 1; for (int i = 1; i &lt;= b; ++i) if (h[i]) s[++tot] = &#123;y[i], y[i + 1] - 1, h[i]&#125;; auto find = [&amp;](int p) &#123; if (!tot) return p; for (int i = tot; i; --i) &#123; if (p &gt; s[i].r) return p; if (p &lt; s[i].l) continue; p = s[i].h + (p - s[i].h) % (s[i].l - s[i].h); &#125; return p; &#125;; for (int i = 1; i &lt;= a; ++i) f[find(hint[i].first)] = hint[i].second; for (int i = 1; i &lt;= q; ++i) &#123; int pos = find(rd()); putchar(f.find(pos) == f.end() ? &#x27;?&#x27; : f[pos]); &#125; return 0;&#125; Um_nik é˜Ÿç”¨äº†ä¸€ä¸ªå¥‡æ€ªçš„ç§‘æŠ€æŠŠæ‰€æœ‰ä¿¡æ¯æ‹†æˆ \\(\\log (r-l)\\) ä¸ª \\([h,h+(r-l)]\\) å’Œ \\([l,r]\\) æ— äº¤çš„ä¿¡æ¯ï¼š è®¾ \\(len = l-h\\) ï¼Œç¬¬ä¸€ç»„ \\([h,h+len-1],[l,l+len-1]\\) ; ç¬¬äºŒç»„å°† \\(len\\) å€é•¿ï¼Œ\\([h,h+2\\times len-1],[l+len,l + 3\\times len - 1]\\) ; ç¬¬ä¸‰ç»„å†å€é•¿ï¼Œä»¥æ¬¡ç±»æ¨ï¼Œç„¶åæœ€åå†å‰©ä¸‹ä¸€å°æ®µã€‚ç®€å•è¯´å°±æ˜¯æŒ‰ç…§ border çš„\\(2^k\\) å€é•¿åˆ’åˆ†ä¸²ã€‚ è¿™æ ·å­æ¯ç»„éƒ½æ²¡æœ‰äº¤äº†ï¼Œæ”¾åˆ°è¿™ä¸ªé¢˜å°±å¯ä»¥ç›´æ¥è·³ã€‚ä¸çŸ¥é“æœ‰å•¥ç”¨ï¼Œç®€å•è®°å½•ä¸€ä¸‹ã€‚","categories":[{"name":"Official Contests","slug":"Official-Contests","permalink":"http://blog.gyx.me/categories/Official-Contests/"}],"tags":[{"name":"Shortest Path","slug":"Shortest-Path","permalink":"http://blog.gyx.me/tags/Shortest-Path/"},{"name":"Geometry","slug":"Geometry","permalink":"http://blog.gyx.me/tags/Geometry/"},{"name":"Flows","slug":"Flows","permalink":"http://blog.gyx.me/tags/Flows/"},{"name":"Tricks","slug":"Tricks","permalink":"http://blog.gyx.me/tags/Tricks/"}]},{"title":"2022-2023 ICPC North Western Russia Regional","slug":"official/icpc/22-northwestern-russia","date":"2022-11-14T16:00:00.000Z","updated":"2023-03-20T16:36:19.623Z","comments":true,"path":"official/icpc/22-northwestern-russia/","link":"","permalink":"http://blog.gyx.me/official/icpc/22-northwestern-russia/","excerpt":"","text":"æ¯”èµ›åœ°å€ ï¼šCodeforces Gym 104012 å¾…è¡¥ï¼šDFGHJM A - Absolutely Flat ç­¾åˆ°é¢˜ã€‚ 123456789101112131415161718#include&lt;bits/stdc++.h&gt;int ii() &#123; int x; scanf(&quot;%d&quot;, &amp;x); return x;&#125;int main() &#123; int a[4]; for (int i = 0; i &lt; 4; ++i) a[i] = ii(); int b = ii(); std::sort(a, a + 4); if (a[0] == a[1] &amp;&amp; a[0] == a[2] &amp;&amp; a[0] == a[3]) puts(&quot;1&quot;); else if (a[0] + b == a[1] &amp;&amp; a[0] + b == a[2] &amp;&amp; a[0] + b == a[3]) puts(&quot;1&quot;); else puts(&quot;0&quot;);&#125; B - Bricks in the Wall ç»™ä¸€ä¸ªçŸ©é˜µç”± # å’Œ . ç»„æˆï¼Œæ‰§è¡Œä¸¤æ¬¡æ“ä½œï¼šåœ¨æŸä¸€è¡Œæˆ–æŸä¸€åˆ—ä¸­é€‰æ‹©ä¸€æ®µè¿ç»­çš„ . ï¼Œå°†å…¶æ”¹ä¸º # ã€‚ æ±‚ä¸¤æ¬¡æ“ä½œèƒ½ä¿®æ”¹çš„æœ€å¤§ . çš„ä¸ªæ•°ã€‚ åˆ†ç±»è®¨è®ºï¼Œä¸¤æ¬¡éƒ½é€‰è¡Œ/åˆ—è‚¯å®šä¸ä¼šå†²çªï¼Œæ‰€ä»¥ç»´æŠ¤æœ€å¤§å’Œæ¬¡å¤§å³å¯ã€‚ å¦‚æœé€‰ä¸€è¡Œä¸€åˆ—ï¼Œäº¤ç‚¹å¤„å¦‚æœæ˜¯ # ä¹Ÿç›´æ¥é€‰æœ€å¤§å’Œæ¬¡å¤§å³å¯ï¼Œå¦åˆ™è¦æšä¸¾æ–­æ‰å“ªä¸ªæ–¹å‘ã€‚ æ¯è¡Œæ¯åˆ—çš„çº¿æ®µå¼€ä¸ª set ç»´æŠ¤å³å¯ã€‚å¤æ‚åº¦ \\(\\mathcal{O}(nm\\log \\max(n,m))\\) ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;bits/stdc++.h&gt;using namespace std;#define N 2000007bool mp[N];int u[N], d[N], l[N], r[N];multiset&lt;int, greater&lt;int&gt; &gt; R[N], C[N];inline void work() &#123; int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); auto p = [&amp;](int x, int y) &#123;return (x - 1) * m + y;&#125;; for (int i = 1; i &lt;= n; ++i) R[i].clear(); for (int j = 1; j &lt;= m; ++j) C[j].clear(); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) &#123; char c = getchar(); while (c != &#x27;.&#x27; &amp;&amp; c != &#x27;#&#x27;) c = getchar(); int pos = p(i, j); mp[pos] = (c == &#x27;#&#x27;); u[pos] = d[pos] = l[pos] = r[pos] = 0; &#125; for (int i = 1; i &lt;= n; ++i) for (int j = 1, pos; j &lt;= m; ++j) if (!mp[pos = p(i, j)]) &#123; u[pos] = (i &gt; 1 ? u[p(i - 1, j)] + 1 : 1); l[pos] = (j &gt; 1 ? l[p(i, j - 1)] + 1 : 1); &#125; for (int i = n; i; --i) for (int j = m, pos; j; --j) if (!mp[pos = p(i, j)]) &#123; d[pos] = (i &lt; n ? d[p(i + 1, j)] + 1 : 1); r[pos] = (j &lt; m ? r[p(i, j + 1)] + 1 : 1); &#125; for (int i = 1, pos; i &lt;= n; ++i) &#123; if (!mp[pos = p(i, 1)]) R[i].insert(r[pos]); for (int j = 1; j &lt; m; ++j) if (mp[p(i, j)] &amp;&amp; !mp[pos = p(i, j + 1)]) R[i].insert(r[pos]); &#125; for (int j = 1, pos; j &lt;= m; ++j) &#123; if (!mp[pos = p(1, j)]) C[j].insert(d[pos]); for (int i = 1; i &lt; n; ++i) if (mp[p(i, j)] &amp;&amp; !mp[pos = p(i + 1, j)]) C[j].insert(d[pos]); &#125; int mx = 0, mxx = 0; auto upd = [&amp;](int x) &#123; if (mx &lt; x) &#123;mxx = mx; mx = x;&#125; else if (mxx &lt; x) mxx = x; &#125;; for (int i = 1; i &lt;= n; ++i) &#123; int sz = R[i].size(); if (sz) upd(*R[i].begin()); if (sz &gt; 1) upd(*++R[i].begin()); &#125; int ans = mx + mxx; mx = mxx = 0; for (int j = 1; j &lt;= m; ++j) &#123; int sz = C[j].size(); if (sz) upd(*C[j].begin()); if (sz &gt; 1) upd(*++C[j].begin()); &#125; ans = max(ans, mx + mxx); for (int i = 1; i &lt;= n; ++i) for (int j = 1, pos; j &lt;= m; ++j) if (!mp[pos = p(i, j)]) ans = max(ans, u[pos] + d[pos] + l[pos] + r[pos] - 2 - min(&#123;u[pos], d[pos], l[pos], r[pos]&#125;)); for (int i = 1; i &lt;= n; ++i) for (int j = 1, pos; j &lt;= m; ++j) &#123; if (!mp[pos = p(i, j)]) &#123; int lr = l[pos] + r[pos] - 1; int ud = u[pos] + d[pos] - 1; // cut lr R[i].erase(R[i].lower_bound(lr)); R[i].insert(l[pos] - 1); R[i].insert(r[pos] - 1); mx = 0; mxx = 0; int sz = R[i].size(); if (sz) upd(*R[i].begin()); if (sz &gt; 1) upd(*++R[i].begin()); sz = C[j].size(); if (sz) upd(*C[j].begin()); if (sz &gt; 1) upd(*++C[j].begin()); ans = max(ans, mx + mxx); R[i].erase(R[i].lower_bound(l[pos] - 1)); R[i].erase(R[i].lower_bound(r[pos] - 1)); R[i].insert(lr); // cut ud C[j].erase(C[j].lower_bound(ud)); C[j].insert(u[pos] - 1); C[j].insert(d[pos] - 1); mx = 0; mxx = 0; sz = R[i].size(); if (sz) upd(*R[i].begin()); if (sz &gt; 1) upd(*++R[i].begin()); sz = C[j].size(); if (sz) upd(*C[j].begin()); if (sz &gt; 1) upd(*++C[j].begin()); ans = max(ans, mx + mxx); C[j].erase(C[j].lower_bound(u[pos] - 1)); C[j].erase(C[j].lower_bound(d[pos] - 1)); C[j].insert(ud); &#125; else &#123; mx = 0; mxx = 0; int sz = R[i].size(); if (sz) upd(*R[i].begin()); if (sz &gt; 1) upd(*++R[i].begin()); sz = C[j].size(); if (sz) upd(*C[j].begin()); if (sz &gt; 1) upd(*++C[j].begin()); ans = max(ans, mx + mxx); &#125; &#125; printf(&quot;%d\\n&quot;, ans);&#125;int main() &#123; int t; scanf(&quot;%d&quot;, &amp;t); for (int i = 1; i &lt;= t; ++i) work(); return 0;&#125; C - Computer Network ç­¾åˆ°ã€‚ 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;int ii() &#123; int x; scanf(&quot;%d&quot;, &amp;x); return x;&#125;int main() &#123; int n = ii(); int k = ii(); std::priority_queue&lt;int&gt; vec; for (int i = 0; i &lt; k; ++i) vec.push(0); int a[n]; for (int i = 0; i &lt; n; ++i) a[i] = ii(); std::sort(a, a + n); long long ans&#123;&#125;; for (int i = 0; i &lt; n; ++i) &#123; int x = -vec.top(); vec.pop(); int y = -x - a[i]; ans += x + a[i]; vec.push(y); &#125; std::cout &lt;&lt; ans &lt;&lt; std::endl;&#125; *D - Dice Grid *E - Easily Distinguishable Triangles ç»™ä¸€ä¸ªçŸ©é˜µç”± #.? ç»„æˆï¼Œ# ä»£è¡¨é»‘è‰²ï¼Œ. ä»£è¡¨ç™½è‰²ï¼Œä½ éœ€è¦å°† ? çš„ä¸€ä¸ªè§’ï¼ˆä¸€åŠé¢ç§¯ï¼‰æŸ“æˆé»‘è‰²ã€‚ ä½¿å¾—æœ€ç»ˆå¯¹äºæ¯ä¸ªä¸‰è§’å½¢ï¼Œä»–æ‰€æŸ“é»‘çš„ä¸¤æ¡è¾¹ä¸å’Œä»»ä½•å…¶ä»–é»‘è‰²è¾¹ç•Œç›¸é‚»ã€‚æ±‚æ–¹æ¡ˆæ•°ã€‚ ç©ä¸€ä¸‹å‘ç°è¡Œåˆ—æ˜¯ç‹¬ç«‹çš„ï¼Œæ¢å¥è¯è¯´ï¼ŒæŸ“è‰²ç›¸å½“äºä»å·¦å³ä¸­é€‰ä¸€ä¸ªè¾¹æŸ“è‰²ï¼Œä¸Šä¸‹ä¸­é€‰ä¸€ä¸ªè¾¹æŸ“è‰²ã€‚ è¡Œåˆ—å•ç‹¬è®¡æ•°ï¼Œä»¥æŸè¡Œä¸ºä¾‹ï¼Œå¦‚æœå·¦å³éƒ½æ˜¯é»‘è‰²çš„å°±ä¸è¡Œï¼Œä¸€ä¾§é»‘è‰²æ–¹æ¡ˆæ•°ä¸º \\(1\\) ï¼Œæ²¡æœ‰é»‘è‰²æ–¹æ¡ˆæ•°ä¸º \\(len+1\\) ã€‚ å¯¹æ¯ä¸ªè¡Œ / åˆ—è¿é€šå—æ‰§è¡Œä¸Šè¿°è¿‡ç¨‹å³å¯ã€‚ 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;#define N 1007#define mod 998244353char mp[N][N];int main() &#123; int n, ans = 1; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(&quot;%s&quot;, mp[i] + 1); mp[i][0] = mp[i][n + 1] = &#x27;.&#x27;; for (int j = 1, l = 0; j &lt;= n + 1; ++j) if (mp[i][j] == &#x27;?&#x27; &amp;&amp; mp[i][j - 1] != &#x27;?&#x27;) l = j - 1; else if (mp[i][j] != &#x27;?&#x27; &amp;&amp; mp[i][j - 1] == &#x27;?&#x27;) &#123; int cnt = (mp[i][l] == &#x27;#&#x27;) + (mp[i][j] == &#x27;#&#x27;); if (cnt == 2) &#123;puts(&quot;0&quot;); return 0;&#125; ans = 1ll * ans * (cnt ? 1 : j - l) % mod; &#125; &#125; for (int j = 1; j &lt;= n; ++j) &#123; mp[0][j] = mp[n + 1][j] = &#x27;.&#x27;; for (int i = 1, l = 0; i &lt;= n + 1; ++i) if (mp[i][j] == &#x27;?&#x27; &amp;&amp; mp[i - 1][j] != &#x27;?&#x27;) l = i - 1; else if (mp[i][j] != &#x27;?&#x27; &amp;&amp; mp[i - 1][j] == &#x27;?&#x27;) &#123; int cnt = (mp[l][j] == &#x27;#&#x27;) + (mp[i][j] == &#x27;#&#x27;); if (cnt == 2) &#123;puts(&quot;0&quot;); return 0;&#125; ans = 1ll * ans * (cnt ? 1 : i - l) % mod; &#125; &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125; *I - IQ Game \\(n\\le 10^9\\) ä¸ªç‚¹å›´æˆä¸€åœˆï¼Œæœ‰ \\(k\\le 200\\) ä¸ªæ˜¯é»‘ç‚¹ï¼Œå…¶ä½™æ˜¯ç™½ç‚¹ï¼Œä¸” \\(k\\) ä¸ªç‚¹ä¸­æœ‰ä¸€ä¸ªæ˜¯ç‚¸å¼¹ã€‚ æ¯è½®éšæœºé€‰ä¸€ä¸ªç‚¹ï¼Œç„¶åæ‰¾åˆ°ä»–é¡ºæ—¶é’ˆæ–¹å‘çš„ç¬¬ä¸€ä¸ªé»‘ç‚¹ï¼Œå¦‚æœæ˜¯ç‚¸å¼¹æ¸¸æˆç»“æŸï¼Œå¦åˆ™å°†è¿™ä¸ªé»‘ç‚¹å˜ç™½ã€‚ é—®æ¸¸æˆè¿›è¡Œçš„æœŸæœ›è½®æ•°ã€‚ é¦–å…ˆè¦æœ‰ä¸€ä¸ªæ ¸å¿ƒæ€è·¯ï¼Œå¯¹äºå€¼æ’æ­£çš„éšæœºå˜é‡ \\(x\\) ï¼Œæœ‰ \\(E(x)=\\sum_{i=1}^{\\infty} P(x\\ge i)\\) ã€‚ æ³¨æ„åˆ°æ¸¸æˆ \\(k\\) è½®ä¹‹åå¿…å®šç»“æŸï¼Œæ‰€ä»¥åªè¦æ±‚å‡º \\(0\\le i&lt; k\\) è½®æ¸¸æˆä¸ç»“æŸçš„æ¦‚ç‡å³å¯ã€‚ è€ƒè™‘å°†æ¢ä»ç‚¸å¼¹å¤„æ–­å¼€ï¼ŒæŒ‰ç…§é€†æ—¶é’ˆæ–¹å‘ä»¥ç‚¸å¼¹ä¸ºèµ·ç‚¹å‘åå»¶ç”³ï¼Œä»¥ç‰¹æ®Šç‚¹åˆ†æ®µã€‚ é‚£ä¹ˆæ¸¸æˆä¸ç»“æŸçš„è¦æ±‚å°±æ˜¯ï¼šç¬¬ä¸€æ®µé‡Œçš„ç‚¹ä¸èƒ½é€‰ï¼Œç¬¬äºŒæ®µæœ€å¤šé€‰ä¸€ä¸ªï¼Œå‰ä¸‰æ®µæœ€å¤šé€‰ä¸¤ä¸ªï¼Œä»¥æ­¤ç±»æ¨ã€‚ å‘ç°è¦æ±‚æ˜¯å‰ \\(i\\) æ®µæœ€å¤šé€‰ \\(i-1\\) ä¸ªï¼Œè®¾ \\(f[i][j]\\) è¡¨ç¤ºåœ¨å‰ \\(i\\) æ®µé€‰äº† \\(j\\) æ¬¡ï¼Œæ²¡æœ‰è¿èƒŒè¦æ±‚çš„æ¦‚ç‡ï¼Œç­”æ¡ˆå°±æ˜¯ \\(\\sum_{j=0}^{k-1} f[n][j]\\) ã€‚ è½¬ç§»æšä¸¾æœ€åä¸€æ®µé€‰äº†å‡ ä¸ªï¼Œç„¶åå†å°†è¿™äº›æ’å…¥åˆ°æ­¤å‰çš„æ“ä½œåºåˆ—ä¸­ï¼Œå³ \\(f[i][j] = \\sum_{k=0}^j f[i-1][j-k]\\times {j\\choose k}\\times (\\frac{len_i}{n})^k\\) ç›´æ¥åšå¤æ‚åº¦ \\(\\mathcal{O}(n^3)\\) çš„å¯è¿‡ï¼Œä¸è¿‡è½¬ç§»æ˜¯ä¸ªå·ç§¯çš„å½¢å¼ï¼Œå¯ä»¥ä¼˜åŒ–åˆ° \\(\\mathcal{O}(n^2\\log n)\\) ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 207#define mod 998244353inline int fpow(int x, int t) &#123; int res = 1; for (; t; t &gt;&gt;= 1, x = 1ll * x * x % mod) if (t &amp; 1) res = 1ll * res * x % mod; return res;&#125;ll pos[N], p[N][N], c[N][N], f[N][N];int main() &#123; int n = rd(), m = rd(), s = rd(); int invn = fpow(n, mod - 2); for (int i = 0; i &lt;= m; ++i) &#123; c[i][0] = 1; for (int j = 1; j &lt;= i; ++j) c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % mod; &#125; for (int i = 1; i &lt;= m; ++i) &#123; pos[i] = rd(); if (pos[i] &gt; s) pos[i] -= n; &#125; pos[0] = s - n; sort(pos + 1, pos + 1 + m); for (int i = 1; i &lt;= m; ++i) &#123; p[i][0] = 1; p[i][1] = 1ll * (pos[m - i + 1] - pos[m - i]) * invn % mod; for (int j = 2; j &lt;= m; ++j) p[i][j] = p[i][j - 1] * p[i][1] % mod; &#125; f[0][0] = 1; for (int i = 1; i &lt;= m; ++i) for (int j = 0; j &lt; i; ++j) for (int k = 0; k &lt;= j; ++k) f[i][j] = (f[i][j] + c[j][k] * f[i - 1][j - k] % mod * p[i][k]) % mod; ll ans = 0; for (int j = 0; j &lt; m; ++j) ans = (ans + f[m][j]) % mod; printf(&quot;%lld\\n&quot;, ans); return 0;&#125; K - K-Shaped Figures ç»™å®šå¹³é¢ä¸Š \\(n\\le 10^3\\) ä¸ªçº¿æ®µï¼Œé—®æœ‰å¤šå°‘ä¸ª \\(K\\) ï¼Œå®šä¹‰ä¸‰æ¡çº¿æ®µæ„æˆäº†ä¸€ä¸ª K ï¼š å…¶ä¸­ä¸¤æ¡äº¤äºä¸€ç‚¹ï¼Œä¸”è¿™ä¸€ç‚¹åœ¨ç¬¬ä¸‰æ¡çº¿æ®µå†…ï¼ˆä¸èƒ½æ˜¯ç«¯ç‚¹ï¼‰ å‰ä¸¤æ¡çº¿åœ¨ç¬¬ä¸‰æ¡çº¿çš„åŒä¾§ï¼Œä¸”ä¸‰æ¡çº¿ä¸¤ä¸¤ä¸å…±çº¿ã€‚ åšæ³•ä¸€ è‡ªç„¶çš„æšä¸¾è¿™ä¸ªä¸­å¿ƒç‚¹ï¼Œæ‰¾å‡ºæ¥ç©¿è¿‡è¯¥ç‚¹çš„çº¿æ®µ \\(\\{A\\}\\)ï¼Œå’Œä»¥è¯¥ç‚¹ä¸ºç«¯ç‚¹çš„çº¿æ®µ \\(\\{B\\}\\) ï¼Œéƒ½æŒ‰è¯¥ç‚¹ä¸ºä¸­å¿ƒæè§’åºæ’åºã€‚ ç„¶åå¯¹äºæ¯ä¸ªç©¿è¿‡è¯¥ç‚¹çš„çº¿æ®µ \\(A\\) ï¼Œçº¿æ®µä¸¤ä¾§çš„ \\(B\\) çº¿æ®µä¸‹æ ‡ä¸€å®šä¾æè§’åºè¿ç»­ï¼ŒåŒæŒ‡é’ˆæ‰¾å‡ºæ¥è¿™ä¸ªåŒºé—´å³å¯ã€‚ å¯¹äºä¸èƒ½å…±çº¿ï¼Œé—®é¢˜ç›¸å½“äºè®¡æ•°ç»™å®š \\(n\\) ä¸ªé›†åˆï¼Œå…ˆé€‰ä¸¤ä¸ªé›†åˆï¼Œå†ä»è¿™ä¸¤ä¸ªé›†åˆä¸­å„è‡ªé€‰ä¸€ä¸ªæ•°çš„æ–¹æ¡ˆæ•°ã€‚ è€ƒè™‘å‡æ‰ä¸åˆæ³•çš„æ–¹æ¡ˆæ•°ï¼Œåˆ™ç­”æ¡ˆä¸º \\({\\sum a_i\\choose 2} - \\sum {a_i\\choose 2}\\) ï¼Œåˆ†ä¸¤é¡¹ç»´æŠ¤å³å¯ã€‚ ä¸ºäº†é¿å…è®¨è®ºï¼Œæˆ‘ä»¬éœ€è¦ä¿è¯ä»»æ„æ—¶åˆ»ç›´çº¿æ¯ä¸€ä¾§éƒ½æœ‰ç‚¹ï¼Œå› æ­¤åŠ å…¥å››ä¸ªå‚ç›´æ–¹å‘çš„è™šæ‹Ÿç‚¹å³å¯ã€‚ æ³¨æ„åˆ°åŒæŒ‡é’ˆæ—‹è½¬æ—¶ï¼Œå¦‚æœè§’åº¦è¶…è¿‡äº† \\(180^\\circ\\) å¯èƒ½ä¼šå‡ºç°é—®é¢˜ï¼Œæ‰€ä»¥å†æ’å…¥å‚ç›´æ–¹å‘çš„å››æ¡ç›´çº¿å³å¯ã€‚ å¤æ‚åº¦ä¸º \\(\\mathcal{O}(n^2\\log n)\\) ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 1007#define letp const Pstruct P &#123; ll x, y; P(ll x = 0, ll y = 0) : x(x), y(y) &#123;&#125; P operator + (letp &amp;p) const &#123;return &#123;x + p.x, y + p.y&#125;;&#125; P operator - (letp &amp;p) const &#123;return &#123;x - p.x, y - p.y&#125;;&#125; ll operator | (letp &amp;p) const &#123;return x * p.x + y * p.y;&#125; // dot ll operator ^ (letp &amp;p) const &#123;return x * p.y - y * p.x;&#125; // cross bool operator &lt; (letp &amp;p) const &#123;return x &lt; p.x || (x == p.x &amp;&amp; y &lt; p.y);&#125; bool operator == (letp &amp;p) const &#123;return x == p.x &amp;&amp; y == p.y;&#125; int ori(letp &amp;p) const &#123;ll t = (*this) ^ p; return (t &gt; 0) - (t &lt; 0);&#125;&#125;;vector&lt;P&gt; pt;struct argcmp &#123; bool operator() (letp &amp;a, letp &amp;b) const &#123; const auto quad = [](letp &amp;a) &#123; if (a.y &lt; 0) return 1; if (a.y &gt; 0) return 4; if (a.x &lt; 0) return 5; if (a.x &gt; 0) return 3; return 2; &#125;; const int qa = quad(a), qb = quad(b); if (qa != qb) return qa &lt; qb; const auto t = (a ^ b); return t &gt; 0; &#125;&#125;;struct S &#123; P a, b; int is_on(letp &amp;p) const &#123; if (p == a || p == b) return -1; return (p - a).ori(p - b) == 0 &amp;&amp; ((p - a) | (p - b)) &lt; 0; &#125; int ori(letp &amp;p) const &#123;return (b - a).ori(p - a);&#125;&#125; s[N];vector&lt;pair&lt;P, S&gt;&gt; Cr;vector&lt;P&gt; out;vector&lt;pair&lt;P, int&gt;&gt; Out;inline ll c2(int x) &#123;return 1ll * x * (x - 1) / 2;&#125;inline void work() &#123; int n = rd(); pt.clear(); for (int i = 1; i &lt;= n; ++i) &#123; P a, b; a.x = rd(); a.y = rd(); b.x = rd(); b.y = rd(); pt.push_back(a); pt.push_back(b); s[i] = &#123;a, b&#125;; &#125; sort(pt.begin(), pt.end()); pt.erase(unique(pt.begin(), pt.end()), pt.end()); ll ans = 0; for (auto p : pt) &#123; Cr.clear(); out.clear(); Out.clear(); for (int i = 1; i &lt;= n; ++i) &#123; int fl = s[i].is_on(p); if (fl == 1) &#123; Cr.push_back(make_pair(s[i].a, S&#123;s[i].a, s[i].b&#125;)); Cr.push_back(make_pair(s[i].b, S&#123;s[i].b, s[i].a&#125;)); &#125; else if (fl == -1) &#123; out.push_back(p == s[i].a ? s[i].b : s[i].a); &#125; &#125; if (Cr.empty()) continue; if (out.empty()) continue; Cr.push_back(make_pair(P&#123;p.x - 100000000, p.y&#125;, S&#123;P&#123;p.x - 100000000, p.y&#125;, P&#123;p.x + 1, p.y&#125;&#125;)); Cr.push_back(make_pair(P&#123;p.x + 100000000, p.y&#125;, S&#123;P&#123;p.x + 100000000, p.y&#125;, P&#123;p.x - 1, p.y&#125;&#125;)); Cr.push_back(make_pair(P&#123;p.x, p.y - 100000000&#125;, S&#123;P&#123;p.x, p.y - 100000000&#125;, P&#123;p.x, p.y + 1&#125;&#125;)); Cr.push_back(make_pair(P&#123;p.x, p.y + 100000000&#125;, S&#123;P&#123;p.x, p.y + 100000000&#125;, P&#123;p.x, p.y - 1&#125;&#125;)); auto cmp = [&amp;](P &amp;a, P &amp;b) &#123;return argcmp()(a - p, b - p);&#125;; auto cmpCr = [&amp;](pair&lt;P, S&gt; &amp;a, pair&lt;P, S&gt; &amp;b) &#123;return cmp(a.first, b.first);&#125;; auto cmpOut = [&amp;](pair&lt;P, int&gt; &amp;a, pair&lt;P, int&gt; &amp;b) &#123;return cmp(a.first, b.first);&#125;; sort(Cr.begin(), Cr.end(), cmpCr); sort(out.begin(), out.end(), cmp); auto para = [&amp;](P &amp;a, P &amp;b) &#123;return ((a - p) ^ (b - p)) == 0 &amp;&amp; ((a - p) | (b - p)) &gt; 0;&#125;; for (auto x : out) if (Out.empty() || !para(Out.back().first, x)) Out.push_back(make_pair(x, 1)); else ++Out[Out.size() - 1].second; Out.push_back(make_pair(P&#123;p.x + 1, p.y&#125;, 0)); Out.push_back(make_pair(P&#123;p.x - 1, p.y&#125;, 0)); Out.push_back(make_pair(P&#123;p.x, p.y + 1&#125;, 0)); Out.push_back(make_pair(P&#123;p.x, p.y - 1&#125;, 0)); sort(Out.begin(), Out.end(), cmpOut); int sz = Out.size(); auto nxt = [&amp;](int x) &#123;return x == sz - 1 ? 0 : x + 1;&#125;; auto pre = [&amp;](int x) &#123;return x == 0 ? sz - 1 : x - 1;&#125;; int l = 0, r = 0; auto pos = [&amp;](S &amp;l, P &amp;x) &#123;return l.ori(x) &gt; 0;&#125;; ll sum = 0, del = 0; while (!pos(Cr[0].second, Out[r].first)) r = nxt(r); while (pos(Cr[0].second, Out[r].first)) r = nxt(r); r = pre(r); l = r; while (pos(Cr[0].second, Out[l].first)) l = pre(l); l = nxt(l); for (int i = l; i != nxt(r); i = nxt(i)) &#123; sum += Out[i].second; del += c2(Out[i].second); &#125; for (auto [tmp, s] : Cr) &#123; while (pos(s, Out[nxt(r)].first)) &#123; r = nxt(r); sum += Out[r].second; del += c2(Out[r].second); &#125; while (!pos(s, Out[l].first)) &#123; sum -= Out[l].second; del -= c2(Out[l].second); l = nxt(l); &#125; if (max(abs(tmp.x), abs(tmp.y)) &lt;= 10000000) ans += c2(sum) - del; &#125; &#125; printf(&quot;%lld\\n&quot;, ans);&#125;int main() &#123; int t; scanf(&quot;%d&quot;, &amp;t); for (int i = 1; i &lt;= t; ++i) work(); return 0;&#125; åšæ³•äºŒ å› ä¸ºè¿™é¢˜æ˜¯è¦æ±‚å…¨éƒ¨çš„ \\(K\\) çš„ä¸ªæ•°ï¼Œæ‰€ä»¥å…¶å®æš´åŠ›çš„å¤æ‚åº¦æ˜¯å¯¹çš„ã€‚ å…ˆæšä¸¾ä¸­å¿ƒç‚¹ï¼Œå†æšä¸¾ç©¿è¿‡ä»–çš„çº¿ï¼Œå†æšä¸¾æ‰€æœ‰ä»¥å®ƒä¸ºç«¯ç‚¹çš„çº¿è®¡ç®—ç­”æ¡ˆï¼Œè®¡ç®—æ–¹å¼ä¸ä¸Šä¸€åšæ³•ç›¸åŒã€‚ åŒå‘å»é‡éœ€è¦ä¸€äº›æŠ€å·§ï¼Œæ¯”å¦‚ unordered_map ä»¥æ–¹å‘å‘é‡é™¤ \\(\\gcd\\) åšä¸‹æ ‡å³å¯ç»Ÿè®¡ã€‚ è€ƒè™‘ä»¥æšä¸¾ç‚¹ä¸ºç«¯ç‚¹çš„çº¿æ®µæ•°çš„å’Œï¼Œçœ‹ä¼¼æ˜¯ \\(\\mathcal{O}(n^2)\\) å®é™…ä¸Šæ˜¯ \\(\\mathcal{O}(n)\\) çš„ï¼Œæ‰€ä»¥æ€»å¤æ‚åº¦æ˜¯ \\(\\mathcal{O}(n^2)\\) çš„ã€‚ å®é™…ä¸Šç”±äº unordered_map æ¯” sort å¸¸æ•°è¿˜å¤§ï¼Œæ‰€ä»¥è·‘èµ·æ¥å¹¶ä¸å¿«ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;int gcd(int a, int b) &#123;return b ? gcd(b, a % b) : a;&#125;#define N 1007#define letp const Pstruct P &#123; ll x, y; P(ll x = 0, ll y = 0) : x(x), y(y) &#123;&#125; P operator + (letp &amp;p) const &#123;return &#123;x + p.x, y + p.y&#125;;&#125; P operator - (letp &amp;p) const &#123;return &#123;x - p.x, y - p.y&#125;;&#125; P operator / (int t) const &#123;return &#123;x / t, y / t&#125;;&#125; ll operator | (letp &amp;p) const &#123;return x * p.x + y * p.y;&#125; // dot ll operator ^ (letp &amp;p) const &#123;return x * p.y - y * p.x;&#125; // cross bool operator &lt; (letp &amp;p) const &#123;return x &lt; p.x || (x == p.x &amp;&amp; y &lt; p.y);&#125; bool operator == (letp &amp;p) const &#123;return x == p.x &amp;&amp; y == p.y;&#125; int ori(letp &amp;p) const &#123;ll t = (*this) ^ p; return (t &gt; 0) - (t &lt; 0);&#125;&#125;;vector&lt;P&gt; pt;struct argcmp &#123; bool operator() (letp &amp;a, letp &amp;b) const &#123; const auto quad = [](letp &amp;a) &#123; if (a.y &lt; 0) return 1; if (a.y &gt; 0) return 4; if (a.x &lt; 0) return 5; if (a.x &gt; 0) return 3; return 2; &#125;; const int qa = quad(a), qb = quad(b); if (qa != qb) return qa &lt; qb; const auto t = (a ^ b); return t &gt; 0; &#125;&#125;;struct S &#123; P a, b; int is_on(letp &amp;p) const &#123; if (p == a || p == b) return -1; return (p - a).ori(p - b) == 0 &amp;&amp; ((p - a) | (p - b)) &lt; 0; &#125; int ori(letp &amp;p) const &#123;return (b - a).ori(p - a);&#125;&#125; s[N];vector&lt;P&gt; B;vector&lt;S&gt; A;unordered_map&lt;ll, int&gt; cnt;inline ll trans(P x) &#123; static const ll bs = 10000000; return (x.x + bs) * 2 * bs + (x.y + bs);&#125;inline ll c2(int x) &#123;return 1ll * x * (x - 1) / 2;&#125;inline void work() &#123; int n = rd(); pt.clear(); for (int i = 1; i &lt;= n; ++i) &#123; P a, b; a.x = rd(); a.y = rd(); b.x = rd(); b.y = rd(); pt.push_back(a); pt.push_back(b); s[i] = &#123;a, b&#125;; &#125; sort(pt.begin(), pt.end()); pt.erase(unique(pt.begin(), pt.end()), pt.end()); ll ans = 0; for (auto p : pt) &#123; A.clear(); B.clear(); for (int i = 1; i &lt;= n; ++i) if (p == s[i].a || p == s[i].b) &#123; P dlt = (p == s[i].a ? s[i].b : s[i].a) - p; dlt = dlt / gcd(abs(dlt.x), abs(dlt.y)); B.push_back(dlt); &#125; else if (s[i].is_on(p)) A.push_back(s[i]); for (auto seg : A) &#123; cnt.clear(); int suml = 0, sumr = 0, dell = 0, delr = 0; auto addl = [&amp;](ll x) &#123; suml -= cnt[x]; dell -= c2(cnt[x]); ++cnt[x]; suml += cnt[x]; dell += c2(cnt[x]); &#125;; auto addr = [&amp;](ll x) &#123; sumr -= cnt[x]; delr -= c2(cnt[x]); ++cnt[x]; sumr += cnt[x]; delr += c2(cnt[x]); &#125;; for (auto dlt : B) &#123; int dir = seg.ori(dlt + p); if (dir == 1) addl(trans(dlt)); if (dir == -1) addr(trans(dlt)); &#125; ans += c2(suml) + c2(sumr) - dell - delr; &#125; &#125; printf(&quot;%lld\\n&quot;, ans);&#125;int main() &#123; int t; scanf(&quot;%d&quot;, &amp;t); for (int i = 1; i &lt;= t; ++i) work(); return 0;&#125; L - Limited Swaps ç­¾åˆ°ã€‚ 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;int ii() &#123; int x; scanf(&quot;%d&quot;, &amp;x); return x;&#125;int main() &#123; int n = ii(); int a[n]; for (int i = 0; i &lt; n; ++i) a[i] = ii(); int b[n]; for (int i = 0; i &lt; n; ++i) b[i] = ii(); std::vector&lt;int&gt; ans; for (int i = 0; i &lt; n; ++i) &#123; int k = 0; for (int j = i; j &lt; n; ++j) if (a[j] == b[i]) k = j; for (; k &gt; i; --k) if (abs(a[k - 1] - a[k]) &lt; 2) &#123; puts(&quot;-1&quot;); return 0; &#125; else &#123; ans.push_back(k); std::swap(a[k - 1], a[k]); &#125; &#125; int m = ans.size(); std::cout &lt;&lt; ans.size() &lt;&lt; std::endl; for (int i = 0; i &lt; m; ++i) std::cout &lt;&lt; ans[i] &lt;&lt; &quot; \\n&quot;[i == m - 1];&#125; M - Mex and Cards ç»™å®šä¸€ä¸ªæ•°é›†ï¼Œå¼€å§‹ \\(i\\) æœ‰ \\(a_i\\) ä¸ªï¼ŒæŠŠæ•°é›†åˆ†æˆè‹¥å¹²ä¸ªé›†åˆï¼Œæœ€å¤§åŒ–æ‰€æœ‰åˆ†å‡ºæ¥çš„é›†åˆ MEX çš„å’Œã€‚ æ”¯æŒæ¯æ¬¡æ’å…¥ / åˆ é™¤ä¸€ä¸ªæ•°å­—ï¼Œç»´æŠ¤ç­”æ¡ˆã€‚ çº¿æ®µæ ‘ã€‚è®¨è®ºä¸€ä¸‹å³å¯ã€‚å¯ä»¥åšåˆ°ä¸€ä¸ª \\(\\log\\) ï¼Œå›å¤´å†è¡¥ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define fr first#define sc second#define mp make_pairusing namespace std;typedef long long LL;const int maxn=200000,maxt=maxn&lt;&lt;2;int n,te,a[maxn+5];int MIN[maxt+5];pair&lt;LL,int&gt; res[maxt+5];inline int Miner(int x,int y) &#123;return a[x]&lt;a[y] || a[x]==a[y] &amp;&amp; x&gt;y?x:y;&#125;pair&lt;LL,int&gt; Find(int L,int R,int p,int who)&#123; if (L==R) return a[L]&lt;=a[who]?mp((LL)(a[who]-a[L])*(L-1),L):mp(0LL,who); int mid=L+(R-L&gt;&gt;1); if (a[who]&lt;a[MIN[p&lt;&lt;1]]) return Find(mid+1,R,p&lt;&lt;1|1,who); else &#123; pair&lt;LL,int&gt; ls=Find(L,mid,p&lt;&lt;1,who); return mp(ls.fr+res[p].fr,res[p].sc); &#125;&#125;void Build(int l,int r,int p=1)&#123; if (l==r) &#123;MIN[p]=l;return;&#125; int mid=l+(r-l&gt;&gt;1); Build(l,mid,p&lt;&lt;1);Build(mid+1,r,p&lt;&lt;1|1); MIN[p]=Miner(MIN[p&lt;&lt;1],MIN[p&lt;&lt;1|1]); res[p]=Find(mid+1,r,p&lt;&lt;1|1,MIN[p&lt;&lt;1]);&#125;void Update(int pos,int l=1,int r=n,int p=1)&#123; if (l==r) return; int mid=l+(r-l&gt;&gt;1); pos&lt;=mid?Update(pos,l,mid,p&lt;&lt;1):Update(pos,mid+1,r,p&lt;&lt;1|1); MIN[p]=Miner(MIN[p&lt;&lt;1],MIN[p&lt;&lt;1|1]); res[p]=Find(mid+1,r,p&lt;&lt;1|1,MIN[p&lt;&lt;1]);&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n);n++; for (int i=1;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]); a[0]=1e9;Build(1,n); printf(&quot;%lld\\n&quot;,Find(1,n,1,0).fr); for (scanf(&quot;%d&quot;,&amp;te);te;te--)&#123; int tp,x;scanf(&quot;%d%d&quot;,&amp;tp,&amp;x);x++; a[x]+=(tp==1?1:-1);Update(x); printf(&quot;%lld\\n&quot;,Find(1,n,1,0).fr); &#125; return 0;&#125; N - New Time ç­¾åˆ°ã€‚ 1234567891011121314151617181920#include&lt;cstdio&gt;using namespace std;int a,b,c,d,ans;int main()&#123; scanf(&quot;%d:%d%d:%d&quot;,&amp;a,&amp;b,&amp;c,&amp;d); if (b&lt;=d)&#123; ans+=d-b; if (a&lt;=c) ans+=c-a; else ans+=24-a+c; &#125; else &#123; ans+=60-b+d; a=(a+1)%24; if (a&lt;=c) ans+=c-a; else ans+=24-a+c; &#125; printf(&quot;%d\\n&quot;,ans); return 0;&#125;","categories":[{"name":"Official Contests","slug":"Official-Contests","permalink":"http://blog.gyx.me/categories/Official-Contests/"}],"tags":[{"name":"STL","slug":"STL","permalink":"http://blog.gyx.me/tags/STL/"},{"name":"Segment Tree","slug":"Segment-Tree","permalink":"http://blog.gyx.me/tags/Segment-Tree/"},{"name":"Geometry","slug":"Geometry","permalink":"http://blog.gyx.me/tags/Geometry/"},{"name":"Probabilities","slug":"Probabilities","permalink":"http://blog.gyx.me/tags/Probabilities/"},{"name":"Tricks","slug":"Tricks","permalink":"http://blog.gyx.me/tags/Tricks/"}]},{"title":"2022 CCPC Guangzhou Site","slug":"official/ccpc/22-guangzhou","date":"2022-11-13T16:00:00.000Z","updated":"2023-03-20T16:35:28.185Z","comments":true,"path":"official/ccpc/22-guangzhou/","link":"","permalink":"http://blog.gyx.me/official/ccpc/22-guangzhou/","excerpt":"","text":"æ¯”èµ›åœ°å€ ï¼šCodeforces Gym 104053 å¾…è¡¥ï¼šADFGJ B - Ayano and sequences æ•°æ®ç»“æ„é¢˜ï¼Œèƒ–èƒ–è¡¥æ‰äº†ã€‚é“¾æ¥ *C - Customs Controls 2 ç»™å®šä¸€ä¸ª DAG ï¼Œä¿è¯æ‰€æœ‰ç‚¹éƒ½èƒ½ä» \\(1\\) åˆ°è¾¾ï¼Œä¸”éƒ½èƒ½åˆ°è¾¾ \\(n\\) ã€‚ è¦æ±‚ç»™æ¯ä¸ªç‚¹åˆ†é…ä¸€ä¸ªç‚¹æƒï¼Œä½¿å¾—ä» \\(1\\) åˆ° \\(n\\) çš„æ‰€æœ‰è·¯å¾„ç»è¿‡çš„ç‚¹æƒå’Œç›¸åŒã€‚ å®šä¹‰ \\(dis[u]\\) è¡¨ç¤ºä» \\(1\\) åˆ° \\(u\\) çš„è·ç¦»ï¼Œå¦‚æœè¦ç¬¦åˆæœ€ç»ˆè¦æ±‚ï¼Œæ˜¾ç„¶é¦–å…ˆ \\(dis[u]\\) çš„å€¼è¦å”¯ä¸€ã€‚ è€ƒè™‘å¯¹äºæ¯ä¸ªç‚¹ \\(v\\) ï¼Œå›¾ä¸­å­˜åœ¨ \\(u\\to v\\) çš„è¾¹ï¼Œé‚£ä¹ˆè¿™æ ·çš„ \\(u\\) çš„ \\(dis[u]\\) ä¹Ÿå¿…é¡»ç›¸åŒã€‚ å¹¶æŸ¥é›†æŠŠè¿™æ ·çš„ç‚¹ç¼©ç‚¹ï¼Œé‡å»ºå›¾ï¼Œå› ä¸ºç‚¹æƒæ˜¯æ­£çš„ï¼Œå› æ­¤å¦‚æœå›¾ä¸­å­˜åœ¨ç¯å°±æ— è§£ã€‚ å¦åˆ™æŒ‰ç…§ä» \\(1\\) å¼€å§‹çš„æ‹“æ‰‘åºè®¾å®š \\(dis[u]\\) å³å¯ï¼Œ\\(v\\) çš„ç‚¹æƒå°±æ˜¯ \\(dis[v] - dis[u]\\) çš„å€¼ï¼ˆåŸå›¾ä¸­å­˜åœ¨ \\(u\\to v\\) ï¼‰ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 200007struct DSU &#123; int f[N]; inline void reset(int x) &#123;for (int i = 1; i &lt;= x; ++i) f[i] = i;&#125; int find(int x) &#123;return x == f[x] ? x : f[x] = find(f[x]);&#125; bool merge(int u, int v) &#123; u = find(u); v = find(v); return (u == v ? false : (f[u] = v, true)); &#125; &#125; dsu;int deg[N], tag[N], val[N];queue&lt;int&gt; q;vector&lt;int&gt; in[N], out[N];inline void work() &#123; int n = rd(), m = rd(); dsu.reset(n); for (int i = 1; i &lt;= n; ++i) &#123;deg[i] = 0; in[i].clear(); out[i].clear();&#125; for (int i = 1; i &lt;= m; ++i) &#123; int u = rd(), v = rd(); in[v].push_back(u); &#125; for (int u = 1; u &lt;= n; ++u) if (!in[u].empty()) &#123; int sy = in[u][0]; for (auto x : in[u]) dsu.merge(x, sy); &#125; for (int u = 1; u &lt;= n; ++u) &#123; int U = dsu.find(u); for (auto v : in[u]) &#123; int V = dsu.find(v); ++deg[U]; out[V].push_back(U); &#125; &#125; int tot = 0, cnt = 0; for (int i = 1; i &lt;= n; ++i) if (dsu.find(i) == i) &#123; ++tot; if (!deg[i]) q.push(i); &#125; while (!q.empty()) &#123; --tot; int u = q.front(); q.pop(); tag[u] = ++cnt; for (auto v : out[u]) &#123; --deg[v]; if (!deg[v]) q.push(v); &#125; &#125; if (tot) &#123;puts(&quot;No&quot;); return;&#125; puts(&quot;Yes&quot;); for (int i = 1; i &lt;= n; ++i) val[i] = tag[dsu.find(i)]; for (int i = 1; i &lt;= n; ++i) &#123; int ans = val[i]; if (!in[i].empty()) ans -= val[in[i][0]]; if (i &lt; n) printf(&quot;%d &quot;, ans); else printf(&quot;%d\\n&quot;, ans); &#125;&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; E - Elevator ç­¾åˆ°é¢˜ï¼Œé€†åºæ•°ã€‚è¦æŠŠ \\(x\\) å‰é¢çš„å˜æˆ \\(&gt; x\\) ï¼Œåé¢çš„å˜æˆ \\(\\ge x\\) ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;vector&lt;int&gt; s, s1;#define N 500007int a[N], c[N];#define lowbit(x) ((x) &amp; -(x))inline void add(int p) &#123; for (; p &lt; N; p += lowbit(p)) ++c[p];&#125;inline int sum(int p) &#123; int res = 0; for (; p; p -= lowbit(p)) res += c[p]; return res;&#125;ll presum[N];int main() &#123; int n = rd(), m = rd() - 2; for (int i = 1; i &lt;= n; ++i) &#123; a[i] = rd(); s.push_back(a[i]); &#125; sort(s.begin(), s.end()); s1 = s; for (int i = 1; i &lt;= n; ++i) presum[i] = presum[i - 1] + s1[i - 1]; s.erase(unique(s.begin(), s.end()), s.end()); auto calc = [&amp;](int x) &#123; return lower_bound(s.begin(), s.end(), x) - s.begin() + 1; &#125;; for (int i = 1; i &lt;= n; ++i) &#123; int nw = calc(a[i]); ll tot = sum(nw); add(nw); int p = lower_bound(s1.begin(), s1.end(), a[i]) - s1.begin() + 1; tot += 1ll * p * a[i] - presum[p]; if (tot &gt; m) puts(&quot;-1&quot;); else printf(&quot;%lld\\n&quot;, tot); &#125; return 0;&#125; H - GameX ç»™å®šä¸€ä¸ªæ•°é›†ï¼ŒåŒæ–¹è½®æµæ“ä½œ \\(k\\) è½®ï¼Œæ¯ä¸ªäººå¾€æ•°é›†é‡ŒåŠ å…¥ä¸€ä¸ªéè´Ÿæ•´æ•°ã€‚ å…ˆæ‰‹æƒ³è®©æœ€ç»ˆæ•°é›† MEX æ˜¯å¶æ•°ï¼Œåæ‰‹æƒ³è¦æ˜¯å¥‡æ•°ï¼Œé—®æœ€ç»ˆç»“æœã€‚ å…ˆæ‰‹æƒ³è®©æœ€ç»ˆç»“æœæ˜¯å¶æ•°ï¼Œåˆ™å¿…ä¸ä¼šåŠ å…¥å¶æ•°ï¼ŒåªåŠ å…¥å¥‡æ•°ï¼›åŒç†åæ‰‹åªä¼šåŠ å…¥å¶æ•°ã€‚ å†æ³¨æ„åˆ°å¦‚æœå°çš„å¥‡æ•°è¿˜æ²¡åŠ ï¼ŒåŠ å¤§çš„å¥‡æ•°æ˜¯æ²¡ç”¨çš„ï¼Œæ‰€ä»¥ä¸€å®šä¼šä»å°åˆ°å¤§åŠ ã€‚æ¨¡æ‹Ÿå³å¯ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 2000007bool vis[N];int a[N];vector&lt;int&gt; s;inline void work() &#123; s.clear(); int n = rd(), k = rd(); for (int i = 1; i &lt;= n; ++i) &#123; a[i] = rd(); vis[a[i]] = true; &#125; int A = 1, B = 0; for (int i = 1; i &lt;= k; ++i) &#123; while (vis[A]) A += 2; vis[A] = true; s.push_back(A); while (vis[B]) B += 2; vis[B] = true; s.push_back(B); &#125; int mx = 0; while (vis[mx]) ++mx; puts((mx &amp; 1) ? &quot;Bob&quot; : &quot;Alice&quot;); for (int i = 1; i &lt;= n; ++i) vis[a[i]] =false; for (auto x : s) vis[x] = false;&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; *I - Infection ç»™ä¸€æ£µæ ‘ï¼Œæ¯ä¸ªç‚¹æœ‰ \\(\\frac{a_i}{\\sum a_i}\\) çš„æ¦‚ç‡è¢«é€‰ä½œæ ¹ï¼Œç„¶åè¢«æŸ“é»‘ã€‚ è‹¥ \\(u\\) çˆ¶èŠ‚ç‚¹è¢«æŸ“é»‘ï¼Œåˆ™ \\(u\\) è¢«æŸ“é»‘çš„æ¦‚ç‡ä¸º \\(p_u = \\frac{b_u}{c_u}\\) ï¼Œé—®æŸ“é»‘ \\(k=1,2,\\dots, n\\) ä¸ªç‚¹çš„æ¦‚ç‡æ¨¡ \\(10^9+7\\) ã€‚ è€ƒè™‘ä¸€ä¸ªæ ‘ä¸Šè¿é€šç‚¹é›†å¯¹ç­”æ¡ˆçš„è´¡çŒ®ï¼š \\[ contri_S = \\sum_{root\\in S}\\bigg(\\frac{a_{root}}{\\sum a}\\prod_{u\\in S,u\\ne root} p_u\\prod_{(u,v)\\in Tree, v\\not\\in S,u\\in S}(1-p_v)\\bigg) \\] è®¾ \\(F[i][j]\\) è¡¨ç¤ºä»¥ \\(i\\) ä¸ºæ ¹çš„ç‚¹é›†ä¸­æœ‰ \\(j\\) ä¸ªç‚¹ï¼Œä¸”æœªé€‰å®šåˆå§‹æ„ŸæŸ“ç‚¹çš„è´¡çŒ®å’Œã€‚ \\(G[i][j]\\) è¡¨ç¤ºå·²é€‰å®šåˆå§‹æ„ŸæŸ“ç‚¹çš„è´¡çŒ®å’Œã€‚ æ ‘å½¢èƒŒåŒ…è½¬ç§»ï¼Œå¤æ‚åº¦ \\(\\mathcal{O}(n^2)\\) ã€‚æ¯ä¸ªç‚¹æŠŠ \\(G\\) æ•°ç»„è´¡çŒ®åˆ°ç­”æ¡ˆä¸­å³å¯ã€‚æ ‘å½¢èƒŒåŒ…å®ç°è¿˜æ˜¯å¾ˆç²¾ç»†çš„... 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 2007#define mod 1000000007vector&lt;int&gt; e[N];inline int fpow(int x, int t = mod - 2) &#123; int res = 1; for (; t; t &gt;&gt;= 1, x = 1ll * x * x % mod) if (t &amp; 1) res = 1ll * res * x % mod; return res;&#125;// f[u][v] : choose j nodes in subtree u, without root// g[u][v] : choose j nodes in subtree u, already choose a rootint a[N], p[N], sz[N], f[N][N], g[N][N], ans[N];void dfs(int u, int fa, int pfa) &#123; f[u][0] = 1; for (auto v : e[u]) if (v != fa) &#123; dfs(v, u, p[u]); for (int j = sz[u] + sz[v]; j &gt;= 0; --j) &#123; // è¿™é‡Œæœ¬æ¥åº”è¯¥å¼€ä¸€ä¸ªå¦å¤–çš„æ•°ç»„æ¥å­˜å€¼ï¼Œæœ€åå†èµ‹å€¼å›å»çš„ï¼Œä½†æ˜¯æ³¨æ„åˆ°k=0çš„è½¬ç§»éå¸¸å¥½å†™å°±ç›´æ¥èµ‹å€¼äº† // failed at v f[u][j] = (ll)f[u][j] * (mod + 1 - p[v]) % mod; g[u][j] = (ll)g[u][j] * (mod + 1 - p[v]) % mod; // choose k nodes in subtree v for (int k = max(1, j - sz[u]); k &lt;= min(j, sz[v]); ++k) &#123; f[u][j] = (f[u][j] + (ll)f[u][j - k] * f[v][k]) % mod; g[u][j] = (g[u][j] + (ll)g[u][j - k] * f[v][k] + (ll)f[u][j - k] * g[v][k]) % mod; &#125; &#125; sz[u] += sz[v]; &#125; ++sz[u]; for (int j = sz[u]; j; --j) &#123; f[u][j] = (ll)f[u][j - 1] * p[u] % mod; g[u][j] = (ll)f[u][j - 1] * a[u] % mod; if (j &gt; 1) g[u][j] = (g[u][j] + (ll)g[u][j - 1] * p[u]) % mod; ans[j] = (ans[j] + (ll)g[u][j] * (mod + 1 - pfa)) % mod; // æ³¨æ„è¦ä¿è¯çˆ¶äº²æ²¡æœ‰é€‰ &#125;&#125;int main() &#123; int n = rd(); for (int i = 1; i &lt; n; ++i) &#123; int u = rd(), v = rd(); e[u].push_back(v); e[v].push_back(u); &#125; int sum = 0; for (int i = 1; i &lt;= n; ++i) &#123; a[i] = rd(); sum += a[i]; p[i] = rd(); p[i] = (ll)p[i] * fpow(rd()) % mod; &#125; sum = fpow(sum); for (int i = 1; i &lt;= n; ++i) a[i] = (ll)a[i] * sum % mod; dfs(1, 1, 0); for (int i = 1; i &lt;= n; ++i) printf(&quot;%d\\n&quot;, ans[i]); return 0;&#125; K - Middle Point Graph ç»™ä¸€å¹…å›¾ï¼Œå¯¹æ¯ä¸ªé¡¶ç‚¹ï¼Œåœ¨ä¸‰ç»´ç«‹æ–¹ä½“åŒºåŸŸ \\([0,0,0]\\sim[1,1,1]\\) ä¸­éšæœºä¸€ä¸ªåæ ‡ã€‚ å¯¹æ¯æ¡è¾¹ï¼Œå®šä¹‰ä»–çš„åæ ‡æ˜¯è¿æ¥çš„ä¸¤ä¸ªé¡¶ç‚¹çš„ä¸­ç‚¹ã€‚è¿™æ ·å°±å¾—åˆ°äº† \\(n+m\\) ä¸ªåæ ‡ã€‚ é—®è¿™ \\(n+m\\) ä¸ªåæ ‡ä¸­ï¼Œé€‰å‡ºå››ç‚¹å…±å¹³é¢çš„æ–¹æ¡ˆæ•°çš„æœŸæœ›ã€‚ é¦–å…ˆå¾—çŸ¥é“ä¸‰ç»´ç©ºé—´é‡Œéšæœºä¸€ä¸ªå¹³é¢çš„æ¦‚ç‡æ˜¯ \\(0\\) ï¼Œå› ä¸ºæ˜¯è¿ç»­æ¦‚ç‡ã€‚æ‰€ä»¥å››ä¸ªç‚¹éƒ½å–è‡ªåŸå›¾é¡¶ç‚¹çš„æœŸæœ›æ˜¯ \\(0\\) ã€‚ æ‰€ä»¥å“ªäº›ç‚¹å…±é¢å…¶å®æ˜¯ç¡®å®šçš„ã€‚åˆ†è®¨ç»„æˆæƒ…å†µå³å¯ã€‚æˆ‘çš„åˆ†è®¨å’Œé¢˜è§£ä¸å¤ªä¸€æ ·ï¼š ä¸€æ¡è¾¹çš„ä¸¤é¡¶ç‚¹ + ä¸­ç‚¹ + é¢å¤–çš„ä¸€ä¸ªç‚¹ï¼šé¢å¤–çš„ç‚¹åœ¨å“ªé‡Œéƒ½å’Œä¸€æ¡çº¿å…±é¢ï¼Œæ–¹æ¡ˆæ•°æ˜¯ \\(m(n+m-3)\\) ã€‚ ä¸‰ä¸ªç‚¹é€šè¿‡ä¸¤æ¡è¾¹ç›¸è¿ï¼Œé€‰æ‹©ä¸¤æ¡è¾¹ç»ˆç‚¹ + å¤–ä¾§çš„ä¸¤ä¸ªç«¯ç‚¹ï¼šæ–¹æ¡ˆæ•°æ˜¯ \\(\\sum_u \\frac{deg_u(deg_u- 1)}{2}\\) ï¼Œå³æ¯ä¸ªç‚¹é€‰ä¸¤æ¡è¾¹ã€‚ ä¸‰å…ƒç¯ä¸‰æ¡è¾¹ä¸­ç‚¹ + æŸä¸ªé¡¶ç‚¹ï¼šæ–¹æ¡ˆæ•°æ˜¯ \\(3\\times\\) ä¸‰å…ƒç¯ä¸ªæ•°ã€‚ å››å…ƒç¯çš„å››ä¸ªä¸­ç‚¹ï¼šæ–¹æ¡ˆæ•°æ˜¯å››å…ƒç¯ä¸ªæ•°ã€‚ æ±‚ä¸‰å…ƒç¯å’Œå››å…ƒç¯çš„å¤æ‚åº¦æ˜¯ \\(\\mathcal{O}(m\\sqrt m)\\) çš„ï¼Œç§‘æŠ€ä¸å†èµ˜è¿°ã€‚ å…¶å®å¦‚æœè®¨è®ºæƒ…å†µæƒ³ä¸å…¨çš„è¯ï¼Œå¯ä»¥æš´åŠ›éšæœºç»Ÿè®¡ç„¶åæ‰¾è§„å¾‹ï¼ˆæ³¨é‡Šæ‰çš„ä»£ç å°±æ˜¯èµ›æ—¶æ‰¾è§„å¾‹ç”¨çš„ï¼‰ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MOD=1e9+7;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 500007// struct vec &#123;// double x, y, z;// vec operator + (const vec &amp;b) &#123;return &#123;x + b.x, y + b.y, z + b.z&#125;;&#125;// vec operator - (const vec &amp;b) &#123;return &#123;x - b.x, y - b.y, z - b.z&#125;;&#125;// vec operator / (const double &amp;b) &#123;return &#123;x / b, y / b, z / b&#125;;&#125;// &#125; p[N];// bool det(vec a, vec b, vec c) &#123;// double res = a.x * b.y * c.z +// b.x * c.y * a.z + // c.x * a.y * b.z - // a.x * c.y * b.z -// b.x * a.y * c.z - // c.x * b.y * a.z;// return abs(res) &lt;= 1e-8; // &#125;// inline double randp() &#123;// return 1.0 * rand() / RAND_MAX;// &#125;// inline void work() &#123;// int n = rd(), m = rd();// int k = n;// for (int i = 1; i &lt;= n; ++i) &#123;// p[i].x = randp();// p[i].y = randp();// p[i].z = randp();// &#125;// for (int i = 1; i &lt;= m; ++i) &#123;// int u = rd(), v = rd();// p[++n] = (p[u] + p[v]) / 2;// &#125;// int ans = 0;// for (int a = 1; a &lt;= k; ++a)// for (int b = a + 1; b &lt;= k; ++b)// for (int c = b + 1; c &lt;= n; ++c)// for (int d = c + 1; d &lt;= n; ++d) // if (det(p[b] - p[a], p[c] - p[a], p[d] - p[a])) &#123;// ++ans; printf(&quot;%d %d %d %d\\n&quot;, a, b, c, d);// &#125;// printf(&quot;%d\\n&quot;, ans);// &#125;int n,m,X[N],Y[N],d[N],ti,vis[N],cnt[N];vector&lt;int&gt; e[N],h[N];ll ans3,ans4;inline bool cmp(const int &amp;i,const int &amp;j) &#123;return d[i]&lt;d[j] || (d[i]==d[j] &amp;&amp; i&lt;j);&#125;void workz()&#123; n=rd();m=rd(); for (int i=1;i&lt;=n;i++) d[i]=0,cnt[i]=0,e[i].clear(),h[i].clear(); for (int i=1;i&lt;=m;i++)&#123; X[i]=rd();Y[i]=rd();d[X[i]]++;d[Y[i]]++; h[X[i]].push_back(Y[i]);h[Y[i]].push_back(X[i]); &#125; for (int i=1;i&lt;=m;i++) cmp(X[i],Y[i])?e[X[i]].push_back(Y[i]):e[Y[i]].push_back(X[i]); ans3=0; for (int i=1;i&lt;=m;i++)&#123; ti++;for (auto x:e[X[i]]) vis[x]=ti; for (auto x:e[Y[i]]) if (vis[x]==ti) ans3++; &#125; ans4=0; for (int x=1;x&lt;=n;x++)&#123; for (auto y:h[x]) for (auto z:e[y]) if (cmp(x,z)) ans4+=cnt[z],cnt[z]++; for (auto y:h[x]) for (auto z:e[y]) cnt[z]=0; &#125; ll ans=(ll)m*(n+m-3); for (int i=1;i&lt;=n;i++) ans+=(ll)d[i]*(d[i]-1)/2; ans+=3*ans3;ans+=ans4; printf(&quot;%lld\\n&quot;, ans%MOD);&#125;int main() &#123; for (int t = rd(); t; --t) workz(); return 0;&#125; L - Station of Fate \\(n\\) ä¸ªäººåˆ†æˆ \\(m\\) ä¸ªå¯åŒºåˆ†çš„éç©ºé˜Ÿåˆ—çš„æ–¹æ¡ˆæ•°ã€‚ é¡ºåºæœ‰ \\(n!\\) ç§ï¼Œæ’æ¿æ³•åˆ’åˆ†æˆ \\(m\\) ä¸ªéç©ºåºåˆ—ï¼Œæ€»æ–¹æ¡ˆæ•°ä¸º \\(n!{n-1\\choose m - 1}\\) 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 100007#define mod 998244353int fac[N], ifac[N];inline int fpow(int x, int t) &#123; int res = 1; for (; t; t &gt;&gt;= 1, x = 1ll * x * x % mod) if (t &amp; 1) res = 1ll * res * x % mod; return res;&#125;inline int C(int n, int m) &#123; return 1ll * fac[n] * ifac[m] % mod * ifac[n - m] % mod;&#125;inline void work() &#123; int n = rd(), m = rd(); printf(&quot;%lld\\n&quot;, 1ll * fac[n] * C(n - 1, m - 1) % mod);&#125;int main() &#123; fac[0] = ifac[0] = 1; for (int i = 1; i &lt; N; ++i) fac[i] = 1ll * fac[i - 1] * i % mod; ifac[N - 1] = fpow(fac[N - 1], mod - 2); for (int i = N - 2; i; --i) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % mod; for (int t = rd(); t; --t) work(); return 0;&#125;","categories":[{"name":"Official Contests","slug":"Official-Contests","permalink":"http://blog.gyx.me/categories/Official-Contests/"}],"tags":[{"name":"Constructive Algorithm","slug":"Constructive-Algorithm","permalink":"http://blog.gyx.me/tags/Constructive-Algorithm/"},{"name":"Graphs","slug":"Graphs","permalink":"http://blog.gyx.me/tags/Graphs/"},{"name":"Geometry","slug":"Geometry","permalink":"http://blog.gyx.me/tags/Geometry/"},{"name":"Probabilities","slug":"Probabilities","permalink":"http://blog.gyx.me/tags/Probabilities/"}]},{"title":"2022 CCPC Guangzhou Site","slug":"official/ccpc/22-mianyang","date":"2022-11-13T16:00:00.000Z","updated":"2023-03-20T16:35:32.878Z","comments":true,"path":"official/ccpc/22-mianyang/","link":"","permalink":"http://blog.gyx.me/official/ccpc/22-mianyang/","excerpt":"","text":"æ¯”èµ›åœ°å€ ï¼šCodeforces Gym 104053 å¾…è¡¥ï¼šADFGJ B - Ayano and sequences æ•°æ®ç»“æ„é¢˜ï¼Œèƒ–èƒ–è¡¥æ‰äº†ã€‚é“¾æ¥ *C - Customs Controls 2 ç»™å®šä¸€ä¸ª DAG ï¼Œä¿è¯æ‰€æœ‰ç‚¹éƒ½èƒ½ä» \\(1\\) åˆ°è¾¾ï¼Œä¸”éƒ½èƒ½åˆ°è¾¾ \\(n\\) ã€‚ è¦æ±‚ç»™æ¯ä¸ªç‚¹åˆ†é…ä¸€ä¸ªç‚¹æƒï¼Œä½¿å¾—ä» \\(1\\) åˆ° \\(n\\) çš„æ‰€æœ‰è·¯å¾„ç»è¿‡çš„ç‚¹æƒå’Œç›¸åŒã€‚ å®šä¹‰ \\(dis[u]\\) è¡¨ç¤ºä» \\(1\\) åˆ° \\(u\\) çš„è·ç¦»ï¼Œå¦‚æœè¦ç¬¦åˆæœ€ç»ˆè¦æ±‚ï¼Œæ˜¾ç„¶é¦–å…ˆ \\(dis[u]\\) çš„å€¼è¦å”¯ä¸€ã€‚ è€ƒè™‘å¯¹äºæ¯ä¸ªç‚¹ \\(v\\) ï¼Œå›¾ä¸­å­˜åœ¨ \\(u\\to v\\) çš„è¾¹ï¼Œé‚£ä¹ˆè¿™æ ·çš„ \\(u\\) çš„ \\(dis[u]\\) ä¹Ÿå¿…é¡»ç›¸åŒã€‚ å¹¶æŸ¥é›†æŠŠè¿™æ ·çš„ç‚¹ç¼©ç‚¹ï¼Œé‡å»ºå›¾ï¼Œå› ä¸ºç‚¹æƒæ˜¯æ­£çš„ï¼Œå› æ­¤å¦‚æœå›¾ä¸­å­˜åœ¨ç¯å°±æ— è§£ã€‚ å¦åˆ™æŒ‰ç…§ä» \\(1\\) å¼€å§‹çš„æ‹“æ‰‘åºè®¾å®š \\(dis[u]\\) å³å¯ï¼Œ\\(v\\) çš„ç‚¹æƒå°±æ˜¯ \\(dis[v] - dis[u]\\) çš„å€¼ï¼ˆåŸå›¾ä¸­å­˜åœ¨ \\(u\\to v\\) ï¼‰ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 200007struct DSU &#123; int f[N]; inline void reset(int x) &#123;for (int i = 1; i &lt;= x; ++i) f[i] = i;&#125; int find(int x) &#123;return x == f[x] ? x : f[x] = find(f[x]);&#125; bool merge(int u, int v) &#123; u = find(u); v = find(v); return (u == v ? false : (f[u] = v, true)); &#125; &#125; dsu;int deg[N], tag[N], val[N];queue&lt;int&gt; q;vector&lt;int&gt; in[N], out[N];inline void work() &#123; int n = rd(), m = rd(); dsu.reset(n); for (int i = 1; i &lt;= n; ++i) &#123;deg[i] = 0; in[i].clear(); out[i].clear();&#125; for (int i = 1; i &lt;= m; ++i) &#123; int u = rd(), v = rd(); in[v].push_back(u); &#125; for (int u = 1; u &lt;= n; ++u) if (!in[u].empty()) &#123; int sy = in[u][0]; for (auto x : in[u]) dsu.merge(x, sy); &#125; for (int u = 1; u &lt;= n; ++u) &#123; int U = dsu.find(u); for (auto v : in[u]) &#123; int V = dsu.find(v); ++deg[U]; out[V].push_back(U); &#125; &#125; int tot = 0, cnt = 0; for (int i = 1; i &lt;= n; ++i) if (dsu.find(i) == i) &#123; ++tot; if (!deg[i]) q.push(i); &#125; while (!q.empty()) &#123; --tot; int u = q.front(); q.pop(); tag[u] = ++cnt; for (auto v : out[u]) &#123; --deg[v]; if (!deg[v]) q.push(v); &#125; &#125; if (tot) &#123;puts(&quot;No&quot;); return;&#125; puts(&quot;Yes&quot;); for (int i = 1; i &lt;= n; ++i) val[i] = tag[dsu.find(i)]; for (int i = 1; i &lt;= n; ++i) &#123; int ans = val[i]; if (!in[i].empty()) ans -= val[in[i][0]]; if (i &lt; n) printf(&quot;%d &quot;, ans); else printf(&quot;%d\\n&quot;, ans); &#125;&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; E - Elevator ç­¾åˆ°é¢˜ï¼Œé€†åºæ•°ã€‚è¦æŠŠ \\(x\\) å‰é¢çš„å˜æˆ \\(&gt; x\\) ï¼Œåé¢çš„å˜æˆ \\(\\ge x\\) ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;vector&lt;int&gt; s, s1;#define N 500007int a[N], c[N];#define lowbit(x) ((x) &amp; -(x))inline void add(int p) &#123; for (; p &lt; N; p += lowbit(p)) ++c[p];&#125;inline int sum(int p) &#123; int res = 0; for (; p; p -= lowbit(p)) res += c[p]; return res;&#125;ll presum[N];int main() &#123; int n = rd(), m = rd() - 2; for (int i = 1; i &lt;= n; ++i) &#123; a[i] = rd(); s.push_back(a[i]); &#125; sort(s.begin(), s.end()); s1 = s; for (int i = 1; i &lt;= n; ++i) presum[i] = presum[i - 1] + s1[i - 1]; s.erase(unique(s.begin(), s.end()), s.end()); auto calc = [&amp;](int x) &#123; return lower_bound(s.begin(), s.end(), x) - s.begin() + 1; &#125;; for (int i = 1; i &lt;= n; ++i) &#123; int nw = calc(a[i]); ll tot = sum(nw); add(nw); int p = lower_bound(s1.begin(), s1.end(), a[i]) - s1.begin() + 1; tot += 1ll * p * a[i] - presum[p]; if (tot &gt; m) puts(&quot;-1&quot;); else printf(&quot;%lld\\n&quot;, tot); &#125; return 0;&#125; H - GameX ç»™å®šä¸€ä¸ªæ•°é›†ï¼ŒåŒæ–¹è½®æµæ“ä½œ \\(k\\) è½®ï¼Œæ¯ä¸ªäººå¾€æ•°é›†é‡ŒåŠ å…¥ä¸€ä¸ªéè´Ÿæ•´æ•°ã€‚ å…ˆæ‰‹æƒ³è®©æœ€ç»ˆæ•°é›† MEX æ˜¯å¶æ•°ï¼Œåæ‰‹æƒ³è¦æ˜¯å¥‡æ•°ï¼Œé—®æœ€ç»ˆç»“æœã€‚ å…ˆæ‰‹æƒ³è®©æœ€ç»ˆç»“æœæ˜¯å¶æ•°ï¼Œåˆ™å¿…ä¸ä¼šåŠ å…¥å¶æ•°ï¼ŒåªåŠ å…¥å¥‡æ•°ï¼›åŒç†åæ‰‹åªä¼šåŠ å…¥å¶æ•°ã€‚ å†æ³¨æ„åˆ°å¦‚æœå°çš„å¥‡æ•°è¿˜æ²¡åŠ ï¼ŒåŠ å¤§çš„å¥‡æ•°æ˜¯æ²¡ç”¨çš„ï¼Œæ‰€ä»¥ä¸€å®šä¼šä»å°åˆ°å¤§åŠ ã€‚æ¨¡æ‹Ÿå³å¯ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 2000007bool vis[N];int a[N];vector&lt;int&gt; s;inline void work() &#123; s.clear(); int n = rd(), k = rd(); for (int i = 1; i &lt;= n; ++i) &#123; a[i] = rd(); vis[a[i]] = true; &#125; int A = 1, B = 0; for (int i = 1; i &lt;= k; ++i) &#123; while (vis[A]) A += 2; vis[A] = true; s.push_back(A); while (vis[B]) B += 2; vis[B] = true; s.push_back(B); &#125; int mx = 0; while (vis[mx]) ++mx; puts((mx &amp; 1) ? &quot;Bob&quot; : &quot;Alice&quot;); for (int i = 1; i &lt;= n; ++i) vis[a[i]] =false; for (auto x : s) vis[x] = false;&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; *I - Infection ç»™ä¸€æ£µæ ‘ï¼Œæ¯ä¸ªç‚¹æœ‰ \\(\\frac{a_i}{\\sum a_i}\\) çš„æ¦‚ç‡è¢«é€‰ä½œæ ¹ï¼Œç„¶åè¢«æŸ“é»‘ã€‚ è‹¥ \\(u\\) çˆ¶èŠ‚ç‚¹è¢«æŸ“é»‘ï¼Œåˆ™ \\(u\\) è¢«æŸ“é»‘çš„æ¦‚ç‡ä¸º \\(p_u = \\frac{b_u}{c_u}\\) ï¼Œé—®æŸ“é»‘ \\(k=1,2,\\dots, n\\) ä¸ªç‚¹çš„æ¦‚ç‡æ¨¡ \\(10^9+7\\) ã€‚ è€ƒè™‘ä¸€ä¸ªæ ‘ä¸Šè¿é€šç‚¹é›†å¯¹ç­”æ¡ˆçš„è´¡çŒ®ï¼š \\[ contri_S = \\sum_{root\\in S}\\bigg(\\frac{a_{root}}{\\sum a}\\prod_{u\\in S,u\\ne root} p_u\\prod_{(u,v)\\in Tree, v\\not\\in S,u\\in S}(1-p_v)\\bigg) \\] è®¾ \\(F[i][j]\\) è¡¨ç¤ºä»¥ \\(i\\) ä¸ºæ ¹çš„ç‚¹é›†ä¸­æœ‰ \\(j\\) ä¸ªç‚¹ï¼Œä¸”æœªé€‰å®šåˆå§‹æ„ŸæŸ“ç‚¹çš„è´¡çŒ®å’Œã€‚ \\(G[i][j]\\) è¡¨ç¤ºå·²é€‰å®šåˆå§‹æ„ŸæŸ“ç‚¹çš„è´¡çŒ®å’Œã€‚ æ ‘å½¢èƒŒåŒ…è½¬ç§»ï¼Œå¤æ‚åº¦ \\(\\mathcal{O}(n^2)\\) ã€‚æ¯ä¸ªç‚¹æŠŠ \\(G\\) æ•°ç»„è´¡çŒ®åˆ°ç­”æ¡ˆä¸­å³å¯ã€‚æ ‘å½¢èƒŒåŒ…å®ç°è¿˜æ˜¯å¾ˆç²¾ç»†çš„... 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 2007#define mod 1000000007vector&lt;int&gt; e[N];inline int fpow(int x, int t = mod - 2) &#123; int res = 1; for (; t; t &gt;&gt;= 1, x = 1ll * x * x % mod) if (t &amp; 1) res = 1ll * res * x % mod; return res;&#125;// f[u][v] : choose j nodes in subtree u, without root// g[u][v] : choose j nodes in subtree u, already choose a rootint a[N], p[N], sz[N], f[N][N], g[N][N], ans[N];void dfs(int u, int fa, int pfa) &#123; f[u][0] = 1; for (auto v : e[u]) if (v != fa) &#123; dfs(v, u, p[u]); for (int j = sz[u] + sz[v]; j &gt;= 0; --j) &#123; // è¿™é‡Œæœ¬æ¥åº”è¯¥å¼€ä¸€ä¸ªå¦å¤–çš„æ•°ç»„æ¥å­˜å€¼ï¼Œæœ€åå†èµ‹å€¼å›å»çš„ï¼Œä½†æ˜¯æ³¨æ„åˆ°k=0çš„è½¬ç§»éå¸¸å¥½å†™å°±ç›´æ¥èµ‹å€¼äº† // failed at v f[u][j] = (ll)f[u][j] * (mod + 1 - p[v]) % mod; g[u][j] = (ll)g[u][j] * (mod + 1 - p[v]) % mod; // choose k nodes in subtree v for (int k = max(1, j - sz[u]); k &lt;= min(j, sz[v]); ++k) &#123; f[u][j] = (f[u][j] + (ll)f[u][j - k] * f[v][k]) % mod; g[u][j] = (g[u][j] + (ll)g[u][j - k] * f[v][k] + (ll)f[u][j - k] * g[v][k]) % mod; &#125; &#125; sz[u] += sz[v]; &#125; ++sz[u]; for (int j = sz[u]; j; --j) &#123; f[u][j] = (ll)f[u][j - 1] * p[u] % mod; g[u][j] = (ll)f[u][j - 1] * a[u] % mod; if (j &gt; 1) g[u][j] = (g[u][j] + (ll)g[u][j - 1] * p[u]) % mod; ans[j] = (ans[j] + (ll)g[u][j] * (mod + 1 - pfa)) % mod; // æ³¨æ„è¦ä¿è¯çˆ¶äº²æ²¡æœ‰é€‰ &#125;&#125;int main() &#123; int n = rd(); for (int i = 1; i &lt; n; ++i) &#123; int u = rd(), v = rd(); e[u].push_back(v); e[v].push_back(u); &#125; int sum = 0; for (int i = 1; i &lt;= n; ++i) &#123; a[i] = rd(); sum += a[i]; p[i] = rd(); p[i] = (ll)p[i] * fpow(rd()) % mod; &#125; sum = fpow(sum); for (int i = 1; i &lt;= n; ++i) a[i] = (ll)a[i] * sum % mod; dfs(1, 1, 0); for (int i = 1; i &lt;= n; ++i) printf(&quot;%d\\n&quot;, ans[i]); return 0;&#125; K - Middle Point Graph ç»™ä¸€å¹…å›¾ï¼Œå¯¹æ¯ä¸ªé¡¶ç‚¹ï¼Œåœ¨ä¸‰ç»´ç«‹æ–¹ä½“åŒºåŸŸ \\([0,0,0]\\sim[1,1,1]\\) ä¸­éšæœºä¸€ä¸ªåæ ‡ã€‚ å¯¹æ¯æ¡è¾¹ï¼Œå®šä¹‰ä»–çš„åæ ‡æ˜¯è¿æ¥çš„ä¸¤ä¸ªé¡¶ç‚¹çš„ä¸­ç‚¹ã€‚è¿™æ ·å°±å¾—åˆ°äº† \\(n+m\\) ä¸ªåæ ‡ã€‚ é—®è¿™ \\(n+m\\) ä¸ªåæ ‡ä¸­ï¼Œé€‰å‡ºå››ç‚¹å…±å¹³é¢çš„æ–¹æ¡ˆæ•°çš„æœŸæœ›ã€‚ é¦–å…ˆå¾—çŸ¥é“ä¸‰ç»´ç©ºé—´é‡Œéšæœºä¸€ä¸ªå¹³é¢çš„æ¦‚ç‡æ˜¯ \\(0\\) ï¼Œå› ä¸ºæ˜¯è¿ç»­æ¦‚ç‡ã€‚æ‰€ä»¥å››ä¸ªç‚¹éƒ½å–è‡ªåŸå›¾é¡¶ç‚¹çš„æœŸæœ›æ˜¯ \\(0\\) ã€‚ æ‰€ä»¥å“ªäº›ç‚¹å…±é¢å…¶å®æ˜¯ç¡®å®šçš„ã€‚åˆ†è®¨ç»„æˆæƒ…å†µå³å¯ã€‚æˆ‘çš„åˆ†è®¨å’Œé¢˜è§£ä¸å¤ªä¸€æ ·ï¼š ä¸€æ¡è¾¹çš„ä¸¤é¡¶ç‚¹ + ä¸­ç‚¹ + é¢å¤–çš„ä¸€ä¸ªç‚¹ï¼šé¢å¤–çš„ç‚¹åœ¨å“ªé‡Œéƒ½å’Œä¸€æ¡çº¿å…±é¢ï¼Œæ–¹æ¡ˆæ•°æ˜¯ \\(m(n+m-3)\\) ã€‚ ä¸‰ä¸ªç‚¹é€šè¿‡ä¸¤æ¡è¾¹ç›¸è¿ï¼Œé€‰æ‹©ä¸¤æ¡è¾¹ç»ˆç‚¹ + å¤–ä¾§çš„ä¸¤ä¸ªç«¯ç‚¹ï¼šæ–¹æ¡ˆæ•°æ˜¯ \\(\\sum_u \\frac{deg_u(deg_u- 1)}{2}\\) ï¼Œå³æ¯ä¸ªç‚¹é€‰ä¸¤æ¡è¾¹ã€‚ ä¸‰å…ƒç¯ä¸‰æ¡è¾¹ä¸­ç‚¹ + æŸä¸ªé¡¶ç‚¹ï¼šæ–¹æ¡ˆæ•°æ˜¯ \\(3\\times\\) ä¸‰å…ƒç¯ä¸ªæ•°ã€‚ å››å…ƒç¯çš„å››ä¸ªä¸­ç‚¹ï¼šæ–¹æ¡ˆæ•°æ˜¯å››å…ƒç¯ä¸ªæ•°ã€‚ æ±‚ä¸‰å…ƒç¯å’Œå››å…ƒç¯çš„å¤æ‚åº¦æ˜¯ \\(\\mathcal{O}(m\\sqrt m)\\) çš„ï¼Œç§‘æŠ€ä¸å†èµ˜è¿°ã€‚ å…¶å®å¦‚æœè®¨è®ºæƒ…å†µæƒ³ä¸å…¨çš„è¯ï¼Œå¯ä»¥æš´åŠ›éšæœºç»Ÿè®¡ç„¶åæ‰¾è§„å¾‹ï¼ˆæ³¨é‡Šæ‰çš„ä»£ç å°±æ˜¯èµ›æ—¶æ‰¾è§„å¾‹ç”¨çš„ï¼‰ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MOD=1e9+7;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 500007// struct vec &#123;// double x, y, z;// vec operator + (const vec &amp;b) &#123;return &#123;x + b.x, y + b.y, z + b.z&#125;;&#125;// vec operator - (const vec &amp;b) &#123;return &#123;x - b.x, y - b.y, z - b.z&#125;;&#125;// vec operator / (const double &amp;b) &#123;return &#123;x / b, y / b, z / b&#125;;&#125;// &#125; p[N];// bool det(vec a, vec b, vec c) &#123;// double res = a.x * b.y * c.z +// b.x * c.y * a.z + // c.x * a.y * b.z - // a.x * c.y * b.z -// b.x * a.y * c.z - // c.x * b.y * a.z;// return abs(res) &lt;= 1e-8; // &#125;// inline double randp() &#123;// return 1.0 * rand() / RAND_MAX;// &#125;// inline void work() &#123;// int n = rd(), m = rd();// int k = n;// for (int i = 1; i &lt;= n; ++i) &#123;// p[i].x = randp();// p[i].y = randp();// p[i].z = randp();// &#125;// for (int i = 1; i &lt;= m; ++i) &#123;// int u = rd(), v = rd();// p[++n] = (p[u] + p[v]) / 2;// &#125;// int ans = 0;// for (int a = 1; a &lt;= k; ++a)// for (int b = a + 1; b &lt;= k; ++b)// for (int c = b + 1; c &lt;= n; ++c)// for (int d = c + 1; d &lt;= n; ++d) // if (det(p[b] - p[a], p[c] - p[a], p[d] - p[a])) &#123;// ++ans; printf(&quot;%d %d %d %d\\n&quot;, a, b, c, d);// &#125;// printf(&quot;%d\\n&quot;, ans);// &#125;int n,m,X[N],Y[N],d[N],ti,vis[N],cnt[N];vector&lt;int&gt; e[N],h[N];ll ans3,ans4;inline bool cmp(const int &amp;i,const int &amp;j) &#123;return d[i]&lt;d[j] || (d[i]==d[j] &amp;&amp; i&lt;j);&#125;void workz()&#123; n=rd();m=rd(); for (int i=1;i&lt;=n;i++) d[i]=0,cnt[i]=0,e[i].clear(),h[i].clear(); for (int i=1;i&lt;=m;i++)&#123; X[i]=rd();Y[i]=rd();d[X[i]]++;d[Y[i]]++; h[X[i]].push_back(Y[i]);h[Y[i]].push_back(X[i]); &#125; for (int i=1;i&lt;=m;i++) cmp(X[i],Y[i])?e[X[i]].push_back(Y[i]):e[Y[i]].push_back(X[i]); ans3=0; for (int i=1;i&lt;=m;i++)&#123; ti++;for (auto x:e[X[i]]) vis[x]=ti; for (auto x:e[Y[i]]) if (vis[x]==ti) ans3++; &#125; ans4=0; for (int x=1;x&lt;=n;x++)&#123; for (auto y:h[x]) for (auto z:e[y]) if (cmp(x,z)) ans4+=cnt[z],cnt[z]++; for (auto y:h[x]) for (auto z:e[y]) cnt[z]=0; &#125; ll ans=(ll)m*(n+m-3); for (int i=1;i&lt;=n;i++) ans+=(ll)d[i]*(d[i]-1)/2; ans+=3*ans3;ans+=ans4; printf(&quot;%lld\\n&quot;, ans%MOD);&#125;int main() &#123; for (int t = rd(); t; --t) workz(); return 0;&#125; L - Station of Fate \\(n\\) ä¸ªäººåˆ†æˆ \\(m\\) ä¸ªå¯åŒºåˆ†çš„éç©ºé˜Ÿåˆ—çš„æ–¹æ¡ˆæ•°ã€‚ é¡ºåºæœ‰ \\(n!\\) ç§ï¼Œæ’æ¿æ³•åˆ’åˆ†æˆ \\(m\\) ä¸ªéç©ºåºåˆ—ï¼Œæ€»æ–¹æ¡ˆæ•°ä¸º \\(n!{n-1\\choose m - 1}\\) 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 100007#define mod 998244353int fac[N], ifac[N];inline int fpow(int x, int t) &#123; int res = 1; for (; t; t &gt;&gt;= 1, x = 1ll * x * x % mod) if (t &amp; 1) res = 1ll * res * x % mod; return res;&#125;inline int C(int n, int m) &#123; return 1ll * fac[n] * ifac[m] % mod * ifac[n - m] % mod;&#125;inline void work() &#123; int n = rd(), m = rd(); printf(&quot;%lld\\n&quot;, 1ll * fac[n] * C(n - 1, m - 1) % mod);&#125;int main() &#123; fac[0] = ifac[0] = 1; for (int i = 1; i &lt; N; ++i) fac[i] = 1ll * fac[i - 1] * i % mod; ifac[N - 1] = fpow(fac[N - 1], mod - 2); for (int i = N - 2; i; --i) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % mod; for (int t = rd(); t; --t) work(); return 0;&#125;","categories":[{"name":"Official Contests","slug":"Official-Contests","permalink":"http://blog.gyx.me/categories/Official-Contests/"}],"tags":[{"name":"Constructive Algorithm","slug":"Constructive-Algorithm","permalink":"http://blog.gyx.me/tags/Constructive-Algorithm/"},{"name":"Graphs","slug":"Graphs","permalink":"http://blog.gyx.me/tags/Graphs/"},{"name":"Geometry","slug":"Geometry","permalink":"http://blog.gyx.me/tags/Geometry/"},{"name":"Probabilities","slug":"Probabilities","permalink":"http://blog.gyx.me/tags/Probabilities/"}]},{"title":"2020-2021 ICPC Asia Yinchuan Regional","slug":"official/icpc/20-yinchuan","date":"2022-11-08T16:00:00.000Z","updated":"2023-03-20T16:36:05.381Z","comments":true,"path":"official/icpc/20-yinchuan/","link":"","permalink":"http://blog.gyx.me/official/icpc/20-yinchuan/","excerpt":"","text":"Summary æ¯”èµ›åœ°å€ ï¼šCodeforces Gym 104022 å¾…è¡¥ï¼šCFIL éš¾åº¦ï¼šAEJ - GK - BDM - CFHIL A - Best Player ç»™å®šä¸€ä¸ªä¸‰ç»´ç‚¹é›†ï¼Œé—®å»æ‰å“ªä¸€ç»´ä¹‹åæœ¬è´¨ä¸åŒçš„ç‚¹æœ€å¤šã€‚ æ¨¡æ‹Ÿã€‚map&lt;pair&lt;int, int&gt;, bool&gt; å»é‡ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 107int x[N], y[N], z[N];map&lt;pair&lt;int, int&gt;, bool&gt; vis;int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; x[i] = rd(); y[i] = rd(); z[i] = rd(); &#125; int X = 0, Y = 0, Z = 0; for (int i = 1; i &lt;= n; ++i) &#123; pii nw = make_pair(y[i], z[i]); if (vis[nw]) continue; vis[nw] = true; ++X; &#125; vis.clear(); for (int i = 1; i &lt;= n; ++i) &#123; pii nw = make_pair(x[i], y[i]); if (vis[nw]) continue; vis[nw] = true; ++Z; &#125; vis.clear(); for (int i = 1; i &lt;= n; ++i) &#123; pii nw = make_pair(x[i], z[i]); if (vis[nw]) continue; vis[nw] = true; ++Y; &#125; if (X &gt;= Y &amp;&amp; X &gt;= Z) puts(&quot;X&quot;); else if (Y &gt;= X &amp;&amp; Y &gt;= Z) puts(&quot;Y&quot;); else puts(&quot;Z&quot;); return 0;&#125; *B - The Great Wall ä¸€ä¸ªé•¿åº¦ä¸º \\(n\\ (1\\le n\\le 10^4)\\) çš„æ•°åˆ— \\(a_1,a_2,\\dots,a_n\\)ï¼Œåˆ’åˆ†æˆ \\(k\\) æ®µï¼Œå‡è®¾ç¬¬ \\(i\\) æ®µæ˜¯ \\([l_i,r_i]\\) ï¼Œæœ€å¤§åŒ–ï¼š \\[ \\sum_{i=1}^k\\bigg(\\max_{l_i\\le j\\le r_i} a_j-\\min_{l_i\\le j\\le r_i} a_j\\bigg) \\] å¯¹ \\(k=1,2,\\dots,n\\) æ±‚å‡ºç­”æ¡ˆã€‚ Trick é¢˜ï¼Œéœ€è¦è½¬æ¢ä¸€ä¸‹ã€‚æ³¨æ„åˆ° \\[ \\max_{l_i\\le j\\le r_i} a_j-\\min_{l_i\\le j\\le r_i} a_j = \\max_{l_i\\le j,k\\le r_i}\\big(a_j-a_k\\big) \\] ç›®æ ‡ä¼˜åŒ–çš„æ–¹å‘ï¼ˆè¦æ±‚å·®å€¼å’Œæœ€å¤§ï¼‰å’Œå·®å€¼ä¼˜åŒ–æ–¹å‘ï¼ˆå·®å€¼æœ€å¤§ï¼‰ç›¸åŒï¼Œæ‰€ä»¥é—®é¢˜å¯ä»¥å˜æˆæœ€å¤§åŒ–æ¯æ®µå†…ä»»é€‰ä¸¤ä¸ªçš„å·®å€¼å’Œã€‚ è®¾ f[i][j][0/1/2/3] è¡¨ç¤ºå‰ \\(i\\) ä¸ªåˆ†äº† \\(j\\) æ®µï¼Œå½“å‰ä¸€ä¸ªéƒ½æ²¡é€‰ / åªé€‰äº†ä¸€ä¸ª \\(-a_k\\) / åªé€‰äº†ä¸€ä¸ª \\(+a_j\\) / ä¸¤ä¸ªéƒ½é€‰äº†çš„æœ€å¤§å’Œã€‚ æ³¨æ„åˆå§‹åŒ–ä¸º \\(-\\infty\\) ï¼ˆå› ä¸º f[i][j][1] çŠ¶æ€å¯èƒ½æœ‰è´Ÿå€¼ï¼‰ï¼Œè½¬ç§»è¦è€ƒè™‘ \\(j=k\\) ï¼ˆé€‰åœ¨åŒä¸€ä¸ªæ•°ï¼‰çš„æƒ…å†µã€‚ ç©ºé—´æ¯”è¾ƒç´§ï¼Œéœ€è¦æŠŠç¬¬ä¸€ç»´æ»šåŠ¨æ•°ç»„ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;template&lt;typename T&gt;inline bool getmax(T &amp;a, T b) &#123;return a &lt; b ? (a = b, true) : false;&#125;#define N 10007#define mp make_pair#define pb push_backint a[N], f[2][N][4];// 1 : - a[y]// 2 : a[x]// 3 : a[x] - a[y]int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) a[i] = rd(); memset(f, 0xcf, sizeof(f)); f[0][0][3] = 0; for (int i = 1; i &lt;= n; ++i) &#123; int nw = (i &amp; 1); int pre = 1 - nw; for (int j = 1; j &lt;= n; ++j) for (int k = 0; k &lt; 4; ++k) f[nw][j][k] = f[pre][j][k]; for (int j = 1; j &lt;= n; ++j) &#123; getmax(f[nw][j][0], f[pre][j - 1][3]); getmax(f[nw][j][1], max(f[pre][j][0], f[pre][j - 1][3]) - a[i]); getmax(f[nw][j][2], max(f[pre][j][0], f[pre][j - 1][3]) + a[i]); getmax(f[nw][j][3], max(&#123;f[pre][j - 1][3], f[pre][j][1] + a[i], f[pre][j][2] - a[i]&#125;)); &#125; &#125; for (int j = 1; j &lt;= n; ++j) printf(&quot;%d\\n&quot;, f[n &amp; 1][j][3]); return 0; &#125; *D - Farm \\(n\\ (n\\le 10^5)\\) ä¸ªç‚¹çš„å›¾ï¼Œæœ‰ \\(m\\ (m\\le 5\\times 10^5)\\) æ¡è¾¹å¯ä»¥é€‰æ‹©æ˜¯å¦åŠ å…¥ï¼Œæ±‚è¿é€šæœ€å°ä»£ä»·ã€‚ æ­¤å¤–æœ‰ \\(q\\ (q\\le 16)\\) ä¸ªè¦æ±‚ï¼Œæ¯ä¸ªè¦æ±‚ \\(a_i\\) å’Œ \\(b_i\\) ä¸¤æ¡è¾¹ä¸­è‡³å°‘æœ‰ä¸€æ¡è¢«åŠ å…¥ã€‚ å…ˆæŠŠè¦æ±‚æ¶‰åŠåˆ°çš„ \\(2q\\) æ¡è¾¹åŠ å…¥åˆ°å›¾ä¸­ï¼Œåœ¨æ­¤åŸºç¡€ä¸Šè·‘ Kruskal ï¼Œæ–°åŠ å…¥çš„è¾¹é›†ç§°ä½œ out ã€‚ out ä¸­çš„è¾¹ä¸€å®šæ˜¯å­˜åœ¨åœ¨æœ€ç»ˆç­”æ¡ˆä¸­çš„ã€‚å†æŠŠå›¾æ¸…ç©ºï¼ŒåªåŠ å…¥ out ä¸­çš„è¾¹ï¼Œç„¶åæŒ‰ç…§è¿é€šæ€§ç¼©ç‚¹ã€‚ è¿™æ ·å­é¡¶ç‚¹æœ€å¤šåªæœ‰ \\(64\\) ä¸ªï¼Œæœ‰æ„ä¹‰çš„è¾¹æœ€å¤šåªæœ‰ \\(\\frac{64\\times 63}{2}=2016\\) æ¡ã€‚ ç„¶å \\(2^q\\) æšä¸¾æ¯ä¸ªæ¡ä»¶è‡³å°‘é€‰äº†å“ªä¸€ä¸ªï¼Œç„¶åæš´åŠ›æŠŠè¿™äº›è¾¹åŠ å…¥ï¼Œç„¶åå¯¹è¿™ \\(2016\\) æ¡è¾¹å†è·‘ Kruskal å³å¯ã€‚ å› ä¸ºæ¯æ¬¡ä¸ç”¨é‡æ–°æ’åºï¼Œæ‰€ä»¥å¤æ‚åº¦æ˜¯ \\(\\mathcal{O}(2^q\\times 2016+m\\log m)\\) çš„ï¼Œçº¦ \\(2\\times 10^8\\) å‡ ä¹æ²¡å¸¸æ•°ã€‚ *å‘ï¼šç¼©ç‚¹ä¹‹åæ¯æ¡è¾¹çš„é¡¶ç‚¹è¦ç»´æŠ¤ï¼Œä¸èƒ½ç”¨çš„æ—¶å€™å† find ï¼Œå› ä¸ºæ¯æ¬¡å¹¶æŸ¥é›†ä¸æ˜¯æ‰€æœ‰ç‚¹éƒ½æ¢å¤ï¼Œfind ä¼šæ‰¾åˆ°é”™è¯¯çš„ä½ç½®ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 100007#define M 500007#define all(s) (s).begin(), (s).end()struct edge &#123;int u, v, w;&#125; e[M];vector&lt;int&gt; vertex, sel;vector&lt;edge&gt; E, out;map&lt;pair&lt;int, int&gt;, bool&gt; vis;int f[N], id[20][2];int find(int x) &#123;return x == f[x] ? x : f[x] = find(f[x]);&#125;inline bool merge(int u, int v) &#123; u = find(u); v = find(v); return u == v ? false : (f[u] = v, true);&#125;int main() &#123; int n = rd(), m = rd(); for (int i = 1; i &lt;= n; ++i) f[i] = i; for (int i = 1; i &lt;= m; ++i) &#123; int u = rd(), v = rd(), w = rd(); E.push_back(e[i] = &#123;u, v, w&#125;); &#125; sort(all(E), [&amp;](edge &amp;a, edge &amp;b)&#123;return a.w &lt; b.w;&#125;); int q = rd(), cnt = n - 1; for (int i = 0; i &lt; q; ++i) for (int j = 0; j &lt;= 1; ++j) &#123; id[i][j] = rd(); cnt -= merge(e[id[i][j]].u, e[id[i][j]].v); &#125; int add = 0; for (auto ed : E) if (merge(ed.u, ed.v)) &#123;--cnt; add += ed.w; out.push_back(ed);&#125; if (cnt) &#123;puts(&quot;-1&quot;); return 0;&#125; // not connected int ans = 1e9; for (int i = 1; i &lt;= n; ++i) f[i] = i; for (auto ed : out) merge(ed.u, ed.v); for (int i = 1; i &lt;= n; ++i) if (f[i] == i) vertex.push_back(i); for (int i = 1; i &lt;= m; ++i) &#123; e[i].u = find(e[i].u); e[i].v = find(e[i].v); &#125; for (auto ed : E) &#123; // reduction int u = find(ed.u), v = find(ed.v); if (u == v || vis[make_pair(u, v)]) continue; vis[make_pair(u, v)] = true; E[cnt++] = &#123;u, v, ed.w&#125;; &#125; E.resize(cnt); for (int i = 0; i &lt; (1 &lt;&lt; q); ++i) &#123; int tmp = 0; sel.clear(); for (auto x : vertex) f[x] = x; for (int j = 0; j &lt; q; ++j) sel.push_back(id[j][(i &gt;&gt; j) &amp; 1]); sort(all(sel)); sel.erase(unique(all(sel)), sel.end()); for (auto ID : sel) &#123;tmp += e[ID].w; merge(e[ID].u, e[ID].v);&#125; for (auto ed : E) if (merge(ed.u, ed.v)) tmp += ed.w; ans = min(ans, tmp); &#125; printf(&quot;%d\\n&quot;, ans + add); return 0;&#125; E - Isomerism é˜…è¯»ç†è§£ï¼Œèƒ–èƒ–åšçš„ã€‚ 123456789101112131415161718192021222324252627282930313233343536#include&lt;map&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;iostream&gt;using namespace std;int te,A,B,C,D;map&lt;string,int&gt; f;void readi(int &amp;x)&#123; static string s; cin&gt;&gt;s; x=f[s];&#125;int main()&#123; f[&quot;-F&quot;]=8; f[&quot;-Cl&quot;]=7; f[&quot;-Br&quot;]=6; f[&quot;-I&quot;]=5; f[&quot;-CH3&quot;]=4; f[&quot;-CH2CH3&quot;]=3; f[&quot;-CH2CH2CH3&quot;]=2; f[&quot;-H&quot;]=1; for (scanf(&quot;%d&quot;,&amp;te);te;te--)&#123; readi(A);readi(B);readi(C);readi(D); if (A==C || B==D) puts(&quot;None&quot;); else if (A==B || A==D || B==C || C==D)&#123; if (A==B || C==D) puts(&quot;Cis&quot;); else puts(&quot;Trans&quot;); &#125; else &#123; if (A&gt;C &amp;&amp; B&gt;D || A&lt;C &amp;&amp; B&lt;D) puts(&quot;Zasamman&quot;); else puts(&quot;Entgegen&quot;); &#125; &#125; return 0;&#125; G - Photograph \\(n\\ (n\\le 10^5)\\) ä¸ªäººç¼–å· \\(1\\sim n\\) ï¼Œç¼–å·ä¸º \\(i\\) çš„äººèº«é«˜ \\(h_i\\) ï¼Œç°åœ¨è¦å»æ‹åˆç…§ã€‚ ç»™å®šä¸€ä¸ª \\(1\\sim n\\) çš„æ’åˆ— \\(p\\) ï¼Œä»£è¡¨ \\(n\\) ä¸ªäººæ¥çš„é¡ºåºï¼Œåˆå§‹æ²¡äººï¼Œç¬¬ \\(i\\) ä¸ªåŠ å…¥çš„æ˜¯ç¼–å·ä¸º \\(p_i\\) çš„äººã€‚ æ¯ä¸ªäººåŠ å…¥ä¹‹åï¼Œéƒ½è¦æ–°æ‹ä¸€å¼ ç…§ç‰‡ï¼Œä¹Ÿå°±æ˜¯ä¸€å…±ä¼šæ‹ \\(n\\) å¼ ç…§ç‰‡ã€‚ æ‹ç…§ç‰‡æ—¶ï¼Œæ‰€æœ‰äººä¼šæŒ‰ç…§ç¼–å·ä»å°åˆ°å¤§æ’åˆ—ï¼Œç„¶åå®šä¹‰ç…§ç‰‡çš„å’Œè°åº¦ä¸ºç›¸é‚»ä¸¤ä¸ªäººèº«é«˜å·®å€¼çš„å¹³æ–¹å’Œã€‚ å½¢å¼åŒ–çš„ï¼Œå¯¹äºç¬¬ \\(k\\) å¼ ç…§ç‰‡ï¼Œå‡è®¾å°† \\(p_1,p_2,\\dots,p_k\\) ä»å°åˆ°å¤§æ’åºåä¸º \\(q_1,q_2,\\dots, q_k\\) ï¼Œå’Œè°åº¦ä¸º \\(\\sum_{i=1}^{k-1}(h_{q_i}-h_{q_{i+1}})^2\\) ç°è¯·ä½ æ±‚å‡º \\(n\\) å¼ ç…§ç‰‡çš„å’Œè°åº¦ä¹‹å’Œã€‚ æ¥ä¸‹æ¥ï¼Œ\\(Q\\ (Q\\le 100)\\) æ¬¡è¯¢é—®ï¼Œæ¯æ¬¡å°†åºåˆ—å‘å·¦ Shift \\((k+lastans)\\) æ¬¡ï¼Œå†æ±‚ç­”æ¡ˆã€‚ æ—¶é—´å€’æµï¼Œå¼€å§‹æ‰€æœ‰äººéƒ½åœ¨ï¼Œæ¯æ¬¡ç›¸å½“äºæŠŠä¸¤ä¸ªåŒºé—´åˆå¹¶ï¼Œé“¾è¡¨ç»´æŠ¤ã€‚å¤æ‚åº¦ \\(O(nQ)\\) ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define M 10007#define N 100007#define mp make_pairint h[N], p[N], l[N], r[N];set&lt;int&gt; s;int main() &#123; int n = rd(), q = rd(); for (int i = 1; i &lt;= n; ++i) h[i] = rd(); for (int i = 1; i &lt;= n; ++i) p[i] = rd(); ll ans = 0; auto sqr = [&amp;](int x) &#123;return x * x;&#125;; auto pre = [&amp;](int x) &#123;return x == 1 ? n : x - 1;&#125;; auto work = [&amp;](int x) &#123; x = pre(x); s.clear(); ans = 0; ll nw = 0; for (int i = 1; i &lt; n; ++i) &#123; l[i] = i - 1; r[i] = i + 1; nw += sqr(h[i + 1] - h[i]); &#125; l[n] = n - 1; for (int i = 1; i &lt;= n; ++i) &#123; ans += nw; int id = p[x]; if (l[id]) nw -= sqr(h[id] - h[l[id]]); if (r[id]) nw -= sqr(h[id] - h[r[id]]); if (l[id] &amp;&amp; r[id]) nw += sqr(h[l[id]] - h[r[id]]); r[l[id]] = r[id]; l[r[id]] = l[id]; x = pre(x); &#125; &#125;; int st = 1; work(st); printf(&quot;%lld\\n&quot;, ans); for (int i = 1; i &lt;= q; ++i) &#123; int k = (rd() + ans) % n; st = (st + k - 1) % n + 1; work(st); printf(&quot;%lld\\n&quot;, ans); &#125; return 0; &#125; **H - Absolute Space æ„é€ ä¸€ä¸ªå¤§å°ä¸è¶…è¿‡ \\(100\\) çš„ç‚¹é›†ï¼Œæ»¡è¶³å¯¹äºå…¶ä¸­ä»»æ„ä¸€ä¸ªç‚¹ï¼Œé›†åˆä¸­æ°å¥½éƒ½æœ‰ \\(n\\ (n\\le 10)\\) ä¸ªç‚¹ä¸ä»–è·ç¦»ä¸º \\(1\\) ã€‚ é¦–å…ˆå¯¹äº \\(n\\le 4\\) çš„æƒ…å†µï¼šé•¿åº¦ä¸º \\(1\\) çš„çº¿æ®µï¼›æ­£ä¸‰è§’å½¢ï¼›æ­£å››é¢ä½“ï¼›æ­£å…«é¢ä½“ï¼› å¯¹äº \\(n=k&gt;4\\) çš„æƒ…å†µï¼Œå¾ˆå®¹æ˜“æƒ³åˆ°æŠŠ \\(k-1\\) çš„è§£å¤åˆ¶ä¸€ä»½ï¼Œä½¿å¾—æ¯ä¸ªç‚¹å’ŒåŸæœ¬çš„è·ç¦»ä¸º \\(1\\) ï¼Œä½†ç‚¹æ•°ä¼šè¶…ã€‚ ç†æ€§æ€è€ƒä¸€ä¸‹ï¼Œè¿™ä¸ªè¿‡ç¨‹å…¶å®æ˜¯ \\(n=1\\) çš„è§£å’Œ \\(n=k-1\\) çš„è§£çš„é—µå¯å¤«æ–¯åŸºå’Œã€‚é‚£æ¢æˆ \\(n=x\\) å’Œ \\(n=k-x\\) åˆå¹¶å¯ä¸å¯ä»¥å‘¢ï¼Ÿ æ­£ç¡®æ€§ï¼šå‡è®¾ \\(A\\) æ˜¯ \\(n=k_1\\) çš„è§£ï¼Œ\\(B\\) æ˜¯ \\(n=k_2\\) çš„è§£ï¼Œç°åœ¨ç›¸å½“äºè¯æ˜ \\(\\forall p_a\\in A,p_b\\in B\\) ï¼š \\[ \\sum_{a\\in A,b\\in B} [dis(a + b, p_a + p_b) = 1]=k_1+k_2 \\] é¦–å…ˆæ³¨æ„åˆ°ï¼š1. \\(a=pa\\) ï¼Œä¼šæœ‰ \\(k_2\\) ä¸ª \\(b\\) ç¬¦åˆæ¡ä»¶ï¼›2. \\(b=pb\\) ï¼Œä¼šæœ‰ \\(k_1\\) ä¸ª \\(a\\) ç¬¦åˆæ¡ä»¶; ä¸”è¿™ä¸¤ä¸ªæƒ…å†µäº¤é›†ä¸ºç©ºï¼Œæ‰€ä»¥å·²ç»æ„æˆäº†æ‰€æ±‚çš„ \\(k_1+k_2\\) ä¸ªç‚¹ã€‚ å¯¹äºå…¶ä»–æƒ…å†µï¼Œåªéœ€è¦æŠŠ \\(A\\) æˆ– \\(B\\) é‡Œæ‰€æœ‰ç‚¹æ•´ä½“æ²¿ç€ä¸‰ä¸ªè½´éƒ½éšæœºæ—‹è½¬ä¸€ä¸ªè§’åº¦ï¼Œå°±å¯ä»¥é¿å…æ°å¥½å‡‘å‡ºè·ç¦» \\(=1\\) çš„æƒ…å†µã€‚ åˆæ³•æ€§ï¼šæœ€å°åŒ–é—µå¯å¤«æ–¯åŸºå’Œå¤§å° \\(=size[k-x]\\times size[x]\\) æ—¶ï¼Œæ‰€éœ€çš„ç‚¹æ•°åˆ†åˆ«ä¸ºï¼š\\(12,16,24,36,64,96\\) åˆšå¥½ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define pb push_backconst double eps = 1e-4;#define z(x) (abs((x)) &lt;= eps)#define sqr(x) ((x) * (x)) #define letp const Pstruct P &#123; double x, y, z; P operator + (letp &amp;p) const &#123;return &#123;x + p.x, y + p.y, z + p.z&#125;;&#125; P operator - (letp &amp;p) const &#123;return &#123;x - p.x, y - p.y, z - p.z&#125;;&#125; bool operator == (letp &amp;p) const &#123;return x == p.x &amp;&amp; y == p.y &amp;&amp; z == p.z;&#125; P rotx(double ang) const &#123; double cosa = cos(ang), sina = sin(ang); return &#123;x, y * cosa - z * sina, y * sina + z * cosa&#125;; &#125; P roty(double ang) const &#123; double cosa = cos(ang), sina = sin(ang); return &#123;x * cosa - z * sina, y, x * sina + z * cosa&#125;; &#125; P rotz(double ang) const &#123; double cosa = cos(ang), sina = sin(ang); return &#123;x * cosa - y * sina, x * sina + y * cosa, z&#125;; &#125; inline double dis(letp &amp;p) &#123; return sqrt(sqr(x - p.x) + sqr(y - p.y) + sqr(z - p.z)); &#125;&#125;;inline bool check(vector&lt;P&gt; &amp;s, int n) &#123; for (auto x : s) &#123; int cnt = 0; for (auto y : s) &#123; if (x == y) continue; double d = x.dis(y); if (z(d)) return false; if (z(d - 1.0)) ++cnt; &#125; if (cnt != n) return false; &#125; return true;&#125;inline vector&lt;P&gt; random_rotate(vector&lt;P&gt; &amp;s) &#123; vector&lt;P&gt; res = s; double ang = 360.0 * rand() / RAND_MAX; for (auto &amp;x : res) x = x.rotx(ang); ang = 360.0 * rand() / RAND_MAX; for (auto &amp;x : res) x = x.roty(ang); ang = 360.0 * rand() / RAND_MAX; for (auto &amp;x : res) x = x.rotz(ang); return res;&#125;vector&lt;P&gt; ans[11];int main() &#123; ans[1].pb(&#123;0, 0, 0&#125;); ans[1].pb(&#123;1, 0, 0&#125;); ans[2] = ans[1]; ans[2].pb(&#123;0.5, sqrt(3) / 2, 0&#125;); ans[3] = ans[2]; ans[3].pb(&#123;0.5, sqrt(3) / 6, sqrt(6) / 3&#125;); ans[4].pb(&#123;0, 0, 0&#125;); ans[4].pb(&#123;1, 0, 0&#125;); ans[4].pb(&#123;0, 1, 0&#125;); ans[4].pb(&#123;1, 1, 0&#125;); ans[4].pb(&#123;0.5, 0.5, sqrt(2) / 2&#125;); ans[4].pb(&#123;0.5, 0.5, -sqrt(2) / 2&#125;); for (int i = 5; i &lt;= 10; ++i) &#123; int x = 1, nw = 100; for (int j = 1; j &lt; i; ++j) if (ans[j].size() * ans[i - j].size() &lt; nw) &#123; nw = ans[j].size() * ans[i - j].size(); x = j; &#125; vector&lt;P&gt; p; while (true) &#123; ans[i].clear(); p = random_rotate(ans[x]); for (auto a : p) for (auto b : ans[i - x]) ans[i].pb(a + b); if (check(ans[i], i)) break; &#125; &#125; int n = rd(); printf(&quot;%d\\n&quot;, (int)ans[n].size()); for (auto x : ans[n]) printf(&quot;%.10lf %.10lf %.10lf\\n&quot;, x.x, x.y, x.z); return 0;&#125; J - Let's Play Jigsaw Puzzles! ä¸€ä¸ª \\(m\\times m\\) çš„çŸ©é˜µå¡«å…¥ \\(1\\sim m^2\\) ï¼Œç»™å®šæ¯ä¸ªæƒå€¼çš„å››é‚»æ¥æƒ…å†µï¼Œæ¢å¤çŸ©é˜µã€‚ ç¡®å®šå·¦ä¸Šè§’ä¹‹å BFS å³å¯ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 1007#define mp make_pairconst int dx[4] = &#123;-1, 1, 0, 0&#125;;const int dy[4] = &#123;0, 0, -1, 1&#125;;int adj[N * N][4], ans[N][N];queue&lt;pii&gt; q;int main() &#123; int n = rd(); for (int i = 1, m = n * n; i &lt;= m; ++i) for (int j = 0; j &lt; 4; ++j) adj[i][j] = rd(); for (int i = 1, m = n * n; i &lt;= m; ++i) if (adj[i][0] == -1 &amp;&amp; adj[i][2] == -1) &#123; ans[1][1] = i; q.push(mp(1, 1)); break; &#125; while (!q.empty()) &#123; auto [x, y] = q.front(); q.pop(); int num = ans[x][y]; for (int j = 0; j &lt; 4; ++j) if (adj[num][j] != -1) &#123; int tx = x + dx[j]; int ty = y + dy[j]; if (ans[tx][ty]) continue; ans[tx][ty] = adj[num][j]; q.push(mp(tx, ty)); &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; printf(&quot;%d&quot;, ans[i][1]); for (int j = 2; j &lt;= n; ++j) printf(&quot; %d&quot;, ans[i][j]); puts(&quot;&quot;); &#125; return 0; &#125; K - Browser Games ç»™å®š \\(n\\) ä¸ªä¸² \\(S_1,S_2,\\dots,S_n\\) ï¼Œå¯¹æ¯ä¸ª \\(k=1,2,\\dots,n\\) ï¼Œé—®æœ€å°‘é€‰å¤šå°‘ä¸ªå­—ç¬¦ä¸² \\(|\\{T_i\\}|\\) ï¼Œä½¿å¾—ï¼š å¯¹ä»»æ„ \\(1\\le i\\le k\\) ï¼Œå­˜åœ¨ä¸€ä¸ª \\(T_j\\) ï¼Œä½¿å¾— \\(T_j\\) æ˜¯ \\(S_i\\) çš„å‰ç¼€ å¯¹ä»»æ„ \\(k&lt; i\\le n\\) ï¼Œä¸å­˜åœ¨ä¸€ä¸ª \\(T_j\\) ï¼Œä½¿å¾— \\(T_j\\) æ˜¯ \\(S_i\\) çš„å‰ç¼€ è€ƒè™‘æŠŠ Trie æ ‘å»ºå‡ºæ¥ï¼Œç„¶åå€’ç€ä¸€ä¸ªä¸€ä¸ªæ’¤é”€ã€‚åˆå§‹ç­”æ¡ˆå°±æ˜¯æ ¹ç»“ç‚¹å„¿å­ä¸ªæ•°ã€‚ æ¯æ¬¡æ’¤é”€ä¸€ä¸ªä¸²ï¼Œè·¯å¾„ä¸Šçš„èŠ‚ç‚¹ä»¥åå°±éƒ½ä¸èƒ½é€‰äº†ï¼Œä¸”è·¯å¾„ä¸Šæ‰€æœ‰ç‚¹çš„å…¶ä»–åˆ†æ”¯éƒ½å¾—è¢«è¦†ç›–è¿‡ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 50007#define mp make_pairinline int trans(char c) &#123; if (c &gt;= &#x27;a&#x27; &amp;&amp; c &lt;= &#x27;z&#x27;) return c - &#x27;a&#x27;; if (c == &#x27;.&#x27;) return 26; return 27;&#125;int tot = 1;struct node&#123;bool tag, vis; int fa, tr[28];&#125; c[3000007];int Ans;int insert(int *s, int len) &#123; int nw = 1; for (int i = 1; i &lt;= len; nw = c[nw].tr[s[i++]]) if (!c[nw].tr[s[i]]) c[c[nw].tr[s[i]] = ++tot].fa = nw; return nw;&#125;void del(int nw, int *s, int len) &#123; while (nw != 1) &#123; if (c[nw].tag) &#123;c[nw].tag = false; --Ans;&#125; // è‹¥åŸæœ¬æœ‰æ ‡è®°åˆ™è¦æ’¤é”€ if (!c[nw].vis) &#123; // è‹¥ç¬¬ä¸€æ¬¡ç»è¿‡è¯¥ç‚¹ï¼Œåˆ™å¯¹æ‰€æœ‰å…¶ä»–å„¿å­æ‰“æ ‡è®° c[nw].vis = true; for (int i = 0; i &lt; 28; ++i) if (c[nw].tr[i] &amp;&amp; !c[c[nw].tr[i]].vis) &#123;++Ans; c[c[nw].tr[i]].tag = true;&#125; &#125; --len; nw = c[nw].fa; &#125;&#125;char S[N];int s[N][60], pos[N];int len[N], ans[N];int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; scanf(&quot;%s&quot;, S + 1); len[i] = strlen(S + 1); for (int j = 1; j &lt;= len[i]; ++j) s[i][j] = trans(S[j]); pos[i] = insert(s[i], len[i]); &#125; for (int i = 0; i &lt; 28; ++i) if (c[1].tr[i]) &#123;++Ans; c[c[1].tr[i]].tag = true;&#125; ans[n] = Ans; for (int i = n; i; --i) &#123; del(pos[i], s[i], len[i]); ans[i - 1] = Ans; &#125; for (int i = 1; i &lt;= n; ++i) printf(&quot;%d\\n&quot;, ans[i]); return 0; &#125; M - Tower of the Sorcerer ä¸Šå–æ•´æ•´é™¤åˆ†å— + ä¸å¯é‡ ST è¡¨ã€‚èµ›å 1min è¿‡äº†ã€‚","categories":[{"name":"Official Contests","slug":"Official-Contests","permalink":"http://blog.gyx.me/categories/Official-Contests/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"},{"name":"Graphs","slug":"Graphs","permalink":"http://blog.gyx.me/tags/Graphs/"},{"name":"Minkowski Sum","slug":"Minkowski-Sum","permalink":"http://blog.gyx.me/tags/Minkowski-Sum/"},{"name":"Tricks","slug":"Tricks","permalink":"http://blog.gyx.me/tags/Tricks/"},{"name":"Trie","slug":"Trie","permalink":"http://blog.gyx.me/tags/Trie/"}]},{"title":"2022 CCPC Weihai Site","slug":"official/ccpc/22-weihai","date":"2022-11-06T16:00:00.000Z","updated":"2023-03-20T16:35:23.427Z","comments":true,"path":"official/ccpc/22-weihai/","link":"","permalink":"http://blog.gyx.me/official/ccpc/22-weihai/","excerpt":"","text":"æ¯”èµ›åœ°å€ ï¼šCodeforces Gym 104023 å¾…è¡¥ï¼šHLM A - Duna ç­¾åˆ°é¢˜ã€‚ç­”æ¡ˆæ˜¯äº”ä¸ªä½ç½®å„è‡ªçš„äººæ•°å’Œé‚£è¿‡å† å†›çš„äººæ•°çš„ \\(\\min\\) ã€‚ 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;#define N 10007inline int getid() &#123; static string s; static int totid; static map&lt;string, int&gt; id; cin &gt;&gt; s; if (!id[s]) id[s] = ++totid; return id[s];&#125;bool champ[N];int cnt[6], tot;int main() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= 5; ++j) champ[getid()] = true; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; int id = getid(), pos; cin &gt;&gt; pos; tot += champ[id]; cnt[pos]++; &#125; for (int i = 1; i &lt;= 5; ++i) tot = min(tot, cnt[i]); printf(&quot;%d\\n&quot;, tot); return 0;&#125; B - Recruitment æœ‰ä¸€ä¸ªé•¿åº¦ä¸º \\(n\\) çš„åºåˆ—ï¼Œåˆå§‹ç”±åŠ å·è¿æ¥ã€‚æ¯æ¬¡æŠŠä¸€ä¸ªåŠ å·æ”¹æˆä¹˜å·ï¼Œåˆ°æœ€åå…¨éƒ¨å˜ä¸ºä¹˜å·ï¼Œä¸€å…±æœ‰ \\(n\\) ä¸ªè¡¨è¾¾å¼ã€‚ ç»™å®š \\(n\\) ä¸ªè¡¨è¾¾å¼çš„ç»“æœ \\((s_i\\le 10^9)\\) ï¼Œæ„é€ åˆå§‹åºåˆ—å’Œä¿®æ”¹è¿‡ç¨‹ã€‚ æ³¨æ„åˆ°æœ€åçš„å€¼å°±æ˜¯å…¨éƒ¨çš„ä¹˜ç§¯ï¼Œæ‰€ä»¥ä¸æ˜¯ \\(1\\) çš„æ•°å­—ä¸ªæ•°æœ€å¤šåªæœ‰ \\(30\\) ä¸ªã€‚ æ³¨æ„åˆ°æŠŠ \\(+1\\) å˜æˆ \\(\\times 1\\) ä¼šè®©ç»“æœå˜å°ï¼Œä¸”æ­¤æ¡ä»¶æ˜¯å……è¦æ¡ä»¶ï¼Œæ‰€ä»¥å…ˆæŠŠæ‰€æœ‰çš„ \\(1\\) æ‰¾å‡ºæ¥ï¼Œæ”¾åˆ°æœ€åã€‚ ç„¶åç¼©å‡æ•°åˆ—ï¼Œåªä¼šå‰©ä¸‹ \\(30\\) ä¸ªï¼Œæœ€åä¸€ä¸ªæ•°å°±æ˜¯æ‰€æœ‰çš„ä¹˜ç§¯ï¼Œç„¶åå€’ç€æ¯æ¬¡å°è¯•åˆ†è§£ï¼Œæœç´¢åˆ†è§£çš„æ ‘ç»“æ„å³å¯ã€‚ é”™è¯¯ 1ï¼š \\(2+2=2\\times 2\\) æ‰€ä»¥ç¼©å‡æ•°åˆ—çš„æ—¶å€™ä¸èƒ½ç®€å•çš„åˆ¤æ–­ç›¸é‚»ä¸åŒ é”™è¯¯ 2ï¼š åœ¨ auto éå† STL çš„æ—¶å€™ä¸èƒ½ä¿®æ”¹ï¼Œæ‰€ä»¥ä¸èƒ½åœ¨å¾ªç¯ä¸­ä¿®æ”¹æ•°é›† / å°†æ•°é›†ä¼ å¼•ç”¨æ¥ dfs å¯¼è‡´è¢«ä¿®æ”¹ ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first#define sc second#define mp make_pair#define pb push_back#define N 100007bool del[N];int a[N], res[N], op[N];int A, B;inline bool check(int n, int dlt) &#123; int lim = sqrt(n); for (int i = 1; i &lt;= lim; ++i) if (n % i == 0) if (n - i - n / i == dlt) &#123;A = i; B = n / i; return true;&#125; return false;&#125;int nodecnt, totlim;struct node &#123;int ls = 0, rs = 0, x = 0, tim = 0;&#125; c[N];map&lt;multiset&lt;int&gt;, bool&gt; vis;pii lim[N];bool dfs(int p, set&lt;int&gt; leaf, multiset&lt;int&gt; val) &#123; if (vis[val]) return false; set&lt;int&gt; nxtleaf = leaf; multiset&lt;int&gt; nxtval = val; vis[val] = true; if (p == totlim + 1) return true; for (auto x : leaf) &#123; if (check(c[x].x, lim[p].fr)) &#123; nxtleaf.erase(x); nxtval.erase(nxtval.lower_bound(c[x].x)); c[x].tim = lim[p].sc; c[c[x].ls = ++nodecnt].x = A; c[c[x].rs = ++nodecnt].x = B; nxtleaf.insert(nodecnt - 1); nxtleaf.insert(nodecnt); nxtval.insert(A); nxtval.insert(B); if (dfs(p + 1, nxtleaf, nxtval)) return true; nxtval.erase(nxtval.lower_bound(c[nodecnt].x)); nxtval.erase(nxtval.lower_bound(c[nodecnt - 1].x)); nxtleaf.erase(nodecnt); nxtleaf.erase(nodecnt - 1); c[x].tim = c[x].ls = c[x].rs = 0; nodecnt -= 2; nxtval.insert(c[x].x); nxtleaf.insert(x); &#125; &#125; return false;&#125;int id = 0;void build(int u) &#123; if (!c[u].ls) &#123;res[++id] = c[u].x; return;&#125; build(c[u].ls); op[c[u].tim] = id; build(c[u].rs);&#125;int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) a[i] = rd(); int tot = n, cnt1 = 0; for (int i = n - 1; i; --i) if (a[i] &gt; a[i + 1]) &#123;del[i] = true; ++cnt1; res[tot--] = 1; op[i] = tot;&#125; for (int i = 1; i &lt;= n; ++i) if (i &lt; n &amp;&amp; a[i] &gt; a[i + 1]) &#123;a[i] -= cnt1; --cnt1;&#125; else a[i] -= cnt1; c[nodecnt = 1].x = a[n]; for (int i = n - 1; i; --i) if (!del[i]) lim[++totlim] = make_pair(a[i + 1] - a[i], i); if (!dfs(1, set&lt;int&gt;&#123;1&#125;, multiset&lt;int&gt;&#123;a[n]&#125;)) &#123;puts(&quot;-1&quot;); return 0;&#125; build(1); for (int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, res[i]); puts(&quot;&quot;); for (int i = 1; i &lt; n; ++i) printf(&quot;%d\\n&quot;, op[i]); return 0;&#125; C - Grass 5 ç»™å®š \\(n\\) ä¸ªç‚¹ï¼Œé—®èƒ½å¦é€‰äº”ä¸ªç‚¹ \\(ABCDE\\) ä½¿å¾— \\(BCDE\\) å’Œ \\(A\\) æ„æˆçš„çº¿æ®µä¸¤ä¸¤åªäº¤åœ¨ \\(A\\) ã€‚ ç©ä¸€ä¸‹å‘ç°åªè¦ä¸å…±çº¿æ€»èƒ½æ‰¾åˆ°è§£ï¼Œäºæ˜¯æ‰¾åˆ°ä¸å…±çº¿çš„äº”ä¸ªç‚¹ä¹‹åæš´åŠ›æšä¸¾ç­”æ¡ˆã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first#define sc second#define mp make_pair#define pb push_back#define N 25007#define letp const Pstruct P &#123; ll x, y; P operator - (letp &amp;p) const &#123;return &#123;x - p.x, y - p.y&#125;;&#125; ll operator | (letp &amp;p) const &#123;return x * p.x + y * p.y;&#125; // dot ll operator ^ (letp &amp;p) const &#123;return x * p.y - y * p.x;&#125; // cross&#125; a[N], p[6];inline void work() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123;a[i].x = rd(); a[i].y = rd();&#125; if (n &lt;= 4) &#123;puts(&quot;NO&quot;); return;&#125; int tot = 2; p[1] = a[1]; p[2] = a[2]; bool fl = false; for (int i = 3; i &lt;= n &amp;&amp; tot &lt; 5; ++i) if (fl || tot &lt; 4) &#123; p[++tot] = a[i]; if (((p[i] - p[1]) ^ (p[2] - p[1])) != 0) fl = true; &#125; else if (((a[i] - p[1]) ^ (p[2] - p[1])) != 0) &#123; fl = true; p[++tot] = a[i]; &#125; if (tot &lt; 5) &#123;puts(&quot;NO&quot;); return;&#125; puts(&quot;YES&quot;); for (int i = 1; i &lt;= 5; ++i) &#123; bool fl = true; for (int j = 1; j &lt;= 5; ++j) if (j != i) for (int k = 1; k &lt;= 5; ++k) if (k != i &amp;&amp; k != j) if (((p[k] - p[i]) ^ (p[j] - p[i])) == 0 &amp;&amp; ((p[k] - p[i]) | (p[j] - p[i])) &gt;= 0) &#123; fl = false; break; &#125; if (fl) &#123; printf(&quot;%lld %lld\\n&quot;, p[i].x, p[i].y); for (int j = 1; j &lt;= 5; ++j) if (j != i) printf(&quot;%lld %lld\\n&quot;, p[j].x, p[j].y); return; &#125; &#125;&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; D. Sternhalma èƒ–èƒ–è¯´æ˜¯ç­¾åˆ°é¢˜ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=5,maxs=1&lt;&lt;19;int te,num[maxn+5];char s[maxn+5][maxn+5];int pic[maxn+5][maxn+5],cnt,ID[maxn+5][maxn+5];int m,SA[maxs+5],f[maxs+5],si[maxs+5];int getop() &#123;char ch=getchar();while (ch!=&#x27;.&#x27; &amp;&amp; ch!=&#x27;#&#x27;) ch=getchar();return ch==&#x27;#&#x27;;&#125;void Fix(int &amp;x,int y) &#123;if (y&gt;x) x=y;&#125;int gettl(int x,int y)&#123; if (num[x]&gt;num[x-1]) return ID[x-1][y-1]; else return ID[x-1][y];&#125;int gettr(int x,int y)&#123; if (num[x]&gt;num[x-1]) return ID[x-1][y]; else return ID[x-1][y+1];&#125;int getl(int x,int y) &#123;return ID[x][y-1];&#125;int getr(int x,int y) &#123;return ID[x][y+1];&#125;int getdl(int x,int y)&#123; if (num[x]&gt;num[x+1]) return ID[x+1][y-1]; else return ID[x+1][y];&#125;int getdr(int x,int y)&#123; if (num[x]&gt;num[x+1]) return ID[x+1][y]; else return ID[x+1][y+1];&#125;inline bool cmp(const int &amp;i,const int &amp;j) &#123;return si[i]&lt;si[j] || si[i]==si[j] &amp;&amp; i&lt;j;&#125;int main()&#123; memset(ID,255,sizeof(ID)); num[1]=3;num[2]=4;num[3]=5;num[4]=4;num[5]=3; for (int i=1;i&lt;=5;i++) for (int j=1;j&lt;=num[i];j++) scanf(&quot;%d&quot;,&amp;pic[i][j]),ID[i][j]=cnt++; memset(f,192,sizeof(f)); f[0]=0; for (int i=1;i&lt;maxs;i++) SA[++m]=i,si[i]=si[i&gt;&gt;1]+(i&amp;1); sort(SA+1,SA+1+m,cmp); for (int k=1,i=SA[k];k&lt;maxs;k++,i=SA[k]) for (int x=1;x&lt;=5;x++) for (int y=1;y&lt;=num[x];y++) if (i&gt;&gt;ID[x][y]&amp;1)&#123; Fix(f[i],f[i^(1&lt;&lt;ID[x][y])]); int tl=gettl(x,y),tr=gettr(x,y); int dl=getdl(x,y),dr=getdr(x,y); int l=getl(x,y),r=getr(x,y); if (tl&gt;=0 &amp;&amp; dr&gt;=0) if ((i&gt;&gt;tl&amp;1)+(i&gt;&gt;dr&amp;1)==1) Fix(f[i],f[i^(1&lt;&lt;tl)^(1&lt;&lt;ID[x][y])^(1&lt;&lt;dr)]+pic[x][y]); if (l&gt;=0 &amp;&amp; r&gt;=0) if ((i&gt;&gt;l&amp;1)+(i&gt;&gt;r&amp;1)==1) Fix(f[i],f[i^(1&lt;&lt;l)^(1&lt;&lt;ID[x][y])^(1&lt;&lt;r)]+pic[x][y]); if (tr&gt;=0 &amp;&amp; dl&gt;=0) if ((i&gt;&gt;tr&amp;1)+(i&gt;&gt;dl&amp;1)) Fix(f[i],f[i^(1&lt;&lt;tr)^(1&lt;&lt;ID[x][y])^(1&lt;&lt;dl)]+pic[x][y]); &#125; for (scanf(&quot;%d&quot;,&amp;te);te;te--)&#123; int S=0; for (int i=1;i&lt;=5;i++) for (int j=1;j&lt;=num[i];j++) S|=getop()&lt;&lt;ID[i][j]; printf(&quot;%d\\n&quot;,f[S]); &#125; return 0;&#125; E. Python Will be Faster than C++ ç­¾åˆ°é¢˜ï¼Œå‘ç° \\(a_{n+i} = a_n + (a_n-a_{n-1})i\\) ï¼Œç„¶åç®€å•åˆ†ç±»è®¨è®ºä¸€ä¸‹ã€‚ 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;#define N 1000int a[N];int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i]; if (a[i] &lt; k) &#123; printf(&quot;Python 3.%d will be faster than C++\\n&quot;, i); return 0; &#125; &#125; int add = a[n] - a[n - 1]; if (add &gt;= 0) puts(&quot;Python will never be faster than C++&quot;); else &#123; k = a[n] - k; add = -add; int ans = k / add; while (ans * add &lt;= k) ++ans; printf(&quot;Python 3.%d will be faster than C++&quot;, n + ans); return 0; &#125; return 0;&#125; F. Mooncake Delivery æ³¨æ„åˆ°è·¯å¾„ä¸­æ¯æ¬¡æ¢é¢œè‰²å¿…å®šä¼šæŠŠä¸Šä¸€æ®µé¢œè‰²çš„æƒå€¼å…¨éƒ¨æ”¶å›ï¼Œæ‰€ä»¥ç­”æ¡ˆæ˜¯ï¼ˆæ¯ä¸€æ®µæƒå€¼+ä¸‹ä¸€æ®µèµ·ç‚¹æƒå€¼ï¼‰çš„ \\(\\max\\) ã€‚ æ‰€ä»¥å…¶å®æœ‰ä¸¤å¹…å›¾ï¼Œå…ˆè·‘ä¸€é floyd ï¼Œè·¯å¾„æƒå€¼ä¸ºè¾¹æƒçš„åŠ æ³•ï¼Œå¾—åˆ°æ¯ä¸€æ®µé¢œè‰²ç›¸åŒçš„æƒå€¼ï¼› ç„¶åå†æšä¸¾ï¼ˆèµ·ç‚¹ Aï¼Œç»ˆç‚¹Bï¼Œä¸‹ä¸€ä¸ªé¢œè‰²èµ·ç‚¹Cï¼‰å»ºå‡º A åˆ° C æ–°çš„è¾¹ï¼Œå†è·‘ä¸€é floyd ï¼Œè·¯å¾„æƒå€¼ä¸ºè¾¹æƒçš„ \\(\\max\\) ã€‚ æœ€åå†è€ƒè™‘ä¸Šè·¯å¾„æœ€åä¸€æ®µé¢œè‰²ç›¸åŒçš„å³å¯ã€‚æ‰€æœ‰è¿‡ç¨‹å¤æ‚åº¦å‡ä¸º \\(\\mathcal{O}(n^3)\\) ã€‚ é”™è¯¯ 1ï¼š å› ä¸ºè·¯å¾„å¯èƒ½åªæœ‰ä¸€æ®µï¼Œæ‰€ä»¥ç¬¬äºŒå¹…å›¾è¦è®¾ç½®ä¸€ä¸‹è‡ªå·±åˆ°è‡ªå·±è·ç¦»ä¸º \\(0\\) ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;#define rep(i, x, y) for(int (i) = (x); (i) &lt;= (y); ++(i))#define per(i, x, y) for(int (i) = (x); (i) &gt;= (y); --(i))template&lt;typename T&gt;inline bool getmin(T &amp;a, T b) &#123;return a &gt; b ? (a = b, true) : false;&#125;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 307#define inf 4000000000000000000llbool e[N][N];int col[N], w[N];ll dis[N][N], mx[N][N], ans[N][N];inline void work() &#123; int n = rd(), m = rd(); rep(i, 1, n) rep(j, 1, n) &#123;e[i][j] = false; mx[i][j] = dis[i][j] = inf;&#125; rep(i, 1, n) col[i] = rd(); rep(i, 1, n) &#123;w[i] = rd(); mx[i][i] = dis[i][i] = 0;&#125; rep(i, 1, m) &#123; int u = rd(), v = rd(); e[u][v] = e[v][u] = true; dis[u][v] = w[v]; dis[v][u] = w[u]; &#125; // floyd for same color rep(k, 1, n) rep(u, 1, n) rep(v, 1, n) getmin(dis[u][v], dis[u][k] + dis[k][v]); rep(u, 1, n) rep(v, 1, n) dis[u][v] += w[u]; // new graph : a path of same color points + an another color point rep(u, 1, n) rep(k, 1, n) if (col[u] == col[k]) rep(v, 1, n) if (col[k] != col[v] &amp;&amp; e[k][v]) getmin(mx[u][v], dis[u][k] + w[v]); // floyd on new graph rep(k, 1, n) rep(u, 1, n) rep(v, 1, n) getmin(mx[u][v], max(mx[u][k], mx[k][v])); // consider adding a path of same color in the end rep(u, 1, n) rep(v, 1, n) &#123; ans[u][v] = mx[u][v]; rep(k, 1, n) if (col[v] == col[k]) getmin(ans[u][v], max(mx[u][k], dis[k][v])); &#125; rep(u, 1, n) &#123; rep(v, 1, n) printf(&quot;%lld &quot;, ans[u][v]); puts(&quot;&quot;); &#125;&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; G. Grade 2 ç»™å®š \\(x\\) ï¼Œå¤šæ¬¡è¯¢é—® \\([l,r]\\) ï¼Œè®¡ç®— \\(\\sum_{k=l}^r[\\operatorname{gcd}(k x \\oplus x, x)=1]\\) æŸ´è€å¸ˆå‘ç°å¾ªç¯èŠ‚æ˜¯ \\(2^{\\lceil \\log_2 x\\rceil}\\) ï¼Œé‚æš´åŠ›ï¼ˆåšå·®ä¸ç”¨è®¨è®ºå†™æ³•å¾ˆç®€å•ï¼‰ã€‚ 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 10000007ll gcd(ll a, ll b) &#123;return b ? gcd(b, a % b) : a;&#125;int sum[N];int main() &#123; int x = rd(), n = rd(); int period = 2 &lt;&lt; __lg(x); for (int i = 0; i &lt; period; ++i) sum[i] = sum[i - 1] + (gcd((1ll * i * x) ^ x, x) == 1ll); auto calc = [&amp;](ll p) &#123; return sum[period - 1] * (p / period) + sum[p % period]; &#125;; for (int i = 1; i &lt;= n; ++i) &#123; ll l = rd(), r = rd(); printf(&quot;%lld\\n&quot;, calc(r) - calc(l - 1)); &#125; return 0;&#125; I. Dragon Bloodline èƒ–èƒ–åšçš„ï¼Œè´ªå¿ƒ + å¡å¸¸ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn=50000,LOG=20;int te,n,m;LL a[maxn+5],b[LOG+5],sum;LL now[maxn+5],tem[LOG+5];int K,ID[maxn+5];inline bool cmp(const int &amp;i,const int &amp;j) &#123;return now[i]&gt;now[j] || now[i]==now[j] &amp;&amp; i&gt;j;&#125;bool check(LL mid)&#123; for (int i=0;i&lt;=LOG;i++) tem[i]=b[i]; for (int i=1;i&lt;=n;i++) now[i]=a[i]*mid; for (int j=LOG;j&gt;=0;j--)&#123; for (int i=1;i&lt;=n &amp;&amp; tem[j];i++) if (now[i]&gt;=(1LL&lt;&lt;j))&#123; LL cnt=min(now[i]&gt;&gt;j,tem[j]); now[i]-=cnt&lt;&lt;j; tem[j]-=cnt; &#125; if (!tem[j]) continue; K=0;for (int i=1;i&lt;=n;i++) if (now[i]) ID[++K]=i; if (K&lt;=tem[j]) return true; nth_element(ID+1,ID+tem[j],ID+K+1,cmp); LL lim=now[ID[tem[j]]];int y=ID[tem[j]]; // printf(&quot;[%d]\\n&quot;,tem[j]); int cnt=0; for (int i=1;i&lt;=K;i++) if (now[ID[i]]&gt;lim || now[ID[i]]==lim &amp;&amp; ID[i]&gt;=y) now[ID[i]]=0,cnt++; // printf(&quot;[%d]\\n&quot;,cnt); &#125; for (int i=1;i&lt;=n;i++) if (now[i]) return false; return true;&#125;int main()&#123; for (scanf(&quot;%d&quot;,&amp;te);te;te--)&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); LL L=0,R=0;sum=0; for (int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;a[i]),R=max(R,a[i]); for (int i=0;i&lt;=LOG;i++) b[i]=0; for (int i=0;i&lt;m;i++) scanf(&quot;%lld&quot;,&amp;b[i]),sum+=b[i]&lt;&lt;i; R=sum/R; for (LL mid=L+(R-L&gt;&gt;1);L&lt;=R;mid=L+(R-L&gt;&gt;1)) check(mid)?L=mid+1:R=mid-1; printf(&quot;%lld\\n&quot;,R); &#125; return 0;&#125; J. Eat, Sleep, Repeat ç»™å®š \\(n\\) ä¸ªæ•° \\(a_1, a_2,\\dots, a_n\\) ï¼Œä¸¤äººåšå¼ˆæ¯æ¬¡å¯ä»¥è®©ä¸€ä¸ªæ•°å­— \\(-1\\) ã€‚ æœ‰è‹¥å¹²é™åˆ¶ \\(lim_{x_i}=y_i\\) è¡¨ç¤ºé›†åˆä¸­ä»»æ„æ—¶åˆ» \\(x_i\\) å‡ºç°æ¬¡æ•°ä¸èƒ½è¶…è¿‡ \\(y_i\\) ã€‚ æ— æ³•è¡ŒåŠ¨ï¼ˆéƒ½æ˜¯ \\(0\\) æˆ–ç§»åŠ¨åå¿…å®šè¿åé™åˆ¶ï¼‰çš„äººè¾“ï¼Œé—®ç»“æœã€‚ æ³¨æ„åˆ°å€¼åŸŸæŒ‰ç…§ \\(lim_{x_i} = 0\\) åˆ†æˆäº†è‹¥å¹²æ®µï¼ˆè¡¥ä¸€ä¸ª \\(\\lim_{-1}=0\\) ï¼‰ï¼Œå¯¹äºæ¯æ®µè€ƒè™‘ï¼š ä»å°åˆ°å¤§æ‰«ææ¯ä¸€ä¸ªé™åˆ¶ï¼Œè‹¥æœå­˜åœ¨ä¸€ä¸ª \\(x_i\\) æ²¡æœ‰é™åˆ¶ï¼Œé‚£ä¹ˆæ¯”ä»–å¤§çš„éƒ½å¯ä»¥å˜æˆä»–ï¼›å¦åˆ™æŒ‰ç…§é™åˆ¶å®¹çº³å°½å¯èƒ½å¤šçš„æ•°ã€‚ æ‰€ä»¥æ“ä½œæ¬¡æ•°æ˜¯å›ºå®šçš„ï¼Œæ¨¡æ‹Ÿå³å¯ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 100007int a[N];#define fr first#define sc second#define mp make_pair#define pb push_backvector&lt;pii&gt; lim, tmplim;vector&lt;int&gt; tmp;inline void work() &#123; lim.clear(); int n = rd(), k = rd(); for (int i = 1; i &lt;= n; ++i) a[i] = rd(); sort(a + 1, a + 1 + n); for (int i = 1; i &lt;= k; ++i) &#123; int x = rd(), y = rd(); lim.push_back(mp(x, y)); &#125; lim.push_back(mp(1000000001, 0)); sort(lim.begin(), lim.end()); int ptr = 1, den = -1, mx = 0; ll ans = 0; auto calc = [&amp;]()&#123; int id = 0; ll sum = 0, cnt = tmp.size(); for (auto x : tmp) sum += x; ll fin = 0; for (int i = den + 1, limid = tmplim.size(); i &lt;= mx; ++i, ++id) &#123; if (id &gt;= limid) &#123;fin = i; break;&#125; if (tmplim[id].fr &gt; i) &#123;fin = i; break;&#125; ll t = min(cnt, (ll)tmplim[id].sc); cnt -= t; sum -= t * i; if (!cnt) break; &#125; sum -= cnt * fin; ans += sum; tmp.clear(); tmplim.clear(); &#125;; for (auto [x, y] : lim) &#123; while (ptr &lt;= n &amp;&amp; a[ptr] &lt; x) tmp.pb(a[ptr++]); if (y == 0) &#123;mx = x - 1; calc(); den = x;&#125; else tmplim.push_back(mp(x, y)); &#125; tmplim.clear(); tmp.clear(); puts((ans &amp; 1) ? &quot;Pico&quot; : &quot;FuuFuu&quot;);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; K. I Wanna Maker æ•°æ®ç»“æ„ + æ•°æ•°ã€‚æŸ´è€å¸ˆå’Œèƒ–èƒ–åšçš„ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;set&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn=100000,maxq=maxn&lt;&lt;1;int te,n,tp[maxn+5],L[maxn+5],R[maxn+5];int lx,ly,rx,ry;LL ans;struct DATA &#123;int tp,x,y;&#125;;int Q;DATA q[maxq+5];multiset&lt;int&gt; S;inline bool cmp(const DATA &amp;a,const DATA &amp;b) &#123;return a.x&lt;b.x;&#125;int main()&#123; for (scanf(&quot;%d&quot;,&amp;te);te;te--)&#123; scanf(&quot;%d&quot;,&amp;n); bool Z=false; for (int i=1;i&lt;=n;i++)&#123; LL k,x; scanf(&quot;%d%lld%lld&quot;,&amp;tp[i],&amp;k,&amp;x); if (2*x-k*(k-1)&lt;=0)&#123; if (tp[i]==1) Z=true; else L[i]=1,R[i]=0; &#125; else &#123; L[i]=(2*x-k*(k-1))/(2*k); R[i]=(2*x+k*(k-1)+2*k-1)/(2*k); &#125; &#125; if (Z) goto zero; ly=2e9;rx=0; for (int i=1;i&lt;=n;i++) if (tp[i]==1) ly=min(ly,L[i]),rx=max(rx,R[i]); if (ly&gt;rx) goto infty; lx=1;ry=2e9; for (int i=1;i&lt;=n;i++) if (tp[i]==2 &amp;&amp; L[i]&lt;=R[i])&#123; if (ly&lt;=L[i] &amp;&amp; R[i]&lt;=rx) goto zero; if (L[i]&lt;ly &amp;&amp; R[i]&lt;=rx) lx=max(lx,L[i]+1); if (ly&lt;=L[i] &amp;&amp; R[i]&gt;rx) ry=min(ry,R[i]-1); &#125; if (lx&gt;ly || rx&gt;ry) goto zero; if (ry==2e9) goto infty; Q=0; for (int i=1;i&lt;=n;i++) if (tp[i]==2 &amp;&amp; L[i]&lt;=R[i]) if (lx&lt;=L[i] &amp;&amp; L[i]&lt;ly &amp;&amp; rx&lt;R[i] &amp;&amp; R[i]&lt;=ry) q[++Q]=&#123;1,lx,R[i]&#125;,q[++Q]=&#123;-1,L[i]+1,R[i]&#125;; ans=(LL)(ly-lx+1)*(ry-rx+1); sort(q+1,q+1+Q,cmp); S.clear(); for (int i=1,j=2;i&lt;=Q;i=j)&#123; for (j=i;j&lt;=Q &amp;&amp; q[i].x==q[j].x;j++)&#123; if (q[j].tp==1) S.insert(q[j].y); else S.erase(S.lower_bound(q[j].y)); &#125; if (!S.empty())&#123; LL lenr=ry-(*S.begin())+1; LL lenl=(j&lt;=Q?q[j].x:ly+1)-q[i].x; ans-=lenl*lenr; &#125; &#125; printf(&quot;%lld\\n&quot;,ans);continue; zero:puts(&quot;0&quot;);continue; infty:puts(&quot;-1&quot;);continue; &#125; return 0;&#125;","categories":[{"name":"Official Contests","slug":"Official-Contests","permalink":"http://blog.gyx.me/categories/Official-Contests/"}],"tags":[{"name":"Constructive Algorithm","slug":"Constructive-Algorithm","permalink":"http://blog.gyx.me/tags/Constructive-Algorithm/"},{"name":"Graphs","slug":"Graphs","permalink":"http://blog.gyx.me/tags/Graphs/"},{"name":"Counting","slug":"Counting","permalink":"http://blog.gyx.me/tags/Counting/"}]},{"title":"2018-2019 ICPC Asia Nanjing Regional","slug":"official/icpc/18-nanjing","date":"2022-11-03T16:00:00.000Z","updated":"2023-03-20T16:35:45.000Z","comments":true,"path":"official/icpc/18-nanjing/","link":"","permalink":"http://blog.gyx.me/official/icpc/18-nanjing/","excerpt":"","text":"æ¯”èµ›åœ°å€ ï¼šCodeforces Gym 101981 è¿˜æ²¡è¡¥å®Œï¼šFHKLM A - Adrien and Austin ç»™å®šæ•°é›† \\(\\{1,\\dots, n\\}\\) ï¼Œæ¯æ¬¡åªèƒ½åˆ æ‰è‡³å¤š \\(k\\) ä¸ªè¿ç»­çš„æ•°å­—ï¼Œåˆ ç©ºçš„äººèµ¢ï¼Œé—®æœ€ç»ˆç»“æœã€‚ è‹¥ \\(k=1\\) ç›´æ¥åˆ¤è§£ï¼›å¦åˆ™å¥‡æ•°åˆ æ‰ä¸­ä½æ•°ï¼Œå¶æ•°åˆ æ‰ä¸¤ä¸ªä¸­ä½æ•°ï¼Œç„¶åå¯¹ç§°æ“ä½œï¼Œå…ˆæ‰‹ä¸€å®šèµ¢ã€‚ æƒ³å‡ºæ¥æ”¾ \\(n=0\\) çš„ corner case çš„å‡ºé¢˜äººçœŸæ˜¯äººæ‰ã€‚ 12345678910#include&lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; if (n == 0) &#123;puts(&quot;Austin&quot;); return 0;&#125; if (m == 1) &#123;puts((n &amp; 1) ? &quot;Adrien&quot; : &quot;Austin&quot;); return 0;&#125; puts(&quot;Adrien&quot;); return 0;&#125; B - Tournament wqs äºŒåˆ† + å‡¸ä¼˜åŒ–ã€‚é˜Ÿå‹åšè¿‡ä¸€æ‘¸ä¸€æ ·çš„æ¿å­é¢˜ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#define fr first#define sc second#define mp make_pairusing namespace std;typedef long long LL;const int maxn=300000;int n,m,a[maxn+5];int que[maxn+5],l[maxn+5],r[maxn+5],p[maxn+5];LL sum[maxn+5],f[maxn+5];int g[maxn+5];#define EOLN(x) ((x)==10 || (x)==13 || (x)==EOF)inline char readc()&#123; static char buf[1&lt;&lt;16],*l=buf,*r=buf; return l==r &amp;&amp; (r=(l=buf)+fread(buf,1,1&lt;&lt;16,stdin),l==r)?EOF:*l++;&#125;template&lt;typename T&gt; int readi(T &amp;x)&#123; T tot=0;char ch=readc(),lst=&#x27;+&#x27;; while (!isdigit(ch)) &#123;if (ch==EOF) return EOF;lst=ch;ch=readc();&#125; while (isdigit(ch)) tot=(tot&lt;&lt;3)+(tot&lt;&lt;1)+(ch^48),ch=readc(); lst==&#x27;-&#x27;?x=-tot:x=tot;return EOLN(ch);&#125;inline LL Sum(int L,int R)&#123; int m=(L+R&gt;&gt;1),A=m-L+1,B=R-m; return (LL)(A-B)*a[m]-(sum[m]-sum[L-1])+(sum[R]-sum[m]);&#125;#define val(j,i) (mp(f[j]+Sum((j)+1,(i))+c,g[j]+1))bool check(LL c)&#123; f[0]=0;g[0]=0; int Head=1,Tail=0; p[++Tail]=0;l[Tail]=1;r[Tail]=n; for (int i=1;i&lt;=n;i++)&#123; pair&lt;LL,int&gt; now=val(p[Head],i); f[i]=now.fr;g[i]=now.sc; int lst=-1; while (Head&lt;=Tail) if (val(p[Tail],l[Tail])&gt;val(i,l[Tail])) lst=l[Tail--]; else &#123; int L=l[Tail],R=r[Tail]; for (int mid=L+(R-L&gt;&gt;1);L&lt;=R;mid=L+(R-L&gt;&gt;1)) val(p[Tail],mid)&gt;val(i,mid)?R=mid-1:L=mid+1; if (L&lt;=r[Tail]) lst=L,r[Tail]=L-1; break; &#125; if (~lst) p[++Tail]=i,l[Tail]=lst,r[Tail]=n; if (Head&lt;=Tail) &#123;l[Head]++;if (l[Head]&gt;r[Head]) Head++;&#125; &#125; return g[n]&lt;=m;&#125;int main()&#123; readi(n);readi(m); for (int i=1;i&lt;=n;i++) readi(a[i]),sum[i]=sum[i-1]+a[i]; LL L=0,R=3e14; for (LL mid=L+(R-L&gt;&gt;1);L&lt;=R;mid=L+(R-L&gt;&gt;1)) check(mid)?R=mid-1:L=mid+1; check(L); printf(&quot;%lld\\n&quot;,f[n]-L*m); return 0;&#125; **C - Cherry and Chocolate ç»™ä¸€æ£µæ ‘ï¼Œç¬¬ä¸€ä¸ªäººæŠŠæŸä¸ªç‚¹æŸ“æˆç²‰è‰²ï¼Œç¬¬äºŒä¸ªäººæŠŠå¦ä¸€ä¸ªç‚¹æŸ“æˆæ£•è‰²ï¼Œç¬¬ä¸€ä¸ªäººå†æŠŠå¦å¦ä¸€ä¸ªç‚¹æŸ“æˆç²‰è‰²ã€‚ å®šä¹‰æ ‘çš„æƒå€¼ä¸ºç¬¦åˆä¸‹è¿°æè¿°çš„èŠ‚ç‚¹ \\(u\\) çš„ä¸ªæ•°ï¼šä» \\(u\\) åˆ°æ£•è‰²ç‚¹çš„è·¯å¾„ä¸Šç»è¿‡æŸä¸ªç²‰è‰²ç‚¹ã€‚ ç¬¬ä¸€ä¸ªäººæƒ³æœ€å¤§åŒ–æƒå€¼ï¼Œç¬¬äºŒä¸ªäººæƒ³æœ€å°åŒ–æƒå€¼ï¼Œé—®æœ€ç»ˆæ ‘çš„æƒå€¼ã€‚ æˆ‘ä»¬ç§°ç¬¬ä¸€ä¸ªç²‰è‰²ç‚¹ä¸º \\(x\\) ï¼Œæ£•è‰²ç‚¹ä¸º \\(y\\) ï¼Œç¬¬äºŒä¸ªç²‰è‰²ç‚¹ä¸º \\(z\\) ã€‚ æˆ‘ä»¬ä»¥ç¬¬ä¸€ä¸ªäººçš„è§†è§’ï¼Œå‡è®¾ \\(x,y\\) å·²ç»ç¡®å®šï¼Œé‚£ä¹ˆä»¤ \\(x\\) ä¸ºæ ¹ï¼Œæ‰€æœ‰å­æ ‘é‡Œé™¤æ‰ \\(y\\) æ‰€åœ¨çš„å­æ ‘ä»¥å¤–çš„å…¨éƒ¨çš„ç‚¹éƒ½å·²ç»è¢«èµšåˆ°äº†ã€‚ æ‰€ä»¥ \\(z\\) ä¸€å®šä¼šæ”¾åœ¨ \\(y\\) æ‰€åœ¨çš„å­æ ‘ä¸­ã€‚æŠŠè¿™ä¸ªå­æ ‘æ‹æˆä»¥ \\(y\\) ä¸ºæ ¹ï¼Œ \\(z\\) èƒ½èµšå›æ¥çš„æ˜¯æŸä¸ªå­æ ‘å¤§å°ï¼Œå› æ­¤ä¸€å®šé€‰ \\(y\\) çš„æŸä¸ªå„¿å­ã€‚ å› æ­¤å¦‚æœ \\(y\\) æ‰€åœ¨çš„å­æ ‘å·²ç»é€‰å®šï¼Œä¸ºäº†è®© \\(z\\) æå›å»çš„ç‚¹æ•°æœ€å°‘ï¼Œ \\(y\\) ä¸€å®šä¼šé€‰åœ¨è¿™ä¸ªå­æ ‘çš„é‡å¿ƒä¸Šã€‚ æ‰€ä»¥ \\(y\\) æå›æ¥çš„å€¼æ˜¯ \\(sz[\\text{å­æ ‘}]-mxs[\\text{é‡å¿ƒ}]\\) ï¼Œä¼šæŠŠ \\(y\\) é€‰åœ¨ä½¿å¾—è¿™ä¸ªæƒå€¼æœ€å¤§çš„å­æ ‘çš„é‡å¿ƒä¸Šã€‚ è¿™æ ·å°±å¯ä»¥ \\(\\mathcal{O}(n)\\) æ£€æŸ¥ä¸€ä¸ªé€‰å®šçš„ \\(x\\) ä¹‹åæœ€ç»ˆæ ‘çš„æƒå€¼äº†ã€‚ é‚£ä¹ˆè€ƒè™‘ç°åœ¨æˆ‘ä»¬å·²ç»æœ‰äº†ä¸€ä¸ªæ–¹æ¡ˆ \\((x,y,z)\\) ï¼Œé‚£ä¹ˆæŠŠ \\(x\\) æœè¿œç¦» \\(y\\) çš„æ–¹å‘ç§»åŠ¨ä¸ä¼šä½¿ç­”æ¡ˆå˜ä¼˜ã€‚ å› æ­¤æ¯æ¬¡éœ€æ£€æŸ¥çš„èŒƒå›´éƒ½æ˜¯å½“å‰ \\(x\\) çš„æŸä¸ªå­æ ‘ï¼Œé‚£ä¹ˆæ¯æ¬¡éƒ½é€‰è¿™ä¸ªèŒƒå›´çš„é‡å¿ƒï¼Œå°±åªéœ€è¦æ£€æŸ¥ \\(\\mathcal{O}(\\log n)\\) æ¬¡ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;inline bool getmin(int &amp;a, int b) &#123;return a &gt; b ? (a = b, true) : false;&#125;inline bool getmax(int &amp;a, int b) &#123;return a &lt; b ? (a = b, true) : false;&#125;#define N 100007bool tag[N]; // [tag[u] = true] : should be tested to be the first pink pointint sz[N], mxs[N];vector&lt;int&gt; e[N];int n, rt, tot, mn;void getcentre(int u, int fa) &#123; sz[u] = 1; mxs[u] = 0; for (auto v : e[u]) if (tag[v] &amp;&amp; v != fa) &#123;getcentre(v, u); sz[u] += sz[v]; mxs[u] = max(mxs[u], sz[v]);&#125; mxs[u] = max(mxs[u], tot - sz[u]); mn = min(mn, mxs[u]);&#125;vector&lt;int&gt; subtree[N];void getsz(int u, int fa, int top) &#123; sz[u] = 1; mxs[u] = 0; subtree[top].push_back(u); for (auto v : e[u]) if (v != fa) &#123;getsz(v, u, top); sz[u] += sz[v]; mxs[u] = max(mxs[u], sz[v]);&#125;&#125;int main() &#123; n = tot = rd(); for (int i = 1; i &lt;= n; ++i) tag[i] = true; for (int i = 1; i &lt; n; ++i) &#123; int u = rd(), v = rd(); e[u].push_back(v); e[v].push_back(u); &#125; int ans = 0; for (rt = 1; tag[rt]; ) &#123; // find the centre mn = 1e9; getcentre(rt, rt); for (int u = 1; u &lt;= n; ++u) if (tag[u] &amp;&amp; mxs[u] == mn) &#123;rt = u; break;&#125; tag[rt] = false; --tot; // find the best brown point in the initial tree // i.e. find a subtree whose centre maximize |subtree| - mxs[centre] int res = n, pos = rt; for (auto u : e[rt]) &#123; subtree[u].clear(); getsz(u, rt, u); int bst = u; for (auto v : subtree[u]) mxs[v] = max(mxs[v], sz[u] - sz[v]); for (auto v : subtree[u]) if (mxs[v] &lt; mxs[bst]) bst = v; int cur = n - sz[u] + mxs[bst]; if (getmin(res, cur)) pos = u; &#125; ans = max(ans, res); for (auto u : e[rt]) if (u != pos) for (auto v : subtree[u]) if (tag[v]) &#123;tag[v] = false; --tot;&#125; rt = pos; &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125; D - Country Meow æ±‚æœ€å°çƒè¦†ç›–çš„åŠå¾„ã€‚ æ¿å­é¢˜ã€‚æ¢ä¸€æ¢ä¼°ä»·å‡½æ•°ç±»ä¼¼çš„é¢˜ç›®ä¹Ÿå¯ä»¥è€ƒè™‘ä¸‰åˆ†å¥—ä¸‰åˆ†å¥—ä¸‰åˆ†ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;bits/stdc++.h&gt;using namespace std;int n, cnt, i;double R, tmp;const double eps = 1e-5;struct P &#123; double x, y, z; P()&#123;&#125; P(double _x, double _y, double _z) &#123;x = _x; y = _y; z = _z;&#125; P operator + (const P &amp;b) &#123;return P(x + b.x, y + b.y, z + b.z);&#125; P operator - (const P &amp;b) &#123;return P(x - b.x, y - b.y, z - b.z);&#125; P operator * (double b) &#123;return P(x * b, y * b, z * b);&#125; P operator / (double b) &#123;return P(x / b, y / b, z / b);&#125;&#125; a[200007], b[4], O;double dis(const P &amp;a, const P &amp;b) &#123; return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y) + (a.z - b.z) * (a.z - b.z);&#125;double dot(const P &amp;a, const P &amp;b) &#123; return a.x * b.x + a.y * b.y + a.z * b.z;&#125;void ball() &#123; P q[3]; double m[3][3], f[3], L[3], det; int i, j; O.x = O.y = O.z = R = 0; switch(cnt) &#123; case 1 : O = b[0]; break; case 2 : O = (b[0] + b[1]) / 2; R = dis(O, b[0]); break; case 3 : for (i = 0; i &lt; 2; ++i) q[i] = b[i + 1] - b[0]; for (i = 0; i &lt; 2; ++i) for (j = 0; j &lt; 2; ++j) m[i][j] = dot(q[i], q[j]) * 2; for (i = 0; i &lt; 2; ++i) f[i] = dot(q[i], q[i]); if (fabs(det = m[0][0] * m[1][1] - m[0][1] * m[1][0]) &lt; eps) return; L[0] = (f[0] * m[1][1] - f[1] * m[0][1]) / det; L[1] = (f[1] * m[0][0] - f[0] * m[1][0]) / det; O = b[0] + q[0] * L[0] + q[1] * L[1]; R = dis(O, b[0]); break; case 4 : for (i = 0; i &lt; 3; ++i) q[i] = b[i + 1] - b[0 ], f[i] = dot(q[i], q[i]); for (i = 0; i &lt; 3; ++i) for (j = 0; j &lt; 3; ++j) m[i][j] = dot(q[i], q[j]) * 2; det = m[0][0] * m[1][1] * m[2][2] + m[0][1] * m[1][2] * m[2][0] + m[0][2] * m[2][1] * m[1][0] - m[0][2] * m[1][1] * m[2][0] - m[0][1] * m[1][0] * m[2][2] - m[0][0] * m[1][2] * m[2][1]; if (fabs(det) &lt; eps) return; for (j = 0; j &lt; 3; ++j) &#123; for (i = 0; i &lt; 3; ++i) m[i][j] = f[i]; L[j] = (m[0][0] * m[1][1] * m[2][2] + m[0][1] * m[1][2] * m[2][0] + m[0][2] * m[2][1] * m[1][0] - m[0][2] * m[1][1] * m[2][0] - m[0][1] * m[1][0] * m[2][2] - m[0][0] * m[1][2] * m[2][1]) / det; for (i = 0; i &lt; 3; ++i) m[i][j] = dot(q[i], q[j]) * 2; &#125; O = b[0]; for (i = 0; i &lt; 3; ++i) O = O + q[i] * L[i]; R = dis(O, b[0]); &#125;&#125;void minball(int n) &#123; ball(); if (cnt &lt; 4) for (int i = 0; i &lt; n; ++i) if (dis(O, a[i]) - R &gt; eps) &#123; b[cnt++] = a[i]; minball(i); --cnt; if (i &gt; 0) &#123; P t = a[i]; memmove(&amp;a[1], &amp;a[0], sizeof(P) * i); a[0] = t; &#125; &#125;&#125;int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; ++i) scanf(&quot;%lf%lf%lf&quot;, &amp;a[i].x, &amp;a[i].y, &amp;a[i].z); random_shuffle(a, a + n); R = -1; for (i = 0; i &lt; n; ++i) &#123; if (dis(O, a[i]) - R &gt; eps) cnt = 1, b[0] = a[i], minball(i); //printf(&quot;%.12lf %.12lf %.12lf %.12lf\\n&quot;, O.x, O.y, O.z, R); &#125; printf(&quot;%.12lf\\n&quot;, sqrt(R)); return 0;&#125; *E - Eva and Euro coins ç»™å®šä¸¤ä¸ª \\(01\\) åºåˆ— \\(A,B\\) ï¼Œæ¯æ¬¡å¯ä»¥æŠŠ \\(A\\) ä¸­è¿ç»­ \\(k\\) ä¸ªç›¸åŒçš„ä½ç½®ä¸€èµ·ç¿»è½¬ï¼Œé—®æ˜¯å¦èƒ½æŠŠ \\(A\\) å˜æˆ \\(B\\) ã€‚ æ‰‹ç©ä¸€ä¸‹å‘ç°ï¼šå¯¹äº \\(k\\) ä¸ª \\(x=0/1\\) , \\(xx\\dots xxy\\) å’Œ \\(y x x\\dots x\\) ä¸€å®šæ˜¯å¯ä»¥äº’ç›¸è½¬æ¢çš„ã€‚ æ¢è¨€ä¹‹ï¼Œ \\(k\\) ä¸ªç›¸åŒçš„å­—ç¬¦å¯ä»¥åœ¨åºåˆ—é‡Œä»»æ„ç§»åŠ¨ï¼Œè€Œä¸”ä¸å…·ä½“æ˜¯ \\(0/1\\) æ— å…³ã€‚ æ‰€ä»¥æŠŠå°½å¯èƒ½å¤šçš„ \\(k\\) ä¸ªè¿ç»­ç›¸åŒçš„æ‰”æ‰ï¼Œçœ‹å‰©ä¸‹çš„æ˜¯å¦ç›¸åŒå³å¯ã€‚ç”¨æ ˆç»´æŠ¤ï¼ˆå­—ç¬¦ï¼Œä¸ªæ•°ï¼‰å³å¯ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 1000007#define fr first#define sc second#define pci pair&lt;char, int&gt;int na, nb;pci a[N], b[N];int main() &#123; int n = rd(), k = rd(); if (k == 1) &#123;puts(&quot;Yes&quot;); return 0;&#125; for (int i = 1; i &lt;= n; ++i) &#123; char c = getchar(); while (!isdigit(c)) c = getchar(); if (na &amp;&amp; a[na].fr == c) &#123; ++a[na].sc; if (a[na].sc == k) --na; &#125; else a[++na] = mp(c, 1); &#125; for (int i = 1; i &lt;= n; ++i) &#123; char c = getchar(); while (!isdigit(c)) c = getchar(); if (nb &amp;&amp; b[nb].fr == c) &#123; ++b[nb].sc; if (b[nb].sc == k) --nb; &#125; else b[++nb] = mp(c, 1); &#125; if (na != nb) &#123;puts(&quot;No&quot;); return 0;&#125; for (int i = 1; i &lt;= na; ++i) if (a[i] != b[i]) &#123;puts(&quot;No&quot;); return 0;&#125; puts(&quot;Yes&quot;); return 0;&#125; **F - Frank DAG éšæœºæ¸¸èµ°ã€‚ é˜Ÿå‹åˆ‡äº† è²Œä¼¼æ˜¯ \\(O(n^2)\\) æ”¯æŒä¿®æ”¹ä¸€ä¸ªæ–¹ç¨‹å¹¶æ±‚è§£æ–¹ç¨‹ç»„ã€‚ ä¸€ä¸ªç›¸å…³å¥—è·¯é¢˜ï¼šè¿æ¥1 G - Pyramid æ‰“è¡¨æ’å€¼/æ‰¾è§„å¾‹/æ¨å¼å­ï¼ŒæŸ´è€å¸ˆæ¨å‡ºæ¥æ˜¯ \\({n+3\\choose 4}\\) ã€‚ 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define mod 1000000007#define inv24 41666667int main()&#123; for (int t = rd(); t; --t) &#123; int n = rd(); printf(&quot;%lld\\n&quot;, 1ll * (n + 3) * (n + 2) % mod * (n + 1) % mod * n % mod * inv24 % mod); &#125; return 0;&#125; *H - Huge Discount I - Magic Potion æœ€å¤§æµæ¿å­é¢˜ã€‚è¯æ°´å½“ä½œå¦ä¸€ä¸ªæºç‚¹ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;inline bool getmin(int &amp;a, int b) &#123;return (a &gt; b ? (a = b, true) : false);&#125;inline bool getmax(int &amp;a, int b) &#123;return (a &lt; b ? (a = b, true) : false);&#125;// F is the type of flowtemplate&lt;const int V, const int E, class F, const F flowInf&gt;struct Flow &#123; int tot = 1, S, T, hd[V], cur[V], dis[V]; struct edge&#123;int to, nxt; F cap;&#125; e[E &lt;&lt; 1]; void clear() &#123;tot = 1; memset(hd, 0, sizeof(hd));&#125; void add(int u, int v, F w) &#123; e[++tot].nxt = hd[u], hd[u] = tot, e[tot].to = v, e[tot].cap = w; e[++tot].nxt = hd[v], hd[v] = tot, e[tot].to = u, e[tot].cap = 0; &#125; inline bool bfs() &#123; static int q[V], qhd, qtl; memcpy(cur, hd, sizeof(hd)); memset(dis, -1, sizeof(dis)); q[qhd = qtl = 1] = S; dis[S] = 0; while (qhd &lt;= qtl) &#123; int u = q[qhd++]; for (int i = hd[u], v; i; i = e[i].nxt) if (dis[v = e[i].to] == -1 &amp;&amp; e[i].cap != 0) &#123; dis[v] = dis[u] + 1; q[++qtl] = v; &#125; &#125; return dis[T] != -1; &#125; F dfs(int u, F rem) &#123; if (u == T) return rem; F flow = 0; for (int i = cur[u], v; i &amp;&amp; rem; i = e[i].nxt) &#123; cur[u] = i; v = e[i].to; F nw = min(rem, e[i].cap); if (nw != 0 &amp;&amp; dis[v] == dis[u] + 1) &#123; int ret = dfs(v, nw); flow += ret; rem -= ret; e[i].cap -= ret; e[i ^ 1].cap += ret; &#125; &#125; if (flow == 0) dis[u] = -1; return flow; &#125; F dinic(int source, int sink) &#123; S = source; T = sink; F flow = 0; while (bfs()) flow += dfs(S, flowInf); return flow; &#125;&#125;;constexpr int N = 1007;constexpr int M = 100007;constexpr int inf = 1e9;Flow&lt;N, M, int, inf&gt; f;int main()&#123; int n = rd(), m = rd(), k = rd(); int S = 0, T = N - 1, P = N - 2; f.add(S, P, k); for (int i = 1; i &lt;= m; ++i) f.add(i + n, T, 1); for (int i = 1; i &lt;= n; ++i) &#123; f.add(S, i, 1); f.add(P, i, 1); for (int j = rd(); j; --j) f.add(i, rd() + n, 1); &#125; printf(&quot;%d\\n&quot;, f.dinic(S, T)); return 0;&#125; J - Prime Game ç»™å®šä¸€ä¸ªæ•°åˆ—ï¼Œå®šä¹‰ä¸€ä¸ªåŒºé—´çš„æƒå€¼ä¸ºåŒºé—´æ‰€æœ‰æ•°çš„ä¹˜ç§¯çš„è´¨å› å­é›†å¤§å°ï¼Œæ±‚æ‰€æœ‰åŒºé—´æƒå€¼å’Œã€‚ å¯¹æ¯ä¸ªè´¨æ•°è®¡ç®—ï¼Œç”¨æ€»åŒºé—´æ•°å‡æ‰ä¸åŒ…å«è¿™ä¸ªè´¨æ•°çš„åŒºé—´æ•°ï¼Œå¤æ‚åº¦ \\(\\mathcal{O}(n\\log(\\max a_i))\\) ã€‚åˆ†è§£è´¨å› æ•°ç”¨çº¿æ€§ç­›å‡º mindiv ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;cstdio&gt;#include&lt;cctype&gt;using namespace std;typedef long long LL;const int maxn=1000000;int n,a[maxn+5];LL ans;int p[maxn+5],D[maxn+5];bool pri[maxn+5];int lst[maxn+5];#define EOLN(x) ((x)==10 || (x)==13 || (x)==EOF)inline char readc()&#123; static char buf[1&lt;&lt;16],*l=buf,*r=buf; return l==r &amp;&amp; (r=(l=buf)+fread(buf,1,1&lt;&lt;16,stdin),l==r)?EOF:*l++;&#125;template&lt;typename T&gt; int readi(T &amp;x)&#123; T tot=0;char ch=readc(),lst=&#x27;+&#x27;; while (!isdigit(ch)) &#123;if (ch==EOF) return EOF;lst=ch;ch=readc();&#125; while (isdigit(ch)) tot=(tot&lt;&lt;3)+(tot&lt;&lt;1)+(ch^48),ch=readc(); lst==&#x27;-&#x27;?x=-tot:x=tot;return EOLN(ch);&#125;void Make(int n)&#123; for (int i=2;i&lt;=n;i++)&#123; if (!pri[i]) p[++p[0]]=i,D[i]=i; for (int j=1,t;j&lt;=p[0] &amp;&amp; (t=i*p[j])&lt;=n;j++) &#123;pri[t]=true;D[t]=p[j];if (!(i%p[j])) break;&#125; &#125;&#125;int main()&#123; readi(n);Make(maxn); ans=(LL)n*(n+1)/2*p[0]; for (int i=1,x;i&lt;=n;i++)&#123; readi(x); for (int d=D[x];x&gt;1;x/=d,d=D[x])&#123; int len=i-lst[d]-1; ans-=(LL)len*(len+1)/2; lst[d]=i; &#125; &#125; for (int i=1;i&lt;=p[0];i++)&#123; int len=n-lst[p[i]]; ans-=(LL)len*(len+1)/2; &#125; printf(&quot;%lld\\n&quot;,ans); return 0;&#125; K - Kangaroo Puzzle ç»™ä¸€ä¸ª \\(20\\times 20\\) çš„ç½‘æ ¼å›¾ï¼Œæ¯ä¸ªä½ç½®æ˜¯è¢‹é¼ /å¢™ï¼Œä¿è¯è¢‹é¼ è”é€šï¼Œæ„é€ ä¸€ä¸ªLURDåºåˆ—ä½¿å¾—æ‰€æœ‰çš„è¢‹é¼ èµ°åˆ°ä¸€èµ·ã€‚ ç½‘æ ¼å¤ªå°æƒ³ä¸€æƒ³éšæœºå¯è¿‡ï¼Œè¾“å‡º \\(50000\\) ä¸ªéšæœºå­—ç¬¦å°±è¿‡äº†ã€‚æ­£è§£æ˜¯è€ƒè™‘æ¯æ¬¡åˆå¹¶ä¸¤ä¸ªè¢‹é¼ ï¼Œåˆåœ¨ä¸€èµ·çš„è‚¯å®šä¸ä¼šå†åˆ†å¼€äº†ã€‚ *L - Lagrange the Chef M - Mediocre String Problem Z å‡½æ•° + manacherã€‚","categories":[{"name":"Official Contests","slug":"Official-Contests","permalink":"http://blog.gyx.me/categories/Official-Contests/"}],"tags":[{"name":"Number Theory","slug":"Number-Theory","permalink":"http://blog.gyx.me/tags/Number-Theory/"},{"name":"String","slug":"String","permalink":"http://blog.gyx.me/tags/String/"},{"name":"Divide and Conquer","slug":"Divide-and-Conquer","permalink":"http://blog.gyx.me/tags/Divide-and-Conquer/"}]},{"title":"2019-2020 ICPC Asia Hong Kong Regional","slug":"official/icpc/19-hongkong","date":"2022-10-28T16:00:00.000Z","updated":"2023-03-20T16:35:49.967Z","comments":true,"path":"official/icpc/19-hongkong/","link":"","permalink":"http://blog.gyx.me/official/icpc/19-hongkong/","excerpt":"","text":"æ¯”èµ›åœ°å€ ï¼šCodeforces Gym 102452 *A - Axis of Symmetry ç»™è‹¥å¹²é¢ç§¯æ— äº¤çš„çŸ©å½¢ï¼Œæ±‚æ•´ä¸ªå›¾æ¡ˆçš„æ‰€æœ‰å¯¹ç§°è½´ã€‚ æŠŠçº¿æ®µè¯¥è¿çš„éƒ½è¿èµ·æ¥ï¼Œå›¾å½¢å†…éƒ¨çš„çº¿æ®µéƒ½åˆ æ‰ã€‚ç„¶ååˆ¤æ–­æ¯ä¸ªçº¿æ®µæ˜¯å¦å¯¹ç§°ã€‚å†™äº†ä¸ªå±å±±ä»£ç éå¸¸åƒåœ¾ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef tuple&lt;int, int, int&gt; tii;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;int gcd(int a, int b) &#123;return b ? gcd(b, a % b) : a;&#125;typedef double T;#define let const auto#define lett const T#define letp const P // P for point#define letl const L // L for lineconst T eps = 1e-5;#define z(x) (abs((x)) &lt;= eps) // is zero inline int roundint(double x) &#123; int y = ceil(x); for (int i = y - 2; i &lt;= y + 2; ++i) if (z(x - i)) return i; return 2e9;&#125; struct P &#123; T x, y; P (T x = 0, T y = 0) : x(x), y(y) &#123;&#125; P operator + (letp &amp;p) const &#123;return &#123;x + p.x, y + p.y&#125;;&#125; P operator - (letp &amp;p) const &#123;return &#123;x - p.x, y - p.y&#125;;&#125; P operator * (lett &amp;d) const &#123;return &#123;x * d, y * d&#125;;&#125; P operator / (lett &amp;d) const &#123;return &#123;x / d, y / d&#125;;&#125; P operator - () const &#123;return &#123;-x, -y&#125;;&#125; T operator | (letp &amp;p) const &#123;return x * p.x + y * p.y;&#125; // dot T operator ^ (letp &amp;p) const &#123;return x * p.y - y * p.x;&#125; // cross T norm() const &#123;return x * x + y * y;&#125; P proj (letp &amp;p) const &#123;return (*this) * (((*this) | p) / norm());&#125; P refl (letp &amp;p) const &#123;return proj(p) * 2 - p;&#125;&#125; zero;double abs(letp &amp;p) &#123;return sqrt(p.norm());&#125;P perp(letp &amp;p) &#123;return &#123;-p.y, p.x&#125;;&#125; // turn pi / 2 left(counterclockwise) struct L &#123; P p, v; L shiftl(double d) const &#123;return &#123;p + perp(v) * d / abs(v), v&#125;;&#125; P proj(letp &amp;a) const &#123;return p + v.proj(a - p);&#125; P refl(letp &amp;a) const &#123;return p + v.refl(a - p);&#125; double dis(letp &amp;a) const &#123;return (v ^ (a - p)) / abs(v);&#125; &#125;;#define N 100007vector&lt;P&gt; Pt;map&lt;int, multiset&lt;pii&gt;&gt; H, V;bool check1(L l) &#123; for (auto [x, S] : V) &#123; for (auto [y1, y2] : S) &#123; P p1 = l.refl(P&#123;1.0 * x, 1.0 * y1&#125;), p2 = l.refl(P&#123;1.0 * x, 1.0 * y2&#125;); int tx = roundint(p1.x), ty1 = roundint(p1.y), ty2 = roundint(p2.y); if (ty1 &gt; ty2) swap(ty1, ty2); if (V[tx].count(make_pair(ty1, ty2)) == 0) return false; &#125; &#125; for (auto [y, S] : H) &#123; for (auto [x1, x2] : S) &#123; P p1 = l.refl(P&#123;1.0 * x1, 1.0 * y&#125;), p2 = l.refl(P&#123;1.0 * x2, 1.0 * y&#125;); int ty = roundint(p1.y), tx1 = roundint(p1.x), tx2 = roundint(p2.x); if (tx1 &gt; tx2) swap(tx1, tx2); if (H[ty].count(make_pair(tx1, tx2)) == 0) return false; &#125; &#125; return true;&#125;bool check2(L l) &#123; for (auto [x, S] : V) &#123; for (auto [y1, y2] : S) &#123; P p1 = l.refl(P&#123;1.0 * x, 1.0 * y1&#125;), p2 = l.refl(P&#123;1.0 * x, 1.0 * y2&#125;); int ty = roundint(p1.y), tx1 = roundint(p1.x), tx2 = roundint(p2.x); if (tx1 &gt; tx2) swap(tx1, tx2); if (H[ty].count(make_pair(tx1, tx2)) == 0) return false; &#125; &#125; for (auto [y, S] : H) &#123; for (auto [x1, x2] : S) &#123; P p1 = l.refl(P&#123;1.0 * x1, 1.0 * y&#125;), p2 = l.refl(P&#123;1.0 * x2, 1.0 * y&#125;); int tx = roundint(p1.x), ty1 = roundint(p1.y), ty2 = roundint(p2.y); if (ty1 &gt; ty2) swap(ty1, ty2); if (V[tx].count(make_pair(ty1, ty2)) == 0) return false; &#125; &#125; return true;&#125;inline void work() &#123; H.clear(); V.clear(); Pt.clear(); int n = rd(); int mxx = -1e9, mxy = -1e9, mnx = 1e9, mny = 1e9; for (int i = 1; i &lt;= n; ++i) &#123; int x1 = rd(), y1 = rd(), x2 = rd(), y2 = rd(); Pt.push_back(P&#123;1.0 * x1, 1.0 * y1&#125;); Pt.push_back(P&#123;1.0 * x1, 1.0 * y2&#125;); Pt.push_back(P&#123;1.0 * x2, 1.0 * y1&#125;); Pt.push_back(P&#123;1.0 * x2, 1.0 * y2&#125;); mxx = max(mxx, x2); mnx = min(mnx, x1); mxy = max(mxy, y2); mny = min(mny, y1); V[x1].insert(make_pair(y1, y2)); V[x2].insert(make_pair(y1, y2)); H[y1].insert(make_pair(x1, x2)); H[y2].insert(make_pair(x1, x2)); &#125; // connect segments multiset&lt;pii&gt; tmp; tmp.clear(); for (auto &amp;[x, S] : V) &#123; int R = -1e9; for (auto [l, r] : S) &#123; if (tmp.empty() || l &gt; R) tmp.insert(make_pair(l, r)); else &#123; auto [l1, r1] = *--tmp.end(); tmp.erase(--tmp.end()); int l2 = l, r2 = r; if (r1 == l2) tmp.insert(make_pair(l1, r2)); else &#123; if (l1 != l2) tmp.insert(make_pair(min(l1, l2), max(l1, l2))); if (r1 != r2) tmp.insert(make_pair(min(r1, r2), max(r1, r2))); &#125; &#125; R = max(R, r); &#125; swap(S, tmp); tmp.clear(); &#125; for (auto &amp;[y, S] : H) &#123; int R = -1e9; for (auto [l, r] : S) &#123; if (tmp.empty() || l &gt; R) tmp.insert(make_pair(l, r)); else &#123; auto [l1, r1] = *--tmp.end(); tmp.erase(--tmp.end()); int l2 = l, r2 = r; if (r1 == l2) tmp.insert(make_pair(l1, r2)); else &#123; if (l1 != l2) tmp.insert(make_pair(min(l1, l2), max(l1, l2))); if (r1 != r2) tmp.insert(make_pair(min(r1, r2), max(r1, r2))); &#125; &#125; R = max(R, r); &#125; swap(S, tmp); tmp.clear(); &#125; vector&lt;tii&gt; ans; ans.clear(); // y = midy if (check1(L&#123;&#123;0, (mxy + mny) / 2.0&#125;,&#123;1, 0&#125;&#125;)) &#123; int a = 0, b = 2, c = mny + mxy; int g = gcd(gcd(abs(a), abs(b)), abs(c)); a /= g; b /= g; c /= g; tii res = max(make_tuple(a, b, c), make_tuple(-a, -b, -c)); ans.push_back(res); &#125; // x = midx if (check1(L&#123;&#123;(mxx + mnx) / 2.0, 0&#125;,&#123;0, 1&#125;&#125;)) &#123; int a = 2, b = 0, c = mnx + mxx; int g = gcd(gcd(abs(a), abs(b)), abs(c)); a /= g; b /= g; c /= g; tii res = max(make_tuple(a, b, c), make_tuple(-a, -b, -c)); ans.push_back(res); &#125; // &quot;/&quot; L l1&#123;&#123;0, 0&#125;, &#123;1, 1&#125;&#125;; double mxd = -1e18, mnd = 1e18; for (auto p : Pt) &#123; double d = l1.dis(p); mxd = max(mxd, d); mnd = min(mnd, d); &#125; l1 = l1.shiftl((mxd + mnd) / 2.0); if (check2(l1)) &#123; int a = roundint(2 * l1.v.y); int b = roundint(-2 * l1.v.x); int c = roundint(2 * (l1.p.x * l1.v.y - l1.p.y * l1.v.x)); int g = gcd(gcd(abs(a), abs(b)), abs(c)); a /= g; b /= g; c /= g; tii res = max(make_tuple(a, b, c), make_tuple(-a, -b, -c)); ans.push_back(res); &#125; // &quot;\\&quot; l1 = L&#123;&#123;0, 0&#125;, &#123;1, -1&#125;&#125;; mxd = -1e18, mnd = 1e18; for (auto p : Pt) &#123; double d = l1.dis(p); mxd = max(mxd, d); mnd = min(mnd, d); &#125; l1 = l1.shiftl((mxd + mnd) / 2.0); // å¹³ç§»åˆ°æœ€è¿œç‚¹å¯¹ä¸­é—´ if (check2(l1)) &#123; int a = roundint(2 * l1.v.y); int b = roundint(-2 * l1.v.x); int c = roundint(2 * (l1.p.x * l1.v.y - l1.p.y * l1.v.x)); int g = gcd(gcd(abs(a), abs(b)), abs(c)); a /= g; b /= g; c /= g; tii res = max(make_tuple(a, b, c), make_tuple(-a, -b, -c)); ans.push_back(res); &#125; printf(&quot;%d\\n&quot;, (int)ans.size()); sort(ans.begin(), ans.end()); reverse(ans.begin(), ans.end()); for (auto [a, b, c] : ans) printf(&quot;%d %d %d &quot;, a, b, c); puts(&quot;&quot;);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; é’ˆå¯¹è¿™ä¸ªé¢˜ï¼Œå› ä¸ºéƒ½æ˜¯è¾¹ç•Œå¹³è¡Œäºå¯¹ç§°è½´çš„å›¾å½¢ä¹‹é—´çš„å¯¹ç§°ï¼Œæ‰€ä»¥å¯¹ç§°è½´å¿…è¿‡ \\((\\frac{mnx+mxx}{2},\\frac{mny+mxy}{2})\\) ï¼Œæ‰¾ç›´çº¿å¥½æ‰¾å¾ˆå¤šã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef tuple&lt;int, int, int&gt; tii;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;int gcd(int a, int b) &#123;return b ? gcd(b, a % b) : a;&#125;typedef double T;#define let const auto#define lett const T#define letp const P // P for point#define letl const L // L for lineconst T eps = 1e-5;#define z(x) (abs((x)) &lt;= eps) // is zero inline int roundint(double x) &#123; int y = ceil(x); if (z(y - 1 - x)) return y - 1; return (z(y - x) ? y : y + 1);&#125; struct P &#123; T x, y; P (T x = 0, T y = 0) : x(x), y(y) &#123;&#125; P operator + (letp &amp;p) const &#123;return &#123;x + p.x, y + p.y&#125;;&#125; P operator - (letp &amp;p) const &#123;return &#123;x - p.x, y - p.y&#125;;&#125; P operator * (lett &amp;d) const &#123;return &#123;x * d, y * d&#125;;&#125; P operator / (lett &amp;d) const &#123;return &#123;x / d, y / d&#125;;&#125; P operator - () const &#123;return &#123;-x, -y&#125;;&#125; T operator | (letp &amp;p) const &#123;return x * p.x + y * p.y;&#125; // dot T operator ^ (letp &amp;p) const &#123;return x * p.y - y * p.x;&#125; // cross T norm() const &#123;return x * x + y * y;&#125; P proj (letp &amp;p) const &#123;return (*this) * (((*this) | p) / norm());&#125; P refl (letp &amp;p) const &#123;return proj(p) * 2 - p;&#125;&#125; zero;struct L &#123; P p, v; P proj(letp &amp;a) const &#123;return p + v.proj(a - p);&#125; P refl(letp &amp;a) const &#123;return p + v.refl(a - p);&#125; &#125;;map&lt;int, multiset&lt;pii&gt;&gt; H, V;bool check1(L l) &#123; // H &lt;-&gt; H, V &lt;-&gt; V for (auto [x, S] : V) &#123; for (auto [y1, y2] : S) &#123; P p1 = l.refl(P&#123;1.0 * x, 1.0 * y1&#125;), p2 = l.refl(P&#123;1.0 * x, 1.0 * y2&#125;); int tx = roundint(p1.x), ty1 = roundint(p1.y), ty2 = roundint(p2.y); if (ty1 &gt; ty2) swap(ty1, ty2); if (V[tx].count(make_pair(ty1, ty2)) == 0) return false; &#125; &#125; for (auto [y, S] : H) &#123; for (auto [x1, x2] : S) &#123; P p1 = l.refl(P&#123;1.0 * x1, 1.0 * y&#125;), p2 = l.refl(P&#123;1.0 * x2, 1.0 * y&#125;); int ty = roundint(p1.y), tx1 = roundint(p1.x), tx2 = roundint(p2.x); if (tx1 &gt; tx2) swap(tx1, tx2); if (H[ty].count(make_pair(tx1, tx2)) == 0) return false; &#125; &#125; return true;&#125;bool check2(L l) &#123; // H &lt;-&gt; V for (auto [x, S] : V) &#123; for (auto [y1, y2] : S) &#123; P p1 = l.refl(P&#123;1.0 * x, 1.0 * y1&#125;), p2 = l.refl(P&#123;1.0 * x, 1.0 * y2&#125;); int ty = roundint(p1.y), tx1 = roundint(p1.x), tx2 = roundint(p2.x); if (tx1 &gt; tx2) swap(tx1, tx2); if (H[ty].count(make_pair(tx1, tx2)) == 0) return false; &#125; &#125; for (auto [y, S] : H) &#123; for (auto [x1, x2] : S) &#123; P p1 = l.refl(P&#123;1.0 * x1, 1.0 * y&#125;), p2 = l.refl(P&#123;1.0 * x2, 1.0 * y&#125;); int tx = roundint(p1.x), ty1 = roundint(p1.y), ty2 = roundint(p2.y); if (ty1 &gt; ty2) swap(ty1, ty2); if (V[tx].count(make_pair(ty1, ty2)) == 0) return false; &#125; &#125; return true;&#125;inline void work() &#123; H.clear(); V.clear(); int n = rd(); int mxx = -1e9, mxy = -1e9, mnx = 1e9, mny = 1e9; for (int i = 1; i &lt;= n; ++i) &#123; int x1 = rd(), y1 = rd(), x2 = rd(), y2 = rd(); mxx = max(mxx, x2); mnx = min(mnx, x1); mxy = max(mxy, y2); mny = min(mny, y1); V[x1].insert(make_pair(y1, y2)); V[x2].insert(make_pair(y1, y2)); H[y1].insert(make_pair(x1, x2)); H[y2].insert(make_pair(x1, x2)); &#125; multiset&lt;pii&gt; tmp; tmp.clear(); for (auto &amp;[x, S] : V) &#123; int R = -1e9; for (auto [l, r] : S) &#123; if (tmp.empty() || l &gt; R) tmp.insert(make_pair(l, r)); else &#123; auto [l1, r1] = *--tmp.end(); tmp.erase(--tmp.end()); int l2 = l, r2 = r; if (r1 == l2) tmp.insert(make_pair(l1, r2)); // connect segments else &#123; // remove the intersection if (l1 != l2) tmp.insert(make_pair(min(l1, l2), max(l1, l2))); if (r1 != r2) tmp.insert(make_pair(min(r1, r2), max(r1, r2))); &#125; &#125; R = max(R, r); &#125; swap(S, tmp); tmp.clear(); &#125; for (auto &amp;[y, S] : H) &#123; int R = -1e9; for (auto [l, r] : S) &#123; if (tmp.empty() || l &gt; R) tmp.insert(make_pair(l, r)); else &#123; auto [l1, r1] = *--tmp.end(); tmp.erase(--tmp.end()); int l2 = l, r2 = r; if (r1 == l2) tmp.insert(make_pair(l1, r2)); // connect segments else &#123; // remove the intersection if (l1 != l2) tmp.insert(make_pair(min(l1, l2), max(l1, l2))); if (r1 != r2) tmp.insert(make_pair(min(r1, r2), max(r1, r2))); &#125; &#125; R = max(R, r); &#125; swap(S, tmp); tmp.clear(); &#125; vector&lt;tii&gt; ans; ans.clear(); // y = midy if (check1(L&#123;&#123;0, (mxy + mny) / 2.0&#125;,&#123;1, 0&#125;&#125;)) &#123; int a = 0, b = 2, c = mny + mxy; int g = gcd(gcd(abs(a), abs(b)), abs(c)); a /= g; b /= g; c /= g; tii res = max(make_tuple(a, b, c), make_tuple(-a, -b, -c)); ans.push_back(res); &#125; // x = midx if (check1(L&#123;&#123;(mxx + mnx) / 2.0, 0&#125;,&#123;0, 1&#125;&#125;)) &#123; int a = 2, b = 0, c = mnx + mxx; int g = gcd(gcd(abs(a), abs(b)), abs(c)); a /= g; b /= g; c /= g; tii res = max(make_tuple(a, b, c), make_tuple(-a, -b, -c)); ans.push_back(res); &#125; // &quot;/&quot; L l1&#123;&#123;(mxx + mnx) / 2.0, (mxy + mny) / 2.0&#125;, &#123;1, 1&#125;&#125;; if (check2(l1)) &#123; int a = roundint(2 * l1.v.y); int b = roundint(-2 * l1.v.x); int c = roundint(2 * (l1.p.x * l1.v.y - l1.p.y * l1.v.x)); int g = gcd(gcd(abs(a), abs(b)), abs(c)); a /= g; b /= g; c /= g; tii res = max(make_tuple(a, b, c), make_tuple(-a, -b, -c)); ans.push_back(res); &#125; // &quot;\\&quot; l1 = L&#123;&#123;(mxx + mnx) / 2.0, (mxy + mny) / 2.0&#125;, &#123;1, -1&#125;&#125;; if (check2(l1)) &#123; int a = roundint(2 * l1.v.y); int b = roundint(-2 * l1.v.x); int c = roundint(2 * (l1.p.x * l1.v.y - l1.p.y * l1.v.x)); int g = gcd(gcd(abs(a), abs(b)), abs(c)); a /= g; b /= g; c /= g; tii res = max(make_tuple(a, b, c), make_tuple(-a, -b, -c)); ans.push_back(res); &#125; printf(&quot;%d\\n&quot;, (int)ans.size()); sort(ans.begin(), ans.end()); reverse(ans.begin(), ans.end()); for (auto [a, b, c] : ans) printf(&quot;%d %d %d &quot;, a, b, c); puts(&quot;&quot;);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; çœ‹äº†ä¸‹æ¯”è¾ƒçŸ­çš„ä»£ç ï¼Œå‘ç°éƒ½æ˜¯ç”¨è¾¹ç•Œä¸Šæ‰€æœ‰æ‹ç‚¹çš„å¯¹ç§°æ€§æ¥åˆ¤æ–­çš„ã€‚è¾¹ç•Œä¸Šæ‹ç‚¹å°±æ˜¯åªå‡ºç°è¿‡ä¸€æ¬¡çš„çŸ©å½¢é¡¶ç‚¹ ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef tuple&lt;int, int, int&gt; tii;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;int gcd(int a, int b) &#123;return b ? gcd(b, a % b) : a;&#125;typedef double T;#define let const auto#define lett const T#define letp const P // P for point#define letl const L // L for lineconst T eps = 1e-5;#define z(x) (abs((x)) &lt;= eps) // is zero inline int roundint(double x) &#123; int y = ceil(x); for (int i = y - 1; i &lt;= y + 1; ++i) if (z(x - i)) return i; return 2e9;&#125; struct P &#123; T x, y; P (T x = 0, T y = 0) : x(x), y(y) &#123;&#125; P operator + (letp &amp;p) const &#123;return &#123;x + p.x, y + p.y&#125;;&#125; P operator - (letp &amp;p) const &#123;return &#123;x - p.x, y - p.y&#125;;&#125; P operator * (lett &amp;d) const &#123;return &#123;x * d, y * d&#125;;&#125; P operator / (lett &amp;d) const &#123;return &#123;x / d, y / d&#125;;&#125; P operator - () const &#123;return &#123;-x, -y&#125;;&#125; T operator | (letp &amp;p) const &#123;return x * p.x + y * p.y;&#125; // dot T operator ^ (letp &amp;p) const &#123;return x * p.y - y * p.x;&#125; // cross bool operator == (letp &amp;p) const &#123;return z(x - p.x) &amp;&amp; z(y - p.y);&#125; bool operator != (letp &amp;p) const &#123;return ! operator == (p);&#125; bool operator &lt; (letp &amp;p) const &#123;return z(x - p.x) ? y &lt; p.y : x &lt; p.x;&#125; bool operator &gt; (letp &amp;p) const &#123;return !(*this &lt; p || *this == p);&#125; T norm() const &#123;return x * x + y * y;&#125; P proj (letp &amp;p) const &#123;return (*this) * (((*this) | p) / norm());&#125; P refl (letp &amp;p) const &#123;return proj(p) * 2 - p;&#125;&#125; zero;struct L &#123; P p, v; P proj(letp &amp;a) const &#123;return p + v.proj(a - p);&#125; P refl(letp &amp;a) const &#123;return p + v.refl(a - p);&#125; &#125;;set&lt;P&gt; s;vector&lt;tii&gt; ans; inline void work() &#123; s.clear(); ans.clear(); int n = rd(), mxx = -1e9, mxy = -1e9, mnx = 1e9, mny = 1e9; auto add = [&amp;](int x, int y) &#123; P nw = P&#123;1.0 * x, 1.0 * y&#125;; if (s.count(nw)) s.erase(nw); else s.insert(nw); &#125;; for (int i = 1; i &lt;= n; ++i) &#123; int x1 = rd(), y1 = rd(), x2 = rd(), y2 = rd(); add(x1, y1); add(x1, y2); add(x2, y1); add(x2, y2); mxx = max(mxx, x2); mnx = min(mnx, x1); mxy = max(mxy, y2); mny = min(mny, y1); &#125; auto check = [&amp;](L l) &#123; for (auto p : s) if (s.count(l.refl(p)) == 0) return false; return true; &#125;; auto addans = [&amp;](int a, int b, int c) &#123; int g = gcd(gcd(abs(a), abs(b)), abs(c)); a /= g; b /= g; c /= g; tii res = max(make_tuple(a, b, c), make_tuple(-a, -b, -c)); ans.push_back(res); &#125;; // y = midy if (check(L&#123;&#123;0, (mxy + mny) / 2.0&#125;,&#123;1, 0&#125;&#125;)) addans(0, 2, mny + mxy); // x = midx if (check(L&#123;&#123;(mxx + mnx) / 2.0, 0&#125;,&#123;0, 1&#125;&#125;)) addans(2, 0, mnx + mxx); // &quot;/&quot; L l1&#123;&#123;(mxx + mnx) / 2.0, (mxy + mny) / 2.0&#125;, &#123;1, 1&#125;&#125;; if (check(l1)) addans(roundint(2 * l1.v.y), roundint(-2 * l1.v.x), roundint(2 * (l1.p.x * l1.v.y - l1.p.y * l1.v.x))); // &quot;\\&quot; l1 = L&#123;&#123;(mxx + mnx) / 2.0, (mxy + mny) / 2.0&#125;, &#123;1, -1&#125;&#125;; if (check(l1)) addans(roundint(2 * l1.v.y), roundint(-2 * l1.v.x), roundint(2 * (l1.p.x * l1.v.y - l1.p.y * l1.v.x))); printf(&quot;%d\\n&quot;, (int)ans.size()); sort(ans.begin(), ans.end()); reverse(ans.begin(), ans.end()); for (auto [a, b, c] : ans) printf(&quot;%d %d %d &quot;, a, b, c); puts(&quot;&quot;);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; B - Binary Tree ç»™å®šä¸€æ£µæ ‘ï¼Œè½®æµåˆ æ‰ä¸€ä¸ªæ»¡äºŒå‰å­æ ‘ï¼Œé—®è°èµ¢ã€‚ æ³¨æ„åˆ°æ»¡äºŒå‰æ ‘çš„ç‚¹æ•°æ€»æ˜¯å¥‡æ•°ï¼Œæ‰€ä»¥ç­”æ¡ˆåªå’Œæ€»èŠ‚ç‚¹æ•°çš„å¥‡å¶æ€§æœ‰å…³ã€‚ 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;inline void work() &#123; int x = rd(); puts((x &amp; 1) ? &quot;Alice&quot; : &quot;Bob&quot;); for (int i = 1; i &lt; x; ++i) &#123;rd(); rd();&#125;&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; C - Constructing Ranches èƒ–èƒ–è¯´æ˜¯ç‚¹åˆ†æ²»æ¿å­é¢˜ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#define fr first#define sc second#define mp make_pairusing namespace std;typedef long long LL;const int maxn=200000,maxt=maxn&lt;&lt;1,LOG=17;int te,n,a[maxn+5];LL sum[maxn+5],dis[maxn+5],ans;int E,lnk[maxn+5],nxt[(maxn&lt;&lt;1)+5],to[(maxn&lt;&lt;1)+5];int fa[maxn+5],dep[maxn+5],SH[maxn+5],top[maxn+5];int lt[maxn+5],ST[LOG+1][maxn+5],lg[maxn+5];int gr,S,si[maxn+5],ms[maxn+5];bool vis[maxn+5];int m;pair&lt;int,LL&gt; p[maxn+5];LL c[maxt+5];int tr[maxt+5];#define EOLN(x) ((x)==10 || (x)==13 || (x)==EOF)inline char readc()&#123; static char buf[1&lt;&lt;16],*l=buf,*r=buf; return l==r &amp;&amp; (r=(l=buf)+fread(buf,1,1&lt;&lt;16,stdin),l==r)?EOF:*l++;&#125;template&lt;typename T&gt; int readi(T &amp;x)&#123; T tot=0;char ch=readc(),lst=&#x27;+&#x27;; while (!isdigit(ch)) &#123;if (ch==EOF) return EOF;lst=ch;ch=readc();&#125; while (isdigit(ch)) tot=(tot&lt;&lt;3)+(tot&lt;&lt;1)+(ch^48),ch=readc(); lst==&#x27;-&#x27;?x=-tot:x=tot;return EOLN(ch);&#125;inline void Add(int x,int y) &#123;to[++E]=y;nxt[E]=lnk[x];lnk[x]=E;&#125;void DFS(int x,int pre=0)&#123; si[x]=1;SH[x]=0;fa[x]=pre;dep[x]=dep[pre]+1; for (int j=lnk[x];j;j=nxt[j]) if (to[j]!=pre)&#123; DFS(to[j],x);si[x]+=si[to[j]]; if (si[to[j]]&gt;si[SH[x]]) SH[x]=to[j]; &#125;&#125;void HLD(int x,int lst,int pre=0)&#123; lt[x]=++lt[0];ST[0][lt[0]]=a[x];top[x]=lst; if (SH[x]) HLD(SH[x],lst,x); for (int j=lnk[x];j;j=nxt[j]) if (to[j]!=pre &amp;&amp; to[j]!=SH[x]) HLD(to[j],to[j],x);&#125;int Max(int L,int R) &#123;int k=lg[R-L+1];return max(ST[k][L],ST[k][R-(1&lt;&lt;k)+1]);&#125;void getgr(int x,int pre=0)&#123; si[x]=1;ms[x]=0; for (int j=lnk[x],u;j;j=nxt[j]) if ((u=to[j])!=pre &amp;&amp; !vis[u])&#123; getgr(u,x);si[x]+=si[u]; ms[x]=max(ms[x],si[u]); &#125; ms[x]=max(ms[x],S-si[x]); if (!gr || ms[x]&lt;ms[gr]) gr=x;&#125;pair&lt;int,LL&gt; Ask(int x,int y)&#123; int MAX=0;LL S=0; while (top[x]!=top[y])&#123; if (dep[top[x]]&lt;dep[top[y]]) swap(x,y); MAX=max(MAX,Max(lt[top[x]],lt[x])); S+=sum[lt[x]]-sum[lt[top[x]]-1]; x=fa[top[x]]; &#125; if (lt[x]&gt;lt[y]) swap(x,y); MAX=max(MAX,Max(lt[x],lt[y])); S+=sum[lt[y]]-sum[lt[x]-1]; return mp(MAX,S);&#125;void getpair(int x,int fa,int pre=0)&#123; p[++m]=Ask(x,fa); for (int j=lnk[x],u;j;j=nxt[j]) if ((u=to[j])!=pre &amp;&amp; !vis[u]) getpair(to[j],fa,x);&#125;int Find(LL x)&#123; int L=1,R=c[0]; for (int mid=L+(R-L&gt;&gt;1);L&lt;=R;mid=L+(R-L&gt;&gt;1)) x&lt;=c[mid]?R=mid-1:L=mid+1; return L;&#125;void Insert(int x,int y) &#123;for (;x&lt;=c[0];x+=x&amp;-x) tr[x]+=y;&#125;int Sum(int x) &#123;int sum=0;for (;x;x-=x&amp;-x) sum+=tr[x];return sum;&#125;void Count(int x,int fa,int f)&#123; m=0;getpair(x,fa); sort(p+1,p+1+m);c[0]=0; for (int i=1;i&lt;=m;i++) c[++c[0]]=(p[i].fr&lt;&lt;1)-p[i].sc,c[++c[0]]=p[i].sc-a[fa]; sort(c+1,c+1+c[0]);c[0]=unique(c+1,c+1+c[0])-(c+1); for (int i=1;i&lt;=c[0];i++) tr[i]=0; for (int i=1;i&lt;=m;i++)&#123; LL A=c[0]-Find((p[i].fr&lt;&lt;1)-p[i].sc)+1,B=c[0]-Find(p[i].sc-a[fa])+1; ans+=f*Sum(A-1);Insert(B,1); &#125;&#125;void Divide(int x)&#123; vis[x]=true;Count(x,x,1); for (int j=lnk[x],u;j;j=nxt[j]) if (!vis[u=to[j]])&#123; Count(u,x,-1); gr=0;S=si[u];getgr(u);Divide(gr); &#125;&#125;int main()&#123; for (int i=2;i&lt;=maxn;i++) lg[i]=lg[i&gt;&gt;1]+1; for (readi(te);te;te--)&#123; readi(n);for (int i=1;i&lt;=n;i++) readi(a[i]); E=0;for (int i=1;i&lt;=n;i++) lnk[i]=0; for (int i=1,x,y;i&lt;n;i++) readi(x),readi(y),Add(x,y),Add(y,x); DFS(1);lt[0]=0;HLD(1,1); for (int j=1;(1&lt;&lt;j)&lt;=n;j++) for (int i=1;i+(1&lt;&lt;j)-1&lt;=n;i++) ST[j][i]=max(ST[j-1][i],ST[j-1][i+(1&lt;&lt;j-1)]); for (int i=1;i&lt;=n;i++) sum[i]=sum[i-1]+ST[0][i]; for (int i=1;i&lt;=n;i++) vis[i]=false; ans=0;gr=0;S=n;getgr(1);Divide(gr); printf(&quot;%lld\\n&quot;,ans); &#125; return 0;&#125; D - Defining Labels æ‰¾ \\(k\\) è¿›åˆ¶ä¸‹çš„ç¬¬ \\(X\\) å°æ•°ã€‚ 12345678910111213141516171819#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int maxl=100000;int te,K,n,a[maxl+5];int main()&#123; for (scanf(&quot;%d&quot;,&amp;te);te;te--)&#123; scanf(&quot;%d%d&quot;,&amp;K,&amp;n); LL pw=K,len=1; while (n&gt;pw) n-=pw,pw*=K,len++; n--; for (int i=0;i&lt;len;i++) a[i]=n%K,n/=K; for (int i=len-1;~i;i--) putchar(a[i]+10-K+48);puts(&quot;&quot;); &#125; return 0;&#125; *E - Erasing Numbers ç»™å®šé•¿åº¦ä¸º \\(n\\) çš„æ•°åˆ— \\(a_1,a_2,\\dots,a_n\\) ï¼Œä¿è¯ \\(n\\) æ˜¯å¥‡æ•°ï¼Œ\\(a_i\\) ä¸¤ä¸¤ä¸åŒï¼Œæ¯æ¬¡æ“ä½œé€‰æ‹©ç›¸é‚»çš„ä¸‰ä¸ªæ•°ï¼Œä¿ç•™ä¸­ä½æ•°ã€‚ æœ€åä¸€å®šåªä¼šå‰©ä¸‹ä¸€ä¸ªæ•°å­—ã€‚å¯¹äºæ¯ä¸ª \\(a_i\\) ï¼Œè¯¢é—®æ˜¯å¦å­˜åœ¨ä¸€ç§æ“ä½œé¡ºåºï¼Œä½¿å¾—æœ€åå‰©ä¸‹çš„æ•°å­—æ˜¯ä»–ã€‚ åˆæ˜¯å¥‡æ€ªçš„è´ªå¿ƒé¢˜ã€‚é¦–å…ˆå¦‚æœä¸€ä¸ªæ•°æ˜¯ä¸­ä½æ•°ï¼Œé‚£ä¹ˆå®ƒè‚¯å®šèƒ½è¢«ç•™ä¸‹æ¥ã€‚ æ¯”å¦‚å½“å‰è€ƒè™‘çš„æ˜¯ \\(x\\) ï¼Œä»¤æ¯” \\(x\\) å¤§çš„ä¸º \\(1\\) ï¼Œæ¯” \\(x\\) å°çš„ä¸º \\(0\\) ï¼Œé‚£ä¹ˆè‚¯å®šæœ‰æŸä¸€ç±»ä¼šå¤šå‡ºæ¥ã€‚ ä»¥ \\(x\\) ä¸ºæ–­ç‚¹å°†åºåˆ—åˆ†æˆä¸¤æ®µï¼Œæ¯ä¸€æ®µå°½å¯èƒ½æ¶ˆé™¤å¤šçš„é‚£ä¸€ç±»å³å¯ï¼ˆè¿ç»­ \\(3\\) ä¸ªå³å¯å°‘ \\(2\\) ä¸ªï¼‰ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;inline bool getmin(int &amp;a, int b) &#123;return (a &gt; b ? (a = b, true) : false);&#125;inline bool getmax(int &amp;a, int b) &#123;return (a &lt; b ? (a = b, true) : false);&#125;#define N 5007int a[N], b[N];inline int getmax(int l, int r, int tar) &#123; int cnt = 0, sum = 0; for (int i = l; i &lt;= r; ++i) &#123; if (b[i] == tar) &#123; if (cnt) --cnt; else sum += tar; &#125; else &#123; ++cnt; if (cnt &gt;= 3) cnt -= 2; &#125; &#125; return -tar * cnt + sum;&#125;inline void work() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) a[i] = rd(); for (int i = 1; i &lt;= n; ++i) &#123; int sum = 0; for (int j = 1; j &lt;= n; ++j) if (j != i) &#123; b[j] = (a[j] &gt; a[i] ? 1 : -1); sum += b[j]; &#125; if (sum == 0) &#123;putchar(&#x27;1&#x27;); continue;&#125; else &#123; if (sum &gt; 0 &amp;&amp; getmax(1, i - 1, -1) + getmax(i + 1, n, -1) &lt;= 0) &#123;putchar(&#x27;1&#x27;); continue;&#125; if (sum &lt; 0 &amp;&amp; getmax(1, i - 1, 1) + getmax(i + 1, n, 1) &gt;= 0) &#123;putchar(&#x27;1&#x27;); continue;&#125; &#125; putchar(&#x27;0&#x27;); &#125; puts(&quot;&quot;);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; F - Falling Objects ä¸‰ç»´è®¡ç®—å‡ ä½•å¤§æ¨¡æ‹Ÿã€‚ G - Game Design å°æ¸…æ–°æ„é€ ï¼Œæ»¡è¶³å¶å­æƒå€¼ \\(=1\\) ï¼Œçˆ¶èŠ‚ç‚¹æƒå€¼ \\(=\\prod\\) å„¿å­æƒå€¼ \\(+1\\) ï¼Œæ ¹èŠ‚ç‚¹ç»™å®šã€‚ æ¯æ¬¡åˆ†å¥‡å¶è®¨è®ºå³å¯ï¼Œå¶æ•°ä¸€ä¸ªå„¿å­ï¼Œå¥‡æ•°ä¸¤ä¸ªå„¿å­ \\(2\\) å’Œ \\(x/2\\) ï¼Œè¿™æ ·åªæœ‰ \\(\\log n\\) ä¸ªç‚¹ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 200007int tot, fa[N], son[N];int build(int k, int faa) &#123; int u = ++tot; fa[u] = faa; --k; if (k == 0) &#123;son[u] = 1; return u;&#125; if (k &amp; 1) son[u] = son[build(k, u)]; else &#123; son[u] += son[build(2, u)]; son[u] += son[build(k / 2, u)]; &#125; return u;&#125;int main() &#123; int k = rd(); if (k == 1) &#123;puts(&quot;2\\n1\\n1 2&quot;); return 0;&#125; build(k, 0); printf(&quot;%d\\n&quot;, tot); for (int i = 2; i &lt;= tot; ++i) printf(&quot;%d &quot;, fa[i]); puts(&quot;&quot;); for (int i = 1; i &lt;= tot; ++i) printf(&quot;%d &quot;, son[i]); return 0;&#125; H - Hold the Line èƒ–èƒ–è¡¥çš„ï¼Œè²Œä¼¼æ˜¯æŠŠå¤§å¸¸æ•°åŒ log æ”¹å°å¸¸æ•°åŒ logã€‚é“¾æ¥ **I - Incoming Asteroids æœ‰ \\(n\\) ä¸ªé›†åˆï¼Œå¼ºåˆ¶åœ¨çº¿ï¼Œæ”¯æŒ \\(m\\) ä¸ªæ“ä½œï¼š ç”³è¯·ä¸€ä¸ªæ–°çš„ IDï¼Œåˆå§‹æƒå€¼æ˜¯ \\(0\\) ï¼Œç›®æ ‡å€¼æ˜¯ \\(y_i\\) ï¼Œå°† ID åŠ å…¥ç»™å‡ºçš„ \\(k\\ (k\\le 3)\\) ä¸ªé›†åˆã€‚ å¯¹æŸä¸ªé›†åˆä¸­çš„ IDï¼Œä»¤ä»–ä»¬çš„æƒå€¼å¢åŠ  \\(w_i\\) ã€‚æŠ¥å‘Šç¬¬ä¸€æ¬¡è¾¾åˆ°ç›®æ ‡çš„äººæ•°ã€‚ ç¥å¥‡çš„æš´åŠ›ã€‚è€ƒè™‘ä¸€ä¸ªéœ€æ±‚è¢«åˆ†æˆäº† \\(k\\) ä»½ï¼Œå¦‚æœè¦è¢«è¾¾åˆ°ï¼Œæ€»æœ‰ä¸€ä»½è¦è¾¾åˆ°æ€»é‡\\(/k\\) ã€‚ å› æ­¤åœ¨æ¯ä¸ªæ’å…¥çš„é›†åˆé‡Œéƒ½æ”¾ä¸Šä¸€ä¸ªæé†’ï¼Œå¦‚æœå¢é‡è¾¾åˆ°äº†éœ€æ±‚ï¼Œå°±æŠŠæ‰€æœ‰é›†åˆçš„æé†’éƒ½æ’¤é”€ï¼Œç„¶åé‡æ–°åˆ† \\(k\\) ä»½å¡è¿›å»ã€‚ æ¯æ¬¡æé†’å½“å‰å‰©ä½™çš„éœ€æ±‚æœ€å¤šå‰©ä¸‹åŸæ¥çš„ \\(\\frac{k-1}{k}\\) ï¼Œæ‰€ä»¥å¤æ‚åº¦æ˜¯ \\(\\mathcal{O}(m\\log_{\\frac{k}{k+1}} y_i)\\) ï¼Œå½“ \\(k=3\\) æ—¶å¯ä»¥æ¥å—ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first#define sc second#define mp make_pair#define mt make_tuple#define pb push_back#define pii pair&lt;int, int&gt;#define tii tuple&lt;int, int, int&gt;#define all(s) (s).begin(), (s).end()#define N 200007set&lt;pii&gt; s[N];vector&lt;pii&gt; a[N];vector&lt;int&gt; ans, pos;ll need[N], val[N];inline void reset(int id) &#123; pos.clear(); for (auto [w, p] : a[id]) &#123;s[p].erase(mp(w, id)); pos.pb(p);&#125; a[id].clear(); ll nw = 0; for (auto p : pos) nw += val[p]; if (nw &gt;= need[id]) &#123;ans.pb(id); return;&#125; ll w = max(1ull, (need[id] - nw) / pos.size()); for (auto p : pos) &#123; s[p].insert(mp(val[p] + w, id)); a[id].pb(mp(val[p] + w, p)); &#125;&#125; int main() &#123; int n = rd(), m = rd(); int id = 0, lst = 0; for (int i = 1; i &lt;= m; ++i) &#123; int op = rd(); if (op == 1) &#123; need[++id] = rd() ^ lst; int k = rd(); ll w = max(1ll, need[id] / k); for (int p; k; --k) &#123; need[id] += val[p = rd() ^ lst]; s[p].insert(mp(val[p] + w, id)); a[id].pb(mp(val[p] + w, p)); &#125; &#125; else &#123; int x = rd() ^ lst; val[x] += rd() ^ lst; ans.clear(); while (!s[x].empty() &amp;&amp; val[x] &gt;= s[x].begin() -&gt; fr) reset(s[x].begin() -&gt; sc); printf(&quot;%d&quot;, lst = ans.size()); sort(all(ans)); for (auto i : ans) printf(&quot; %d&quot;, i); puts(&quot;&quot;); &#125; &#125; return 0;&#125; J - Junior Mathematician èƒ–èƒ–è¯´æ˜¯æ•°ä½dpæ¿å­é¢˜ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn=5000,maxk=60,MOD=1e9+7;int te,K,pw[maxn+5];char L[maxn+5],R[maxn+5];int n,a[maxn+5],f[maxn+5][maxk+5][maxk+5][2],ans;inline int ADD(int x,int y) &#123;return x+y&gt;=MOD?x+y-MOD:x+y;&#125;inline int MUL(int x,int y) &#123;return (LL)x*y%MOD;&#125;void DP(int tp)&#123; for (int i=0;i&lt;=n;i++) for (int j=0;j&lt;K;j++) for (int k=0;k&lt;K;k++) f[i][j][k][0]=f[i][j][k][1]=0; f[0][a[0]%K][(K-a[0]*pw[n]%K)%K][1]++; for (int i=0;i&lt;a[0];i++) f[0][i%K][(K-i*pw[n]%K)%K][0]++; for (int i=1;i&lt;=n;i++) for (int j=0;j&lt;K;j++) for (int k=0,F;k&lt;K;k++)&#123; if (F=f[i-1][j][k][0]) for (int t=0;t&lt;10;t++)&#123; int A=(j+t)%K,B=(k+j*t+K-t*pw[n-i]%K)%K; f[i][A][B][0]=ADD(f[i][A][B][0],F); &#125; if (F=f[i-1][j][k][1])&#123; for (int t=0;t&lt;a[i];t++)&#123; int A=(j+t)%K,B=(k+j*t+K-t*pw[n-i]%K)%K; f[i][A][B][0]=ADD(f[i][A][B][0],F); &#125; int A=(j+a[i])%K,B=(k+j*a[i]+K-a[i]*pw[n-i]%K)%K; f[i][A][B][1]=ADD(f[i][A][B][1],F); &#125; &#125; for (int i=0;i&lt;K;i++) ans=ADD(ans,MUL(tp,ADD(f[n][i][0][0],f[n][i][0][1])));&#125;int main()&#123; for (scanf(&quot;%d&quot;,&amp;te);te;te--)&#123; scanf(&quot;%s%s%d&quot;,L,R,&amp;K);n=strlen(R); pw[0]=1;for (int i=1;i&lt;=n;i++) pw[i]=(pw[i-1]*10)%K; n=strlen(L)-1;for (int i=0;i&lt;=n;i++) a[i]=L[i]-&#x27;0&#x27;; reverse(a,a+n+1);a[0]--; for (int i=0;i&lt;=n &amp;&amp; a[i]&lt;0;i++) a[i]+=10,a[i+1]--; while (n&gt;0 &amp;&amp; !a[n]) n--; reverse(a,a+n+1); ans=0; DP(MOD-1); n=strlen(R)-1;for (int i=0;i&lt;=n;i++) a[i]=R[i]-&#x27;0&#x27;; DP(1); printf(&quot;%d\\n&quot;,ans); &#125; return 0;&#125; *K - Key Project æœ‰ \\(n\\ (n\\le 800)\\) æ ‹æ¥¼æ’æˆä¸€åˆ—ï¼Œç»™å‡ºç›¸é‚»ä¸¤ä¸ªæ¥¼çš„è·ç¦»ã€‚ æœ‰ \\(m\\ (m\\le 50000)\\) ä¸ª A ç±»äººï¼Œ\\(m\\) ä¸ª B ç±»äººï¼Œæ¯ä¸ªäººæœ‰ä¸¤ä¸ªå‚æ•° \\(x,c\\) ï¼Œä»£è¡¨ä½äºç¬¬ \\(x\\) æ ‹æ¥¼ä¸­ï¼Œè˜è¯·çš„ä»£ä»·æ˜¯ \\(c\\) ã€‚ ç§°ä¸€å¯¹äººåŒ…æ‹¬ä¸€ä¸ª A ç±»äººä¸€ä¸ª B ç±»äººï¼Œä»£ä»·æ˜¯è˜è¯·ä»–ä»¬çš„ä»£ä»·å’Œ + ä»–ä»¬ä¹‹é—´çš„è·ç¦»ã€‚ ç°åœ¨è¦è˜è¯· \\(k\\) å¯¹äººï¼Œä»£ä»·æ˜¯è˜è¯·æ¯ä¸€å¯¹çš„ä»£ä»·ä¹‹å’Œï¼Œæ±‚æœ€å°ä»£ä»·ã€‚å¯¹ \\(k=1\\dots m\\) ã€‚ å¯¹ \\(k=1\\dots m\\) å³æ¯æ¬¡è€ƒè™‘æ–°å¢ä¸€å¯¹ï¼Œè¿™æç¤ºæˆ‘ä»¬è€ƒè™‘è´¹ç”¨æµã€‚ ä¸ºæ¯ä¸ªå»ºç­‘å»ºä¸€ä¸ªç‚¹ï¼Œç›¸é‚»å»ºç­‘ä¹‹é—´è¿å®¹é‡æ— ç©·ï¼Œä»£ä»·ä¸ºè·ç¦»çš„è¾¹ã€‚ å¯¹äºæ¯ä¸ª A ç±»äººï¼Œè¿ \\(S\\to x_i\\) ï¼Œå®¹é‡ä¸º \\(1\\) ï¼Œä»£ä»·ä¸º \\(c_i\\) ï¼›å¯¹äº B ç±»äººå°±å’Œ \\(T\\) ä»¥åŒæ ·çš„æ–¹å¼ç›¸è¿ã€‚ é—®é¢˜å˜æˆæ¯æ¬¡å¢å¹¿æµé‡ä¸º \\(1\\) çš„æµã€‚ç›´æ¥åš EK å¤æ‚åº¦æ¯”è¾ƒé«˜ã€‚ è€ƒè™‘æ¨¡æ‹Ÿè´¹ç”¨æµï¼Œå•æ¬¡å¢å¹¿å¤æ‚åº¦é™ä½åˆ° \\(O(n)\\) ã€‚ å› ä¸ºæ¯æ¬¡å¢å¹¿çš„æµé‡åªæœ‰ \\(1\\) ï¼Œæ‰€ä»¥ï¼š æ¯ä¸ªç‚¹åªéœ€è¦è€ƒè™‘å®ƒæ‹¥æœ‰çš„æœ€å°ä»£ä»·çš„ A ç±»äººå’Œ B ç±»äºº ã€‚ç”¨å †ç»´æŠ¤ã€‚ æ¯æ¡è¾¹åªéœ€è¦è€ƒè™‘ \\(1\\) æµé‡æ—¶çš„æœ€å°ä»£ä»·ï¼Œä¼˜å…ˆè€ƒè™‘é€€æµçš„è´Ÿä»£ä»·è¾¹å³å¯ã€‚ å¯¹æ¯ä¸ªæ–¹å‘æ±‚å‡ºæ¥ä»£ä»·çš„å‰ç¼€å’Œï¼Œé‚£ä¹ˆé€‰æ‹©ä¸€å¯¹ç‚¹çš„ä»£ä»·å¯ä»¥æ‹†åˆ†æˆä¸¤ä¸ªä½ç½®ç‹¬ç«‹çš„è´¡çŒ®ã€‚ ç„¶åæ‰«ä¸€éå°±å¯ä»¥æ±‚å‡ºæ¥ç­”æ¡ˆäº†ï¼Œæ³¨æ„ç­”æ¡ˆæœ‰ A å·¦ B å³ã€B å·¦ A å³ä¸¤ç§æƒ…å†µã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i, x, y) for(int i = (x); i &lt;= (y); ++i)#define per(i, x, y) for(int i = (x); i &gt;= (y); --i)template&lt;typename T&gt;inline bool getmin(T &amp;a, T b) &#123;return a &gt; b ? (a = b, true) : false;&#125;template&lt;typename T&gt;inline bool getmax(T &amp;a, T b) &#123;return a &lt; b ? (a = b, true) : false;&#125;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 807#define inf 1e18/*1. lr[i] : the number of backflow unit from i - 1 to i cost for [(i - 1) -&gt; i] = (lr[i] &gt; 0 ? -d[i] : d[i]);2. rl[i] : the number of backflow unit from i to i - 1 cost for [i -&gt; (i - 1)] = (rl[i] &gt; 0 ? -d[i] : d[i]);*/int d[N], lr[N], rl[N], mnA[N], mnB[N];ll cstlr[N], cstrl[N];priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; A[N], B[N];int main() &#123; int n = rd(), m = rd(); rep(i, 2, n) d[i] = rd(); rep(i, 1, m) &#123;int p = rd(); A[p].push(rd());&#125; rep(i, 1, m) &#123;int p = rd(); B[p].push(rd());&#125; /* cost from l to r : (mnA[L] - cstlr[L]) + (mnB[R] + cstlr[R]) cost from r to l : (mnB[L] - cstrl[L]) + (mnA[R] + cstrl[R]) */ ll ans = 0; rep(t, 1, m) &#123; rep(i, 1, n) &#123; // [mnx[i] = 0] : person of type x dosen&#x27;t exist mnA[i] = (A[i].empty() ? 0 : A[i].top()); mnB[i] = (B[i].empty() ? 0 : B[i].top()); &#125; rep(i, 2, n) &#123; cstlr[i] = cstlr[i - 1] + (lr[i] ? -d[i] : d[i]); cstrl[i] = cstrl[i - 1] + (rl[i] ? -d[i] : d[i]); &#125; ll cst = inf; int pA = 0, pB = 0, Al = 0, Bl = 0; rep(i, 1, n) &#123; if (mnA[i] &amp;&amp; (!Al || mnA[Al] - cstlr[Al] &gt; mnA[i] - cstlr[i])) Al = i; if (mnB[i] &amp;&amp; (!Bl || mnB[Bl] - cstrl[Bl] &gt; mnB[i] - cstrl[i])) Bl = i; if (Al &amp;&amp; mnB[i] &amp;&amp; getmin(cst, mnA[Al] - cstlr[Al] + mnB[i] + cstlr[i])) &#123;pA = Al; pB = i;&#125; if (Bl &amp;&amp; mnA[i] &amp;&amp; getmin(cst, mnB[Bl] - cstrl[Bl] + mnA[i] + cstrl[i])) &#123;pA = i; pB = Bl;&#125; &#125; ans += cst; printf(&quot;%lld\\n&quot;, ans); A[pA].pop(); B[pB].pop(); if (pA &lt; pB) rep(i, pA + 1, pB) lr[i] &gt; 0 ? --lr[i] : ++rl[i]; else rep(i, pB + 1, pA) rl[i] &gt; 0 ? --rl[i] : ++lr[i]; &#125; return 0;&#125;","categories":[{"name":"Official Contests","slug":"Official-Contests","permalink":"http://blog.gyx.me/categories/Official-Contests/"}],"tags":[{"name":"Greedy","slug":"Greedy","permalink":"http://blog.gyx.me/tags/Greedy/"},{"name":"Segment Tree","slug":"Segment-Tree","permalink":"http://blog.gyx.me/tags/Segment-Tree/"},{"name":"Geometry","slug":"Geometry","permalink":"http://blog.gyx.me/tags/Geometry/"},{"name":"Flows","slug":"Flows","permalink":"http://blog.gyx.me/tags/Flows/"},{"name":"Tricks","slug":"Tricks","permalink":"http://blog.gyx.me/tags/Tricks/"},{"name":"Divide and Conquer","slug":"Divide-and-Conquer","permalink":"http://blog.gyx.me/tags/Divide-and-Conquer/"}]},{"title":"2019 ICPC World Finals","slug":"official/icpc/19-world-finals","date":"2022-10-20T16:00:00.000Z","updated":"2023-03-20T16:36:00.467Z","comments":true,"path":"official/icpc/19-world-finals/","link":"","permalink":"http://blog.gyx.me/official/icpc/19-world-finals/","excerpt":"","text":"æ¯”èµ›åœ°å€ ï¼šCodeforces Gym 102511 A - Azulejos ä¸¤æ’é›•åƒï¼Œæ¯æ’ \\(n\\) ä¸ªï¼Œæ¯ä¸ªé›•åƒéƒ½æœ‰ä¸€ä¸ªé«˜åº¦ \\(h_i\\) å’Œæƒå€¼ \\(w_i\\) ã€‚ å¯¹æ¯æ’é‡æ–°æ’åºï¼Œä½¿å¾—ï¼š1. æ¯æ’ \\(w_i\\) ä»å·¦åˆ°å³ä¸¥æ ¼é™åºï¼›2. ç¬¬ä¸€æ’çš„æ¯ä¸ªä½ç½®çš„é›•åƒéƒ½æ¯”ç¬¬äºŒæ’å¯¹åº”ä½ç½®çš„é«˜ã€‚ è´ªå¿ƒï¼Œå…ˆæŒ‰ç…§ \\(w_i\\) ä»å¤§åˆ°å°æ’åºï¼Œæ˜¾ç„¶åªæœ‰ç›¸åŒæƒå€¼ä¹‹é—´çš„å¯ä»¥æœ‰ä½ç½®å˜åŠ¨ã€‚ ä»å·¦åˆ°å³ä¾æ¬¡è€ƒè™‘ï¼Œæ¯æ¬¡éƒ½æ‰©å±•ä¸€ä¸ªç›¸åŒæƒå€¼çš„åŒºé—´ï¼Œç„¶åç”¨å³ç«¯ç‚¹æ›´å°çš„åŒºé—´é‡Œçš„é›•åƒå»åŒ¹é…å³ç«¯ç‚¹æ›´å¤§çš„åŒºé—´é‡Œçš„é›•åƒã€‚ è¿™æ ·å­æˆ‘ä»¬çš„éœ€æ±‚éƒ½æ˜¯åœ¨å¿…é¡»æ»¡è¶³çš„æ—¶å€™æ»¡è¶³çš„ï¼Œå¹¶ä¸”å·²ç»è€ƒè™‘åˆ°äº†æ‰€æœ‰çš„æƒ…å†µã€‚åˆç†ä½¿ç”¨ STL å³å¯ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define mp make_pair#define mt make_tuple#define pb push_back#define pii pair&lt;int, int&gt;#define tii tuple&lt;int, int, int&gt;#define N 500007int p[N], ansb[N], anss[N];tii b[N], s[N];set&lt;pii&gt; B, S;int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) p[i] = rd(); for (int i = 1; i &lt;= n; ++i) b[i] = mt(p[i], rd(), i); sort(b + 1, b + 1 + n); for (int i = 1; i &lt;= n; ++i) p[i] = rd(); for (int i = 1; i &lt;= n; ++i) s[i] = mt(p[i], rd(), i); sort(s + 1, s + 1 + n); int tot = 0; for (int ptrs = 0, ptrb = 0; ptrs &lt; n || ptrb &lt; n;) &#123; if (ptrs &gt; ptrb) &#123; ++ptrb; B.insert(mp(get&lt;1&gt;(b[ptrb]), get&lt;2&gt;(b[ptrb]))); while (ptrb &lt; n &amp;&amp; get&lt;0&gt;(b[ptrb]) == get&lt;0&gt;(b[ptrb + 1])) &#123; ++ptrb; B.insert(mp(get&lt;1&gt;(b[ptrb]), get&lt;2&gt;(b[ptrb]))); &#125; &#125; else if (ptrs &lt; ptrb) &#123; ++ptrs; S.insert(mp(get&lt;1&gt;(s[ptrs]), get&lt;2&gt;(s[ptrs]))); while (ptrs &lt; n &amp;&amp; get&lt;0&gt;(s[ptrs]) == get&lt;0&gt;(s[ptrs + 1])) &#123; ++ptrs; S.insert(mp(get&lt;1&gt;(s[ptrs]), get&lt;2&gt;(s[ptrs]))); &#125; &#125; else &#123; ++ptrb; B.insert(mp(get&lt;1&gt;(b[ptrb]), get&lt;2&gt;(b[ptrb]))); while (ptrb &lt; n &amp;&amp; get&lt;0&gt;(b[ptrb]) == get&lt;0&gt;(b[ptrb + 1])) &#123; ++ptrb; B.insert(mp(get&lt;1&gt;(b[ptrb]), get&lt;2&gt;(b[ptrb]))); &#125; ++ptrs; S.insert(mp(get&lt;1&gt;(s[ptrs]), get&lt;2&gt;(s[ptrs]))); while (ptrs &lt; n &amp;&amp; get&lt;0&gt;(s[ptrs]) == get&lt;0&gt;(s[ptrs + 1])) &#123; ++ptrs; S.insert(mp(get&lt;1&gt;(s[ptrs]), get&lt;2&gt;(s[ptrs]))); &#125; &#125; if (ptrs &lt;= ptrb) &#123; for (auto [h, id] : S) &#123; if (h &gt;= (*--B.end()).first) &#123;puts(&quot;impossible&quot;); return 0;&#125; anss[++tot] = id; ansb[tot] = (*B.upper_bound(mp(h, 1e9))).second; B.erase(B.upper_bound(mp(h, 1e9))); &#125; S.clear(); &#125; else &#123; for (auto [h, id] : B) &#123; if (h &lt;= (*S.begin()).first) &#123;puts(&quot;impossible&quot;); return 0;&#125; ansb[++tot] = id; anss[tot] = (*--S.lower_bound(mp(h, 0))).second; S.erase(--S.lower_bound(mp(h, 0))); &#125; B.clear(); &#125; &#125; for (int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, ansb[i]); puts(&quot;&quot;); for (int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, anss[i]); return 0;&#125; *B - Beautiful Bridges é¢˜é¢å¤ªéº»çƒ¦äº†ä¸å†èµ˜è¿°ï¼Œè¦æ±‚æŠ˜çº¿ä¸èƒ½ä¸ä¸ŠåŠåœ†å¤–æœ‰äº¤ï¼Œæœ€å°åŒ–ä»£ä»·ã€‚ æ•°æ®èŒƒå›´æ˜¯å…è®¸ \\(\\mathcal{O}(n^2)\\) åšçš„ï¼Œå› æ­¤è®¾ \\(f[i]\\) è¡¨ç¤ºå‰ \\(i\\) ä¸ªï¼Œä¸” \\(i\\) æ”¾äº†æ¡¥å¢©çš„æœ€å°ä»£ä»·ï¼Œè½¬ç§»å¾ˆç›´æ¥ã€‚ é—®é¢˜å°±æ˜¯å¦‚ä½•åˆ¤æ–­å¯ä»¥è½¬ç§»ï¼Œå³ï¼šåˆ¤æ–­åŒºé—´å†…çš„ç‚¹æ˜¯å¦åœ¨ä¸ŠåŠåœ†å¤–ã€‚ æˆ‘ä»¬è€ƒè™‘æšä¸¾å·¦ç«¯ç‚¹ \\(i\\) ï¼Œç„¶åå†æšä¸¾è¢«æ›´æ–°çš„æ‰€æœ‰å³ç«¯ç‚¹ \\(j\\) ï¼Œé‚£ä¹ˆå¯ä»¥æ³¨æ„åˆ°åœ†å¿ƒçš„è½¨è¿¹æ˜¯ \\((x_i+r,H-r),r\\ge 0\\) ã€‚ è€ƒè™‘ä¸€ä¸ªç‚¹åˆ°åœ†å¿ƒçš„è·ç¦»ï¼Œå…¶å®å°±æ˜¯ä»æ— ç©·è¿œå˜æˆç‚¹åˆ°ç›´çº¿è·ç¦»å†å˜åˆ°æ— ç©·è¿œï¼Œå› æ­¤ä¸€ä¸ªç‚¹çš„åˆæ³•èŒƒå›´ä¸€å®šæ˜¯ä¸€ä¸ªåŒºé—´ã€‚ è€ƒè™‘ä¸€ä¸ªç‚¹ \\((x_j,y_j)\\) å¸¦æ¥çš„çº¦æŸï¼Œä¸´ç•Œå€¼æ˜¾ç„¶å–åœ¨ \\((x_j-(x_i+r))^2+(y_j-(H-r))^2=r^2\\) å¤„ï¼š å¦‚æœ \\((x_j,y_j)\\) åŠ å…¥æ—¶å¤„äºåœ†å¿ƒä¸Šæ–¹ï¼ˆ \\(y_j\\ge H-\\frac{x_j-x_i}{2}\\) ï¼‰ï¼Œé‚£ä¹ˆçº¦æŸå°±æ˜¯ \\(r\\in\\) æ–¹ç¨‹ä¸¤æ ¹ä¹‹é—´çš„åŒºé—´ã€‚ å¦åˆ™ï¼Œåªä¼šå¯¹ \\(r\\) äº§ç”Ÿä¸€ä¸ªä¸Šç•Œçš„çº¦æŸï¼ˆå› ä¸ºå¦ä¸€ä¸ªçº¦æŸä¸åˆæ³•çš„åŸå› æ˜¯ä¸ä¸‹åŠåœ†å†²çªäº†ï¼Œå®é™…æ²¡å…³ç³»ï¼‰ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 10007ll x[N], y[N], f[N];inline double sqr(double x) &#123;return x * x;&#125;int main() &#123; memset(f, 0x3f, sizeof(f)); ll n = rd(), H = rd(), alpha = rd(), beta = rd(); for (int i = 1; i &lt;= n; ++i) &#123;x[i] = rd(); y[i] = rd();&#125; f[1] = alpha * (H - y[1]); ll inf = f[n]; for (int i = 1; i &lt;= n; ++i) &#123; double l = 0, r = H - y[i]; for (int j = i + 1; j &lt;= n; ++j) &#123; double b = 2 * (x[i] + y[j] - x[j] - H); double c = sqr(x[j] - x[i]) + sqr(y[j] - H); double dlt = sqrt(b * b - 4 * c); double L = (-b - dlt) / 2, R = (-b + dlt) / 2; r = min(r, R); if (1.0 * y[j] &gt;= H - 1.0 * (x[j] - x[i]) / 2.0) l = max(l, L); double nwpos = 1.0 * (x[j] - x[i]) / 2.0; if (nwpos &gt;= l - 1e-8 &amp;&amp; nwpos &lt;= r + 1e-8) f[j] = min(f[j], f[i] + alpha * (H - y[j]) + beta * (x[j] - x[i]) * (x[j] - x[i])); &#125; &#125; if (f[n] == inf) &#123;puts(&quot;impossible&quot;); return 0;&#125; printf(&quot;%lld\\n&quot;, f[n]); return 0;&#125; D - Circular DNA ç»™å®šä¸€ä¸ªç¯çŠ¶æ‹¬å·åºåˆ—ï¼Œæœ‰ \\(n\\) ç±»æ‹¬å·åˆ†åˆ«è®°åš \\((_i\\) å’Œ \\()_i\\) ï¼Œæ¯ç±»å·¦æ‹¬å·åªèƒ½ä¸åŒä¸€ç±»å³æ‹¬å·åŒ¹é…ã€‚ æ‰¾ä¸€ä¸ªæ–­å¼€çš„ä½ç½®å˜æˆä¸€ä¸ªåºåˆ—ï¼Œæœ€å¤§åŒ–åˆæ³•çš„æ‹¬å·ç±»æ•°ï¼Œå¦‚æœæœ‰å¤šä¸ªä½ç½®æ‰¾ä¸‹æ ‡æœ€å°çš„ã€‚ å®šä¹‰ä¸€ç±»æ‹¬å·åˆæ³•ï¼Œå½“ä¸”ä»…å½“ä»…è€ƒè™‘è¯¥ç±»æ‹¬å·ï¼Œå½“å‰åºåˆ—æ˜¯ä¸€ä¸ªåˆæ³•çš„æ‹¬å·åºåˆ—ã€‚ å¯¹æ¯ç±»åˆ†å¼€è€ƒè™‘ï¼Œåˆæ³•çš„ä½ç½®ä¸€å®šæ˜¯è‹¥å¹²ä¸ªåŒºé—´ï¼Œç„¶åçº¿æ®µæ ‘æ”¯æŒåŒºé—´åŠ æ±‚æœ€å€¼å³å¯ã€‚ ä¸€ä¸ªæ¯”è¾ƒå¥½å†™çš„æ–¹æ³•ï¼šå‡è®¾å¼€å§‹çš„ä½ç½®æ˜¯ \\(0\\) ï¼Œå·¦æ‹¬å· \\(-1\\) ï¼Œå³æ‹¬å· \\(+1\\) ï¼Œè®°å½•å‰ç¼€å’Œã€‚ é‚£ä¹ˆåˆæ³•åŒºé—´çš„å·¦ç«¯ç‚¹ä¸€å®šæ˜¯å‰ç¼€å’Œæœ€å°çš„é‚£äº›ä½ç½®ï¼Œå³ç«¯ç‚¹å°±æ˜¯å¯¹åº”çš„ä¸‹ä¸€ä¸ªä½ç½®ã€‚ upd on 2022/11/4 : å› ä¸ºåªéœ€è¦åœ¨æœ€åæŸ¥æœ€å€¼ç‚¹ï¼Œå·®åˆ†å³å¯ï¼Œå¹¶ä¸éœ€è¦çº¿æ®µæ ‘ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first #define sc second#define mp make_pair#define mt make_tuple#define pb push_back#define pii pair&lt;int, int&gt;#define tii tuple&lt;int, int, int&gt;#define N 1000007vector&lt;pii&gt; s[N];#define ls (rt &lt;&lt; 1)#define rs (rt &lt;&lt; 1 | 1)#define mid ((l + r) &gt;&gt; 1)int n, tag[N &lt;&lt; 2];pii mx[N &lt;&lt; 2];void pushdown(int rt) &#123; if (tag[rt]) &#123; mx[ls].fr += tag[rt]; tag[ls] += tag[rt]; mx[rs].fr += tag[rt]; tag[rs] += tag[rt]; tag[rt] = 0; &#125;&#125;void pushup(int rt) &#123; if (mx[ls].fr &gt; mx[rs].fr) mx[rt] = mx[ls]; else if (mx[ls].fr &lt; mx[rs].fr) mx[rt] = mx[rs]; else &#123;mx[rt].fr = mx[ls].fr; mx[rt].sc = min(mx[ls].sc, mx[rs].sc);&#125;&#125;void build(int rt, int l, int r) &#123; mx[rt].sc = l; if (l == r) return; build(ls, l, mid); build(rs, mid + 1, r);&#125;void upd(int rt, int l, int r, int L, int R) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; ++mx[rt].fr; ++tag[rt]; return; &#125; pushdown(rt); if (L &lt;= mid) upd(ls, l, mid, L, R); if (R &gt; mid) upd(rs, mid + 1, r, L, R); pushup(rt);&#125;void add(int l, int r) &#123; if (l &lt;= r) upd(1, 1, n, l, r); else &#123; upd(1, 1, n, 1, r); if (l &lt;= n) upd(1, 1, n, l, n); &#125;&#125;int tmp[N], pos[N];inline void work(int x) &#123; tmp[0] = 0; int tot = 0, mn = 0; for (auto [v, p] : s[x]) &#123; ++tot; tmp[tot] = tmp[tot - 1] + v; mn = min(mn, tmp[tot]); pos[tot] = p; &#125; if (tmp[tot] != 0) return; for (int i = 1; i &lt; tot; ++i) if (tmp[i] == mn) add(pos[i] + 1, pos[i + 1]); if (tmp[tot] == mn) add(pos[tot] + 1, pos[1]);&#125;int main() &#123; n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; char c = getchar(); while (!isalpha(c)) c = getchar(); int x = rd(); s[x].pb(mp((c == &#x27;s&#x27; ? 1 : -1), i)); &#125; build(1, 1, n); for (int i = 1; i &lt;= 1000000; ++i) if (!s[i].empty()) work(i); printf(&quot;%d %d\\n&quot;, mx[1].sc, mx[1].fr); return 0;&#125; *E - Dead-End Detector ç»™å®šæ— å‘å›¾ï¼Œå®šä¹‰ \\(E_i=(u_i,v_i)\\) åœ¨ \\(u_i\\) ç«¯è¦æ”¾æ­»è·¯ç‰Œï¼šä» \\(u_i\\) ç»è¿‡ \\(E_i\\) ä¹‹åï¼Œå¦‚æœæƒ³å› \\(u_i\\) ä¸€å®šè¦åœ¨æŸä¸ªé¡¶ç‚¹åŸè·¯è¿”å›ã€‚ ä½†å¦‚æœå­˜åœ¨ \\(x\\) ç»è¿‡ \\(E_i\\) ä¹‹åå¯ä»¥åˆ°è¾¾ \\(y\\) å†ç»è¿‡ \\(E_j\\) ï¼Œå¹¶ä¸” \\(E_i\\) åœ¨ \\(x\\) ç«¯æœ‰æ­»è·¯ç‰Œã€\\(E_j\\) åœ¨ \\(y\\) ç«¯æœ‰æ­»è·¯ç‰Œï¼Œé‚£ä¹ˆåè€…å¯ä»¥çœå»ã€‚ æ„é€ æœ€å°æ”¾ç½®æ­»è·¯ç‰Œæ•°æ–¹æ¡ˆã€‚ å¯¹æ¯ä¸ªè¿é€šå—è€ƒè™‘ã€‚ å¦‚æœæ˜¯ä¸€æ£µæ ‘ï¼Œæ¯æ¡è¾¹éƒ½æ˜¯æ­»è·¯ã€‚å‘ç°åªéœ€è¦åœ¨æ‰€æœ‰çš„å¶å­ç«¯æ”¾ç½®å³å¯ï¼Œå…¶ä»–è·¯å¾„å¿…å®šå¯ä»¥åç€æ‰¾åˆ°ä¸€æ¡ä»å¶å­å‡ºå‘çš„è¾¹ã€‚ å¦‚æœæ˜¯å…¶ä»–æƒ…å†µï¼Œä¸€å®šå­˜åœ¨å›è·¯ã€‚è€ƒè™‘å…ˆæ‹å‡ºæ¥ä¸€æ£µç”Ÿæˆæ ‘ï¼Œæ¯åŠ ä¸€æ¡è¾¹ï¼ŒåŸæ ‘ä¸Šå¯¹åº”è¿™ä¸¤ä¸ªç«¯ç‚¹ä¹‹é—´çš„è·¯å¾„éƒ½ä¸æ˜¯æ­»è·¯ã€‚ æˆ‘ä»¬ç§°è¿™äº›è¢«è¦†ç›–çš„ç‚¹ä¸ºæ ‡è®°ç‚¹ã€‚å¯ä»¥æ³¨æ„åˆ°ï¼Œä¸¤ä¸ªæ ‡è®°ç‚¹ä¹‹é—´çš„è·¯å¾„ä¹Ÿä¸ä¼šæ˜¯æ­»è·¯ï¼Œå› ä¸ºä¸€å®šä¼šèµ°åˆ°ä¸€ä¸ªç¯ä¸Šã€‚ æ­¤å¤–åŒç†ï¼Œå‰©ä¸‹çš„è¾¹é‡ŒæŒ‡å‘æ ‡è®°ç‚¹çš„è·¯å¾„éƒ½ä¸æ˜¯æ­»è·¯ã€‚åªæœ‰ä»æ ‡è®°ç‚¹èµ°å‡ºæ¥çš„è·¯å¾„ï¼Œå¹¶ä¸”ä¸èƒ½åˆ°å¦ä¸€ä¸ªæ ‡è®°ç‚¹çš„æ˜¯æ­»è·¯ã€‚ æ ¹æ®é¢˜ç›®çš„çœç•¥è¦æ±‚ï¼Œå‘ç°åªè¦æŠŠæ‰€æœ‰æ ‡è®°ç‚¹çš„æœ€å°è¿é€šå—æ‰¾å‡ºæ¥å°±å¯ä»¥äº†ï¼Œè€ƒåœºä¸Šå†™çš„è™šæ ‘ï¼Œå®é™…ä¸ŠæŒ‰å¶å­æ‹“æ‰‘å³å¯ã€‚ è¦æ”¾ç½®æ­»è·¯ç‰Œçš„ä½ç½®å°±æ˜¯ä»æ‹“æ‰‘ä¸­æœªåˆ é™¤ç‚¹æŒ‡å‘è¢«åˆ é™¤ç‚¹çš„é‚£äº›æ–¹å‘ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first #define sc second#define mp make_pair#define mt make_tuple#define pb push_back#define pii pair&lt;int, int&gt;#define tii tuple&lt;int, int, int&gt;#define all(x) (x).begin(), (x).end()#define N 500007bool tree[N], circ[N], not_tree[N];vector&lt;int&gt; s[N];int tot, hd[N], f[N], deg[N];struct edge&#123;int to, nxt;&#125; e[N &lt;&lt; 1];inline void add(int u, int v) &#123; e[++tot].to = v; e[tot].nxt = hd[u]; hd[u] = tot; ++deg[u]; e[++tot].to = u; e[tot].nxt = hd[v]; hd[v] = tot; ++deg[v];&#125;int find(int x) &#123;return x == f[x] ? x : f[x] = find(f[x]);&#125;inline void merge(int x, int y) &#123; x = find(x); y = find(y); f[x] = y; not_tree[y] |= not_tree[x];&#125;vector&lt;pii&gt; ans;queue&lt;int&gt; q;void topo(int x) &#123; for (auto u : s[x]) if (deg[u] == 1 &amp;&amp; !circ[u]) &#123;tree[u] = true; q.push(u);&#125; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = hd[u], v; i; i = e[i].nxt) &#123; --deg[v = e[i].to]; if (deg[v] &lt;= 1 &amp;&amp; !circ[v] &amp;&amp; !tree[v]) &#123; q.push(v); tree[v] = true; &#125; &#125; &#125; for (auto u : s[x]) if (tree[u]) for (int i = hd[u], v; i; i = e[i].nxt) if (!tree[v = e[i].to]) ans.pb(mp(v, u));&#125;int main() &#123; int n = rd(), m = rd(); for (int i = 1; i &lt;= n; ++i) f[i] = i; for (int i = 1, u, v; i &lt;= m; ++i) &#123; u = rd(); v = rd(); if (find(u) == find(v)) not_tree[find(u)] = circ[u] = circ[v] = true; else &#123;merge(u, v); add(u, v);&#125; &#125; for (int i = 1; i &lt;= n; ++i) s[find(i)].pb(i); for (int i = 1; i &lt;= n; ++i) if (f[i] == i) &#123; if (not_tree[i]) topo(i); else for (auto u : s[i]) if (deg[u] == 1) ans.pb(mp(u, e[hd[u]].to)); &#125; sort(all(ans)); printf(&quot;%d\\n&quot;, (int)ans.size()); for (auto [u, v] : ans) printf(&quot;%d %d\\n&quot;, u, v); return 0;&#125; G - First of Her Name ä¸€æ£µæ ‘ï¼Œæ¯ä¸ªç‚¹ä¸Šæœ‰ä¸€ä¸ªå­—ç¬¦ï¼Œå®šä¹‰ä¸€ä¸ªèŠ‚ç‚¹çš„ä¸²å°±æ˜¯ä»ä»–åˆ°æ ¹è·¯å¾„ä¸Šçš„å­—ç¬¦ä¾æ¬¡æ¥èµ·æ¥ã€‚ æ¯æ¬¡è¯¢é—®ä¸€ä¸ªä¸² \\(s\\) ï¼Œé—®æœ‰å¤šå°‘ä¸ªèŠ‚ç‚¹çš„ä¸²ä»¥ \\(s\\) ä¸ºå‰ç¼€ã€‚ æŠŠè¯¢é—®ä¸²ç¿»è½¬ä¸€ä¸‹ï¼ŒèŠ‚ç‚¹çš„ä¸²é¡ºåºä¹Ÿæ”¹ä¸ºä»æ ¹åˆ°å®ƒçš„è·¯å¾„ï¼Œç›¸å½“äºè¯¢é—®æœ‰å¤šå°‘ä¸ªä¸²ä»¥ \\(s\\) ä¸ºåç¼€ã€‚å¹¿ä¹‰ SAMã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;cstdio&gt;#include&lt;cctype&gt;using namespace std;const int maxn=1000000,maxt=maxn&lt;&lt;1,maxi=26;int n,Q,p[maxn+5],cnt[maxt+5];int E,lnk[maxt+5],nxt[maxt+5],to[maxt+5];int pl,ro,son[maxt+5][maxi],fai[maxt+5],MAX[maxt+5];char s[maxn+5];#define EOLN(x) ((x)==10 || (x)==13 || (x)==EOF)inline char readc()&#123; static char buf[1&lt;&lt;16],*l=buf,*r=buf; return l==r &amp;&amp; (r=(l=buf)+fread(buf,1,1&lt;&lt;16,stdin),l==r)?EOF:*l++;&#125;template&lt;typename T&gt; int readi(T &amp;x)&#123; T tot=0;char ch=readc(),lst=&#x27;+&#x27;; while (!isdigit(ch)) &#123;if (ch==EOF) return EOF;lst=ch;ch=readc();&#125; while (isdigit(ch)) tot=(tot&lt;&lt;3)+(tot&lt;&lt;1)+(ch^48),ch=readc(); lst==&#x27;-&#x27;?x=-tot:x=tot;return EOLN(ch);&#125;char getupr() &#123;char ch=readc();while (!isupper(ch)) ch=readc();return ch;&#125;int reads(char *s)&#123; int len=0;char ch=getupr(); while (isupper(ch)) s[++len]=ch,ch=readc(); return len;&#125;struct fastO&#123; int si;char buf[1&lt;&lt;16]; void putc(char ch)&#123; if (si==(1&lt;&lt;16)) fwrite(buf,1,si,stdout),si=0; buf[si++]=ch; &#125; ~fastO() &#123;fwrite(buf,1,si,stdout);&#125;&#125;fo;template&lt;typename T&gt; void writei(T x,char ch=&#x27;\\n&#x27;)&#123; static int len=0,buf[100]; if (x&lt;0) fo.putc(&#x27;-&#x27;),x=-x; do buf[len++]=x%10,x/=10; while (x); while (len) fo.putc(buf[--len]+48); if (ch) fo.putc(ch);&#125;inline void Add(int x,int y) &#123;to[++E]=y;nxt[E]=lnk[x];lnk[x]=E;&#125;inline int newnode() &#123;pl++;return pl;&#125;int Extend(int p,int c)&#123; if (son[p][c])&#123; int q=son[p][c];if (MAX[p]+1==MAX[q]) return q; int nq=newnode();MAX[nq]=MAX[p]+1; for (int i=0;i&lt;maxi;i++) son[nq][i]=son[q][i]; fai[nq]=fai[q];fai[q]=nq; while (p &amp;&amp; son[p][c]==q) son[p][c]=nq,p=fai[p]; return nq; &#125; else &#123; int np=newnode();MAX[np]=MAX[p]+1; while (p &amp;&amp; !son[p][c]) son[p][c]=np,p=fai[p]; if (!p) &#123;fai[np]=ro;return np;&#125; int q=son[p][c];if (MAX[p]+1==MAX[q]) &#123;fai[np]=q;return np;&#125; int nq=newnode();MAX[nq]=MAX[p]+1; for (int i=0;i&lt;maxi;i++) son[nq][i]=son[q][i]; fai[nq]=fai[q];fai[q]=fai[np]=nq; while (p &amp;&amp; son[p][c]==q) son[p][c]=nq,p=fai[p]; return np; &#125;&#125;void DFS(int x) &#123;for (int j=lnk[x];j;j=nxt[j]) DFS(to[j]),cnt[x]+=cnt[to[j]];&#125;int main()&#123; readi(n);readi(Q); ro=newnode();p[0]=ro; for (int i=1,w,x;i&lt;=n;i++)&#123; w=getupr()-&#x27;A&#x27;;readi(x); p[i]=Extend(p[x],w);cnt[p[i]]++; &#125; for (int i=2;i&lt;=pl;i++) Add(fai[i],i); DFS(ro); for (int t=1;t&lt;=Q;t++)&#123; int len=reads(s),p=ro; for (int i=len;i;i--) p=son[p][s[i]-&#x27;A&#x27;]; writei(cnt[p]); &#125; return 0;&#125; *H - Hobsons' trains ç»™ä¸€ä¸ªå†…å‘åŸºç¯æ ‘æ£®æ—ï¼Œå¯¹äºæ¯ä¸ªç‚¹ï¼Œé—®æœ‰å¤šå°‘ä¸ªç‚¹æ²¿ç€å‡ºè¾¹èµ° \\(k\\) æ­¥ä¹‹å†…å¯ä»¥åˆ°è¾¾ä»–ã€‚ å¦‚æœæ˜¯æ ‘ï¼Œå°±å¯ä»¥æ ‘ä¸Šå·®åˆ†ï¼Œå¯¹æ¯ä¸ªç‚¹ \\(+1\\) ï¼Œå†å¯¹å…¶ \\(k\\) çº§ç¥–å…ˆ \\(-1\\) ï¼Œæœ€åæ±‚å­æ ‘å’Œå°±æ˜¯ç­”æ¡ˆã€‚ è€ƒè™‘å¯¹æ¯æ£µæ ‘åšå®Œè¿™ä¸ªæ“ä½œä¹‹åï¼Œå†è€ƒè™‘æ¯ä¸ªç‚¹å¯¹ç¯çš„è´¡çŒ®ï¼Œå‘ç°ä¸€å®šæ˜¯ç¯ä¸Šè¿ç»­çš„ä¸€æ®µï¼Œå› æ­¤ç¯ä¸Šå·®åˆ†å†å•ç‹¬åšä¸€éå³å¯ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define rep(i, x, y) for (int (i) = (x); (i) &lt;= (y); ++(i))#define per(i, x, y) for (int (i) = (x); (i) &gt;= (y); --(i))#define N 500007int n, m, k, tot, d[N], f[N], hd[N];struct edge&#123;int to, nxt;&#125; e[N &lt;&lt; 1];inline void add(int u, int v) &#123; e[++tot].to = v; e[tot].nxt = hd[u]; hd[u] = tot;&#125;int find(int x) &#123;return x == f[x] ? x : f[x] = find(f[x]);&#125;int vis[N], circ[N], pref[N], ans[N], stk[N], top;void dfs(int u, int id) &#123; stk[++top] = u; ++ans[u]; if (top - k &gt; 1) --ans[stk[top - k - 1]]; else &#123; --ans[stk[1]]; int len = k - top + 2; if (len &gt;= m) ++pref[1]; else &#123; int l = id, r = id + len - 1; ++pref[l]; if (r &gt; m) &#123;r -= m; ++pref[1];&#125; if (r &lt; m) --pref[r + 1]; &#125; &#125; for (int i = hd[u], v; i; i = e[i].nxt) if (vis[v = e[i].to] != 2) &#123;dfs(v, id); ans[u] += ans[v];&#125; --top;&#125;inline void work(int u) &#123; m = 0; int t = u; for (; !vis[t]; t = d[t]) vis[t] = 1; for (; vis[t] != 2; t = d[t]) &#123;vis[t] = 2; circ[++m] = t;&#125; rep(i, 1, m) dfs(circ[i], i); rep(i, 1, m) &#123;pref[i] += pref[i - 1]; ans[circ[i]] += pref[i];&#125; rep(i, 1, m) pref[i] = 0;&#125;int main() &#123; n = rd(); k = rd(); rep(i, 1, n) f[i] = i; rep(i, 1, n) &#123;d[i] = rd(); add(d[i], i); f[i] = find(d[i]);&#125; rep(i, 1, n) if (f[i] == i) work(i); rep(i, 1, n) printf(&quot;%d\\n&quot;, ans[i]); return 0;&#125;","categories":[{"name":"Official Contests","slug":"Official-Contests","permalink":"http://blog.gyx.me/categories/Official-Contests/"}],"tags":[{"name":"Greedy","slug":"Greedy","permalink":"http://blog.gyx.me/tags/Greedy/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"},{"name":"Graphs","slug":"Graphs","permalink":"http://blog.gyx.me/tags/Graphs/"},{"name":"Segment Tree","slug":"Segment-Tree","permalink":"http://blog.gyx.me/tags/Segment-Tree/"},{"name":"Geometry","slug":"Geometry","permalink":"http://blog.gyx.me/tags/Geometry/"},{"name":"String Suffix Structures","slug":"String-Suffix-Structures","permalink":"http://blog.gyx.me/tags/String-Suffix-Structures/"},{"name":"Difference and Prefix Sum","slug":"Difference-and-Prefix-Sum","permalink":"http://blog.gyx.me/tags/Difference-and-Prefix-Sum/"}]},{"title":"2018 CCPC Finals","slug":"official/ccpc/18-finals","date":"2022-10-18T16:00:00.000Z","updated":"2023-03-20T16:34:52.874Z","comments":true,"path":"official/ccpc/18-finals/","link":"","permalink":"http://blog.gyx.me/official/ccpc/18-finals/","excerpt":"","text":"æ¯”èµ›åœ°å€ ï¼šCodeforces Gym 102055 A - Mischievous Problem Setter ç­¾åˆ°ï¼Œæ’åºä¹‹åæ‰«ä¸€æ‰«ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first #define sc second #define N 100007int testcase;pair&lt;int, int&gt; a[N];inline void work() &#123; printf(&quot;Case %d: &quot;, ++testcase); int n = rd(), m = rd(); for (int i = 1; i &lt;= n; ++i) a[i].fr = rd(); for (int i = 1; i &lt;= n; ++i) a[i].sc = rd(); sort(a + 1, a + 1 + n); for (int i = 1; i &lt;= n; ++i) &#123; if (a[i].sc &gt; m) &#123;printf(&quot;%d\\n&quot;, i - 1); return;&#125; m -= a[i].sc; &#125; printf(&quot;%d\\n&quot;, n);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; *B - Balance of the Force æœ‰ \\(n\\) ä½éª‘å£«ï¼Œç°åœ¨è¦åˆ†è£‚æˆä¸¤ä¸ªé˜µè¥ï¼Œç¬¬ \\(i\\) ä½éª‘å£«åŠ å…¥å…‰æ˜é˜µè¥æ­¦åŠ›å€¼ä¸º \\(L_i\\) ï¼ŒåŠ å…¥é»‘æš—é˜µè¥æ­¦åŠ›å€¼ä¸º \\(D_i\\) ã€‚ æ­¤å¤–æœ‰ \\(m\\) å¯¹ä»‡æ•Œå…³ç³» \\((x_i,y_i)\\) ï¼Œè¡¨ç¤ºè¦æ±‚ç¬¬ \\(x_i\\) ä½éª‘å£«ä¸èƒ½å’Œç¬¬ \\(y_i\\) ä½éª‘å£«åŠ å…¥åŒä¸€é˜µè¥ã€‚ é—®æ˜¯å¦å­˜åœ¨åˆæ³•åˆ’åˆ†æ–¹æ¡ˆã€‚è‹¥å­˜åœ¨ï¼Œå‡è®¾ç¬¬ \\(i\\) ä½éª‘å£«æœ€ç»ˆçš„æ­¦åŠ›å€¼ä¸º \\(w_i\\) ï¼Œæœ€å°åŒ– \\(\\max w_i-\\min w_i\\) ã€‚ æŒ‰ç…§å†²çªå…³ç³»è¿è¾¹ï¼Œå¦‚æœä¸æ˜¯äºŒåˆ†å›¾å°±æ— è§£ã€‚ å¦åˆ™äºŒåˆ†å›¾æŸ“è‰²ï¼Œé‚£ä¹ˆå¯¹äºä¸€ä¸ªè¿é€šå—åªæœ‰ä¸¤ç§æŸ“è‰²æ–¹æ¡ˆï¼Œæ­¦åŠ›å€¼åŒºé—´å¯¹åº”ç€ä¸¤ä¸ªä¸åŒçš„ \\([l,r]\\) ã€‚ ä¸å¦¨è®¾ä¸¤ä¸ªåŒºé—´åˆ†åˆ«æ˜¯ \\([l_1,r_1]\\) å’Œ \\([l_2,r_2]\\) ä¸” \\(r_1&lt;r_2\\) ï¼Œæˆ‘ä»¬å…ˆè®©æ¯ä¸ªåŒºé—´å– \\([l_1,r_1]\\) ã€‚ ç„¶åä»å°åˆ°å¤§æšä¸¾ \\(\\min w_i\\) ï¼Œç„¶åå°†ä¸åˆæ³•çš„åŒºé—´å˜æˆå¦ä¸€ä¸ªå³å¯ï¼Œç»´æŠ¤è¿‡ç¨‹ä¸­æœ€å°å·®å€¼ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first #define sc second #define pb push_back#define mp make_pair#define pii pair&lt;int, int&gt;#define N 200007int testcase, col[N], a[N], b[N];vector&lt;int&gt; e[N], s[3];bool dfs(int u) &#123; s[col[u]].pb(u); for (auto v : e[u]) if (!col[v]) &#123; col[v] = 3 - col[u]; if (dfs(v)) return true; &#125; else if (col[u] == col[v]) return true; return false;&#125;int l1[N], r1[N], l2[N], r2[N], tot;priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; q;inline void work() &#123; tot = 0; while(!q.empty()) q.pop(); printf(&quot;Case %d: &quot;, ++testcase); int n = rd(), m = rd(); for (int i = 1; i &lt;= n; ++i) &#123;e[i].clear(); col[i] = 0;&#125; for (int i = 1; i &lt;= m; ++i) &#123; int a = rd(), b = rd(); e[a].pb(b); e[b].pb(a); &#125; for (int i = 1; i &lt;= n; ++i) &#123;a[i] = rd(); b[i] = rd();&#125; int nwr = 0; for (int i = 1; i &lt;= n; ++i) if (!col[i]) &#123; s[1].clear(); s[2].clear(); col[i] = 1; if (dfs(i)) &#123;puts(&quot;IMPOSSIBLE&quot;); return;&#125; ++tot; l1[tot] = l2[tot] = 2e9; r1[tot] = r2[tot] = 0; for (auto u : s[1]) &#123; l1[tot] = min(l1[tot], a[u]); l2[tot] = min(l2[tot], b[u]); r1[tot] = max(r1[tot], a[u]); r2[tot] = max(r2[tot], b[u]); &#125; for (auto u : s[2]) &#123; l1[tot] = min(l1[tot], b[u]); l2[tot] = min(l2[tot], a[u]); r1[tot] = max(r1[tot], b[u]); r2[tot] = max(r2[tot], a[u]); &#125; if (r1[tot] &gt; r2[tot]) &#123; swap(r1[tot], r2[tot]); swap(l1[tot], l2[tot]); &#125; nwr = max(nwr, r1[tot]); q.push(mp(l1[tot], tot)); &#125; int ans = 2e9; while (!q.empty()) &#123; auto [nwl, p] = q.top(); q.pop(); ans = min(ans, nwr - nwl); if (l2[p] == nwl) break; q.push(mp(l2[p], p)); nwr = max(nwr, r2[p]); &#125; printf(&quot;%d\\n&quot;, ans);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; **C - GCD Land å¯¹äº \\(1\\dots n\\) ï¼Œæ„é€ ä¸€ä¸ªä¸è¶…è¿‡ \\(10^n\\) çš„éè´Ÿæ•´æ•°ï¼Œä½¿å¾— \\(x+1,x+2,\\dots x+n\\) è¿é€šã€‚ å®šä¹‰ \\(u,v\\) ç›´æ¥è¿é€šå½“ä¸”ä»…å½“ \\(gcd(u,v)&gt;1\\) ï¼Œå®šä¹‰ \\(u,v\\) è¿é€šå½“ä¸”ä»…å½“ \\(u,v\\) ç›´æ¥è¿é€šæˆ–å­˜åœ¨ \\(w\\) ä½¿å¾— \\(u,w\\) è¿é€šã€\\(w,v\\) è¿é€šã€‚ å¦‚æœä»¤ \\(x=\\prod_{p\\ is\\ prime,p\\le n} p - 1\\) ï¼Œé‚£ä¹ˆæ•°åˆ—ç›¸å½“äºå˜æˆäº† \\(0,1,\\dots,n-1\\) ï¼Œé™¤äº† \\(1\\) å…¶ä»–äººéƒ½å’Œ \\(0\\) è¿é€šã€‚ é‚£ä¹ˆç°åœ¨å°±éœ€è¦æ‰¾ä¸€ä¸ªåˆæ•°æ²Ÿé€š \\(1\\) å’Œå…¶ä»–ï¼Œéšä¾¿æ„é€ ä¸€ä¸‹å°±å¥½äº†ã€‚æ³¨æ„åˆ°ç´ æ•°åªæœ‰ \\(\\mathcal{O}(\\frac{n}{\\ln n})\\) ä¸ªï¼Œæ•°ä½å¹¶ä¸ä¼šè¶…ã€‚ æŸ´è€å¸ˆçš„æ„é€ åœ¨ \\(n&gt;34\\) çš„æ—¶å€™éƒ½æœ‰è§£ï¼Œæ‰€ä»¥ \\([1,34]\\) å°±æ‰“ä¸‹è¡¨ã€‚æ±‚å¾ˆå¤šä¸ªæ•°å­—çš„ä¹˜ç§¯ç”¨åˆ†æ²» + FFTå³å¯ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;typedef vector&lt;int&gt; PN;const int maxn=100000,maxt=1&lt;&lt;18,MOD=998244353;int te,n,P[maxn+5];int p[maxn+5];bool pri[maxn+5];int wn[maxt+5],temA[maxt+5],temB[maxt+5];int m;PN f[maxn+5],F,G,H,res;void Make(int n)&#123; for (int i=2;i&lt;=n;i++)&#123; if (!pri[i]) p[++p[0]]=i; for (int j=1,t;j&lt;=p[0] &amp;&amp; (t=i*p[j])&lt;=n;j++) &#123;pri[t]=true;if (!(i%p[j])) break;&#125; &#125;&#125;inline int ADD(int x,int y) &#123;return x+y&gt;=MOD?x+y-MOD:x+y;&#125;inline int MUL(int x,int y) &#123;return (LL)x*y%MOD;&#125;inline int MUL(int x,int y,int MOD) &#123;return (LL)x*y%MOD;&#125;int Pow(int w,int b) &#123;int s;for (s=1;b;b&gt;&gt;=1,w=MUL(w,w)) if (b&amp;1) s=MUL(s,w);return s;&#125;int Pow(int w,int b,int MOD) &#123;int s;for (s=1;b;b&gt;&gt;=1,w=MUL(w,w,MOD)) if (b&amp;1) s=MUL(s,w,MOD);return s;&#125;void NTTPre()&#123; int x=Pow(3,(MOD-1)/maxt); wn[maxt&gt;&gt;1]=1; for (int i=(maxt&gt;&gt;1)+1;i&lt;maxt;i++) wn[i]=MUL(wn[i-1],x); for (int i=(maxt&gt;&gt;1)-1;i;i--) wn[i]=wn[i&lt;&lt;1];&#125;void NTT(int *a,int n,int f)&#123; if (f&gt;0)&#123; for (int k=n&gt;&gt;1;k;k&gt;&gt;=1) for (int i=0;i&lt;n;i+=k&lt;&lt;1) for (int j=0;j&lt;k;j++)&#123; int x=a[i+j],y=a[i+j+k]; a[i+j+k]=MUL(x+MOD-y,wn[k+j]); a[i+j]=ADD(x,y); &#125; &#125; else &#123; for (int k=1;k&lt;n;k&lt;&lt;=1) for (int i=0;i&lt;n;i+=k&lt;&lt;1) for (int j=0;j&lt;k;j++)&#123; int x=a[i+j],y=MUL(a[i+j+k],wn[k+j]); a[i+j+k]=ADD(x,MOD-y); a[i+j]=ADD(x,y); &#125; for (int i=0,INV=MOD-(MOD-1)/n;i&lt;n;i++) a[i]=MUL(a[i],INV); reverse(a+1,a+n); &#125;&#125;void Print(const PN &amp;a)&#123; int si=a.size(); for (int i=si-1;i&gt;=0;i--) putchar(a[i]+48); puts(&quot;&quot;);&#125;PN operator * (const PN &amp;a,const PN &amp;b)&#123; static PN c; int n=a.size(),m=b.size(),t; for (t=1;t&lt;n+m-1;t&lt;&lt;=1); for (int i=0;i&lt;n;i++) temA[i]=a[i];for (int i=n;i&lt;=t;i++) temA[i]=0; for (int i=0;i&lt;m;i++) temB[i]=b[i];for (int i=m;i&lt;=t;i++) temB[i]=0; NTT(temA,t,1);NTT(temB,t,1); for (int i=0;i&lt;t;i++) temA[i]=MUL(temA[i],temB[i]); NTT(temA,t,-1); for (int i=0;i&lt;n+m-1;i++) temA[i+1]+=temA[i]/10,temA[i]%=10; int si=n+m-1; while (si&gt;1 &amp;&amp; !temA[si]) si--; c.resize(si+1); for (int i=0;i&lt;=si;i++) c[i]=temA[i]; return c;&#125;PN operator * (const PN &amp;a,const int &amp;x)&#123; static PN c; int si=a.size(); for (int i=0;i&lt;si;i++) temA[i]=a[i]*x; for (int i=si;i&lt;=si+10;i++) temA[i]=0; for (int i=0;i&lt;si+10;i++) temA[i+1]+=temA[i]/10,temA[i]%=10; si+=10;while (si&gt;1 &amp;&amp; !temA[si]) si--; c.resize(si+1); for (int i=0;i&lt;=si;i++) c[i]=temA[i]; return c;&#125;PN operator + (const PN &amp;a,const PN &amp;b)&#123; static PN c; int n=a.size(),m=b.size(),si=max(n,m); for (int i=0;i&lt;n;i++) temA[i]=a[i]; for (int i=0;i&lt;m;i++) temB[i]=b[i]; for (int i=n;i&lt;=si;i++) temA[i]=0; for (int i=m;i&lt;=si;i++) temB[i]=0; for (int i=0;i&lt;si;i++) temA[i]+=temB[i]; for (int i=0;i&lt;si;i++) temA[i+1]+=temA[i]/10,temA[i]%=10; while (si&gt;1 &amp;&amp; !temA[si]) si--; c.resize(si+1); for (int i=0;i&lt;=si;i++) c[i]=temA[i]; return c;&#125;void Fix(PN &amp;a,int x)&#123; a.clear(); do a.push_back(x%10),x/=10; while (x);&#125;PN Solve(int L,int R)&#123; if (L==R) return f[L]; int mid=L+(R-L&gt;&gt;1); return Solve(L,mid)*Solve(mid+1,R);&#125;int main()&#123; NTTPre();Make(maxn); for (int i=1,j=1,k=1;i&lt;=maxn;i++)&#123; while (j*j&lt;i) j++; while (k&lt;=p[0] &amp;&amp; p[k]&lt;j) k++; for (int t=k;t&lt;=p[0];t++) if (3*p[t]+1&lt;i &amp;&amp; !pri[2*p[t]+1]) &#123;P[i]=p[t];break;&#125; &#125; scanf(&quot;%d&quot;,&amp;te); for (int t=1;t&lt;=te;t++)&#123; printf(&quot;Case %d: &quot;,t); scanf(&quot;%d&quot;,&amp;n);m=0; if (n&lt;=34)&#123; if (n==1) &#123;puts(&quot;0&quot;);continue;&#125; if (n==17) &#123;puts(&quot;2183&quot;);continue;&#125; if (n==18) &#123;puts(&quot;27828&quot;);continue;&#125; if (n==19) &#123;puts(&quot;27827&quot;);continue;&#125; if (n==20) &#123;puts(&quot;87889&quot;);continue;&#125; if (n==21) &#123;puts(&quot;87889&quot;);continue;&#125; if (n==22) &#123;puts(&quot;171053&quot;);continue;&#125; if (n==23) &#123;puts(&quot;171053&quot;);continue;&#125; if (n==24) &#123;puts(&quot;325309&quot;);continue;&#125; if (n==25) &#123;puts(&quot;127373&quot;);continue;&#125; if (n==26) &#123;puts(&quot;323509&quot;);continue;&#125; if (n==27) &#123;puts(&quot;151061&quot;);continue;&#125; if (n==28) &#123;puts(&quot;151061&quot;);continue;&#125; if (n==29) &#123;puts(&quot;151061&quot;);continue;&#125; if (n==30) &#123;puts(&quot;151060&quot;);continue;&#125; if (n==31) &#123;puts(&quot;151059&quot;);continue;&#125; if (n==32) &#123;puts(&quot;151058&quot;);continue;&#125; if (n==33) &#123;puts(&quot;151057&quot;);continue;&#125; if (n==34) &#123;puts(&quot;7106717&quot;);continue;&#125; puts(&quot;-1&quot;);continue; &#125; int A=2*P[n]+1,B=P[n]; for (int i=1;i&lt;=p[0] &amp;&amp; p[i]&lt;=n;i++) if (p[i]!=P[n] &amp;&amp; p[i]!=(2*P[n]+1))&#123; A=MUL(A,p[i],P[n]);B=MUL(B,p[i],2*P[n]+1); m++;Fix(f[m],p[i]); &#125; F=Solve(1,m); A=Pow(A,P[n]-2,P[n]); B=Pow(B,2*P[n]-1,2*P[n]+1); G=F*A;G=G*(P[n]-1);G=G*(2*P[n]+1); H=F*B;H=H*P[n];H=H*(P[n]+1); res=G+H; res[0]--; for (int i=0;res[i]&lt;0;i++) res[i]+=10,res[i+1]--; while (res.size()&gt;1 &amp;&amp; !res.back()) res.pop_back(); Print(res); &#125; return 0;&#125; G - Pastoral Life in Stardew Valley å¯¹äºä¸€ä¸ª \\(n\\times m\\) çš„çŸ©å½¢ï¼Œæ±‚å’Œï¼šå¯¹äºæ¯ä¸€ä¸ªå­çŸ©å½¢ï¼Œé€‰æ‹©å…¶ä¸¥æ ¼åŒ…å«çš„ï¼ˆè¾¹ç•Œä¸é‡åˆï¼‰å­çŸ©å½¢æ–¹æ¡ˆæ•°ã€‚ æš´åŠ›çš„åšæ³•ï¼šæšä¸¾å­çŸ©å½¢å®½åº¦ \\(w\\) å’Œé«˜åº¦ \\(h\\) ï¼Œç„¶åæš´åŠ›æ±‚å’Œï¼Œå‘ç°ç»´æŠ¤ä¸€ä¸ªå‰ç¼€å’Œå°±è¡Œäº†ã€‚ \\[ ans = \\bigg(\\sum_{h=3}^n(n-h+1)\\sum_{l=1}^{h-2}(h-l+1)\\bigg)\\bigg(\\sum_{w=3}^m(m-w+1)\\sum_{r=1}^{w-2}(w-r+1)\\bigg) \\] ç†æ€§åˆ†æä¸€ä¸‹ï¼Œæ˜¾ç„¶è¿™ä¸ªé¢˜ç›®å¯ä»¥å˜æˆä¸¤ä¸ªä¸€ç»´é—®é¢˜ç­”æ¡ˆçš„ä¹˜ç§¯ã€‚ å¦‚æœå­å­çŸ©å½¢å®½åº¦æ˜¯ \\(1\\) ï¼Œé‚£ä¹ˆå°±è¦ä» \\(n\\) ä¸­é€‰ä¸‰ä¸ªæ•°ï¼Œåˆ†åˆ«ä»£è¡¨å·¦è¾¹ç•Œï¼Œå³è¾¹ç•Œï¼Œå­å­çŸ©å½¢ä½ç½®ï¼Œæ–¹æ¡ˆæ•°ä¸º \\({n\\choose 3}\\) ã€‚ å¦‚æœå­å­çŸ©å½¢å®½åº¦æ˜¯ \\(2\\) ï¼Œé‚£ä¹ˆå°±è¦ä» \\(n\\) ä¸­é€‰å››ä¸ªæ•°ï¼Œæ–¹æ¡ˆæ•°ä¸º \\({n\\choose 4}\\) ã€‚ å› æ­¤æœ€ç»ˆç­”æ¡ˆæ˜¯ \\(({n\\choose 3} + {n\\choose 4})({m\\choose 3} + {m\\choose 4})\\) ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;#define all(s) (s).begin(), (s).end()#define lowbit(x) ((x) &amp; -(x))#define N 100007#define mod 1000000007namespace Comb &#123; int fac[N], ifac[N]; inline int fpow(int x, int t) &#123; int res = 1; for (; t; t &gt;&gt;= 1, x = 1ll * x * x % mod) if (t &amp; 1) res = 1ll * res * x % mod; return res; &#125; inline void init() &#123; fac[0] = ifac[0] = 1; for (int i = 1; i &lt; N; ++i) fac[i] = 1ll * fac[i - 1] * i % mod; ifac[N - 1] = fpow(fac[N - 1], mod - 2); for (int i = N - 2; i; --i) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % mod; &#125; inline int C(int n, int m) &#123; if (n &lt; m) return 0; return 1ll * fac[n] * ifac[m] % mod * ifac[n - m] % mod; &#125;&#125;inline int calc(int x) &#123; return (Comb::C(x, 3) + Comb::C(x, 4)) % mod;&#125;int main() &#123; Comb::init(); for (int t = rd(), i = 1; i &lt;= t; ++i) printf(&quot;Case %d: %lld\\n&quot;, i, 1ll * calc(rd()) * calc(rd()) % mod); return 0;&#125; I - Cockroaches äºŒç»´å¹³é¢ä¸Š \\(n\\) ä¸ªç»™å®šç‚¹ï¼Œé€‰ä¸€ä¸ªä½ç½®å¯ä»¥æŠŠ \\(x\\) æˆ– \\(y\\) ç›¸åŒçš„æ‰€æœ‰ç‚¹éƒ½æ‰“ä¸Šæ ‡è®°ã€‚ å¯¹äºä¸€æ¬¡æ“ä½œï¼šï¼ˆ1ï¼‰æ±‚æœ€å¤šæ ‡è®°å¤šå°‘ä¸ªç‚¹ã€‚ï¼ˆ2ï¼‰åœ¨ä¿è¯æ ‡è®°ç‚¹æ•°æœ€å¤šçš„å‰æä¸‹ï¼Œæœ‰å¤šå°‘ä¸ªå¯èƒ½çš„ä¸åŒçš„è¢«æ ‡è®°ç‚¹é›†ã€‚ ç¦»æ•£åŒ–ï¼Œè®°å½• \\(x\\) ç›¸åŒçš„æœ€å¤šç‚¹æ•° \\(mxx\\) ï¼Œ\\(y\\) ç›¸åŒçš„æœ€å¤šç‚¹æ•° \\(mxy\\) ï¼Œ \\(cnt[x]+cnt[y]=mxx+mxy\\) çš„ç»™å®šç‚¹æ•° \\(tot\\) ï¼Œè®¨è®ºï¼š å¦‚æœ \\(tot &lt; mxx\\times mxy\\) ï¼Œé‚£ä¹ˆç­”æ¡ˆå°±æ˜¯ \\((mxx+mxy, mxx\\times mxy-tot)\\) ã€‚ å¦åˆ™ï¼ˆ1ï¼‰ç­”æ¡ˆå°±è¦å‡ä¸€ï¼Œï¼ˆ2ï¼‰çš„ç­”æ¡ˆè¦ç»§ç»­ç»Ÿè®¡ \\(cnt[x]+cnt[y]=mxx+mxy-1\\) çš„ä¸ªæ•°è®¨è®ºã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first #define sc second #define pb push_back#define all(x) x.begin(), (x).end()#define N 100007int testcase, x[N], y[N], cntx[N], cnty[N];vector&lt;int&gt; X, Y;inline void work() &#123; printf(&quot;Case %d: &quot;, ++testcase); X.clear(); Y.clear(); int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; cntx[i] = cnty[i] = 0; x[i] = rd(); X.pb(x[i]); y[i] = rd(); Y.pb(y[i]); &#125; sort(all(X)); X.erase(unique(all(X)), X.end()); sort(all(Y)); Y.erase(unique(all(Y)), Y.end()); auto getx = [&amp;](int w) &#123;return lower_bound(all(X), w) - X.begin() + 1;&#125;; auto gety = [&amp;](int w) &#123;return lower_bound(all(Y), w) - Y.begin() + 1;&#125;; int mxx = 0, mxy = 0; for (int i = 1; i &lt;= n; ++i) &#123; x[i] = getx(x[i]); y[i] = gety(y[i]); ++cntx[x[i]]; mxx = max(mxx, cntx[x[i]]); ++cnty[y[i]]; mxy = max(mxy, cnty[y[i]]); &#125; int cntmxx = 0, cntmxy = 0, cntnxx = 0, cntnxy = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (cntx[i] == mxx) ++cntmxx; else if (cntx[i] == mxx - 1) ++cntnxx; if (cnty[i] == mxy) ++cntmxy; else if (cnty[i] == mxy - 1) ++cntnxy; &#125; int tot = 0, ans = mxx + mxy, totnx = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (cntx[x[i]] + cnty[y[i]] == ans) ++tot; else if (cntx[x[i]] + cnty[y[i]] == ans - 1) ++totnx; &#125; bool fl = true; if (tot == 1ll * cntmxx * cntmxy) &#123;--ans; fl = false;&#125; if (ans == 1) &#123;puts(&quot;1 1&quot;); return;&#125; if (ans == 2) &#123;printf(&quot;%d %lld\\n&quot;, 2, 1ll * n * (n - 1) / 2); return;&#125; if (fl) printf(&quot;%d %lld\\n&quot;, ans, 1ll * cntmxx * cntmxy - tot); else printf(&quot;%d %lld\\n&quot;, ans, tot + 1ll * cntmxx * cntnxy + 1ll * cntmxy * cntnxx - totnx);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; *K - Mr. Panda and Kakin ç°åœ¨å®šä¹‰ä¸€ä¸ªåŠ å¯† FLAG çš„ç®—æ³•ï¼ˆRSAï¼‰ï¼š éšæœºä» \\([10^5,10^9]\\) ä¸­é€‰å–æ•´æ•° \\(x\\) ã€‚ ä»¤ \\(p\\) ä¸ºå°äº \\(x\\) çš„æœ€å¤§è´¨æ•°ï¼Œ\\(q\\) ä¸ºå¤§äº \\(x\\) çš„æœ€å°è´¨æ•°ï¼Œ\\(n=pq\\) ä»¤ \\(c=\\text{FLAG}^{(2^{30}+3)}\\mod n\\) ç°åœ¨ç»™å®š \\(c,n\\) ï¼Œæ±‚ FLAG ã€‚ å¯†ç å­¦è®²è¿‡ç±»ä¼¼çš„ç ´è§£æ€è·¯ä½†æ˜¯è€ƒåœºä¸Šä¸¤ä¸ªå°æ—¶çš„æ—¶å€™æ‰æƒ³èµ·æ¥ã€‚ã€‚ã€‚ é¦–å…ˆ \\(n=pq\\) ï¼Œå…¶ä¸­ \\(p,q\\) ä¸ºç›¸é‚»ç´ æ•°ï¼Œæ‰€ä»¥ä» \\(\\sqrt n\\) å¼€å§‹æšä¸¾å¤æ‚åº¦ä¸ä¼šé”™ï¼Œæ ¹æ®å”¯ä¸€åˆ†è§£ï¼Œç¬¬ä¸€æ¬¡æ‰¾åˆ°çš„å› æ•°å°±æ˜¯å¯¹çš„ã€‚ ç„¶åå°±å¯ä»¥åˆ†æˆä¸¤ä¸ªåŒä½™æ–¹ç¨‹ï¼Œæœ€åç”¨ CRT åˆå¹¶ä¸€ä¸‹ã€‚ ç ´è§£æ€è·¯ï¼šæ ¹æ®è´¹é©¬å°å®šç†æœ‰ \\(\\text{FLAG} = \\text{FLAG}^{(2^{30}+3)(2^{30}+3)^{-1}\\mod (p-1)}\\mod p\\) ç„¶åæš´åŠ›æ£€éªŒä¸€ä¸‹ \\(2^{30}+3\\) æ˜¯ç´ æ•°ï¼Œæ‰€ä»¥å¯ä»¥ç”¨æ‰©æ¬§æ±‚æ¨¡ \\(p-1\\) ä¸‹çš„é€†å…ƒï¼Œç„¶åè¿˜åŸå›å»å°±å¥½äº†ã€‚ èµ›æ—¶ä¸€ç›´ WA ï¼Œå‘ç°äº†èƒ–èƒ–çš„é»‘ç§‘æŠ€å¿«é€Ÿä¹˜æœ‰ bug ï¼Œä¹˜æ•°ä¸èƒ½è¶…è¿‡æ¨¡æ•°ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;typedef unsigned long long ULL;typedef long double DB;int te;LL n,C;inline ULL ADD(ULL x,ULL y,ULL MOD) &#123;return x+y&gt;=MOD?x+y-MOD:x+y;&#125;inline ULL MUL(ULL x,ULL y,ULL MOD)&#123; LL s=x*y-(ULL)((DB)1/MOD*x*y)*MOD; return s&lt;0?s+=MOD:(s&gt;=MOD?s-=MOD:s);&#125;LL Pow(LL w,LL b,LL MOD) &#123;LL s;for (s=1;b;b&gt;&gt;=1,w=MUL(w,w,MOD)) if (b&amp;1) s=MUL(s,w,MOD);return s;&#125;LL exgcd(LL a,LL b,LL &amp;x,LL &amp;y)&#123; if (!b) &#123;x=1;y=0;return a;&#125; LL r=exgcd(b,a%b,y,x);y-=a/b*x; return r;&#125;LL Inv(LL A,LL C)&#123; LL x,y;exgcd(A,C,x,y); return (x%C+C)%C;&#125;LL Solve(LL A,LL B,LL C)&#123; LL x,y,r=exgcd(A,C,x,y); C/=r;x=(x%C+C)%C;x=MUL(B/r%C,x,C); return x;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;te); for (int t=1;t&lt;=te;t++)&#123; printf(&quot;Case %d: &quot;,t); scanf(&quot;%lld%lld&quot;,&amp;n,&amp;C); LL S=sqrt(n) - 5; while ((n%S)) S++; LL Q=S,P=n/S; LL INV=Inv((1&lt;&lt;30)+3,P-1); LL A=Pow(C%P,INV,P); INV=Inv((1&lt;&lt;30)+3,Q-1); LL B=Pow(C%Q,INV,Q); LL now=Solve(Q,((A-B)%P+P)%P,P); A=ADD(MUL(now,Q,n),B,n); printf(&quot;%lld\\n&quot;,A); &#125; return 0;&#125; L - Ultra Weak Goldbach's Conjecture ç»™ä¸€ä¸ªæ•°å­— \\(x\\) ï¼Œå°è¯•åˆ†æˆå…­ä¸ªç´ æ•°çš„å’Œã€‚ å¶æ•°ï¼š\\(2,2,2,2,x,y\\) ï¼Œå¥‡æ•°ï¼š\\(2,2,2,3,x,y\\) ï¼Œå‰©ä¸‹çš„äº‹æƒ…äº¤ç»™å“¥å¾·å·´èµ«çŒœæƒ³ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define fr first#define sc second#define mp make_pairusing namespace std;typedef long long LL;typedef unsigned long long ULL;typedef long double DB;const int maxn=10000,prime[]=&#123;2,3,5,7,11,13,17,19,23,29,31,37&#125;;int te;LL n;int p[maxn+5];bool pri[maxn+5];bool f[6][maxn+5];pair&lt;int,int&gt; lst[6][maxn+5];inline ULL ADD(ULL x,ULL y,ULL MOD) &#123;return x+y&gt;=MOD?x+y-MOD:x+y;&#125;inline ULL MUL(ULL x,ULL y,ULL MOD)&#123; LL s=x*y-(ULL)((DB)1/MOD*x*y)*MOD; return s&lt;0?s+=MOD:(s&gt;=MOD?s-=MOD:s);&#125;LL Pow(LL w,LL b,LL MOD) &#123;LL s;for (s=1;b;b&gt;&gt;=1,w=MUL(w,w,MOD)) if (b&amp;1) s=MUL(s,w,MOD);return s;&#125;bool check(LL p,LL n)&#123; int k=0;LL d=n-1,x,s; while (d&amp;1^1) d&gt;&gt;=1,k++; x=Pow(p,d,n); for (;k;k--,x=s)&#123; s=MUL(x,x,n); if (s==1) return x==1 || x==n-1; &#125; return false;&#125;bool MR(LL n)&#123; if (n==1) return false; for (int t=0;t&lt;12;t++)&#123; if (n==prime[t]) return true; if (!(n%prime[t])) return false; if (!check(prime[t],n)) return false; &#125; return true;&#125;void Make(int n)&#123; for (int i=2;i&lt;=n;i++)&#123; if (!pri[i]) p[++p[0]]=i; for (int j=1,t;j&lt;=p[0] &amp;&amp; (t=i*p[j])&lt;=n;j++) &#123;pri[t]=true;if (!(i%p[j])) break;&#125; &#125;&#125;int main()&#123; Make(maxn); f[0][0]=true; for (int i=1;i&lt;=5;i++) for (int k=1;k&lt;=p[0];k++) for (int j=p[k];j&lt;=maxn;j++) if (f[i-1][j-p[k]]) f[i][j]=true,lst[i][j]=mp(i-1,j-p[k]); scanf(&quot;%d&quot;,&amp;te); for (int t=1;t&lt;=te;t++)&#123; scanf(&quot;%lld&quot;,&amp;n); printf(&quot;Case %d:&quot;,t); if (n&lt;=11) &#123;puts(&quot; IMPOSSIBLE&quot;);continue;&#125; LL x=n-10; for (;!MR(x) || !f[5][n-x];x--); int i=5,j=n-x; while (i || j)&#123; int x=lst[i][j].fr,y=lst[i][j].sc; printf(&quot; %d&quot;,j-y); i=x;j=y; &#125; printf(&quot; %lld\\n&quot;,x); &#125; return 0;&#125;","categories":[{"name":"Official Contests","slug":"Official-Contests","permalink":"http://blog.gyx.me/categories/Official-Contests/"}],"tags":[{"name":"Graphs","slug":"Graphs","permalink":"http://blog.gyx.me/tags/Graphs/"},{"name":"Number Theory","slug":"Number-Theory","permalink":"http://blog.gyx.me/tags/Number-Theory/"},{"name":"Counting","slug":"Counting","permalink":"http://blog.gyx.me/tags/Counting/"}]},{"title":"2019-2020 ICPC Latin American Regional","slug":"official/icpc/19-latin-american","date":"2022-10-16T16:00:00.000Z","updated":"2023-03-20T16:35:54.514Z","comments":true,"path":"official/icpc/19-latin-american/","link":"","permalink":"http://blog.gyx.me/official/icpc/19-latin-american/","excerpt":"","text":"æ¯”èµ›åœ°å€ ï¼šCodeforces Gym 102428 A - Algorithm Teaching \\(n\\ (1\\le n\\le 10^3)\\) ä¸ªè€å¸ˆï¼Œç¬¬ \\(i\\) ä¸ªè€å¸ˆä¼š \\(m_i\\ (1\\le m_i\\le 10)\\) ä¸ªç§‘ç›®ï¼š\\(s_{i,1},s_{i,2},\\cdots,s_{i,m_i}\\)ã€‚ æ¯ä¸ªå­¦ç”Ÿåªå¯ä»¥ä»ä¸€ä¸ªè€å¸ˆé‚£é‡Œå­¦ä¼šè€å¸ˆä¼šçš„ç§‘ç›®çš„ä¸€ä¸ªå­é›†ï¼Œä¸¤ä¸ªå­¦ç”Ÿå¯ä»¥åˆä½œå½“ä¸”ä»…å½“ä¼šçš„é›†åˆäº’ä¸åŒ…å«ã€‚ é—®æœ€å¤šèƒ½æ‰¾å‡ºæ¥å¤šå°‘ä¸ªå­¦ç”Ÿï¼Œä½¿å¾—ä¸¤ä¸¤éƒ½å¯ä»¥åˆä½œã€‚ æ±‚åŒ…å«å…³ç³»çš„æœ€é•¿åé“¾ï¼Œç”± dilworth å®šç†å°±æ˜¯æ±‚æœ€å°é“¾è¦†ç›–ã€‚ æ¯ä¸ªè€å¸ˆå¯¹åº” \\(2^{m_i}-1\\) ä¸ªé›†åˆï¼Œ\\(3^{m_i}\\) ä¸ªåŒ…å«å…³ç³»ã€‚æœ€å¤šä¸€å…± \\(102300\\) ä¸ªä¸åŒçš„é›†åˆï¼Œ\\(5904900\\) æ¡è¾¹ã€‚ åŒ…å«å…³ç³»å¤©ç„¶çš„æ˜¯ä¼ é€’é—­åŒ…ï¼Œå› æ­¤ç›´æ¥è·‘æœ€å°è·¯å¾„è¦†ç›–å¤æ‚åº¦ \\(\\mathcal{O}(m\\sqrt n)\\) çº¦ \\(10^9\\) ï¼ŒHopcroft å¸¸æ•°å¾ˆå°ï¼ˆåªè·‘äº†217msï¼‰ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define fr first#define sc second#define pb push_back#define mp make_pair#define mt make_tuple#define pii pair&lt;int, int&gt;#define tiii tuple&lt;long, long, long&gt;#define all(s) (s).begin(), (s).end()#define lowbit(x) ((x) &amp; -(x))#define rep(i, x, y) for (int (i) = (x); (i) &lt;= (y); ++(i))#define per(i, x, y) for (int (i) = (x); (i) &gt;= (y); --(i))inline bool getmin(int &amp;a, int b) &#123;return (a &gt; b ? (a = b, true) : false);&#125;inline bool getmax(int &amp;a, int b) &#123;return (a &lt; b ? (a = b, true) : false);&#125;const int N = 110007;const int inf = 1000000000;namespace Hopcroft_Karp &#123; bool vis[N]; vector&lt;int&gt; e[N]; int nl, nr, ml[N], mr[N], dl[N], dr[N]; // m for match, d for distance inline bool bfs() &#123; static int q[N], hd, tl; hd = 1; tl = 0; memset(dl, -1, sizeof(int) * (nl + 1)); memset(dr, -1, sizeof(int) * (nr + 1)); for (int i = 1; i &lt;= nl; ++i) if (!ml[i]) &#123;dl[i] = 0; q[++tl] = i;&#125; int dT = inf; while (hd &lt;= tl) &#123; int u = q[hd++]; if (dl[u] &gt;= dT) break; for (auto v : e[u]) if (dr[v] == -1) &#123; dr[v] = dl[u] + 1; if (!mr[v]) getmin(dT, dr[v] + 1); else &#123;dl[mr[v]] = dr[v] + 1; q[++tl] = mr[v];&#125; &#125; &#125; return dT != inf; &#125; bool dfs(int u) &#123; for (auto v : e[u]) &#123; if (vis[v] || dl[u] + 1 != dr[v]) continue; vis[v] = true; if (!mr[v] || dfs(mr[v])) &#123;mr[v] = u; ml[u] = v; return true;&#125; &#125; return false; &#125; inline void add(int u, int v) &#123;e[u].push_back(v);&#125; inline int max_matching() &#123; int ans = 0; while(bfs()) &#123; memset(vis, 0, sizeof(bool) * (nr + 1)); for (int i = 1; i &lt;= nl; ++i) if (!ml[i]) ans += dfs(i); &#125; return ans; &#125;&#125;int tot, cnts;bool vis[N];unordered_map&lt;string, int&gt; tr;map&lt;vector&lt;int&gt;, int&gt; id;int main() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; int k; cin &gt;&gt; k; vector&lt;int&gt; course(k); for (int j = 0; j &lt; k; ++j) &#123; string str; cin &gt;&gt; str; if (!tr[str]) tr[str] = ++cnts; course[j] = tr[str]; &#125; sort(all(course)); vector&lt;int&gt; subset(1 &lt;&lt; k); for (int S = 1; S &lt; (1 &lt;&lt; k); ++S) &#123; vector&lt;int&gt; tmp(__builtin_popcount(S)); for (int j = 0, tmpcnt = 0; j &lt; k; ++j) if (S &amp; (1 &lt;&lt; j)) tmp[tmpcnt++] = course[j]; if (!id[tmp]) id[tmp] = ++tot; subset[S] = id[tmp]; &#125; for (int S = 1; S &lt; (1 &lt;&lt; k); ++S) &#123; int nwid = subset[S]; if (vis[nwid]) continue; vis[nwid] = true; for (int s = (S &amp; (S - 1)); s; s = (S &amp; (s - 1))) Hopcroft_Karp::add(nwid, subset[s]); &#125; &#125; Hopcroft_Karp::nl = Hopcroft_Karp::nr = tot; printf(&quot;%d\\n&quot;, tot - Hopcroft_Karp::max_matching()); return 0;&#125; *C - Cut Inequality Down ä¸€å…± \\(n\\ (1\\le n\\le 10^5)\\) ä¸ªæœˆï¼Œç¬¬ \\(i\\) ä¸ªæœˆçš„æ”¶å…¥å›ºå®šæ˜¯ \\(a_i\\ (-10^6\\le a_i\\le 10^6)\\) å…ƒã€‚ é™åˆ¶é’±æ•°ä»»ä½•æ—¶åˆ»éƒ½å¿…é¡»åœ¨ \\([L,R]\\) å†…ï¼Œå¦‚æœä¸€ä¸ªæœˆæ”¶å…¥ä¹‹åè¶…è¿‡äº†è¾¹ç•Œå°±æŠŠé’±æ•°æ”¹ä¸ºå¯¹åº”è¾¹ç•Œã€‚ \\(Q\\ (1\\le Q\\le 10^5)\\) æ¬¡è¯¢é—®ï¼šå¦‚æœä»ç¬¬ \\(a\\) å¤©å¼€å§‹çš„æ—¶å€™æœ‰ \\(w\\) å…ƒé’±ï¼Œé‚£ä¹ˆç¬¬ \\(b\\) å¤©çš„æ—¶å€™æœ‰å¤šå°‘é’±ï¼Ÿ å¦‚æœæ²¡æœ‰ç¢°è¿‡è¾¹ç•Œï¼Œç­”æ¡ˆå°±æ˜¯ \\(w+sum[b] - sum[a - 1]\\) ã€‚ å¦‚æœç¢°è¿‡è¾¹ç•Œï¼Œç­”æ¡ˆå°±æ˜¯ æœ€åä¸€æ¬¡ç¢°çš„è¾¹ç•Œå€¼ + å‰©ä¸‹çš„ä¸€æ®µæ”¶å…¥å’Œ ã€‚ å¦‚ä½•æ±‚æœ€åä¸€æ¬¡ç¢°çš„è¾¹ç•Œçš„ä½ç½®å‘¢ï¼Ÿ é¦–å…ˆæˆ‘ä»¬å¯ä»¥ \\(O(1)\\) åˆ¤æ–­ç»™å®šåŒºé—´å’Œåˆå§‹é’±æ•°ï¼ŒåŒºé—´å†…æ˜¯å¦ç¢°è¿‡è¾¹ç•Œï¼š é¢„å¤„ç†å‰ç¼€å’Œçš„åŒºé—´ \\(\\max,\\min\\) çš„ ST è¡¨ï¼ŒæŸ¥åŒºé—´å†…æ”¶å…¥æœ€å¤š/æœ€ä½æ—¶åˆ»ï¼Œä¸è¾¹ç•Œæ¯”è¾ƒå³å¯ã€‚ é‚£ä¹ˆå¯ä»¥ç”¨ä¸Šè¿°æ–¹æ³•å¥—ä¸€ä¸ªäºŒåˆ† \\(\\mathcal{O}(\\log n)\\) æ±‚å‡ºæœ€è¿‘çš„è§¦ç¢°è¾¹ç•Œæ—¶åˆ»ã€‚ å°±å¯ä»¥é¢„å¤„ç†å€å¢ nxt[i][t][0/1] è¡¨ç¤ºå½“å‰åœ¨ \\(i\\) ï¼Œå½“å‰é’±æ•°æ˜¯ä¸Š/ä¸‹è¾¹ç•Œï¼Œå¾€å \\(2^t\\) æ¬¡è§¦åŠè¾¹ç•Œçš„ä½ç½®å’Œå¯¹åº”æ˜¯ä¸Š/ä¸‹è¾¹ç•Œã€‚ æ¯æ¬¡è¯¢é—®å…ˆäºŒåˆ†ä¸€æ¬¡åˆ°è¾¹ç•Œï¼Œç„¶åç”¨å€å¢è·³ï¼Œæœ€åä¸€æ®µç›´æ¥ç”¨å‰ç¼€å’Œï¼Œæ€»å¤æ‚åº¦ \\(\\mathcal{O}(n\\log n+ Q\\log n)\\)ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;#define all(s) (s).begin(), (s).end()#define lowbit(x) ((x) &amp; -(x))#define N 100007int n, L, R, a[N], lg[N];ll mx[N][18], mn[N][18], pre[N];inline ll qmx(int l, int r) &#123; int t = lg[r - l + 1]; return max(mx[l][t], mx[r - (1 &lt;&lt; t) + 1][t]);&#125;inline ll qmn(int l, int r) &#123; int t = lg[r - l + 1]; return min(mn[l][t], mn[r - (1 &lt;&lt; t) + 1][t]);&#125;pair&lt;int, bool&gt; nxt[N][18][2];pair&lt;int, bool&gt; getnxt(int nw, int w) &#123; auto check = [&amp;](int p) &#123; if (w + qmx(nw, p) - pre[nw - 1] &gt; R) return true; if (w + qmn(nw, p) - pre[nw - 1] &lt; L) return true; return false; &#125;; if (!check(n)) return mp(n + 1, 0); int l = nw, r = n; while (l &lt; r) &#123; int mid = (l + r) &gt;&gt; 1; check(mid) ? r = mid : l = mid + 1; &#125; return mp(l, w + qmx(nw, l) - pre[nw - 1] &gt; R);&#125;int main() &#123; for (int t = 0; (1 &lt;&lt; t) &lt; N; ++t) lg[1 &lt;&lt; t] = t; for (int i = 1; i &lt; N; ++i) if (!lg[i]) lg[i] = lg[i - 1]; n = rd(); L = rd(); R = rd(); for (int i = 1; i &lt;= n; ++i) &#123; a[i] = rd(); pre[i] = pre[i - 1] + a[i]; mx[i][0] = mn[i][0] = pre[i]; &#125; for (int t = 1; t &lt;= lg[n]; ++t) for (int i = 1; i &lt;= n - (1 &lt;&lt; t) + 1; ++i) &#123; mx[i][t] = max(mx[i][t - 1], mx[i + (1 &lt;&lt; (t - 1))][t - 1]); mn[i][t] = min(mn[i][t - 1], mn[i + (1 &lt;&lt; (t - 1))][t - 1]); &#125; memset(nxt, 0x3f, sizeof(nxt)); for (int i = 1; i &lt;= n; ++i) &#123; nxt[i][0][0] = getnxt(i, L); nxt[i][0][1] = getnxt(i, R); &#125; for (int t = 1; t &lt;= lg[n]; ++t) for (int i = 1; i &lt;= n; ++i) &#123; if (nxt[i][t - 1][0].fr &lt;= n) nxt[i][t][0] = nxt[nxt[i][t - 1][0].fr + 1][t - 1][nxt[i][t - 1][0].sc]; if (nxt[i][t - 1][1].fr &lt;= n) nxt[i][t][1] = nxt[nxt[i][t - 1][1].fr + 1][t - 1][nxt[i][t - 1][1].sc]; &#125; for (int q = rd(); q; --q) &#123; int l = rd(), r = rd(), w = rd(); auto [p, fl] = getnxt(l, w); if (p &gt; r) &#123; printf(&quot;%lld\\n&quot;, w + pre[r] - pre[l - 1]); continue; &#125; for (int i = lg[n]; ~i; --i) if (nxt[p][i][fl].fr &lt;= r) &#123; auto [nxp, nxfl] = nxt[p][i][fl]; p = nxp + 1; fl = nxfl; &#125; printf(&quot;%lld\\n&quot;, (fl ? R : L) + pre[r] - pre[p - 1]); &#125; return 0;&#125; D - Dazzling Stars ç»™å®šäºŒç»´å¹³é¢ä¸Š \\(n\\ (1\\le n\\le 10^3)\\) ä¸ªç‚¹çš„åæ ‡ \\((x_i,y_i)\\) å’Œæƒå€¼ \\(w_i\\) ã€‚ é—®æ˜¯å¦èƒ½å°†æ‰€æœ‰ç‚¹æ•´ä½“æ—‹è½¬ä¸€ä¸ªè§’åº¦ï¼Œä½¿å¾—ï¼šè‹¥ \\(w_A&gt;w_B\\) ï¼Œé‚£ä¹ˆ \\(y_A\\ge y_B\\) ã€‚ å¯¹äºæ¯ä¸€å¯¹ä¸ç­‰å…³ç³»ï¼Œç¡®å®šåˆæ³•çš„è§’åº¦åŒºé—´ï¼Œè§’åº¦åŒºé—´åˆ¤äº¤ã€‚ æŠŠè§’åº¦åŒºé—´æ§åˆ¶åœ¨ \\([0,2\\pi]\\) å†…ï¼Œå¦‚æœè¶Šè¿‡å°±æ‹†æˆä¸¤æ®µï¼Œç„¶åæ‰«æçº¿ï¼Œå…ˆ \\(+\\) å \\(-\\) ï¼Œåˆ¤æ–­æ˜¯å¦æœ‰ä¸€ä¸ªä½ç½®è¦†ç›–æ¬¡æ•° \\(=\\) åŒºé—´ä¸ªæ•°ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef long double ld;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;#define all(s) (s).begin(), (s).end()#define lowbit(x) ((x) &amp; -(x))const ld PI = 3.1415926535897932384;const ld a90 = atan(1) * 2;const ld a180 = a90 * 2, a270 = a90 * 3, a360 = a90 * 4;const ld dlt[2][2] = &#123;0, a180, a360, a180&#125;;#define N 1007int w[N];ld x[N], y[N];inline ld angle(ld x, ld y) &#123; if (fabs(x) &lt; 1e-15) return a90 * (1 + 2 * (y &lt; 0)); else return atan(y / x) + dlt[y &lt; 0][x &lt; 0];&#125;vector&lt;pair&lt;long double, bool&gt;&gt; s;int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; x[i] = rd(); y[i] = rd(); w[i] = rd(); &#125; int tot = 0, nw = 0; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) if (w[i] &gt; w[j]) &#123; ++tot; ld alpha = angle(x[i] - x[j], y[i] - y[j]); ld l = -alpha, r = PI - alpha; while (l &lt; 0) &#123;l += 2 * PI; r += 2 * PI;&#125; if (r &gt;= 2 * PI) r -= 2 * PI; s.pb(mp(l, false)); s.pb(mp(r, true)); if (l &gt; r) ++nw; &#125; sort(all(s)); if (tot == 0) &#123;puts(&quot;Y&quot;); return 0;&#125; for (auto [p, w] : s) &#123; nw += (w ? -1 : 1); if (nw == tot) &#123;puts(&quot;Y&quot;); return 0;&#125; &#125; puts(&quot;N&quot;); return 0;&#125; E - Eggfruit Cake ç»™ä¸€ä¸ª \\(01\\) ç¯ï¼Œé—®æœ‰å¤šå°‘ä¸ªç¯ä¸Šçš„çš„åŒºé—´ç¬¦åˆé•¿åº¦ä¸è¶…è¿‡ \\(s\\) å¹¶ä¸”è‡³å°‘æœ‰ä¸€ä¸ª \\(1\\) ã€‚ æšä¸¾å·¦ç«¯ç‚¹ï¼Œå¤åˆ¶ä¸€éé¢„å¤„ç†åé¢ç¬¬ä¸€ä¸ª \\(1\\) çš„ä½ç½®ï¼Œç­”æ¡ˆå°±æ˜¯ \\(\\sum s-dis(pos[i]-i)\\) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;#define all(s) (s).begin(), (s).end()#define lowbit(x) ((x) &amp; -(x))string s;#define N 100007bool fl = false;int nxt[N &lt;&lt; 1];int main() &#123; cin &gt;&gt; s; for (auto x : s) if (x == &#x27;E&#x27;) &#123;fl = true; break;&#125; if (!fl) &#123;puts(&quot;0&quot;); return 0;&#125; int n = s.length(); s = &quot; &quot; + s + s; for (int i = (n &lt;&lt; 1), lst = n; i; --i) &#123; if (s[i] == &#x27;E&#x27;) lst = i; nxt[i] = lst; &#125; int mx; cin &gt;&gt; mx; ll ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; ans += max(0, mx - (nxt[i] - i)); &#125; printf(&quot;%lld\\n&quot;, ans); return 0;&#125; *F - Fabricating Sculptures ä¸€äº›ç –å—å †èµ·æ¥ï¼Œè®¡æ•°æ°å¥½ç”¨ \\(B\\) å—ç –ï¼Œæœ€ä¸‹é¢ä¸€å±‚æ°å¥½ \\(S\\ (1\\le S\\le B\\le 10^3)\\) å—ç –ï¼Œå¹¶ä¸”ä¸ä¼šç§¯æ°´çš„å †ç Œæ–¹æ¡ˆæ•°ã€‚ éœ€è¦æ¨ªç€æƒ³ï¼Œä¸€å±‚ä¸€å±‚æ”¾ï¼Œçº¦æŸå˜æˆï¼šæœ€ä¸‹é¢ä¸€å±‚ \\(S\\) ä¸ªï¼Œæ¯ä¸€å±‚ä¸èƒ½æ¯”ä¸‹ä¸€å±‚å¤šçš„æ–¹æ¡ˆæ•°ã€‚ å‘ç°æˆ‘ä»¬å¹¶ä¸å…³å¿ƒå½“å‰æ”¾äº†å¤šå°‘å±‚ï¼Œå› æ­¤çŠ¶æ€å¯ä»¥è®¾è®¡ä¸º \\(f[x][j]\\) è¡¨ç¤ºå·²ç»ç”¨äº† \\(x\\) ä¸ªï¼Œå½“å‰æœ€ä¸Šé¢ä¸€å±‚æ”¾äº† \\(j\\) ä¸ªçš„æ–¹æ¡ˆæ•°ã€‚ è½¬ç§»ï¼š\\(f[x][j] = \\sum_{k=j}^Sf[x - j][k]\\times (k - j + 1) = \\sum_{k=j}^S f[x-j][k]\\times k - (j-1)\\sum_{k=j}^S f[x-j][k]\\) ç»´æŠ¤ \\(f[\\ast][k]\\times k\\) çš„åç¼€å’Œã€\\(f[\\ast][k]\\) çš„åç¼€å’Œå³å¯å®ç° \\(\\mathcal{O}(1)\\) è½¬ç§»ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;#define all(s) (s).begin(), (s).end()#define lowbit(x) ((x) &amp; -(x))#define N 5007#define mod 1000000007int f[N][N], sum[N][N], sumk[N][N];int main() &#123; int m = rd(), n = rd(); f[m][m] = 1; for (int j = m; j; --j) &#123; sum[m][j] = (sum[m][j + 1] + f[m][j]) % mod; sumk[m][j] = (sumk[m][j + 1] + 1ll * j * f[m][j]) % mod; &#125; for (int use = m + 1; use &lt;= n; ++use) &#123; for (int j = min(m, use); j; --j) &#123; f[use][j] = (sumk[use - j][j] + 1ll * sum[use - j][j] * (1 - j + mod)) % mod; sum[use][j] = (sum[use][j + 1] + f[use][j]) % mod; sumk[use][j] = (sumk[use][j + 1] + 1ll * j * f[use][j]) % mod; &#125; &#125; printf(&quot;%d\\n&quot;, sum[n][1]); return 0;&#125; G - Gluing Pictures ç»™å®šä¸€ä¸ªæ¨¡ç‰ˆä¸²ï¼Œå¤šæ¬¡è¯¢é—®ï¼ŒæŠŠä¸€ä¸ªä¸²æœ€å°‘æ‹†æˆå¤šå°‘ä¸ªæ¨¡ç‰ˆä¸²çš„å­ä¸²æ‹¼æ¥èµ·æ¥ã€‚ å®¹æ˜“å‘ç°è´ªå¿ƒæ‹¿æ›´é•¿çš„å­ä¸²æ˜¯æ­£ç¡®çš„ï¼Œæ‰€ä»¥ç›´æ¥åœ¨ SAM ä¸ŠåŒ¹é…å°±å¥½äº†ï¼Œå¤±è´¥å°±å›åˆ°æ ¹ï¼Œç­”æ¡ˆå°±æ˜¯åŒ¹é…æ¬¡æ•°ã€‚ 123456789101112131415161718192021222324252627282930313233343536#include&lt;cstdio&gt;using namespace std;const int maxn=200000,maxt=maxn&lt;&lt;1,maxi=26;int n,te;char s[maxn+5],t[maxn+5];int pl,ro,son[maxt+5][maxi],fai[maxt+5],MAX[maxt+5];inline int newnode() &#123;pl++;return pl;&#125;int Extend(int p,int c)&#123; int np=newnode();MAX[np]=MAX[p]+1; while (p &amp;&amp; !son[p][c]) son[p][c]=np,p=fai[p]; if (!p) &#123;fai[np]=ro;return np;&#125; int q=son[p][c];if (MAX[p]+1==MAX[q]) &#123;fai[np]=q;return np;&#125; int nq=newnode();MAX[nq]=MAX[p]+1; for (int i=0;i&lt;maxi;i++) son[nq][i]=son[q][i]; fai[nq]=fai[q];fai[q]=fai[np]=nq; while (p &amp;&amp; son[p][c]==q) son[p][c]=nq,p=fai[p]; return np;&#125;int main()&#123; scanf(&quot;%s&quot;,s+1);ro=newnode(); for (int i=1,p=ro;s[i];i++) p=Extend(p,s[i]-&#x27;A&#x27;); for (scanf(&quot;%d&quot;,&amp;te);te;te--)&#123; scanf(&quot;%s&quot;,t+1); int ans=0; for (int i=1,p=ro;t[i];i++)&#123; p=son[p][t[i]-&#x27;A&#x27;]; if (!p)&#123; p=son[ro][t[i]-&#x27;A&#x27;];ans++; if (!p) &#123;ans=-2;break;&#125; &#125; &#125; printf(&quot;%d\\n&quot;,ans+1); &#125; return 0;&#125; I - Improve SPAM æ³¨æ„é¢˜ç›®ä¿è¯æ˜¯ä¸ªDAGï¼ŒBFS å»æ‰æ— ç”¨ç‚¹ï¼Œç»Ÿè®¡å‡ºæ­£ç¡®ç‚¹åº¦ï¼Œç„¶åæ‹“æ‰‘æ’åºè·¯å¾„è®¡æ•°å³å¯ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;#define all(s) (s).begin(), (s).end()#define lowbit(x) ((x) &amp; -(x))#define N 2007#define mod 1000000007int deg[N], f[N];vector&lt;int&gt; e[N];queue&lt;int&gt; q;int main() &#123; int n = rd(), m = rd(); for (int i = 1; i &lt;= m; ++i) for (int k = rd(); k; --k) e[i].pb(rd()); q.push(1); while (!q.empty()) &#123; int u = q.front(); q.pop(); for (auto v : e[u]) &#123; if (!deg[v]) q.push(v); ++deg[v]; &#125; &#125; int ans2 = 0; for (int i = m + 1; i &lt;= n; ++i) ans2 += (deg[i] &gt; 0); q.push(1); f[1] = 1; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (auto v : e[u]) &#123; f[v] = (f[v] + f[u]) % mod; --deg[v]; if (!deg[v]) q.push(v); &#125; &#125; int ans1 = 0; for (int i = m + 1; i &lt;= n; ++i) ans1 = (ans1 + f[i]) % mod; printf(&quot;%d %d\\n&quot;, ans1, ans2); return 0;&#125; **J - Jumping Grasshopper ç»™å®šé•¿åº¦ä¸º \\(n\\) çš„æ•°åˆ—ï¼Œè§„å®šä¸€ä¸ªèµ·ç‚¹å’Œæ–¹å‘ï¼ˆå·¦/å³ï¼‰ï¼Œæ¯æ¬¡ä¼šè·³åˆ°è¯¥æ–¹å‘çš„ç¬¬ä¸€ä¸ªæ¯”å½“å‰é«˜çš„ä½ç½®ï¼Œç„¶åè½¬å‘ã€‚ ä¿è¯åˆå§‹æ•°åˆ—ä¸¤ä¸¤ä¸åŒï¼Œæ”¯æŒ \\(m\\) æ¬¡ ï¼š1. æŠŠæŸä¸ªæ•°æ”¹å¤§ï¼ˆä¾æ—§ä¸¤ä¸¤ä¸åŒï¼‰ï¼›2. ç»™å®šèµ·å§‹ä½ç½®å’Œæ–¹å‘ï¼Œé—®æœ€ååœåœ¨çš„ä½ç½®ã€‚ æ•°æ®èŒƒå›´ ï¼š\\(1\\le n,m\\le 2\\times 10^5,1\\le h_i\\le 10^9\\) å¦‚æœä¸¤ä¾§éƒ½å­˜åœ¨æ¯”å½“å‰ä½ç½®å¤§çš„ï¼Œè·³è·ƒä¸ä¼šåœæ­¢ï¼Œæœ€ç»ˆä¼šå…ˆè·³åˆ°å·¦å³æœ€å¤§å€¼è¾ƒå°çš„é‚£ä¸ªï¼Œç„¶åå†å¾€å¯¹é¢è·³ä¸€æ­¥ ã€‚ æ³¨æ„ä¸æ˜¯è·³åˆ°æœ€å¤§çš„ï¼Œå› ä¸ºæœ€å¤§å€¼è¾ƒå°çš„ä¸€ä¾§å›å¤´ä¹‹åç¬¬ä¸€ä¸ªæ¯”ä»–å¤§çš„ï¼Œæœ‰å¯èƒ½ä¸æ˜¯é‚£ä¸€ä¾§æœ€å¤§çš„ã€‚ æ‰€ä»¥çº¿æ®µæ ‘ç»´æŠ¤åŒºé—´ \\(\\max\\) + çº¿æ®µæ ‘ä¸ŠäºŒåˆ†æ‰¾ä¸Šä¸€ä¸ª/ä¸‹ä¸€ä¸ªæ¯”ç»™å®šå€¼å¤§çš„ä½ç½®ï¼Œå¤æ‚åº¦ \\(\\mathcal{O}(n\\log n)\\) ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;#define all(s) (s).begin(), (s).end()#define lowbit(x) ((x) &amp; -(x))#define N 200007#define ls (rt &lt;&lt; 1)#define rs (rt &lt;&lt; 1 | 1)#define mid ((l + r) &gt;&gt; 1)int n, m, h[N], mx[N &lt;&lt; 2];inline void pushup(int rt) &#123; mx[rt] = mx[ls] &gt; mx[rs] ? mx[ls] : mx[rs];&#125;void build(int rt, int l, int r) &#123; if (l == r) &#123;mx[rt] = h[l]; return;&#125; build(ls, l, mid); build(rs, mid + 1, r); pushup(rt);&#125;void upd(int rt, int l, int r, int p, int x) &#123; if (l == r) &#123;mx[rt] = x; return;&#125; p &lt;= mid ? upd(ls, l, mid, p, x) : upd(rs, mid + 1, r, p, x); pushup(rt);&#125;int qmax(int rt, int l, int r, int L, int R) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) return mx[rt]; int ans = 0; if (L &lt;= mid) ans = max(ans, qmax(ls, l, mid, L, R)); if (R &gt; mid) ans = max(ans, qmax(rs, mid + 1, r, L, R)); return ans;&#125;int nxtr(int rt, int l, int r, int L, int w) &#123; if (l == r) return l; if (L &lt;= mid &amp;&amp; mx[ls] &gt; w) &#123; int res = nxtr(ls, l, mid, L, w); if (res &gt; 0) return res; &#125; if (mx[rs] &lt;= w) return -1; return nxtr(rs, mid + 1, r, L, w);&#125;int nxtl(int rt, int l, int r, int L, int w) &#123; if (l == r) return l; if (L &gt; mid &amp;&amp; mx[rs] &gt; w) &#123; int res = nxtl(rs, mid + 1, r, L, w); if (res &gt; 0) return res; &#125; if (mx[ls] &lt;= w) return -1; return nxtl(ls, l, mid, L, w);&#125;unordered_map&lt;int, int&gt; pos;int main() &#123; int n = rd(), m = rd(), mxpos = 1; for (int i = 1; i &lt;= n; ++i) &#123; h[i] = rd(); pos[h[i]] = i; &#125; build(1, 1, n); for (int i = 1; i &lt;= m; ++i) &#123; char c = getchar(); while (!isalpha(c)) c = getchar(); if (c == &#x27;U&#x27;) &#123; int p = rd(); pos[h[p] = rd()] = p; upd(1, 1, n, p, h[p]); &#125; else &#123; int p = rd(); int lmx = qmax(1, 1, n, 1, p); if (c == &#x27;L&#x27; &amp;&amp; lmx == h[p]) &#123;printf(&quot;%d\\n&quot;, p); continue;&#125; int rmx = qmax(1, 1, n, p, n); if (c == &#x27;R&#x27; &amp;&amp; rmx == h[p]) &#123;printf(&quot;%d\\n&quot;, p); continue;&#125; if (lmx &lt; rmx) printf(&quot;%d\\n&quot;, nxtr(1, 1, n, pos[lmx], lmx)); else printf(&quot;%d\\n&quot;, nxtl(1, 1, n, pos[rmx], rmx)); &#125; &#125; return 0;&#125; K - Know your Aliens æ„é€ å¤šé¡¹å¼ \\(P\\) ï¼Œå¯¹äº \\(i=2,4,\\dots,2n\\) ï¼Œç¬¦åˆç»™å®šçš„æ¡ä»¶ \\(P(i)&gt;0\\) æˆ– \\(P(i)&lt;0\\) ã€‚ å¯¹äºç›¸é‚»çš„ç¬¦å·å˜åŒ–çš„ä½ç½®ï¼Œä¸­ä½æ•°ä¸€å®šæ˜¯ä¸ªå¥‡æ•°ï¼ˆå¹¶ä¸”æ˜¯æ•´æ•°ï¼‰ï¼Œå¯ä»¥å‡å®šä»–æ˜¯å¤šé¡¹å¼çš„æ ¹ã€‚ å› æ­¤å°±æ˜¯æ±‚ \\(\\prod (x-w_i)\\) çš„å„ç³»æ•°ï¼Œç„¶åæ ¹æ®ç¬¬ä¸€ä¸ªçš„æ­£è´Ÿè°ƒæ•´ä¸€ä¸‹ç¬¦å·å³å¯ã€‚ æœ‰ä¸€ä¸ª \\(O(n^2)\\) çš„é€’æ¨æ–¹æ³•æ±‚ç³»æ•°ï¼ˆç›´æ¥å¤šé¡¹å¼ä¹˜æ³•å¤æ‚åº¦ä¹Ÿå¯¹ï¼‰ï¼š è®¾ \\(f[i][j]\\) è¡¨ç¤ºå‰ \\(i\\) ä¸ªç³»æ•°é‡Œæ‰€æœ‰çš„é€‰ \\(j\\) ä¸ªçš„æ–¹æ¡ˆå¯¹åº”çš„ä¹˜ç§¯å’Œï¼Œè½¬ç§» \\(f[i][j] = f[i - 1][j] + f[i - 1][j - 1] * w_i\\) ã€‚ ï¼ˆä¸è¿‡è¿™ä¸ªé¢˜é¢˜é¢é‡Œè¯´ä¿è¯å­˜åœ¨ç³»æ•°ä¸è¶…è¿‡ \\(2^{63}\\) çš„å¤šé¡¹å¼ç¬¦åˆè¦æ±‚ï¼Œç†è§£èµ·æ¥æœ‰ç‚¹å¥‡æ€ªï¼‰ 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;#define all(s) (s).begin(), (s).end()#define lowbit(x) ((x) &amp; -(x))#define N 10007char s[N];ll cnt, f[N][N], w[N];int main() &#123; scanf(&quot;%s&quot;, s + 1); int n = strlen(s + 1); for (int i = 1; i &lt; n; ++i) if (s[i] != s[i + 1]) w[++cnt] = - 2 * i - 1; f[0][0] = 1; for (int i = 1; i &lt;= cnt; ++i) &#123; f[i][0] = 1; for (int j = 1; j &lt;= i; ++j) f[i][j] = f[i - 1][j - 1] * w[i] + f[i - 1][j]; &#125; int fl = ((f[cnt][cnt] &gt; 0) == (s[1] == &#x27;H&#x27;) ? 1 : -1); printf(&quot;%lld\\n&quot;, cnt); for (int i = 0; i &lt;= cnt; ++i) printf(&quot;%lld &quot;, fl * f[cnt][i]); return 0;&#125; L - Leverage MDT ç»™ä¸€ä¸ª \\(01\\) çŸ©é˜µï¼Œå¯¹äºæ¯è¡Œä½ éƒ½å¯ä»¥é€‰æ‹©å…¨éƒ¨ \\(01\\) ç¿»è½¬/ä¸ç¿»è½¬ï¼Œç„¶åæ±‚æœ€å¤§å­æ­£æ–¹å½¢ã€‚ æŒ‰åˆ—å»çœ‹ï¼Œæšä¸¾ç­”æ¡ˆçš„å³è¾¹ç•Œï¼Œå¯¹äºæ¯è¡Œçº¦æŸå°±å˜æˆäº†å‘å·¦æ‰¾å’Œå½“å‰ä½ç½®ç›¸åŒçš„æœ€é•¿é•¿åº¦ã€‚ ç„¶ååšä¸€ä¸ªå•è°ƒæ ˆå°±å¯ä»¥äº†ï¼Œå› ä¸ºæ˜¯æ­£æ–¹å½¢ï¼Œæ›´æ–°ç­”æ¡ˆä½¿ç”¨å½“å‰çš„é«˜åº¦å’Œå®½åº¦çš„è¾ƒå°å€¼ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;#define all(s) (s).begin(), (s).end()#define lowbit(x) ((x) &amp; -(x))#define N 1007bool a[N][N];int f[N][N];stack&lt;pii&gt; s;int main() &#123; int n = rd(), m = rd(); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) &#123; char c = getchar(); while (!isalpha(c)) c = getchar(); a[i][j] = (c == &#x27;G&#x27;); f[i][j] = (a[i][j] == a[i][j - 1] ? f[i][j - 1] + 1 : 1); &#125; int ans = 0; for (int j = 1; j &lt;= m; ++j) &#123; for (int i = 1; i &lt;= n; ++i) &#123; int len = 0; while (!s.empty() &amp;&amp; f[s.top().fr][j] &gt;= f[i][j]) &#123; len += s.top().sc; ans = max(ans, min(f[s.top().fr][j], len)); s.pop(); &#125; s.push(mp(i, len + 1)); &#125; int len = 0; while (!s.empty()) &#123; len += s.top().sc; ans = max(ans, min(f[s.top().fr][j], len)); s.pop(); &#125; &#125; printf(&quot;%d\\n&quot;, ans * ans); return 0;&#125; M - Mountain Ranges ç»™å®šæ•°åˆ—ï¼Œæ±‚æœ€é•¿çš„åŒºé—´ï¼ŒåŒºé—´å†…ç›¸é‚»çš„ä¸¤ä¸ªæ•°å·®å€¼ä¸è¶…è¿‡ \\(x\\) ã€‚ç›´æ¥æ‰«ä¸€éã€‚ 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;#define all(s) (s).begin(), (s).end()#define lowbit(x) ((x) &amp; -(x))#define N 1007int a[N];int main() &#123; int n = rd(), k = rd(), ans = 0; for (int i = 1; i &lt;= n; ++i) a[i] = rd(); for (int i = n, cnt = 0; i; --i) &#123; if (a[i + 1] - a[i] &gt; k) cnt = 0; ++cnt; ans = max(ans, cnt); &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125;","categories":[{"name":"Official Contests","slug":"Official-Contests","permalink":"http://blog.gyx.me/categories/Official-Contests/"}],"tags":[{"name":"Binary Search","slug":"Binary-Search","permalink":"http://blog.gyx.me/tags/Binary-Search/"},{"name":"Graphs","slug":"Graphs","permalink":"http://blog.gyx.me/tags/Graphs/"},{"name":"Segment Tree","slug":"Segment-Tree","permalink":"http://blog.gyx.me/tags/Segment-Tree/"},{"name":"Binary Lifting","slug":"Binary-Lifting","permalink":"http://blog.gyx.me/tags/Binary-Lifting/"},{"name":"Sparse Table","slug":"Sparse-Table","permalink":"http://blog.gyx.me/tags/Sparse-Table/"},{"name":"Stack","slug":"Stack","permalink":"http://blog.gyx.me/tags/Stack/"}]},{"title":"Prefix Function and Z Function","slug":"algorithms/z-function","date":"2022-10-14T06:29:18.000Z","updated":"2023-03-20T16:50:16.931Z","comments":true,"path":"algorithms/z-function/","link":"","permalink":"http://blog.gyx.me/algorithms/z-function/","excerpt":"","text":"Z Function Z-function - Algorithms for Competitive Programming Analysis å¯¹äºä¸€ä¸ªå­—ç¬¦ä¸² \\(S\\)ï¼ˆä¸‹æ ‡ä» \\(1\\) å¼€å§‹ï¼‰ï¼Œå®šä¹‰ \\(z[i]\\) è¡¨ç¤º \\(S\\) ä¸­ä» \\(i\\) å¼€å§‹çš„åç¼€ä¸ \\(S\\) çš„æœ€é•¿å…¬å…±å‰ç¼€ï¼ˆLCPï¼‰çš„é•¿åº¦ã€‚ ç›´æ¥æ±‚ \\(z\\) æ•°ç»„æ˜¯ \\(\\mathcal{O}(n^2)\\) çš„ï¼Œä½†æ˜¯å¦‚æœåˆ©ç”¨åˆ°ä»¥å¾€çš„ä¿¡æ¯ï¼Œå°±å¯ä»¥å°†æš´åŠ›ä¼˜åŒ–åˆ° \\(\\mathcal{O}(n)\\) ã€‚ Efficient AlgorithmæŒ‰ç…§ \\(i=1,2,\\dots,|s|\\)çš„é¡ºåºä¾æ¬¡æ±‚ \\(z\\)æ•°ç»„ï¼ŒåŒæ—¶ç»´æŠ¤å½“å‰åŒ¹é…åˆ°æœ€é å³çš„ä½ç½® \\(mxpos=\\arg \\max \\{i + z[i] - 1\\}\\)è®° \\((mxpos,mxpos + z[mxpos] - 1)\\)ä¸º \\((L,R)\\)ï¼Œä»£è¡¨å½“å‰ä¸å‰ç¼€åŒ¹é…çš„æœ€é å³çš„åŒºé—´ã€‚é‚£ä¹ˆå¯¹äºä¸€ä¸ªæ–°æ‰«æçš„ä½ç½® \\(i\\)ï¼Œè®¨è®ºï¼šè‹¥ \\(i&gt;R\\)ï¼Œé‚£ä¹ˆæ›¾ç»çš„ä¿¡æ¯éƒ½ç”¨ä¸ä¸Šäº†ï¼Œæš´åŠ›ä» \\(i\\) å¼€å§‹å‘åå°è¯•åŒ¹é…ã€‚å¦‚æœ \\(i&lt;R\\)ï¼Œæˆ‘ä»¬å°è¯•åˆ©ç”¨æ›¾ç»è®¡ç®—è¿‡çš„ä¿¡æ¯ï¼šé¦–å…ˆå¯ä»¥è‚¯å®š \\(S[i,R]=S[i-l+1,r-l+1]\\) ,å°è¯•åˆ©ç”¨æ‰€ä»¥å¯ä»¥ç»§æ‰¿ \\(z[i-l+1]\\)çš„ä¸€éƒ¨åˆ†ã€‚ä½†å¦‚æœå¯¹åº”ä½ç½®è¶…è¿‡ \\(R\\)å°±ä¸èƒ½ç¡®å®šæ˜¯å¦å¯ä»¥åˆ©ç”¨äº†ï¼Œæ‰€ä»¥ä»¤ \\(z[i]=\\min(z[i-l+1],r - i + 1)\\)ï¼Œç„¶åå†æš´åŠ›å‘ååŒ¹é…ã€‚123456int l = 0, r = 0;for (int i = 2; i &lt;= n; ++i) &#123; if (i &lt;= r) z[i] = min(z[i - l + 1], r - i + 1); while (i + z[i] &lt;= n &amp;&amp; t[z[i] + 1] == t[i + z[i]]) ++z[i]; if (i + z[i] - 1 &gt; r) &#123;l = i; r = i + z[i] - 1;&#125; &#125;Proof of Time Complexityé¦–å…ˆç®—æ³•æ­£ç¡®æ€§æ˜¾ç„¶ï¼Œç©ºé—´å¤æ‚åº¦æ˜¾ç„¶æ˜¯ \\(\\mathcal{O}(n)\\) ï¼Œå°±ä¸å¤šåšåˆ†æäº†ã€‚è¯æ˜æ€è·¯ï¼šè§‚å¯Ÿåˆ°ä¸¤ç§æƒ…å†µä¸‹æ¯æ¬¡æœ‰æ•ˆçš„æš´åŠ›æ¯”è¾ƒéƒ½ä¼šæ‹“å±•å³è¾¹ç•Œ \\(R\\) ï¼Œè€Œå³è¾¹ç•Œåªä¼šå˜åŒ– \\(n\\) æ¬¡ï¼Œæ•…çº¿æ€§å¤æ‚åº¦ã€‚ ARC 058 F - Iroha Loves Strings ç»™å®š \\(n\\) ä¸ªä¸²çš„åºåˆ— \\(s_1,s_2,\\dots,s_n\\) ï¼Œé€‰æ‹©å…¶ä¸­ä¸€äº›ä¸²ï¼ŒæŒ‰ç…§åŸåºåˆ—é¡ºåºè¿æ¥èµ·æ¥ï¼Œä½¿å¾—å¾—åˆ°çš„ä¸²é•¿ä¸º \\(k\\) ä¸”å­—å…¸åºæœ€å°ã€‚ æ•°æ®èŒƒå›´ï¼š\\(1\\le n\\le 2\\times 10^3,1\\le |s_i|\\le k\\le 10^4\\) æŒ‰é¡ºåºæ‹¿ï¼Œå…ˆè§£å†³å¯ä¸å¯ä»¥æ‹¿ï¼Œå€’åºåšä¸€ä¸ª \\(O(nk)\\) çš„ 01 èƒŒåŒ…é¢„å¤„ç† valid[i][j] è¡¨ç¤º \\(i\\) åŠä¹‹åçš„ä¸²æ˜¯å¦èƒ½ç»„åˆå‡ºé•¿åº¦ \\(j\\) ã€‚ æ¥ä¸‹æ¥å…ˆè€ƒè™‘æš´åŠ›ï¼šè®¾ f[i][j] è¡¨ç¤ºå‰ \\(i\\) ä¸ªä¸²ï¼Œå‡‘å‡ºé•¿åº¦ä¸º \\(j\\) çš„æœ€å°å­—å…¸åºå­—ç¬¦ä¸²ï¼Œè½¬ç§»ä¸ºå­—ç¬¦ä¸²æ¯”è¾ƒå¤æ‚åº¦ï¼Œæ€» \\(\\mathcal{O}(nk^2)\\) ã€‚ è€ƒè™‘ä¼˜åŒ–ï¼Œå¯¹äºç›¸åŒé•¿åº¦ï¼Œæœ€ä¼˜è§£æ˜¾ç„¶åªæœ‰ä¸€ä¸ªï¼ˆè½¬ç§»æ—¶åªä» f[i-1][x] è½¬ç§»ï¼Œå·²ç»ä½¿ç”¨ï¼‰ï¼› å¯¹äºä¸åŒé•¿åº¦ä¸¤ä¸ªçŠ¶æ€ï¼Œå‡è®¾è¾ƒçŸ­çš„ä¸º \\(a\\) ï¼Œè¾ƒé•¿çš„ä¸º \\(b\\) ï¼Œè‹¥ \\(b\\) é•¿åº¦ä¸º \\(|a|\\) çš„å‰ç¼€å’Œ \\(a\\) ä¸åŒï¼Œåˆ™ \\(a,b\\) ä¸€å®šæœ‰ä¸€ä¸ªæ²¡ç”¨ã€‚ å› æ­¤å½“å‰æ‰€æœ‰æœ€ä¼˜è§£ä¸­ï¼ŒçŸ­çš„ä¸²å¿…ç„¶æ˜¯é•¿çš„ä¸²çš„å‰ç¼€ï¼Œæ‰€æœ‰ä¸²éƒ½å¯ä»¥ç”¨æœ€é•¿çš„æœ€ä¼˜è§£ \\(S\\) çš„å‰ç¼€æ¥è¡¨ç¤ºã€‚ ç°åœ¨è€ƒè™‘ dp å®é™…åœ¨åšä»€ä¹ˆï¼šå°†ä»¥å¾€çš„æŸä¸ªæœ€ä¼˜è§£æ¥ä¸Šå½“å‰ä¸²ï¼Œæ¥æ›¿æ¢ä»¥å¾€çš„å…¶ä»–æœ€ä¼˜è§£ã€‚ å³å¯¹äºä»¥å¾€çš„ä¸¤ä¸ªæœ€ä¼˜è§£ \\(a,b\\) æ»¡è¶³ \\(|a|+|s_i|=|b|\\) ï¼Œå¦‚æœ \\(s_i\\) æ¯” \\(S\\) ä¸­ \\(|a|+1\\) å¼€å§‹çš„åç¼€å­—å…¸åºè¦å°ï¼Œé‚£ä¹ˆé•¿åº¦ \\(\\ge |a|\\) çš„ä»¥å¾€çš„æœ€ä¼˜è§£éƒ½æ²¡ç”¨äº†ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥æšä¸¾æœ€é å‰çš„è¿™ä¸ªä½ç½®è¿›è¡Œæ’å…¥ï¼ˆå¹¶åˆ é™¤ä»¥å¾€å¤šä½™çš„åç¼€ï¼‰ã€‚ å¯ä»¥å‘ç°æ¯”è¾ƒçš„æ°¸è¿œæ˜¯ \\(S\\) çš„ä¸€ä¸ªåç¼€å’Œ \\(s_i\\) çš„å­—å…¸åºï¼Œå› æ­¤å¯ä»¥ç”¨ \\(s_i+\\#+S\\) è·‘ Z å‡½æ•°ç¡®å®š LCP åè®¨è®ºã€‚ è¿™æ ·å¤æ‚åº¦å°±æ˜¯ \\(\\mathcal{O}(nk)\\) çš„äº†ã€‚å®åœ¨æ˜¯å¤ªç»†èŠ‚äº†ç»·ä¸ä½äº†ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;#define N 2007#define K 10007char s[N][K], S[K], tmp[K &lt;&lt; 1];bool valid[N][K], pos[K];int len[N], z[K &lt;&lt; 1];void zfunc(int p) &#123; memset(z, 0, sizeof(z)); memset(tmp, 0, sizeof(tmp)); strcpy(tmp + 1, s[p] + 1); tmp[len[p] + 1] = &#x27;z&#x27; + 1; strcpy(tmp + len[p] + 2, S + 1); tmp[strlen(tmp + 1) + 1] = &#x27;z&#x27; + 2; int l = 0, r = 0; for (int i = 2, lim = strlen(tmp + 1); i &lt;= lim; ++i) &#123; if (i &lt;= r) z[i] = min(z[i - l + 1], r - i + 1); while (i + z[i] &lt;= lim &amp;&amp; tmp[z[i] + 1] == tmp[i + z[i]]) ++z[i]; if (i + z[i] - 1 &gt; r) &#123;l = i; r = i + z[i] - 1;&#125; &#125;&#125;int main() &#123; int n, k; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for (int i = 1; i &lt;= n; ++i) &#123; scanf(&quot;%s&quot;, s[i] + 1); len[i] = strlen(s[i] + 1); &#125; for (int i = 1; i &lt;= n + 1; ++i) valid[i][0] = true; for (int i = n; i; --i) for (int j = k; j; --j) &#123; valid[i][j] |= valid[i + 1][j]; if (j &gt;= len[i]) valid[i][j] |= valid[i + 1][j - len[i]]; &#125; for (int i = 1; i &lt;= n; ++i) &#123; zfunc(i); int len_S = strlen(S + 1); pos[len_S + 1] = true; for (int j = 1, lim = min(k + 1 - len[i], len_S + 1); j &lt;= lim; ++j) if (valid[i + 1][k - (j + len[i] - 1)] &amp;&amp; pos[j]) &#123; // update to S[j,j + len[i] - 1] int match = z[j + len[i] + 1]; if (match == len[i]) pos[j + len[i]] = true; else if (j + match - 1 == len_S) &#123; strcpy(S + j, s[i] + 1); pos[len_S + 1] = pos[j + len[i]] = true; &#125; else if (match &lt; len[i] &amp;&amp; tmp[match + 1] &lt; tmp[j + len[i] + 1 + match]) &#123; strcpy(S + j, s[i] + 1); for (int p = j + match + 1; p &lt;= k; ++p) pos[p] = false; break; &#125; &#125; &#125; puts(S + 1); return 0;&#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://blog.gyx.me/categories/Algorithms/"}],"tags":[{"name":"String","slug":"String","permalink":"http://blog.gyx.me/tags/String/"}]},{"title":"Dilworth's Theorem","slug":"algorithms/dilworth","date":"2022-09-23T05:57:39.000Z","updated":"2023-03-20T16:45:13.343Z","comments":true,"path":"algorithms/dilworth/","link":"","permalink":"http://blog.gyx.me/algorithms/dilworth/","excerpt":"","text":"Definition Partial order relation : a homogeneous relation that is transitive and antisymmetric. Non-strict (reflexive / weak) partial order \\(\\le\\) : Reflexivity, Antisymmetry, Transitivit. Strict (irreflexive / strong) partial order \\(&lt;\\) : Irreflexivity, Antisymmetry, Transitivit. Converse relation (Transpose) : the relation that occurs when the order of the elements is switched. the converse relation of \\(\\le\\) is \\(\\ge\\) , and the converse relation of \\(&lt;\\) is \\(&gt;\\) ã€‚ For a partial ordered set \\((A, R)\\) ï¼š Chain \\(A&#39;\\subseteq A\\) : a totally ordered set, i.e. \\(\\forall x,y\\in A&#39; (x\\ne y), xRy\\) or \\(yRx\\) holds. Antichain \\(A&#39;\\subseteq A\\) : a totally unordered set, i.e. \\(\\forall x,y\\in A&#39; (x\\ne y),\\) neither \\(xRy\\) nor \\(yRx\\) holds (incomparable). Chain Decomposition (Cover) : a partition of the elements of the order into disjoint chains. Theorem and Proof Dilworth's TheoremIn any finite partially ordered set, the largest antichain has the same size as the smallest chaindecomposition.The width of the partial order is defined as thecommon size of the antichain and chain decomposition.Dual (Mirsky's theorem)In any finite partially ordered set, the largest chain has the same size as the smallest antichain decomposition.The depth of the partial order is defined as thecommon size of the chain and antichain decomposition. The following proof by induction on the size of the partially ordered set \\((P,\\le)\\). Let \\(P\\) be a finite partially ordered set. The theorem holds trivially if \\(P\\) is empty. So, assume that \\(P\\) has at least one element, and let \\(a\\) be a maximal element of \\(P\\). By induction, we assume that for some integer \\(k\\) the partially ordered set \\(P^{\\prime}:=P \\backslash\\{a\\}\\) can be covered by \\(k\\) disjoint chains \\(C_1, \\ldots, C_k\\) and has at least one antichain \\(A_0\\) of size \\(k\\). Clearly, (since \\(A_0\\) is an antichain) , \\(A_0 \\cap C_i \\neq \\emptyset\\) for \\(i=1,2, \\ldots, k\\). For \\(i=1,2, \\ldots, k\\), let \\(x_i\\) be the maximal element in \\(C_i\\) that belongs to an antichain of size \\(k\\) in \\(P^{\\prime}\\) , and set \\(A:=\\left\\{x_1, x_2, \\ldots, x_k\\right\\}\\) . We claim that \\(A\\) is an antichain. Let \\(A_i\\) be an antichain of size \\(k\\) that contains \\(x_i\\) . Fix arbitrary distinct indices \\(i\\) and \\(j\\) . Then \\(A_i \\cap C_j \\neq \\emptyset\\) . Let \\(y \\in A_i \\cap C_j\\) . Then \\(y \\leq x_j\\) , by the definition of \\(x_j\\) . This implies that \\(x_i \\ne x_j\\) , since \\(x_i \\ne y\\) . By interchanging the roles of \\(i\\) and \\(j\\) in this argument we also have \\(x_j \\ne x_i\\). This verifies that \\(A\\) is an antichain. We now return to \\(P\\). Suppose first that \\(a \\geq x_i\\) for some \\(i \\in\\{1,2, \\ldots, k\\}\\). Let \\(K\\) be the chain \\(\\{a\\} \\cup\\left\\{z \\in C_i: z \\leq x_i\\right\\}\\) . Then by the choice of \\(x_i\\) , \\(P \\backslash K\\) does not have an antichain of size \\(k\\) . Induction then implies that \\(P \\backslash K\\) can be covered by \\(k-1\\) disjoint chains since \\(A \\backslash\\left\\{x_i\\right\\}\\) is an antichain of size \\(k-1\\) in \\(P \\backslash K\\) . Thus, \\(P\\) can be covered by \\(k\\) disjoint chains, as required. Next, if \\(a \\not\\ge x_i\\) for each \\(i \\in\\{1,2, \\ldots, k\\}\\), then \\(A \\cup\\{a\\}\\) is an antichain of size \\(k+1\\) in \\(P\\) (since \\(a\\) is maximal in \\(P\\) ). Now \\(P\\) can be covered by the \\(k+1\\) chains \\(\\{a\\}, C_1, C_2, \\ldots, C_k\\), completing the proof. Application æ‰¾äºŒå…ƒå…³ç³»å¹¶æ£€éªŒï¼›2. è¿ç”¨å®šç†ï¼ˆåŠå¯¹å¶å®šç†ï¼‰è½¬åŒ–ã€‚ NOIP 1999 - å¯¼å¼¹æ‹¦æˆª ç»™ä¸€ä¸ªæ•°åˆ— \\(a_1,a_2,\\cdots,a_n\\) ï¼Œé—®æœ€å°‘åˆ’åˆ†ä¸ºå¤šå°‘ä¸ªä¸¥æ ¼ä¸å¢å­åºåˆ—ã€‚ å¯ä»¥æ¥åˆ°ä¸€ä¸ªåºåˆ—çš„å…³ç³»ä¸ºï¼š \\(iRj=i&lt;j\\) ä¸” \\(a_i\\ge a_j\\) ï¼Œå®¹æ˜“éªŒè¯è¯¥äºŒå…ƒå…³ç³»æ˜¯ä¸¥æ ¼ååºã€‚ é‚£ä¹ˆåé“¾çš„è¦æ±‚å³ ( \\(i&lt;j\\) ä¸” \\(a_i&lt;a_j\\) ) æˆ– ( \\(i&gt;j\\) ä¸” \\(a_i&gt; a_j\\) ) ï¼Œå³ä¸¥æ ¼ä¸Šå‡å­åºåˆ—ï¼Œæ‰€ä»¥ç­”æ¡ˆä¸ºæœ€é•¿ä¸Šå‡å­åºåˆ—é•¿åº¦ã€‚ æ¨è®ºï¼šä¸€ä¸ªæ•°åˆ—æ€»æ˜¯å­˜åœ¨ä¸‹é¢äºŒè€…ä¹‹ä¸€ï¼šä¸€ä¸ªé•¿åº¦ä¸º \\(\\sqrt n\\) çš„ä¸Šå‡å­åºåˆ—æˆ–ä¸€ä¸ªé•¿åº¦ä¸º \\(\\sqrt n\\) çš„ä¸‹é™å­åºåˆ—ã€‚ å› æ­¤å¯ä»¥æ„é€ ï¼Œæ¯ \\(\\sqrt n\\) ä¸ªä¸€ç»„ï¼Œå†…éƒ¨ä¸‹é™ï¼Œæ•´ä½“ä¸Šå‡ï¼Œä½¿å¾—å…¶ LIS å’Œ LDS çš„ \\(\\max\\) æœ€å°ã€‚ TJOI 2015 - ç»„åˆæ•°å­¦ ç»™å®šä¸€ä¸ªç½‘æ ¼å›¾ï¼Œæ¯æ¬¡ä»å·¦ä¸Šè§’å‡ºå‘ï¼Œåªèƒ½å¾€å³æˆ–å¾€ä¸‹èµ°ï¼Œæœ€ååˆ°è¾¾å³ä¸‹è§’ï¼Œæ¯ä¸ªæ ¼å­æœ‰æœ€ä½ç»è¿‡æ¬¡æ•°ï¼Œé—®æœ€å°‘èµ°å‡ æ¬¡ï¼Ÿ äºŒå…ƒå…³ç³»ä¸ºå‘å³å‘ä¸‹èµ°çš„å¯è¾¾æ€§ï¼Œä¸”è‡ªå·±ä¸å¯ä»¥åˆ°è‡ªå·±ï¼Œæ˜¯ä¸¥æ ¼ååºã€‚ æ±‚æœ€å°é“¾è¦†ç›–ï¼Œç”± Dilworth å®šç†ï¼Œç­‰ä»·äºæ±‚æœ€é•¿åé“¾ï¼Œä¹Ÿå°±æ˜¯ä¸¤ä¸¤éƒ½æ˜¯ä¸¥æ ¼çš„å·¦ä¸‹ä¸å³ä¸Šçš„å…³ç³»ã€‚ å› æ­¤ä»å·¦ä¸‹è§’åˆ°å³ä¸Šè§’åšæœ€é•¿åé“¾çš„ dp å³å¯ã€‚è®¾ \\(f[i][j]\\) è¡¨ç¤ºä»å·¦ä¸‹è§’å¼€å§‹åˆ° \\((i, j)\\) çš„æœ€é•¿åé“¾ã€‚ 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 1007int a[N][N];ll f[N][N];inline void work() &#123; int n = rd(), m = rd(); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) &#123;f[i][j] = 0; a[i][j] = rd();&#125; for (int i = n; i; --i) for (int j = 1; j &lt;= m; ++j) f[i][j] = max(&#123;f[i + 1][j], f[i][j - 1], f[i + 1][j - 1] + a[i][j]&#125;); printf(&quot;%lld\\n&quot;, f[1][m]);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; Gym 102565 - Artifact ç»™ä¸€å¼ æœ‰å‘å›¾ \\((|V|\\le 3000, |E|\\le 20000)\\) ï¼Œé—®æœ€å¤šé€‰å‡ºå¤šå°‘ä¸ªç‚¹ä¸¤ä¸¤ä¸å¯è¾¾ã€‚ å¯è¾¾å…³ç³» \\(iRj=\\) å¯ä»¥ä» \\(i\\) èµ°åˆ° \\(j\\) ï¼Œå‘ç°å¹¶ä¸æ»¡è¶³åè‡ªåæ€§ï¼Œä½† SCC ç¼©ç‚¹ä¹‹åæ˜¯ä¸€ä¸ªDAG \\((V&#39;,E&#39;)\\)ï¼Œæ»¡è¶³è¦æ±‚ã€‚ å› æ­¤æ±‚æœ€å¤šçš„ç‚¹æ•°æ»¡è¶³ä¸¤ä¸¤ä¸å¯è¾¾ï¼Œå³ä¸¤ä¸¤ä¸å…·æœ‰ \\(R\\) å…³ç³»ï¼Œå› æ­¤æ‰€æ±‚å³ä¸º \\((V&#39;,R)\\) çš„æœ€é•¿åé“¾ã€‚ ç”± Dilworth å®šç†æ±‚ååºå…³ç³» \\(R\\) çš„æœ€å°é“¾è¦†ç›– ( æ³¨æ„æ˜¯åŸå›¾çš„æœ€å°å¯é‡é“¾è¦†ç›– )ï¼Œæˆ‘ä»¬æœ‰ä¸€ç§é€šç”¨çš„åšæ³•ï¼š å¯¹äºååºå…³ç³» \\(R\\) ï¼Œç”¨å›¾ç»“æ„è¡¨ç¤ºä¸€å®šæ˜¯ DAGï¼Œä¸”ç”±ä¼ é€’æ€§ä»»æ„å¯è¾¾çš„ä¸¤ç‚¹ä¹‹é—´è·ç¦»ä¸€å®šä¸º \\(1\\) ï¼› å› æ­¤å¯¹äºæœ¬é¢˜ä¸­çš„åŸå›¾ï¼Œéœ€ç”¨ä¼ é€’é—­åŒ…æ±‚å‡º \\(R\\) ï¼Œå¾—åˆ°ååºå…³ç³»çš„å›¾è¡¨ç¤ºï¼› æ­¤æ—¶ç›¸å½“äºæ±‚æ–°å›¾çš„æœ€å°ä¸å¯é‡è·¯å¾„è¦†ç›–ï¼Œå³é€‰æœ€å°‘çš„ä¸é‡è·¯å¾„ä½¿å¾—æ¯ä¸ªé¡¶ç‚¹æ°å¥½åœ¨ä¸€æ¡è·¯å¾„ä¸­ï¼› å°†æ¯ä¸ªç‚¹æ‹†æˆå…¥ç‚¹å’Œå‡ºç‚¹å»ºç«‹äºŒåˆ†å›¾ï¼Œå¯¹äºå…³ç³»ä¸­å­˜åœ¨çš„ \\(xRy\\ (x\\ne y)\\) è¿è¾¹ï¼š\\((x_{å‡º},y_{å…¥})\\) ã€‚ æ±‚æœ€å¤§åŒ¹é…ï¼Œè¯æ˜ä¼˜åŒ–ç›®æ ‡çš„ä¸€è‡´æ€§ï¼šå‡è®¾å¼€å§‹çš„æ—¶å€™æ¯ä¸ªç‚¹å•ç‹¬æˆé“¾ï¼Œä¸€æ¬¡åŒ¹é…ç›¸å½“äºå°†ä¸¤ä¸ªé“¾è¿æ¥èµ·æ¥ã€‚ æ‰€ä»¥ç»“è®ºä¸ºæœ€å°é“¾è¦†ç›– = åŸå›¾é¡¶ç‚¹æ•° \\(-\\) æ„é€ çš„äºŒåˆ†å›¾æœ€å¤§åŒ¹é…ã€‚ æ­¤é¢˜ç›´æ¥ floyd ä¼ é€’é—­åŒ…å¤ªæ…¢ï¼ŒDAG ä¼ é€’é—­åŒ…å¯ä»¥ç”¨æ‹“æ‰‘æ’åºæ›´æ–°ï¼Œå†ç”¨ bitset åŠ é€Ÿå¤æ‚åº¦ä¸º \\(O(\\frac{nm}{\\omega})\\) ã€‚ åŒ¹é…åŠ é€Ÿå¯ä»¥è€ƒè™‘ä½¿ç”¨ Hopcroft-Karp æˆ– Dinicï¼Œæ€»å¤æ‚åº¦ä¸º \\(O(m(\\frac{n}{\\omega}+\\sqrt n))\\) ã€‚ä¸€é“ç±»ä¼¼çš„é¢˜ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;inline bool getmin(int &amp;a, int b) &#123;return (a &gt; b ? (a = b, true) : false);&#125;inline bool getmax(int &amp;a, int b) &#123;return (a &lt; b ? (a = b, true) : false);&#125;#define fr first#define sc second#define pb push_back#define mp make_pair#define mt make_tuple#define pii pair&lt;int, int&gt;#define tiii tuple&lt;long, long, long&gt;#define all(s) (s).begin(), (s).end()#define lowbit(x) ((x) &amp; -(x))#define rep(i, x, y) for (int (i) = (x); (i) &lt;= (y); ++(i))#define per(i, x, y) for (int (i) = (x); (i) &gt;= (y); --(i))#define N 3007namespace SCC &#123; bool vis[N]; int scc, bl[N]; vector&lt;int&gt; e[N], re[N], nodes[N], order; void add(int u, int v) &#123;e[u].push_back(v); re[v].push_back(u);&#125; void dfs1(int u) &#123; vis[u] = 1; for (auto v : e[u]) if (!vis[v]) dfs1(v); order.push_back(u); &#125; void dfs2(int u) &#123; nodes[bl[u] = scc].push_back(u); for (auto v : re[u]) if (!bl[v]) dfs2(v); &#125; void kosaraju(int n) &#123; for (int u = 1; u &lt;= n; ++u) if (!vis[u]) dfs1(u); reverse(order.begin(), order.end()); for (auto u : order) if (!bl[u]) &#123;++scc; dfs2(u);&#125; &#125; int indeg[N], outdeg[N]; vector&lt;int&gt; source, sink; unordered_map&lt;ll, bool&gt; valid; inline bool has_edge(int u, int v) &#123; ll w = 1000000000ll * u + v; return valid[w] ? true : (valid[w] = true, 0); &#125; inline void shrink(int n) &#123; valid.clear(); for (int u = 1; u &lt;= n; ++u) e[u].clear(); for (int v = 1; v &lt;= n; ++v) for (auto u : re[v]) if (bl[u] != bl[v] &amp;&amp; !has_edge(bl[u], bl[v])) &#123; ++indeg[bl[v]]; ++outdeg[bl[u]]; e[bl[u]].push_back(bl[v]); &#125; for (int u = 1; u &lt;= scc; ++u) if (!indeg[u]) source.push_back(u); for (int u = 1; u &lt;= scc; ++u) if (!outdeg[u]) sink.push_back(u); for (int u = 1; u &lt;= n; ++u) re[u].clear(); for (int u = 1; u &lt;= scc; ++u) for (auto v : e[u]) re[v].push_back(u); &#125;&#125;namespace Hopcroft_Karp &#123; const int inf = 1000000000; bool vis[N]; vector&lt;int&gt; e[N]; int nl, nr, ml[N], mr[N], dl[N], dr[N]; // m for match, d for distance inline bool bfs() &#123; static int q[N], hd, tl; hd = 1; tl = 0; memset(dl, -1, sizeof(int) * (nl + 1)); memset(dr, -1, sizeof(int) * (nr + 1)); for (int i = 1; i &lt;= nl; ++i) if (!ml[i]) &#123;dl[i] = 0; q[++tl] = i;&#125; int dT = inf; while (hd &lt;= tl) &#123; int u = q[hd++]; if (dl[u] &gt;= dT) break; for (auto v : e[u]) if (dr[v] == -1) &#123; dr[v] = dl[u] + 1; if (!mr[v]) getmin(dT, dr[v] + 1); else &#123;dl[mr[v]] = dr[v] + 1; q[++tl] = mr[v];&#125; &#125; &#125; return dT != inf; &#125; bool dfs(int u) &#123; for (auto v : e[u]) &#123; if (vis[v] || dl[u] + 1 != dr[v]) continue; vis[v] = true; if (!mr[v] || dfs(mr[v])) &#123;mr[v] = u; ml[u] = v; return true;&#125; &#125; return false; &#125; inline void add(int u, int v) &#123;e[u].push_back(v);&#125; inline int max_matching() &#123; int ans = 0; while(bfs()) &#123; memset(vis, 0, sizeof(bool) * (nr + 1)); for (int i = 1; i &lt;= nl; ++i) if (!ml[i]) ans += dfs(i); &#125; return ans; &#125;&#125;bitset&lt;N&gt; edg[N];int main() &#123; int n = rd(), m = rd(); for (int i = 1; i &lt;= m; ++i) &#123; int u = rd(), v = rd(); SCC::add(u, v); &#125; SCC::kosaraju(n); SCC::shrink(n); n = SCC::scc; // Transitive Closure for (int i = n; i; --i) &#123; edg[i][i] = true; for (auto v : SCC::e[i]) edg[i] |= edg[v]; for (int j = i + 1; j &lt;= n; ++j) if (edg[i][j]) Hopcroft_Karp::add(i, j); &#125; Hopcroft_Karp::nl = Hopcroft_Karp::nr = n; printf(&quot;%d\\n&quot;, n - Hopcroft_Karp::max_matching()); return 0;&#125; CTSC 2008 - ç¥­ç¥€ ç»™ä¸€ä¸ª DAG ï¼Œé—®ï¼š(1) æœ€å¤šé€‰å‡ºå¤šå°‘ä¸ªç‚¹ä¸¤ä¸¤ä¸å¯è¾¾ï¼›(2) è¾“å‡ºä¸€ç§æ–¹æ¡ˆï¼›(3) è¾“å‡ºæ¯ä¸ªç‚¹æ˜¯å¦å¯ä»¥åœ¨æŸä¸ªæ–¹æ¡ˆä¸­å‡ºç°ã€‚ DAG ç›´æ¥bitsetæš´åŠ›ä¼ é€’é—­åŒ…å¤æ‚åº¦ \\(\\mathcal{O}(\\frac{n^3}{64})=\\mathcal{O}(\\frac{nm}{64})\\)ï¼Œç”¨ Hopcraft-Karp å¤æ‚åº¦ \\(\\mathcal{O}(m\\sqrt n)=\\mathcal{O}(n^{2.5})\\)ã€‚ æ±‚å‡ºæœ€é•¿åé“¾ï¼šæŒ‰ç…§ Konig å®šç†æ„é€ æœ€å°ç‚¹è¦†ç›–çš„æ—¶å€™å¤æ‚åº¦æ˜¯ \\(\\mathcal{O}(m)\\) çš„ï¼Œå› ä¸ºä¸€ä¸ªå³ä¾§ç‚¹è¢«æ‰“è¿‡æ ‡è®°ä¹‹åï¼Œå†ç»è¿‡ä»–å°±ä¸ç”¨ç®¡äº†ã€‚å…ˆæ‰¾å‡ºæ¥ä¸€ä¸ªæœ€å°ç‚¹è¦†ç›–ï¼Œç„¶åå¯¹äºæ‹†çš„ç‚¹éƒ½ä¸åœ¨æœ€å°ç‚¹è¦†ç›–é‡Œçš„ï¼ŒåŠ å…¥æœ€é•¿åé“¾ã€‚ä¸€ä¸ªè¯æ˜ æšä¸¾æ¯ä¸ªç‚¹ï¼Œå‡è®¾å¿…é€‰ä»–ï¼Œé‚£ä¹ˆä¸ä»–æœ‰ååºå…³ç³»çš„æ‰€æœ‰ç‚¹éƒ½ä¸å¯ä»¥é€‰ï¼Œåˆ æ‰è¿™äº›ä¹‹åæ±‚ä¸€ä¸‹æœ€é•¿åé“¾ï¼Œçœ‹ä¸€ä¸‹é•¿åº¦æ˜¯å¦æ˜¯åŸç­”æ¡ˆ \\(-1\\) å³å¯ã€‚ æ€»å¤æ‚åº¦ \\(\\mathcal{O}(\\frac{n^3}{64} + n^2 + n\\times n^{2.5})=\\mathcal{O}(n^{3.5})\\) ï¼Œå¯¹äº \\(n=100\\) å¯è¿‡ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;inline bool getmin(int &amp;a, int b) &#123;return (a &gt; b ? (a = b, true) : false);&#125;inline bool getmax(int &amp;a, int b) &#123;return (a &lt; b ? (a = b, true) : false);&#125;template &lt;const int V, const int inf = 1000000000&gt;struct Hopcroft_Karp &#123; bool vis[V]; vector&lt;int&gt; e[V]; int nl, nr, ml[V], mr[V], dl[V], dr[V]; // m for match, d for distance void clear() &#123; for (int i = 1; i &lt;= nl; ++i) &#123;ml[i] = 0; e[i].clear();&#125; for (int i = 1; i &lt;= nr; ++i) &#123;mr[i] = 0; vis[i] = false;&#125; &#125; inline bool bfs() &#123; static int q[V], hd, tl; hd = 1; tl = 0; memset(dl, -1, sizeof(int) * (nl + 1)); memset(dr, -1, sizeof(int) * (nr + 1)); for (int i = 1; i &lt;= nl; ++i) if (!ml[i]) &#123;dl[i] = 0; q[++tl] = i;&#125; int dT = inf; while (hd &lt;= tl) &#123; int u = q[hd++]; if (dl[u] &gt;= dT) break; for (auto v : e[u]) if (dr[v] == -1) &#123; dr[v] = dl[u] + 1; if (!mr[v]) getmin(dT, dr[v] + 1); else &#123;dl[mr[v]] = dr[v] + 1; q[++tl] = mr[v];&#125; &#125; &#125; return dT != inf; &#125; bool dfs(int u) &#123; for (auto v : e[u]) &#123; if (vis[v] || dl[u] + 1 != dr[v]) continue; vis[v] = true; if (!mr[v] || dfs(mr[v])) &#123;mr[v] = u; ml[u] = v; return true;&#125; &#125; return false; &#125; inline void add(int u, int v) &#123;e[u].push_back(v);&#125; inline int max_matching() &#123; int ans = 0; while(bfs()) &#123; memset(vis, 0, sizeof(bool) * (nr + 1)); for (int i = 1; i &lt;= nl; ++i) if (!ml[i]) ans += dfs(i); &#125; return ans; &#125; bool visl[V], visr[V], anti[V]; void addtag(int u) &#123; visl[u] = true; for (auto v : e[u]) &#123; if (visr[v]) continue; visr[v] = true; addtag(mr[v]); &#125; &#125; inline void Antichain() &#123; for (int i = 1; i &lt;= nl; ++i) if (!ml[i]) addtag(i); // visl[i] = false or visr[i] = true : vertex cover // visl[i] = true or visr[i] = false : independent set for (int i = 1; i &lt;= nl; ++i) if (visl[i] &amp;&amp; !visr[i]) anti[i] = true; &#125;&#125;;#define N 101bool tag[N];Hopcroft_Karp&lt;N&gt; f;bitset&lt;N&gt; adj[N];int main() &#123; int n = rd(), m = rd(); for (int i = 1, u, v; i &lt;= m; ++i) &#123; u = rd(); v = rd(); adj[u][v] = true; &#125; for (int k = 1; k &lt;= n; ++k) for (int u = 1; u &lt;= n; ++u) if (adj[u][k]) adj[u] |= adj[k]; f.nl = f.nr = n; for (int u = 1; u &lt;= n; ++u) for (int v = 1; v &lt;= n; ++v) if (adj[u][v]) f.add(u, v); int ans = n - f.max_matching(); printf(&quot;%d\\n&quot;, ans); f.Antichain(); for (int i = 1; i &lt;= n; ++i) putchar(&#x27;0&#x27; + f.anti[i]); puts(&quot;&quot;); for (int i = 1; i &lt;= n; ++i) &#123; f.clear(); int tot = n; memset(tag, 0, sizeof(tag)); tag[i] = true; --tot; for (int u = 1; u &lt;= n; ++u) if (adj[u][i] || adj[i][u]) &#123;tag[u] = true; --tot;&#125; for (int u = 1; u &lt;= n; ++u) for (int v = 1; v &lt;= n; ++v) if (adj[u][v] &amp;&amp; !tag[u] &amp;&amp; !tag[v]) f.add(u, v); if (tot - f.max_matching() == ans - 1) putchar(&#x27;1&#x27;); else putchar(&#x27;0&#x27;); &#125; return 0;&#125; ä¸€äº›ç»“åˆå…¶ä»–å¥—è·¯çš„é¢˜ç›®ï¼š SPOJ - DIVREL | ABC237Ex - hakata | CF590E - Birthday.","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://blog.gyx.me/categories/Algorithms/"}],"tags":[{"name":"Graphs","slug":"Graphs","permalink":"http://blog.gyx.me/tags/Graphs/"}]},{"title":"Matrix Multiplication","slug":"algorithms/matrix-multiplication","date":"2022-09-10T11:21:52.000Z","updated":"2023-03-20T16:50:11.924Z","comments":true,"path":"algorithms/matrix-multiplication/","link":"","permalink":"http://blog.gyx.me/algorithms/matrix-multiplication/","excerpt":"","text":"é€’æ¨æ•°åˆ— è·¯å¾„è®¡æ•° ç»™å®šä¸€å¼ å›¾ï¼Œå¤„ç†å½¢å¦‚ â€œä» \\(u\\) åˆ° \\(v\\) æ°å¥½ç»è¿‡ \\(k\\) æ¡è¾¹çš„è·¯å¾„æ¡æ•°â€ çš„è®¡æ•°é—®é¢˜ã€‚ è®¾ \\(f[u][v][k]\\) è¡¨ç¤ºä» \\(u\\) åˆ° \\(v\\) æ°å¥½ç»è¿‡ \\(k\\) æ¡è¾¹çš„è·¯å¾„æ¡æ•°ï¼Œè®¾ \\(e[u][v]=1\\) è¡¨ç¤ºå­˜åœ¨ä¸€æ¡ä» \\(u\\) åˆ° \\(v\\) çš„è¾¹ï¼Œæœ‰è½¬ç§» \\[ f[u][v][k] = \\sum_{1\\le w\\le n} f[u][w][k-1]\\cdot e[w][v] \\] è¿™æ˜¯ä¸€ä¸ªå…¸å‹çš„çŸ©é˜µä¹˜æ³•ï¼Œè®¾ \\(F[k]\\) è¡¨ç¤º \\(k\\) æ­¥çš„ \\(f\\) æ•°ç»„ï¼Œæœ‰ \\(F[k]=E^k (k\\ge 0)\\) ã€‚ å¹¿ä¹‰çŸ©é˜µä¹˜æ³• ä½¿ç”¨çŸ©é˜µä¹˜æ³•æ¥ç»´æŠ¤çš„è¦æ±‚æœ‰ä¸¤ä¸ªï¼š è¿ç®—ç»“æœæ»¡è¶³å¯¹åº”ä»£æ•°è¡¨è¾¾å¼ï¼› æ»¡è¶³ç»“åˆå¾‹ï¼ˆç”¨äºå¿«é€Ÿå¹‚åŠ é€Ÿï¼‰ã€‚ æ¯”è¾ƒä¸¥è°¨çš„ç»“è®ºæ˜¯ï¼šçŸ©é˜µä¹˜æ³•å¯ä»¥å¤„ç†çš„ä»£æ•°ç»“æ„ä¸ºåŠç¯ \\((A,+,\\cdot)\\) ï¼Œå³æ»¡è¶³ï¼š \\((A,+)\\) ä¸ºå¸¦æœ‰å•ä½å…ƒ \\(0\\) çš„äº¤æ¢å¹ºåŠç¾¤ï¼ˆå•ä½å…ƒï¼Œç»“åˆå¾‹ï¼Œäº¤æ¢å¾‹ï¼‰ï¼› \\((A,\\cdot\\ )\\) ä¸ºå¸¦æœ‰å•ä½å…ƒ \\(1\\) çš„å¹ºåŠç¾¤ï¼ˆå•ä½å…ƒï¼Œç»“åˆå¾‹ï¼‰ï¼› ä¹˜æ³•å¯¹åŠ æ³•åŒæ—¶æœ‰å·¦ã€å³åˆ†é…å¾‹ï¼› åŠ æ³•å•ä½å…ƒ \\(0\\) æŠµæ¶ˆä¹˜æ³•ã€‚ In general, if the addition and multiplication satisfies the axioms of semi-ring, then the associativity of multiplication of matrices holds, enabling us to optimize DP with the matrix exponentiation like described above. A semi-ring is a set \\(A\\) equipped with two binary operations, addition \\(+\\) and multiplication \\(\\cdot\\) , such that all the following properties is satisfied: \\((A,+)\\) is an commutative monoid; i.e. it satisfies the following three conditions: The associativity of \\(+\\) holds. That is, for any \\(a, b, c \\in A\\), it holds that \\((a+b)+c=a+(b+c)\\). There exists an identity 0 of \\(+\\). That is, there exists \\(0 \\in A\\) such that \\(a+0=0+a=a\\). The commutativity of \\(+\\) holds. That is, for any \\(a, b \\in A\\), it holds that \\(a+b=b+a\\). \\((A, \\cdot)\\) is a monoid; i.e. it satisfies the following two conditions: The associativity of \\(\\cdot\\) holds. That is, for any \\(a,b,c\\in A\\), it holds that \\((a \\cdot b) \\cdot c=a \\cdot(b \\cdot c)\\) . There exists an identity 1 of \\(\\cdot\\). That is, there exists \\(1 \\in A\\) such that \\(a \\cdot 1=1 \\cdot a=a\\). \\(+\\) and \\(\\cdot\\) satisfies the following distributive property holds: For any \\(a, b, c \\in A\\), it holds that \\(a \\cdot(b+c)=a \\cdot b+a \\cdot c\\) . For any \\(a, b, c \\in A\\), it holds that \\((a+b) \\cdot c=a \\cdot c+b \\cdot c\\) . For all \\(a \\in A\\), it holds that \\(0 \\cdot a=a \\cdot 0=0\\). ä¸€äº›ä¾‹å­ æ³¨æ„ï¼Œä½¿ç”¨å¹¿ä¹‰çŸ©é˜µä¹˜æ³•æ—¶ï¼Œåˆå§‹çŸ©é˜µå’Œå•ä½çŸ©é˜µå¯¹åº”çš„ \\(0\\) å’Œ \\(1\\) è‡ªç„¶çš„åº”å½“ä½¿ç”¨å¹¿ä¹‰çš„ \\(0\\) å’Œ \\(1\\) ã€‚ ID \\(A\\) \\(+\\) \\(0\\) \\(\\cdot\\) \\(1\\) 1 \\(\\mathbb{R}\\) \\(\\min\\) \\(+\\infty\\) \\(\\max\\) \\(-\\infty\\) 2 \\(\\mathbb{R}\\) \\(\\max\\) \\(-\\infty\\) \\(\\min\\) \\(+\\infty\\) 3 \\(\\mathbb{R}\\cup \\{-\\infty \\}\\) \\(\\max\\) \\(-\\infty\\) ordinary addition \\(+\\) \\(0\\) 4 \\(\\mathbb{R}\\cup \\{+\\infty \\}\\) \\(\\min\\) \\(+\\infty\\) ordinary addition \\(+\\) \\(0\\) 5 \\(\\forall n\\in \\mathbb{N^+},\\ [0,2^n)\\cap \\mathbb{N}\\) bitwise OR \\(0\\) bitwise AND \\(2^n-1\\) 6 \\(\\forall n\\in \\mathbb{N^+},\\ [0,2^n)\\cap \\mathbb{N}\\) bitwise AND \\(2^n-1\\) bitwise OR \\(0\\) 7 \\(\\forall n\\in \\mathbb{N^+},\\ [0,2^n)\\cap \\mathbb{N}\\) bitwise XOR \\(0\\) bitwise AND \\(2^n-1\\) ABC 236 G - Good Vertices æœ‰ä¸€å¼ æ— å‘å›¾ï¼Œå¼€å§‹æ²¡æœ‰è¾¹ï¼Œç¬¬ \\(1\\sim m\\) ç§’æ¯ç§’åŠ ä¸€æ¡è¾¹ \\(u_i,v_i\\) ã€‚ è¯¢é—®æ¯ä¸ªç‚¹ \\(u\\) ï¼Œè¯¢é—®æœ€æ—©çš„æ—¶åˆ»ï¼Œå›¾ä¸­å­˜åœ¨ä¸€æ¡é•¿åº¦æ°å¥½ä¸º \\(l\\) çš„ä» \\(1\\) åˆ° \\(u\\) çš„è·¯å¾„ã€‚ å°†è¾¹åŠ å…¥çš„æ—¶é—´è®¾ä¸ºè¾¹æƒï¼Œå³ \\(e[u_i][v_i]=i\\) ï¼Œé—®é¢˜æ”¹ä¸ºé•¿åº¦ä¸º \\(l\\) çš„è·¯å¾„ä¸Šæœ€å¤§è¾¹æƒæœ€å°æ˜¯å¤šå°‘ã€‚ è®¾ \\(f[u][v][k]\\) è¡¨ç¤ºæ°å¥½ç»è¿‡ \\(k\\) æ¡è¾¹ä» \\(u\\) åˆ° \\(v\\) ï¼Œè·¯å¾„ä¸Šçš„æœ€å¤§è¾¹æƒæœ€å°å€¼ã€‚ æšä¸¾ç¬¬ \\(k-1\\) æ­¥ï¼ˆå³ \\(v\\) å‰ä¸€ä¸ªï¼‰èµ°åˆ°çš„ç‚¹ \\(w\\) ï¼Œè½¬ç§»æ–¹ç¨‹ä¸ºï¼š\\(f[u][v][k] = \\min_{1\\le w\\le n} \\big\\{ \\max (f[u][w][k-1], e[w][v])\\big\\}\\) åªçœ‹ä¸€æ­¥è½¬ç§»ï¼Œå‘ç°è¿™æ˜¯ä¸€ä¸ªåŠ æ³•ä¸º \\(\\min\\) ï¼Œä¹˜æ³•ä¸º \\(\\max\\) çš„çŸ©é˜µä¹˜æ³•ï¼Œæ£€éªŒï¼š åŠ æ³• \\(\\min\\) çš„å•ä½å…ƒä¸º \\(+\\infty\\) ï¼Œæ»¡è¶³ç»“åˆå¾‹äº¤æ¢å¾‹ï¼› ä¹˜æ³• \\(\\max\\) çš„å•ä½å…ƒä¸º \\(-\\infty\\) ï¼Œæ»¡è¶³ç»“åˆå¾‹ï¼› å·¦åˆ†é…å¾‹ï¼š\\(\\max(a,\\min(b,c)) = \\min(\\max(a,b),\\max(a,c))\\) ï¼Œç”±äº \\(\\max\\) æœ‰äº¤æ¢å¾‹æ‰€ä»¥å³åˆ†é…å¾‹è‡ªç„¶æˆç«‹ï¼› åŠ æ³•å•ä½å…ƒæŠµæ¶ˆä¹˜æ³•ï¼š \\(\\max(+\\infty, x) = +\\infty\\) æ‰€ä»¥å¯ä»¥ç”¨çŸ©é˜µç»´æŠ¤ï¼Œå¯¹é‚»æ¥çŸ©é˜µåšæ­¤æ—¶çš„çŸ©é˜µå¿«é€Ÿå¹‚å³å¯ï¼Œå½“ç„¶è¿™ä¸ªé—®é¢˜å¯ä»¥è¯¢é—®æœ‰å‘å›¾ä»¥åŠä»»æ„ç‚¹å¯¹ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 101int n, m, l;inline int min(const int &amp;a, const int &amp;b) &#123;return a &lt; b ? a : b;&#125;inline int max(const int &amp;a, const int &amp;b) &#123;return a &lt; b ? b : a;&#125;struct matrix &#123; int a[N][N]; matrix(bool id = 0) &#123; memset(a, 0x3f, sizeof(a)); if (id) for (int i = 0; i &lt; N; ++i) a[i][i] = -1e9; &#125; inline matrix operator * (const matrix &amp;obj) const &#123; matrix res; for (int k = 1; k &lt;= n; ++k) for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) res.a[i][j] = min(res.a[i][j], max(a[i][k], obj.a[k][j])); return res; &#125; inline matrix fpow(int t) const &#123; matrix res(1), x = *this; for (; t; t &gt;&gt;= 1, x = x * x) if (t &amp; 1) res = res * x; return res; &#125;&#125; A, res;int main() &#123; n = rd(); m = rd(); l = rd(); for (int i = 1; i &lt;= m; ++i) &#123; int u = rd(), v = rd(); A.a[u][v] = min(A.a[u][v], i); &#125; res = A.fpow(l); for (int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, res.a[1][i] &gt; m ? -1 : res.a[1][i]); return 0;&#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://blog.gyx.me/categories/Algorithms/"}],"tags":[{"name":"Algebra","slug":"Algebra","permalink":"http://blog.gyx.me/tags/Algebra/"},{"name":"Matrix Theory","slug":"Matrix-Theory","permalink":"http://blog.gyx.me/tags/Matrix-Theory/"}]},{"title":"DSU on Tree","slug":"algorithms/dsu-on-tree","date":"2022-08-31T00:13:35.000Z","updated":"2023-03-20T16:50:07.012Z","comments":true,"path":"algorithms/dsu-on-tree/","link":"","permalink":"http://blog.gyx.me/algorithms/dsu-on-tree/","excerpt":"","text":"Analysis DSU on Tree åœ¨ä¸€äº›æ¯”è¾ƒç®€å•çš„å­æ ‘é—®é¢˜æ—¶å¯ä»¥æ›¿ä»£ç‚¹åˆ†æ²»ï¼Œå¤æ‚åº¦ä¹Ÿæ˜¯ \\(\\mathcal O(n\\log n)\\) ã€‚ æŒ‰å­æ ‘ size è½»é‡é“¾å‰–åˆ†ï¼Œç„¶åä½¿ç”¨æŸä¸ªæ•°æ®ç»“æ„ç»Ÿè®¡æ¯ä¸ªç‚¹çš„å­æ ‘ä¿¡æ¯ï¼š å…ˆè®©è½»å„¿å­ç»Ÿè®¡å­æ ‘ä¿¡æ¯ï¼Œå¹¶æ’¤é”€å¯¹æ•°æ®ç»“æ„çš„å½±å“ï¼› å¦‚æœæœ‰é‡å„¿å­ï¼Œç»Ÿè®¡é‡å„¿å­å­æ ‘ä¿¡æ¯ï¼Œä¿ç•™å¯¹æ•°æ®ç»“æ„çš„å½±å“ï¼ˆä¸æ’¤é”€ï¼‰ï¼› å‘æ•°æ®ç»“æ„ä¸­æ·»åŠ è½»å„¿å­å­æ ‘ä¿¡æ¯å’Œå½“å‰ç‚¹ä¿¡æ¯ï¼Œç»Ÿè®¡å½“å‰ç‚¹ä¿¡æ¯ã€‚ å¤æ‚åº¦åˆ†æï¼šæ¯ä¸ªç‚¹åªä¼šåœ¨åˆ°æ ¹è·¯å¾„ä¸Šé‡åˆ°è½»è¾¹æ—¶è¢«æ·»åŠ  /æ’¤é”€ï¼Œç”±è½»é‡è¿å‰–åˆ†æ¯ä¸ªç‚¹åˆ°æ ¹çš„è·¯å¾„ä¸Šè‡³å¤š \\(\\log n\\) æ¡è½»è¾¹ã€‚æ‰€ä»¥æ€»å¤æ‚åº¦æ˜¯ \\(\\mathcal O(n \\log n)\\) ï¼Œç”±äºæ˜æ˜¾è·‘ä¸æ»¡æ‰€ä»¥å¸¸æ•°ä¼šå¾ˆå°ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 100007#define pb push_backint sz[N], mxs[N];vector&lt;int&gt; e[N];void dfs(int u, int fa) &#123; sz[u] = 1; for (auto v : e[u]) if (v != fa) &#123; dfs(v, u); sz[u] += sz[v]; if (sz[v] &gt; sz[mxs[u]]) mxs[u] = v; &#125;&#125;inline void upd(int u) &#123; // adding information of u into data structures&#125;inline void del(int u) &#123; // deleting information of u from data structures&#125;void upd(int u, int fa) &#123; upd(u); for (auto v : e[u]) if (v != fa) upd(v, u);&#125;void del(int u, int fa) &#123; del(u); for (auto v : e[u]) if (v != fa) del(v, u);&#125;void dsu(int u, int fa) &#123; for (auto v : e[u]) if (v != fa &amp;&amp; v != mxs[u]) &#123;dsu(v, u); del(v, u);&#125; if (mxs[u]) dsu(mxs[u], u); for (auto v : e[u]) if (v != fa &amp;&amp; v != mxs[u]) upd(v, u); upd(u); &#125;int main() &#123; int n = rd(); for (int i = 1; i &lt; n; ++i) &#123; int u = rd(), v = rd(); e[u].pb(v); e[v].pb(u); &#125; dfs(1, 1); dsu(1, 1); return 0;&#125; CF 600 E. Lomsat gelral ä¸€æ£µæ ‘æ¯ä¸ªç‚¹æœ‰ä¸€ä¸ªé¢œè‰² \\(c_i\\) ï¼Œæ±‚æ¯ä¸ªç‚¹å­æ ‘å†…å‡ºç°æ¬¡æ•°æœ€å¤šçš„é¢œè‰²çš„å’Œã€‚ å¯¹é¢œè‰²ç»´æŠ¤ cnt æ•°ç»„ï¼Œç”±äº DSU ç»Ÿè®¡æ—¶åªæœ‰åŠ æ³•ï¼Œå› æ­¤å¯ä»¥è®°å½•å‡ºç°æœ€å¤šçš„æ¬¡æ•° mx å’Œæœ€å¤šæ¬¡æ•°çš„é¢œè‰²çš„å’Œ res ã€‚ æ¯æ¬¡ ++cnt[col[u]] çš„æ—¶å€™è®¨è®ºä¸€ä¸‹å’Œ mx çš„å…³ç³»æ›´æ–°å³å¯ï¼ˆè§ upd å‡½æ•°ï¼‰ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 100007#define pb push_backll ans[N], res;int cnt[N], col[N], mx;int sz[N], mxs[N];vector&lt;int&gt; e[N];void dfs(int u, int fa) &#123; sz[u] = 1; for (auto v : e[u]) if (v != fa) &#123; dfs(v, u); sz[u] += sz[v]; if (sz[v] &gt; sz[mxs[u]]) mxs[u] = v; &#125;&#125;inline void upd(int u) &#123; // adding information of u into data structures ++cnt[col[u]]; if (cnt[col[u]] &gt; mx) &#123;mx = cnt[col[u]]; res = col[u];&#125; else if (cnt[col[u]] == mx) res += col[u];&#125;inline void del(int u) &#123; // deleting information of u from data structures mx = 0; res = 0; cnt[col[u]] = 0;&#125;void upd(int u, int fa) &#123; upd(u); for (auto v : e[u]) if (v != fa) upd(v, u);&#125;void del(int u, int fa) &#123; del(u); for (auto v : e[u]) if (v != fa) del(v, u);&#125;void dsu(int u, int fa) &#123; for (auto v : e[u]) if (v != fa &amp;&amp; v != mxs[u]) &#123;dsu(v, u); del(v, u);&#125; if (mxs[u]) dsu(mxs[u], u); for (auto v : e[u]) if (v != fa &amp;&amp; v != mxs[u]) upd(v, u); upd(u); ans[u] = res;&#125;int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) col[i] = rd(); for (int i = 1; i &lt; n; ++i) &#123; int u = rd(), v = rd(); e[u].pb(v); e[v].pb(u); &#125; dfs(1, 1); dsu(1, 1); for (int i = 1; i &lt;= n; ++i) printf(&quot;%lld &quot;, ans[i]); return 0;&#125; CF 1009 F. Dominant Indices ç»™ä¸€æ£µæ ‘ï¼Œå¯¹äºæ¯ä¸€ä¸ªç‚¹æ±‚æœ€å°çš„ \\(k\\) ï¼Œä½¿å¾—å­æ ‘å†…åˆ°ä»–è·ç¦»ä¸º \\(k\\) çš„ç‚¹æœ€å¤šã€‚ åšæ³•å’Œä¸Šä¸€é¢˜å®Œå…¨ç›¸åŒï¼Œæ¯æ¬¡æ›´æ–°çš„æ—¶å€™è®¨è®ºï¼Œè¶…è¿‡äº† mx ç›´æ¥è¦†ç›– res ï¼Œç­‰äº mx å’Œ res å– \\(\\min\\) ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;#define pic pair&lt;int, char&gt;#define lowbit(x) ((x) &amp; -(x))#define N 1000007int cnt[N], ans[N], mx, res;int sz[N], mxs[N], dep[N];vector&lt;int&gt; e[N];void dfs(int u, int fa) &#123; sz[u] = 1; dep[u] = dep[fa] + 1; for (auto v : e[u]) if (v != fa) &#123; dfs(v, u); sz[u] += sz[v]; if (sz[v] &gt; sz[mxs[u]]) mxs[u] = v; &#125;&#125;inline void upd(int u) &#123; // adding information of u into data structures ++cnt[dep[u]]; if (cnt[dep[u]] &gt; mx) &#123;mx = cnt[dep[u]]; res = dep[u];&#125; else if (cnt[dep[u]] == mx) res = min(res, dep[u]);&#125;inline void del(int u) &#123; // deleting information of u from data structures mx = 0; res = 0; cnt[dep[u]] = 0;&#125;void upd(int u, int fa) &#123; upd(u); for (auto v : e[u]) if (v != fa) upd(v, u);&#125;void del(int u, int fa) &#123; del(u); for (auto v : e[u]) if (v != fa) del(v, u);&#125;void dsu(int u, int fa) &#123; for (auto v : e[u]) if (v != fa &amp;&amp; v != mxs[u]) &#123;dsu(v, u); del(v, u);&#125; if (mxs[u]) dsu(mxs[u], u); for (auto v : e[u]) if (v != fa &amp;&amp; v != mxs[u]) upd(v, u); upd(u); ans[u] = res - dep[u];&#125;int main() &#123; int n = rd(); for (int i = 1; i &lt; n; ++i) &#123; int u = rd(), v = rd(); e[u].pb(v); e[v].pb(u); &#125; dfs(1, 1); dsu(1, 1); for (int i = 1; i &lt;= n; ++i) printf(&quot;%d\\n&quot;, ans[i]); return 0;&#125; CF 208 E. Blood Cousins ç»™ä¸€ä¸ªæ£®æ—ï¼Œ\\(q\\) æ¬¡é—®ä¸ \\(u_i\\) æœ‰å…±åŒçš„ç¬¬ \\(k_i\\) çº§ç¥–å…ˆçš„ç‚¹çš„ä¸ªæ•°ã€‚ è¯¢é—®å…¶å®ä¸ \\(u_i\\) å…³ç³»ä¸å¤§ï¼Œç¦»çº¿åæ˜¯ç»‘å®šåœ¨ \\(u_i\\) çš„ \\(k_i\\) çº§ç¥–å…ˆä¸Šçš„ï¼Œå› æ­¤éœ€è¦å¿«é€Ÿæ±‚ \\(k\\) çº§ç¥–å…ˆã€‚ ç„¶åä½¿ç”¨ DSU æ±‚å‡º dep çš„ cnt æ•°ç»„å³å¯ï¼Œç”±äº DSU æœ¬èº«ä¹Ÿè¦ç”¨åˆ°è½»é‡å‰–åˆ†ï¼Œæ‰€ä»¥æ±‚ç¥–å…ˆå°±ä¹Ÿç”¨æ ‘å‰–å®ç°äº†ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 100007#define fr first#define sc second#define pb push_back#define mp make_pair#define pii pair&lt;int, int&gt;int tot, dfn[N], seq[N], top[N], dep[N], ans[N], cnt[N], fa[N];int sz[N], mxs[N];vector&lt;int&gt; son[N];vector&lt;pii&gt; que[N];void dfs(int u) &#123; sz[u] = 1; for (auto v : son[u]) &#123; dfs(v); sz[u] += sz[v]; if (sz[v] &gt; sz[mxs[u]]) mxs[u] = v; &#125;&#125;void dfs2(int u, int t) &#123; top[u] = t; dfn[u] = ++tot; seq[tot] = u; if (mxs[u]) &#123;dep[mxs[u]] = dep[u] + 1; dfs2(mxs[u], t);&#125; for (auto v : son[u]) if (!dfn[v]) &#123;dep[v] = dep[u] + 1; dfs2(v, v);&#125;&#125;void upd(int u) &#123; ++cnt[dep[u]]; for (auto v : son[u]) upd(v);&#125;void del(int u) &#123; --cnt[dep[u]]; for (auto v : son[u]) del(v);&#125;void dsu(int u) &#123; for (auto v : son[u]) if (v != mxs[u]) &#123;dsu(v); del(v);&#125; if (mxs[u]) dsu(mxs[u]); for (auto v : son[u]) if (v != mxs[u]) upd(v); ++cnt[dep[u]]; for (auto q : que[u]) ans[q.sc] = cnt[dep[u] + q.fr] - 1;&#125;inline int anc(int u, int k) &#123; if (dep[u] &lt; k) return 0; int nw = u; while (dep[u] - dep[top[nw]] &lt; k) nw = fa[top[nw]]; return seq[dfn[nw] - (k - (dep[u] - dep[nw]))];&#125;int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) son[fa[i] = rd()].pb(i); for (auto u : son[0]) dfs(u); for (auto u : son[0]) dfs2(u, u); int q = rd(); for (int i = 1; i &lt;= q; ++i) &#123; int u = rd(), k = rd(); int w = anc(u, k); if (w == 0) continue; que[w].pb(mp(k, i)); &#125; for (auto u : son[0]) &#123;dsu(u); del(u);&#125; for (int i = 1; i &lt;= q; ++i) printf(&quot;%d &quot;, ans[i]); return 0;&#125; å¦ä¸€ç§æ¯”è¾ƒæœ‰æ„æ€çš„åšæ³•ï¼š å…¨éƒ¨ç¦»çº¿ï¼ŒDFS æ—¶ç”¨æ ˆè®°å½•ä»æ ¹åˆ°å½“å‰ç‚¹çš„è·¯å¾„ï¼Œå¾—åˆ° \\(k\\) çº§ç¥–å…ˆï¼Œå¤æ‚åº¦ \\(\\mathcal O(n)\\) ã€‚ å°†è¯¢é—®æŒ‰æ·±åº¦åˆ†ç±»ï¼Œå…ˆå°†è¯¥æ·±åº¦çš„ç‚¹åŠ å…¥æ•°æ®ç»“æ„ï¼Œç„¶åå°±ç›¸å½“äºæ±‚ DFS åºä¸ŠåŒºé—´å’Œã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;#define pic pair&lt;int, char&gt;#define lowbit(x) ((x) &amp; -(x))#define N 100007vector&lt;pii&gt; q[N], que[N];int tot, dfn[N], sz[N], ans[N], stk[N], c[N];vector&lt;int&gt; son[N], cur[N];inline void add(int p, int x) &#123; for (; p &lt; N; p += lowbit(p)) c[p] += x;&#125;inline int sum(int p) &#123; int res = 0; for (; p; p -= lowbit(p)) res += c[p]; return res;&#125;inline int sum(int l, int r) &#123; return sum(r) - sum(l - 1);&#125;void dfs(int u, int dep) &#123; sz[u] = 1; stk[dep] = u; cur[dep].pb(u); dfn[u] = ++tot; for (auto v : son[u]) &#123;dfs(v, dep + 1); sz[u] += sz[v];&#125; for (auto [k, id] : q[u]) if (dep &gt; k) que[dep].pb(mp(stk[dep - k], id));&#125;int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) son[rd()].pb(i); int m = rd(); for (int i = 1; i &lt;= m; ++i) &#123; int u = rd(), k = rd(); q[u].pb(mp(k, i)); &#125; for (auto u : son[0]) dfs(u, 1); for (int i = 1; i &lt;= n; ++i) &#123; for (auto u : cur[i]) add(dfn[u], 1); for (auto [u, id] : que[i]) ans[id] = sum(dfn[u], dfn[u] + sz[u] - 1) - 1; for (auto u : cur[i]) add(dfn[u], -1); &#125; for (int i = 1; i &lt;= m; ++i) printf(&quot;%d &quot;, ans[i]); return 0;&#125; CF 246 E. Blood Cousins Return ä¸€æ£µæ ‘æ¯ä¸ªç‚¹ä¸Šæœ‰ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œå¤šæ¬¡è¯¢é—® \\(u_i\\) å­æ ‘å†…æ·±åº¦ä¸º \\(k\\) çš„ç‚¹å¯¹åº”çš„å­—ç¬¦ä¸²é›†åˆä¸­æœ‰å¤šå°‘ä¸ªä¸åŒçš„ã€‚ è¿˜æ˜¯ä¸Šé¢é‚£ä¸ªé—®é¢˜ï¼Œæ”¹æˆç”¨ä¸€ä¸ª unordered_map æ¥è®¡æ•°æ¯ä¸ªæ·±åº¦çš„å­—ç¬¦ä¸²å³å¯ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 100007#define fr first#define sc second#define pb push_back#define mp make_pair#define pii pair&lt;int, int&gt;int dfn[N], top[N], dep[N], ans[N], tot, seq[N], fa[N];int sz[N], mxs[N];string nam[N];vector&lt;int&gt; son[N];vector&lt;pii&gt; que[N];unordered_map&lt;string, int&gt; cnt[N];void dfs(int u) &#123; sz[u] = 1; for (auto v : son[u]) &#123; dfs(v); sz[u] += sz[v]; if (sz[v] &gt; sz[mxs[u]]) mxs[u] = v; &#125;&#125;void dfs2(int u, int t) &#123; top[u] = t; dfn[u] = ++tot; seq[tot] = u; if (mxs[u]) &#123;dep[mxs[u]] = dep[u] + 1; dfs2(mxs[u], t);&#125; for (auto v : son[u]) if (!dfn[v]) &#123;dep[v] = dep[u] + 1; dfs2(v, v);&#125;&#125;inline void upd(int u) &#123; // adding information of u into data structures ++cnt[dep[u]][nam[u]];&#125;inline void del(int u) &#123; // deleting information of u from data structures --cnt[dep[u]][nam[u]]; if (!cnt[dep[u]][nam[u]]) cnt[dep[u]].erase(nam[u]);&#125;void upd(int u, int fa) &#123; upd(u); for (auto v : son[u]) upd(v, u);&#125;void del(int u, int fa) &#123; del(u); for (auto v : son[u]) del(v, u);&#125;void dsu(int u, int fa) &#123; for (auto v : son[u]) if (v != mxs[u]) &#123;dsu(v, u); del(v, u);&#125; if (mxs[u]) dsu(mxs[u], u); for (auto v : son[u]) if (v != mxs[u]) upd(v, u); upd(u); for (auto q : que[u]) &#123; int d = q.fr, id = q.sc; ans[id] = cnt[dep[u] + d].size(); &#125;&#125;int main() &#123; cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false); int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; nam[i] &gt;&gt; fa[i]; son[fa[i]].pb(i); &#125; for (auto u : son[0]) dfs(u); for (auto u : son[0]) dfs2(u, u); int q; cin &gt;&gt; q; for (int i = 1, u, k; i &lt;= q; ++i) &#123; cin &gt;&gt; u &gt;&gt; k; if (dep[u] + k &gt; n) continue; que[u].pb(mp(k, i)); &#125; for (auto u : son[0]) &#123;dsu(u, u); del(u, u);&#125; for (int i = 1; i &lt;= q; ++i) cout &lt;&lt; ans[i] &lt;&lt; endl; return 0;&#125; CF 570 D. Tree Requests ä¸€æ£µæ ‘æ¯ä¸ªç‚¹ä¸Šæœ‰ä¸€ä¸ªå­—ç¬¦ï¼Œæ¯æ¬¡è¯¢é—® \\(u_i\\) å­æ ‘å†…æ·±åº¦ä¸º \\(k_i\\) çš„æ‰€æœ‰ç‚¹ä¸Šçš„å­—ç¬¦æ˜¯å¦å¯ä»¥é€šè¿‡é‡æ’å½¢æˆå›æ–‡ä¸²ã€‚ å½¢æˆå›æ–‡ä¸²çš„æ¡ä»¶æ˜¯å‡ºç°å¥‡æ•°æ¬¡çš„å­—ç¬¦è‡³å¤šä¸€ç§ã€‚ ç”¨ DSU on Tree ç»´æŠ¤ cnt[dep][c] è¡¨ç¤ºåœ¨ dep è¿™ä¸ªæ·±åº¦ä¸Šçš„ç‚¹å­—ç¬¦ c çš„å‡ºç°æ¬¡æ•°ã€‚ å†ç”¨ä¸€ä¸ª odd[dep] è¡¨ç¤º cnt[dep][c] æ˜¯å¥‡æ•°çš„ c çš„ä¸ªæ•°ï¼Œè¯¢é—® Yes å°±æ˜¯å¯¹åº”æ·±åº¦çš„ odd[dep] &lt;= 1 ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;#define pic pair&lt;int, char&gt;#define lowbit(x) ((x) &amp; -(x))#define N 500007bool ans[N];int cnt[N][26], ch[N], odd[N];int sz[N], mxs[N], dep[N];vector&lt;int&gt; son[N];vector&lt;pii&gt; que[N];void dfs(int u, int fa) &#123; sz[u] = 1; dep[u] = dep[fa] + 1; for (auto v : son[u]) &#123; dfs(v, u); sz[u] += sz[v]; if (sz[v] &gt; sz[mxs[u]]) mxs[u] = v; &#125;&#125;inline void upd(int u) &#123; // adding information of u into data structures ++cnt[dep[u]][ch[u]]; (cnt[dep[u]][ch[u]] &amp; 1) ? ++odd[dep[u]] : --odd[dep[u]];&#125;inline void del(int u) &#123; // deleting information of u from data structures cnt[dep[u]][ch[u]] = odd[dep[u]] = 0;&#125;void upd(int u, int fa) &#123; upd(u); for (auto v : son[u]) if (v != fa) upd(v, u);&#125;void del(int u, int fa) &#123; del(u); for (auto v : son[u]) if (v != fa) del(v, u);&#125;void dsu(int u, int fa) &#123; for (auto v : son[u]) if (v != fa &amp;&amp; v != mxs[u]) &#123;dsu(v, u); del(v, u);&#125; if (mxs[u]) dsu(mxs[u], u); for (auto v : son[u]) if (v != fa &amp;&amp; v != mxs[u]) upd(v, u); upd(u); for (auto [k, id] : que[u]) ans[id] = (odd[k] &lt;= 1);&#125;int main() &#123; int n = rd(), m = rd(); for (int i = 2; i &lt;= n; ++i) son[rd()].pb(i); char c = getchar(); while (!isalpha(c)) c = getchar(); for (int i = 1; i &lt;= n; ++i, c = getchar()) ch[i] = c - &#x27;a&#x27;; for (int i = 1; i &lt;= m; ++i) &#123; int u = rd(), k = rd(); que[u].pb(mp(k, i)); &#125; dfs(1, 1); dsu(1, 1); for (int i = 1; i &lt;= m; ++i) puts(ans[i] ? &quot;Yes&quot; : &quot;No&quot;); return 0;&#125; CF 375 D. Tree and Queries ä¸€æ£µæ ‘æ¯ä¸ªç‚¹æœ‰ä¸€ä¸ªé¢œè‰²ï¼Œæ¯æ¬¡è¯¢é—® \\(u_i\\) å­æ ‘å†…å‡ºç°æ¬¡æ•°è¶…è¿‡ \\(k_i\\) çš„é¢œè‰²æ•°ã€‚ DSU on Tree æ±‚å‡ºæ¥å­æ ‘å†…é¢œè‰²çš„å‡ºç°æ¬¡æ•° cnt æ•°ç»„ï¼Œå†å¯¹ cnt æ±‚å‡ºç°æ¬¡æ•° cnt' æ•°ç»„ï¼Œè¯¢é—®å°±æ˜¯é—® cnt' çš„ \\(k_i\\) åç¼€å’Œã€‚ å› æ­¤å¾ˆå®¹æ˜“ \\(\\mathcal O(n\\log^2 n)\\) åšï¼Œé¢å¤–å†ç”¨ä¸€ä¸ªæ ‘çŠ¶æ•°ç»„ç»´æŠ¤ cnt' å°±å¥½äº†ã€‚ ä½†å®é™…ä¸Šå¯ä»¥ \\(\\mathcal O(n\\log n)\\) å¤„ç†ï¼Œæˆ‘ä»¬å®é™…åœ¨åšï¼š1. å¯¹ cnt' ä¸­æŸä¸ªä½ç½® x æ‰§è¡Œ --cnt'[x], ++cnt'[x+1]; 2. æ±‚åç¼€å’Œã€‚ å¯ä»¥å‘ç°ä¿®æ”¹æ“ä½œå¯¹åç¼€å’Œæ•°ç»„çš„å½±å“æ˜¯ \\(\\mathcal O(1)\\) çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç›´æ¥åœ¨ä¿®æ”¹çš„åŒæ—¶ç»´æŠ¤æ¯ä¸ªä½ç½®çš„åç¼€å’Œã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;#define pic pair&lt;int, char&gt;#define lowbit(x) ((x) &amp; -(x))#define N 100007int col[N], cnt[N], sum[N], ans[N];int sz[N], mxs[N], dep[N];vector&lt;int&gt; e[N];vector&lt;pii&gt; que[N];void dfs(int u, int fa) &#123; sz[u] = 1; dep[u] = dep[fa] + 1; for (auto v : e[u]) if (v != fa) &#123; dfs(v, u); sz[u] += sz[v]; if (sz[v] &gt; sz[mxs[u]]) mxs[u] = v; &#125;&#125;inline void upd(int u) &#123; // adding information of u into data structures ++sum[++cnt[col[u]]];&#125;inline void del(int u) &#123; // deleting information of u from data structures sum[cnt[col[u]]--]--;&#125;void upd(int u, int fa) &#123; upd(u); for (auto v : e[u]) if (v != fa) upd(v, u);&#125;void del(int u, int fa) &#123; del(u); for (auto v : e[u]) if (v != fa) del(v, u);&#125;void dsu(int u, int fa) &#123; for (auto v : e[u]) if (v != fa &amp;&amp; v != mxs[u]) &#123;dsu(v, u); del(v, u);&#125; if (mxs[u]) dsu(mxs[u], u); for (auto v : e[u]) if (v != fa &amp;&amp; v != mxs[u]) upd(v, u); upd(u); for (auto [k, id] : que[u]) ans[id] = sum[k];&#125;int main() &#123; int n = rd(), m = rd(); for (int i = 1; i &lt;= n; ++i) col[i] = rd(); for (int i = 1; i &lt; n; ++i) &#123; int u = rd(), v = rd(); e[u].pb(v); e[v].pb(u); &#125; for (int i = 1; i &lt;= m; ++i) &#123; int u = rd(), k = rd(); que[u].pb(mp(k, i)); &#125; dfs(1, 1); dsu(1, 1); for (int i = 1; i &lt;= m; ++i) printf(&quot;%d\\n&quot;, ans[i]); return 0;&#125; 2020 CCPC Changchun F. Strange Memory ç»™ä¸€æ£µæ ‘ï¼Œæ¯ä¸ªç‚¹æœ‰ä¸€ä¸ªæƒå€¼ \\(a_i\\) ï¼Œæ±‚ \\(\\sum_{1\\le i&lt;j\\le n} [a_i\\oplus a_j=a_{lca(i,j)}] (i\\oplus j)\\) ç›´æ¥ dsu on tree ä¼šå‘ç°æ— æ³•å¤„ç†å½¢å¦‚ \\(\\sum (w_i\\oplus x)\\) çš„æŸ¥è¯¢ï¼Œå› æ­¤å¯ä»¥æŒ‰ä½ç»Ÿè®¡ï¼ˆæ³¨æ„æ˜¯èŠ‚ç‚¹ç¼–å·çš„ä½æ•°ï¼‰ã€‚ æ¯æ¬¡å°†ä¸€ä¸ªå­æ ‘çš„ç­”æ¡ˆå…ˆæŸ¥å‡ºæ¥å†åŠ å…¥ï¼Œå› ä¸º \\(a_i&gt;0\\) æ‰€ä»¥ä¸ç”¨è€ƒè™‘ç¥–å…ˆåä»£å…³ç³»çš„è´¡çŒ®ã€‚ æ€»å¤æ‚åº¦ \\(\\mathcal{O}(n\\log^2 n)\\) ï¼Œæœ¬é¢˜æ¯”è¾ƒå¡å¸¸ï¼Œæ‰€ä»¥éœ€è¦æŠŠæ‰€æœ‰è½»å„¿å­çš„å­æ ‘ç‚¹é›†é¢„å¤„ç†å‡ºæ¥ï¼Œçœæ‰é€’å½’çš„å¸¸æ•°ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;#define pic pair&lt;int, char&gt;#define lowbit(x) ((x) &amp; -(x))#define N 1000007int cnt[N &lt;&lt; 1][2], mx, res;int sz[N], mxs[N], dep[N], a[N], b;ll ans;vector&lt;int&gt; e[N], subtree[N];void dfs(int u, int fa) &#123; sz[u] = 1; dep[u] = dep[fa] + 1; for (auto v : e[u]) if (v != fa) &#123; dfs(v, u); sz[u] += sz[v]; if (sz[v] &gt; sz[mxs[u]]) mxs[u] = v; &#125;&#125;void calc(int u, int fa, int w) &#123; for (auto v : e[u]) if (v != fa) calc(v, u, w);&#125;void dsu(int u, int fa) &#123; for (auto v : e[u]) if (v != fa &amp;&amp; v != mxs[u]) &#123; dsu(v, u); for (auto k : subtree[v]) cnt[a[k]][(k &gt;&gt; b) &amp; 1] = 0; &#125; if (mxs[u]) dsu(mxs[u], u); for (auto v : e[u]) if (v != fa &amp;&amp; v != mxs[u]) &#123; for (auto k : subtree[v]) ans += (1ll &lt;&lt; b) * cnt[a[k] ^ a[u]][((k &gt;&gt; b) &amp; 1) ^ 1]; for (auto k : subtree[v]) ++cnt[a[k]][(k &gt;&gt; b) &amp; 1]; &#125; ++cnt[a[u]][(u &gt;&gt; b) &amp; 1];&#125;void get_subtree(int u, int fa, int cur) &#123; subtree[cur].pb(u); for (auto v : e[u]) if (v != fa) get_subtree(v, u, cur);&#125;void dsu_tree(int u, int fa) &#123; for (auto v : e[u]) if (v != fa &amp;&amp; v != mxs[u]) get_subtree(v, u, v); for (auto v : e[u]) if (v != fa) dsu_tree(v, u);&#125;int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) a[i] = rd(); for (int i = 1; i &lt; n; ++i) &#123; int u = rd(), v = rd(); e[u].pb(v); e[v].pb(u); &#125; dfs(1, 1); dsu_tree(1, 1); for (b = 0; b &lt;= 16; ++b) &#123; dsu(1, 1); for (int u = 1; u &lt;= n; ++u) cnt[a[u]][0] = cnt[a[u]][1] = 0; &#125; printf(&quot;%lld\\n&quot;, ans); return 0;&#125; CF 741 D. Arpaâ€™s letter-marked tree and Mehrdadâ€™s Dokhtar-kosh paths ä¸€æ£µæ ‘æ¯æ¡è¾¹ä¸Šæœ‰ä¸€ä¸ªå­—ç¬¦ (a - v) ï¼Œæ¯æ¬¡è¯¢é—® \\(u_i\\) å­æ ‘å†…æœ€é•¿çš„ç®€å•è·¯å¾„ï¼Œæ»¡è¶³å…¶ä¸Šçš„å­—ç¬¦é‡æ’å¯å½¢æˆå›æ–‡ä¸²ã€‚ \\((u,v)\\) è·¯å¾„ä¿¡æ¯ \\(=u\\) åˆ°æ ¹ä¿¡æ¯ \\(+v\\) åˆ°æ ¹ä¿¡æ¯ \\(-2*lca(u,v)\\) åˆ°æ ¹ä¿¡æ¯ã€‚ å­—ç¬¦é›†åªæœ‰ \\(22\\) ï¼ŒçŠ¶å‹ \\(u\\) åˆ°æ ¹æ¯ä¸ªå­—ç¬¦çš„å¥‡å¶æ€§ \\(s_u\\) ï¼Œè·¯å¾„ä¿¡æ¯å³ä¸º \\(s_u\\oplus s_v\\) ï¼ˆlca ä¿¡æ¯å› ä¸ºå¼‚æˆ–ä¸¤æ¬¡æ¶ˆæ‰äº†ï¼‰ è€ƒè™‘è·¯å¾„åˆå¹¶ï¼Œæ¯ä¸ªç‚¹å¯èƒ½çš„é…å¯¹æ–¹æ¡ˆåªæœ‰ \\(23\\) ç§ï¼ˆå¼‚æˆ–åä¸º \\(0\\) æˆ– \\(2\\) çš„å¹‚æ¬¡ï¼Œå³æœ€å¤šå…è®¸ä¸€ä¸ªå­—ç¬¦å‡ºç°å¥‡æ•°æ¬¡ï¼‰ DSU on Treeï¼Œç»Ÿè®¡æ­¤å‰å­æ ‘çš„ä¿¡æ¯ï¼Œç»´æŠ¤æ¯ä¸ªçŠ¶å‹å€¼çš„æœ€æ·±æ·±åº¦ï¼Œä¿è¯ lca æ˜¯å½“å‰ç‚¹éœ€æ•´ä¸ªå­æ ‘å…ˆæŸ¥è¯¢åæ’å…¥ã€‚ å†™æŒ‚çš„åœ°æ–¹ï¼š1. å­æ ‘å†…æœ€é•¿è¦å’Œå„¿å­çš„ ans å– \\(\\max\\) ï¼›2.æšä¸¾é…å¯¹çš„çŠ¶æ€æ—¶ï¼Œå¾—ä¿è¯å­˜åœ¨å†æ›´æ–°ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;#define pic pair&lt;int, char&gt;#define lowbit(x) ((x) &amp; -(x))#define N 500007int ch[N], sta[N], mxd[1 &lt;&lt; 22], ans[N], res;int sz[N], mxs[N], dep[N];vector&lt;int&gt; son[N];void dfs(int u, int fa, int S) &#123; sz[u] = 1; dep[u] = dep[fa] + 1; if (u != 1) S ^= (1 &lt;&lt; ch[u]); sta[u] = S; for (auto v : son[u]) &#123; dfs(v, u, S); sz[u] += sz[v]; if (sz[v] &gt; sz[mxs[u]]) mxs[u] = v; &#125;&#125;inline void upd(int u) &#123; // adding information of u into data structures mxd[sta[u]] = max(mxd[sta[u]], dep[u]);&#125;inline void del(int u) &#123; // deleting information of u from data structures mxd[sta[u]] = 0; res = 0;&#125;void upd(int u, int fa) &#123; upd(u); for (auto v : son[u]) if (v != fa) upd(v, u);&#125;void del(int u, int fa) &#123; del(u); for (auto v : son[u]) if (v != fa) del(v, u);&#125;void updans(int u, int del) &#123; // æšä¸¾é…å¯¹çš„çŠ¶æ€éœ€è¦ä¿è¯å­˜åœ¨ï¼ï¼ï¼ if (mxd[sta[u]]) res = max(res, dep[u] + mxd[sta[u]] - 2 * del); for (int i = 0; i &lt; 22; ++i) if (mxd[sta[u] ^ (1 &lt;&lt; i)]) res = max(res, dep[u] + mxd[sta[u] ^ (1 &lt;&lt; i)] - 2 * del);&#125;void getans(int u, int del) &#123; updans(u, del); for (auto v : son[u]) getans(v, del);&#125;void dsu(int u, int fa) &#123; for (auto v : son[u]) if (v != fa &amp;&amp; v != mxs[u]) &#123;dsu(v, u); del(v, u);&#125; if (mxs[u]) dsu(mxs[u], u); updans(u, dep[u]); upd(u); for (auto v : son[u]) if (v != fa &amp;&amp; v != mxs[u]) &#123; getans(v, dep[u]); res = max(res, ans[v]); upd(v, u); &#125; ans[u] = res;&#125;int main() &#123; int n = rd(); for (int i = 2; i &lt;= n; ++i) &#123; son[rd()].pb(i); char c = getchar(); while (!isalpha(c)) c = getchar(); ch[i] = (c - &#x27;a&#x27;); &#125; dfs(1, 1, 0); dsu(1, 1); for (int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, ans[i]); return 0;&#125; HDU 7255 Expected Inversions æ¢æ ¹ + DSU on Tree ç»Ÿè®¡ä¿¡æ¯ï¼Œè§å¤šæ ¡é¢˜è§£ã€‚","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://blog.gyx.me/categories/Algorithms/"}],"tags":[{"name":"DFS and Similar","slug":"DFS-and-Similar","permalink":"http://blog.gyx.me/tags/DFS-and-Similar/"}]},{"title":"AtCoder Beginner Contest 266","slug":"atcoder/abc266","date":"2022-08-30T13:58:14.000Z","updated":"2023-03-20T16:28:23.288Z","comments":true,"path":"atcoder/abc266/","link":"","permalink":"http://blog.gyx.me/atcoder/abc266/","excerpt":"","text":"ABCD æ¯”è¾ƒç®€å•å°±ä¸å†™äº†ã€‚ E. Throwing the Die æœ‰ \\(k\\) æ¬¡æ·éª°å­çš„æœºä¼šï¼Œå¯ä»¥ä»»æ„æ—¶åˆ»å–Šåœï¼Œå¾—åˆ†å°±æ˜¯åœçš„æ—¶å€™éª°å­å‘ä¸Šçš„æ•°å­—ï¼Œé—®æœ€ä¼˜ç­–ç•¥æœŸæœ›å¾—åˆ†ã€‚ æœŸæœ›è¦å€’ç€ç®—ã€‚è®¾ \\(f[x]\\) è¡¨ç¤ºå¯ä»¥æ· \\(x\\) æ¬¡çš„æœ€ä¼˜æœŸæœ›å¾—åˆ†ï¼Œé¦–å…ˆæœ‰ \\(f[1] = 3.5\\) ã€‚ æ¥ä¸‹æ¥è€ƒè™‘ \\(f[i]\\) å·²çŸ¥æ±‚ \\(f[i + 1]\\) ï¼šæšä¸¾ç¬¬ \\(i+1\\) æ¬¡çš„å…­ç§å¯èƒ½æƒ…å†µï¼Œå¦‚æœæœ¬æ¬¡å¾—åˆ†æ¯” \\(f[i]\\) è¦å¤§å°±ä¸ä¼šå†æŠ•äº†ï¼Œå¦åˆ™ä¼šç»§ç»­æŠ•ã€‚ å› æ­¤æ–¹ç¨‹ä¸º \\(f[i + 1] =\\frac{1}{6}\\sum_{j=1}^6j\\times\\big[j &gt; f[i]\\big]+f[i]\\times \\big[j \\le f[i]\\big]\\) ã€‚ 12345678910111213int main() &#123; int n = rd(); double f[101] = &#123;0, 3.5&#125;; for (int i = 2; i &lt;= n; ++i) &#123; f[i] = 0; for (int j = 1; j &lt;= 6; ++j) &#123; if (1.0 * j &lt; f[i - 1]) f[i] += f[i - 1] / 6; else f[i] += j / 6.0; &#125; &#125; printf(&quot;%.10lf\\n&quot;, f[n]); return 0;&#125; F. Well-defined Path Queries on a Namori ç»™ä¸€æ£µæ— å‘åŸºç¯æ ‘ï¼Œ\\(q\\) æ¬¡é—® \\(u_i\\) å’Œ \\(v_i\\) ä¹‹é—´çš„ç®€å•è·¯å¾„æ˜¯å¦å”¯ä¸€ã€‚ è·¯å¾„ä¸ç»è¿‡ç¯å°±å”¯ä¸€ï¼Œå› æ­¤æ‹“æ‰‘æŠŠç¯æ‰¾å‡ºæ¥åˆ æ‰ï¼Œå¦‚æœä¸¤ä¸ªç‚¹åœ¨åŒä¸€æ£µæ ‘å†…ç­”æ¡ˆå°±æ˜¯ Yes ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 200007#define pb push_backvector&lt;int&gt; e[N];bool vis[N];int deg[N];queue&lt;int&gt; q;int col[N], cnt;void dfs(int u, int c) &#123; for (auto v : e[u]) if (!col[v]) &#123; col[v] = c; dfs(v, c); &#125;&#125;int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; int u = rd(), v = rd(); e[u].pb(v); e[v].pb(u); ++deg[u]; ++deg[v]; &#125; for (int i = 1; i &lt;= n; ++i) if (deg[i] == 1) &#123;vis[i] = true; q.push(i);&#125; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (auto v : e[u]) if (!vis[v]) &#123; --deg[v]; if (deg[v] == 1) &#123; vis[v] = true; q.push(v); &#125; &#125; &#125; for (int i = 1; i &lt;= n; ++i) if (!vis[i]) col[i] = ++cnt; for (int i = 1; i &lt;= n; ++i) if (!vis[i]) dfs(i, col[i]); for (int q = rd(); q; --q) &#123; int u = rd(), v = rd(); puts(col[u] == col[v] ? &quot;Yes&quot; : &quot;No&quot;); &#125; return 0;&#125; G. Yet Another RGB Sequence è®¡æ•° \\(R\\) ä¸ª r ï¼Œ\\(G\\) ä¸ª g ï¼Œ\\(B\\) ä¸ª b çš„å­—ç¬¦ä¸²ï¼Œä¸”å…¶ä¸­rg å­ä¸²æ°å¥½ \\(k\\ (k\\le \\min(R,G))\\) ä¸ªã€‚ å…ˆæ•°å‡ºæ¥ \\(k\\) ä¸ª rg ã€\\(G-k\\) ä¸ª g ã€\\(B\\) ä¸ª b çš„å­—ç¬¦ä¸²ä¸ªæ•°æ˜¯ \\(\\frac{(G+B)!}{k!(G-k)!B!}\\) ï¼ˆå¤šé‡é›†çš„æ’åˆ—ï¼‰ å†å°†å‰©ä¸‹çš„ \\(R-k\\) ä¸ª r æ’è¿›å»ï¼Œå› ä¸ºä¸èƒ½æ’åœ¨ g å‰é¢ï¼Œæ‰€ä»¥åªèƒ½æ’åœ¨ rg æˆ– b çš„å‰é¢ï¼ˆåŠæœ€åï¼‰ å› æ­¤å°±æ˜¯ \\(B+k\\) ä¸ªéš”æ¿å’Œ \\(R-k\\) ä¸ªçƒçš„æ’åˆ—ä¸ªæ•°é—®é¢˜ï¼Œæ–¹æ¡ˆæ•°ä¸º \\({R+B\\choose R-k}\\) ï¼Œä¸¤éƒ¨åˆ†ä¹˜èµ·æ¥å³å¯ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 2000007#define mod 998244353int fac[N], ifac[N];inline int fpow(int x, int t) &#123; int res = 1; for (; t; t &gt;&gt;= 1, x = 1ll * x * x % mod) if (t &amp; 1) res = 1ll * res * x % mod; return res;&#125; inline void init() &#123; fac[0] = ifac[0] = 1; for (int i = 1; i &lt; N; ++i) fac[i] = 1ll * fac[i - 1] * i % mod; ifac[N - 1] = fpow(fac[N - 1], mod - 2); for (int i = N - 2; i; --i) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % mod;&#125; inline int C(int n, int m) &#123; if (n &lt; m) return 0; return 1ll * fac[n] * ifac[m] % mod * ifac[n - m] % mod;&#125;int main() &#123; init(); int r = rd(), g = rd(), b = rd(), k = rd(); r -= k; g -= k; int ans = 1ll * fac[g + b + k] * ifac[g] % mod * ifac[b] % mod * ifac[k] % mod; b += k; printf(&quot;%lld\\n&quot;, 1ll * ans * C(r + b, r) % mod); return 0;&#125; Ex. Snuke Panic (2D) äºŒç»´å¹³é¢ä¸Š \\(n\\ (n\\le 10^5)\\) ä¸ªç‚¹ï¼Œä½äº \\((x_i,y_i)\\) ï¼Œå‡ºç°æ—¶é—´ \\(t_i\\) ï¼Œä»·å€¼ \\(a_i\\) ã€‚ å¼€å§‹ä½ åœ¨ \\((0,0)\\) ï¼Œæ¯ç§’å››é€‰ä¸€ï¼š\\(x\\) æ–¹å‘ \\(+1/-1/y\\) æ–¹å‘ \\(+1/\\) ä¸åŠ¨ã€‚ æ°å¥½åœ¨ \\(t_i\\) æ—¶åˆ»åˆ°è¾¾ \\((x_i,y_i)\\) ï¼Œå¯ä»¥è·å¾— \\(a_i\\) ï¼Œæ±‚èƒ½å¾—åˆ°çš„æœ€å¤§ä»·å€¼ã€‚ ç›´æ¥è®¾ \\(f[t][x][y]\\) è¡¨ç¤ºå‰ \\(t\\) ç§’ï¼Œ \\(t\\) æ—¶åœ¨ \\((x,y)\\) èƒ½å¾—åˆ°çš„æœ€å¤§ä»·å€¼ï¼›è®¾ \\(val(t,x,y)\\) è¡¨ç¤º \\(t\\) æ—¶åˆ» \\((x,y)\\) çš„ä»·å€¼ã€‚ \\[ f[t][x][y]= \\max \\{f[t&#39;][x&#39;][y&#39;]\\ |\\ t&#39; \\le t, y&#39; \\le y, |x-x&#39;|+y-y&#39;\\le t - t&#39;\\} + val(t,x,y) \\] ç”±åä¸¤ä¸ªé™åˆ¶æ¡ä»¶æœ‰ \\(t-t\\ge y - y&#39;\\ge 0\\) å› æ­¤ç¬¬ä¸€ä¸ªæ¡ä»¶å¯ä»¥ä¸¢æ‰ï¼Œå‰©ä¸‹çš„æ¡ä»¶å†™ä¸ºï¼š \\[ \\left\\{ \\begin{array}{l} y&#39; \\le y\\\\ x - x&#39; + y - y&#39; \\le t - t&#39;\\\\ x&#39;-x + y - y&#39; \\le t - t&#39; \\end{array} \\right. \\ \\ \\Longrightarrow \\left\\{ \\begin{array}{l} y&#39; \\le y\\\\ t&#39; - x&#39; - y&#39; \\le t - x - y\\\\ t&#39; + x&#39; - y&#39; \\le t + x - y \\end{array} \\right. \\] å¯ä»¥å‘ç°åšä¸ªçº¿æ€§å˜æ¢ä¹‹åæ˜¯ä¸ªä¸‰ç»´ååºï¼Œä»¤ \\(a=t-x-y,b=t+x-y\\) ï¼Œæœ‰ï¼š \\[ f[a][b][y] = \\max\\{f[a&#39;][b&#39;][y&#39;]\\ |\\ a&#39;\\le a, b&#39;\\le b, y&#39;\\le y \\} + val(a,b,y) \\] ä¸‰ç»´éƒ½ä»å°åˆ°å¤§æ’åºåå¯ä»¥å»æ‰ä¸€ç»´ï¼Œå‰©ä¸‹ä¸¤ç»´ç”¨äºŒç»´æ ‘çŠ¶æ•°ç»„ç»´æŠ¤å³å¯ï¼Œç­”æ¡ˆæ˜¾ç„¶åªä¼šåœ¨ \\(val(a,b,y)\\) æœ‰å€¼å¤„ç»Ÿè®¡åˆ°ã€‚ ä½†æ˜¯å³ä½¿ç¦»æ•£åŒ–çš„äºŒç»´æ ‘çŠ¶æ•°ç»„ä¹Ÿå¼€ä¸ä¸‹ï¼Œéœ€è¦å°†ä¸€ç»´ç”¨ unordered_map ä»£æ›¿ï¼Œæ—¶ç©ºå¤æ‚åº¦å‡ä¸º \\(\\mathcal O(n\\log^2n)\\) ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define pb push_back#define lowbit(x) ((x) &amp; -(x))#define all(x) (x).begin(), (x).end()#define N 100007struct node &#123;int y, a, b, w;&#125; g[N];vector&lt;int&gt; A, B;int X, Y;unordered_map&lt;int, ll&gt; c[N];inline ll max(ll a, ll b) &#123;return a &gt; b ? a : b;&#125;inline void upd(int x, int y, ll w) &#123; for (int i = x; i &lt;= X; i += lowbit(i)) for (int j = y; j &lt;= Y; j += lowbit(j)) c[i][j] = max(c[i][j], w);&#125;inline ll qmax(int x, int y) &#123; ll res = 0; for (int i = x; i; i -= lowbit(i)) for (int j = y; j; j -= lowbit(j)) res = max(res, c[i][j]); return res;&#125;int main() &#123; int n = rd(), m = 0; for (int i = 1; i &lt;= n; ++i) &#123; int t = rd(), x = rd(), y = rd(), w = rd(); if (t - x - y &lt; 0 || t + x - y &lt; 0) continue; g[++m].y = y; g[m].w = w; g[m].a = t - x - y; A.pb(g[m].a); g[m].b = t + x - y; B.pb(g[m].b); &#125; n = m; auto cmp = [&amp;](node a, node b) &#123; if (a.y != b.y) return a.y &lt; b.y; if (a.a != b.a) return a.a &lt; b.a; return a.b &lt; b.b; &#125;; sort(g + 1, g + 1 + n, cmp); sort(all(A)); A.erase(unique(all(A)), A.end()); X = A.size(); sort(all(B)); B.erase(unique(all(B)), B.end()); Y = B.size(); ll ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; int a = lower_bound(all(A), g[i].a) - A.begin() + 1; int b = lower_bound(all(B), g[i].b) - B.begin() + 1; ll nw = qmax(a, b) + g[i].w; ans = max(ans, nw); upd(a, b, nw); &#125; printf(&quot;%lld\\n&quot;, ans); return 0;&#125;","categories":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://blog.gyx.me/categories/AtCoder/"},{"name":"AtCoder Beginner Contest","slug":"AtCoder/AtCoder-Beginner-Contest","permalink":"http://blog.gyx.me/categories/AtCoder/AtCoder-Beginner-Contest/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"},{"name":"Counting","slug":"Counting","permalink":"http://blog.gyx.me/tags/Counting/"},{"name":"Fenwick Tree","slug":"Fenwick-Tree","permalink":"http://blog.gyx.me/tags/Fenwick-Tree/"}]},{"title":"Metacamp 2022","slug":"misc/metacamp2022","date":"2022-08-23T14:43:27.000Z","updated":"2023-03-20T16:38:42.959Z","comments":true,"path":"misc/metacamp2022/","link":"","permalink":"http://blog.gyx.me/misc/metacamp2022/","excerpt":"","text":"è‡ªé—­äº†ï¼Œå› ä¸ºç–«æƒ…æ²¡èƒ½å»æˆåŒ—äº¬ï¼Œçº¿ä¸Šæ‰“çš„å†³èµ›ã€‚ è¡¥é¢˜åœ°å€ &amp; å®˜æ–¹é¢˜è§£ï¼šOnline A , Solution | Online B , Solution å¤è¯»æœº \\(n\\) ä¸ªäººï¼Œæ¯ä¸ªäººæœ‰ä¸€ä¸ª \\(a_i,b_i\\) ï¼Œæ¯æ¬¡å¯ä»¥è®© \\(a_i\\leftarrow a_{b_i}\\) ï¼Œæ±‚æœ€å°æ“ä½œæ¬¡æ•°ä½¿å¾—æ‰€æœ‰æ•°å­—éƒ½ä¸€æ ·ã€‚ å›¾æ˜¯ä¸€ä¸ªå†…å‘åŸºç¯æ ‘æ£®æ—ï¼Œæ˜¾ç„¶åªæœ‰ç¯å†…çš„é¢œè‰²æœ‰å¯èƒ½æˆä¸ºæœ€ç»ˆé¢œè‰²ï¼Œå› æ­¤æ±‚ä¸€ä¸‹æ‰€æœ‰ç¯ä¸Šé¢œè‰²çš„äº¤ã€‚ å‡è®¾æœ€ç»ˆçš„é¢œè‰²æ˜¯ \\(w\\) ï¼Œé‚£ä¹ˆæœ€ç»ˆéœ€è¦çš„æ“ä½œæ¬¡æ•°å°±æ˜¯ \\(n-cnt_w\\) ï¼Œæ¯æ¬¡æŠŠä¸€æ¡ä¸æ˜¯ \\(w\\) çš„é“¾ä¾æ¬¡æŸ“è‰²å³å¯ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;using namespace std;using ll = long long;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 1000007int a[N], b[N], deg[N];bool vis[N];queue&lt;int&gt; q;map&lt;int, int&gt; cnt, tmpcnt;int tot;void dfs(int u) &#123; vis[u] = 1; if (tmpcnt[a[u]] != tot) &#123; if (tmpcnt[a[u]] &lt; tot - 1) tmpcnt[a[u]] = 0; else tmpcnt[a[u]] = tot; &#125; if (!vis[b[u]]) dfs(b[u]);&#125;inline void work() &#123; tot = 0; int n = rd(); cnt.clear(); tmpcnt.clear(); for (int i = 1; i &lt;= n; ++i) &#123; ++cnt[a[i] = rd()]; deg[i] = 0; vis[i] = false; &#125; for (int i = 1; i &lt;= n; ++i) ++deg[b[i] = rd()]; for (int i = 1; i &lt;= n; ++i) if (!deg[i]) q.push(i); while (!q.empty()) &#123; int u = q.front(); q.pop(); --deg[b[u]]; vis[u] = true; if (!deg[b[u]]) q.push(b[u]); &#125; for (int i = 1; i &lt;= n; ++i) if (!vis[i]) &#123;++tot; dfs(i);&#125; int ans = 1e9; for (int u = 1; u &lt;= n; ++u) if (tmpcnt[a[u]] == tot) &#123; ans = min(ans, n - cnt[a[u]]); &#125; printf(&quot;%d\\n&quot;, ans &lt; 1e9 ? ans : -1);&#125; int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; çŸ³å¤´å‰ªåˆ€å¸ƒ ä¸¤ä¸ªå‰ªåˆ€çŸ³å¤´å¸ƒçš„ç­‰é•¿åºåˆ—ï¼Œæ¯æ¬¡å¯ä»¥æŠŠè‡ªå·±çš„åºåˆ—çš„æŸä¸ªæ•°ç§»åˆ°æœ€åï¼Œæ±‚èµ¢çš„æ¬¡æ•°å‡æ“ä½œæ¬¡æ•°çš„æœ€å¤§å€¼ã€‚ æ€§è´¨æ˜¯è¢«ç§»åˆ°åé¢çš„æ•°å­—é¡ºåºä»»æ„ï¼Œå› æ­¤è¢«ç§»åˆ°åé¢çš„æ•°å­—å¯ä»¥å°½é‡åŒ¹é…èµ¢ã€‚ è®¾ \\(f[i][a][b][c]\\) è¡¨ç¤ºå‰ \\(i\\) ä¸ªï¼ŒæŠŠ \\(a\\) ä¸ªå‰ªåˆ€ã€\\(b\\) ä¸ªçŸ³å¤´ã€\\(c\\) ä¸ªå¸ƒç§»åŠ¨åˆ°åé¢ï¼Œå‰©ä½™çš„æœ€å¤§èµ¢æ¬¡æ•°ã€‚ æœ€åå¯¹æ¯ä¸ªçŠ¶æ€æ‰«æçš„æ—¶å€™ç»Ÿè®¡è¢«æ“ä½œçš„æ•°å­—èƒ½èµ¢å¤šå°‘å³å¯ï¼Œå¯¹æ¯ç§è®°ä¸ªåç¼€å’Œå³å¯ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;using namespace std;using ll = long long;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;#define rep(i, x, y) for (int i = (x); i &lt;= (y); ++i)#define per(i, x, y) for (int i = (x); i &gt;= (y); --i)inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 107char A[N], B[N];int f[N][N][N][N], a[N], b[N];inline int tr(char c) &#123; if (c == &#x27;r&#x27;) return 2; if (c == &#x27;s&#x27;) return 1; return 0;&#125;inline int win(int a, int b) &#123; if (a == 2 &amp;&amp; b == 1) return 1; if (a == 1 &amp;&amp; b == 0) return 1; if (a == 0 &amp;&amp; b == 2) return 1; return 0;&#125;int suf[3][N];int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); scanf(&quot;%s&quot;, A + 1); scanf(&quot;%s&quot;, B + 1); for (int i = 1; i &lt;= n; ++i) &#123; a[i] = tr(A[i]); b[i] = tr(B[i]); &#125; for (int i = n; i; --i) &#123; for (int j = 0; j &lt; 3; ++j) suf[j][i] = suf[j][i + 1]; suf[b[i]][i]++; &#125; memset(f, 0xcf, sizeof(f)); f[0][0][0][0] = 0; for (int i = 1; i &lt;= n; ++i) for (int x = 0; x &lt;= i; ++x) for (int y = 0; y &lt;= i - x; ++y) for (int z = 0; z &lt;= i - x - y; ++z) &#123; int p = i - x - y - z; f[i][x][y][z] = max(f[i][x][y][z], f[i - 1][x][y][z] + win(a[i], b[p])); if (a[i] == 0 &amp;&amp; x) f[i][x][y][z] = max(f[i][x][y][z], f[i - 1][x - 1][y][z]); if (a[i] == 1 &amp;&amp; y) f[i][x][y][z] = max(f[i][x][y][z], f[i - 1][x][y - 1][z]); if (a[i] == 2 &amp;&amp; z) f[i][x][y][z] = max(f[i][x][y][z], f[i - 1][x][y][z - 1]); &#125; int ans = 0; for (int x = 0; x &lt;= n; ++x) for (int y = 0; y &lt;= n - x; ++y) for (int z = 0; z &lt;= n - x - y; ++z) &#123; int tot = x + y + z; int nw = f[n][x][y][z] + min(x, suf[2][n - tot + 1]) + min(y, suf[0][n - tot + 1]) + min(z, suf[1][n - tot + 1]); ans = max(ans, nw - tot); &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125; KSharpe ç»™å®šä¸€ä¸ª \\(01\\) åºåˆ—ï¼Œæ±‚æ‰€æœ‰åŒºé—´æƒå€¼ =ï¼ˆå‡å€¼ / æ ‡å‡†å·®ï¼‰çš„ç¬¬ \\(k\\) å¤§ï¼Œç‰¹æ®Šçš„å¦‚æœæ ‡å‡†å·®ä¸º \\(0\\) åˆ™æƒå€¼ä¹Ÿå®šä¹‰ä¸º \\(0\\) ã€‚ æ¨ä¸€æ¨å‘ç°æƒå€¼çš„å¹³æ–¹ = åŒºé—´ \\(1\\) çš„ä¸ªæ•° / åŒºé—´ \\(0\\) çš„ä¸ªæ•°ï¼ŒäºŒåˆ†æƒå€¼çš„å¹³æ–¹ç¬¬ \\(k\\) å¤§ä¸º \\(w\\) ï¼Œå³ç»Ÿè®¡å¤šå°‘ä¸ª \\(l,r\\) æ»¡è¶³ï¼š \\[ \\frac{sum_r-sum_{l-1}}{(r - sum_r) - (l-1 - sum_{l-1})}\\ge w \\] è®° \\(f(x) =sum_x-w(x - sum_x)\\) ï¼Œæ‰€æ±‚å³ \\(f(r)\\ge f(l-1)\\) ï¼Œç¦»æ•£åŒ– + æ ‘çŠ¶æ•°ç»„ç»Ÿè®¡é¡ºåºå¯¹å³å¯ã€‚ ç‰¹æ®Šçš„å…¨ \\(1\\) åŒºé—´ä¼šè®¤ä¸ºå¤§äº \\(w\\) æ’æˆç«‹ï¼Œæ‰€ä»¥éœ€è¦æ‰£æ‰ã€‚æå‰æ•°ä¸€ä¸‹å³å¯ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;using namespace std;using ll = long long;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;#define rep(i, x, y) for (int i = (x); i &lt;= (y); ++i)#define per(i, x, y) for (int i = (x); i &gt;= (y); --i)inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 100007ll k;int n, sum[N];ll c[N];vector&lt;pair&lt;double, int&gt; &gt; s;inline int lowbit(int x) &#123;return x &amp; -x;&#125;inline void add(int x) &#123; for (; x &lt; N; x += lowbit(x)) ++c[x];&#125;inline ll calc(int x) &#123; ll res = 0; for (; x; x -= lowbit(x)) res += c[x]; return res;&#125;ll cntint1 = 0;int ha[N];inline bool valid(double x) &#123; s.clear(); s.pb(mp(0, 0)); for (int i = 1; i &lt;= n; ++i) s.pb(mp(sum[i] - x * (i - sum[i]), i)); sort(s.begin(), s.end()); int cnt = 0; ha[s[0].sc] = ++cnt; for (int i = 1; i &lt;= n; ++i) &#123; if (s[i].fr != s[i - 1].fr) ++cnt; ha[s[i].sc] = cnt; &#125; memset(c, 0, sizeof(c)); add(ha[0]); ll tot = 0; for (int i = 1; i &lt;= n; ++i) &#123; tot += calc(ha[i]); add(ha[i]); &#125; return tot - cntint1 &gt;= k;&#125;int main() &#123; n = rd(); k = rd(); int cnt1 = 0; for (int i = 1; i &lt;= n; ++i) &#123; int w = rd(); sum[i] = sum[i - 1] + w; if (w == 1) ++cnt1; else &#123;cntint1 += 1ll * cnt1 * (cnt1 + 1) / 2; cnt1 = 0;&#125; &#125; cntint1 += 1ll * cnt1 * (cnt1 + 1) / 2; double l = 0, r = n; for (int i = 1; i &lt;= 100; ++i) &#123; double mid = (r + l) / 2; valid(mid) ? l = mid : r = mid; &#125; printf(&quot;%.10lf\\n&quot;, sqrt(l)); return 0;&#125;","categories":[{"name":"Misc Solutions","slug":"Misc-Solutions","permalink":"http://blog.gyx.me/categories/Misc-Solutions/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"},{"name":"DFS and Similar","slug":"DFS-and-Similar","permalink":"http://blog.gyx.me/tags/DFS-and-Similar/"},{"name":"System of Difference Constraints","slug":"System-of-Difference-Constraints","permalink":"http://blog.gyx.me/tags/System-of-Difference-Constraints/"}]},{"title":"2022 HDU Multi-University Training Contest 8","slug":"misc/2022summer-8","date":"2022-08-11T14:24:33.000Z","updated":"2023-03-20T16:39:03.046Z","comments":true,"path":"misc/2022summer-8/","link":"","permalink":"http://blog.gyx.me/misc/2022summer-8/","excerpt":"","text":"1001. Theramore ç»™ä¸€ä¸ª \\(01\\) åºåˆ—ï¼Œæ¯æ¬¡å¯ä»¥å¯¹ç§°ç¿»è½¬ä¸€ä¸ªå¥‡æ•°é•¿åº¦çš„åŒºé—´ï¼Œé—®ä»»æ„æ¬¡æ“ä½œèƒ½å¾—åˆ°çš„æœ€å°å­—å…¸åºåºåˆ—ã€‚ æ ¸å¿ƒç‚¹æ˜¯ç¿»è½¬ä¸ä¼šäº¤æ¢å¥‡å¶ä½ä¸Šçš„æ•°å­—ï¼Œæ‰€ä»¥åªç”¨é•¿åº¦ä¸º \\(3\\) çš„æ“ä½œï¼Œå¯¹å¥‡å¶åˆ†åˆ«æ’åºå³å¯ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;using ll = long long;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 100007char s[N];int even[2], odd[2];inline void work() &#123; odd[0] = odd[1] = even[0] = even[1] = 0; scanf(&quot;%s&quot;, s + 1); int n = strlen(s + 1); for (int i = 1; i &lt;= n; ++i) &#123; if (i &amp; 1) ++odd[s[i] - &#x27;0&#x27;]; else ++even[s[i] - &#x27;0&#x27;]; &#125; for (int i = 1; i &lt;= n; ++i) &#123; if (i &amp; 1) &#123; if (odd[0]) &#123;putchar(&#x27;0&#x27;); --odd[0];&#125; else putchar(&#x27;1&#x27;); &#125; else &#123; if (even[0]) &#123;putchar(&#x27;0&#x27;); --even[0];&#125; else putchar(&#x27;1&#x27;); &#125; &#125; puts(&quot;&quot;);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; 1005. Ironforge ç»™ä¸€æ¡é“¾ï¼Œæ¯ä¸ªç‚¹ä¸Šæœ‰ä¸€ä¸ªæ•°å­—ï¼Œæ¯æ¡è¾¹ä¸Šæœ‰ä¸€ä¸ªè´¨æ•°ï¼Œå¤šæ¬¡è¯¢é—®æ˜¯å¦èƒ½ä» \\(x\\) åˆ° \\(y\\) ã€‚ æ¯æ¬¡ç»è¿‡ä¸€ä¸ªç‚¹å°±å¯ä»¥å¾—åˆ°è¿™ä¸ªç‚¹çš„å…¨éƒ¨è´¨æ•°ï¼Œç»è¿‡ä¸€æ¡è¾¹å¿…é¡»è¦æœ‰è¾¹ä¸Šçš„è´¨æ•°æ‰èƒ½é€šè¿‡ã€‚ å¤æ‚åº¦åˆ†æé¢˜ï¼Œä¸»è¦ç›®çš„æ˜¯åˆ©ç”¨ç›¸é‚»çš„ç‚¹çš„ä¿¡æ¯ï¼Œæ±‚å‡ºæ¯ä¸ªç‚¹å‡ºå‘çš„å¯è¾¾åŒºé—´ \\([l_i,r_i]\\) ã€‚ åˆ¤æ–­èƒ½å¦é€šè¿‡è¾¹ï¼šé¢„å¤„ç†å‡ºæ¥æ¯æ¡è¾¹ä¸¤ä¾§æœ€è¿‘çš„åŒ…å«å¯¹åº”è´¨æ•°çš„ç‚¹çš„ä½ç½®ï¼Œæƒ³è¦é€šè¿‡åŒºé—´è¦åŒ…å«å¯¹åº”ä¸€ä¾§çš„ç‚¹ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;using namespace std;using ll = long long;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 200007bool vis[N];int prm[N], mnd[N], tot;int a[N], b[N], l[N], r[N], lst[N], L[N], R[N];inline bool inseg(int x, int pos) &#123; return pos &gt;= l[x] &amp;&amp; pos &lt;= r[x];&#125;inline void work() &#123; int n = rd(), m = rd(); for (int i = 1; i &lt;= n; ++i) l[i] = r[i] = i, a[i] = rd(); for (int i = 1; i &lt; N; ++i) lst[i] = 0; for (int i = 1; i &lt; n; ++i) &#123; int w = a[i]; while(w &gt; 1) &#123;lst[mnd[w]] = i; w = w / prm[mnd[w]];&#125; b[i] = mnd[rd()]; L[i] = lst[b[i]]; &#125; for (int i = 1; i &lt; N; ++i) lst[i] = n + 1; for (int i = n - 1; i; --i) &#123; int w = a[i + 1]; while (w &gt; 1) &#123;lst[mnd[w]] = i + 1; w = w / prm[mnd[w]];&#125; R[i] = lst[b[i]]; &#125; for (int i = n - 1; i; --i) while (r[i] &lt; n &amp;&amp; inseg(i, L[r[i]])) r[i] = r[r[i] + 1]; for (int i = 2; i &lt;= n; ++i) &#123; if (!inseg(i, R[l[i] - 1])) continue; if (r[i - 1] &gt;= i) &#123;l[i] = l[i - 1]; r[i] = r[i - 1]; continue;&#125; l[i] = l[i - 1]; bool fl = 1; while (fl) &#123; fl = 0; if (l[i] &gt; 1 &amp;&amp; inseg(i, R[l[i] - 1])) &#123; if (r[l[i] - 1] &gt;= i) &#123; r[i] = r[l[i] - 1]; l[i] = l[l[i] - 1]; break; &#125; l[i] = l[l[i] - 1]; fl = 1; &#125; if (r[i] &lt; n &amp;&amp; inseg(i, L[r[i]])) &#123; r[i] = r[r[i] + 1]; fl = 1; &#125; &#125; &#125; for (; m; --m) &#123; int x = rd(), y = rd(); puts(y &gt;= l[x] &amp;&amp; y &lt;= r[x] ? &quot;Yes&quot; : &quot;No&quot;); &#125;&#125;int main() &#123; for (int i = 2; i &lt; N; ++i) &#123; if (!vis[i]) &#123;prm[tot] = i; mnd[i] = tot++;&#125; for (int j = 0, w; j &lt; tot; ++j) &#123; if (1ll * i * prm[j] &gt;= N) break; mnd[w = i * prm[j]] = j; vis[w] = 1; if (j == mnd[i]) break; &#125; &#125; for (int t = rd(); t; --t) work(); return 0;&#125; 1007. Darnassus ç»™ä¸€ä¸ªæ’åˆ—ï¼Œå»ºå®Œå…¨å›¾ \\(i\\) å’Œ \\(j\\) ä¹‹é—´è¾¹æƒä¸º \\(|i-j|\\times |p_i-p_j|\\) ï¼Œæ±‚æœ€å°ç”Ÿæˆæ ‘ã€‚ æ³¨æ„åˆ°å¦‚æœç›¸é‚»è¿è¾¹è¾¹æƒéƒ½ä¸ä¼šè¶…è¿‡ \\(n\\) ï¼Œæ‰€ä»¥åªéœ€è¦ä¿ç•™ \\(n\\) ä»¥å†…çš„è¾¹ã€‚ å› æ­¤ä¹˜ç§¯ä¸¤éƒ¨åˆ†éƒ½æŒ‰æ ¹å·æšä¸¾å³å¯ï¼Œç”¨æ¡¶æ’åºä¿å­˜æ‰€æœ‰çš„è¾¹ï¼Œæ€»å¤æ‚åº¦ \\(\\mathcal O(n\\sqrt n\\alpha(n))\\)ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;using namespace std;using ll = long long;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 50007int f[N], p[N], q[N];vector&lt;pii&gt; e[N];inline int find(int x) &#123;return x == f[x] ? x : f[x] = find(f[x]);&#125;inline int Abs(int x) &#123;return x &lt; 0 ? -x : x;&#125;inline void work() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; f[i] = i; p[i] = rd(); q[p[i]] = i; e[i].clear(); &#125; int lim = sqrt(n) + 1; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = max(1, i - lim), w; j &lt; i; ++j) &#123; if ((w = (i - j) * Abs(p[j] - p[i])) &gt; n) continue; e[w].pb(mp(i, j)); &#125; for (int j, w, pj = max(1, p[i] - lim); pj &lt; p[i]; ++pj) &#123; j = q[pj]; if (Abs(q[pj] - i) &lt;= lim) continue; if ((w = (p[i] - pj) * Abs(j - i)) &gt; n) continue; e[w].pb(mp(i, j)); &#125; &#125; ll ans = 0; int cnt = n - 1; for (int i = 1; i &lt;= n; ++i) &#123; for (auto cur : e[i]) &#123; int u = cur.fr, v = cur.sc; if (find(u) != find(v)) &#123; --cnt; f[find(u)] = find(v); ans += i; &#125; if (!cnt) break; &#125; if (!cnt) break; &#125; printf(&quot;%lld\\n&quot;, ans);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; 1008. Orgrimmar ç»™ä¸€æ£µæ ‘ï¼Œæ±‚æœ€å¤§è§£ç¦»é›†çš„å¤§å°ï¼ˆè¯±å¯¼å­å›¾é‡Œæ¯ä¸ªç‚¹åº¦ä¸è¶…è¿‡ \\(1\\) ï¼‰ è®¾çŠ¶æ€ dp[u][0/1/2] è¡¨ç¤º \\(u\\) èŠ‚ç‚¹ï¼šæ²¡é€‰ / é€‰äº†ï¼Œä½†å„¿å­éƒ½æ²¡é€‰ / é€‰äº†ï¼Œå¹¶ä¸”é€‰äº†ä¸€ä¸ªå„¿å­ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;using ll = long long;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 500007vector&lt;int&gt; e[N];int f[N][3];// f[u][0] : not choose u// f[u][1] : choose u, not choose u&#x27;s son// f[u][2] : choose u, choose u&#x27;s sonvoid dfs(int u, int fa) &#123; int dlt = 0; f[u][0] = 0; f[u][1] = 1; f[u][2] = 1; for (auto v : e[u]) if (v != fa) &#123; dfs(v, u); f[u][0] += max(&#123;f[v][0], f[v][1], f[v][2]&#125;); f[u][1] += f[v][0]; dlt = max(dlt, f[v][1] - f[v][0]); &#125; f[u][2] = f[u][1] + dlt;&#125;inline void work() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) e[i].clear(); for (int i = 1; i &lt; n; ++i) &#123; int u = rd(), v = rd(); e[u].pb(v); e[v].pb(u); &#125; dfs(1, 1); printf(&quot;%d\\n&quot;, max(&#123;f[1][0], f[1][1], f[1][2]&#125;));&#125;int main() &#123; int size(512&lt;&lt;20); // 512M __asm__ ( &quot;movq %0, %%rsp\\n&quot;::&quot;r&quot;((char*)malloc(size)+size)); for (int t = rd(); t; --t) work(); exit(0);&#125; 1010. Vale of Eternal ç»™ä¸€ä¸ªç‚¹é›†ï¼Œæ¯ç§’æ¯ä¸ªç‚¹å‘ä¸Šä¸‹å·¦å³è·ç¦» \\(1\\) çš„ä½ç½®å¤åˆ¶ä¸€ä¸ªç‚¹ï¼Œé—®ç¬¬ \\(t\\) ç§’æ‰€æœ‰ç‚¹çš„å‡¸åŒ…é¢ç§¯å¤§å°ã€‚ æŸ´è€å¸ˆæ¨çš„å¼å­ï¼Œå‰ \\(t\\) ç§’çš„å¢é‡ä¸º \\(2t^2+t\\sum \\max(|\\Delta x|,|\\Delta y|)\\) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include&lt;bits/stdc++.h&gt;using namespace std;using ll = long long;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;#define rep(i, x, y) for (int i = (x); i &lt;= (y); ++i)#define per(i, x, y) for (int i = (x); i &gt;= (y); --i)inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;typedef long long T;#define let const auto#define lett const T#define letp const P // P for point#define lets const S // S for segment#define letl const L // L for line#define letc const C // C for convex#define z(x) (abs((x)) &lt;= eps) // is zeroconst T eps = 1e-8;constexpr double PI=3.1415926535897932384;struct P &#123; T x, y; P (T x = 0, T y = 0) : x(x), y(y) &#123;&#125; P operator + (letp &amp;p) const &#123;return &#123;x + p.x, y + p.y&#125;;&#125; P operator - (letp &amp;p) const &#123;return &#123;x - p.x, y - p.y&#125;;&#125; P operator * (lett &amp;d) const &#123;return &#123;x * d, y * d&#125;;&#125; P operator / (lett &amp;d) const &#123;return &#123;x / d, y / d&#125;;&#125; P operator - () const &#123;return &#123;-x, -y&#125;;&#125; T operator | (letp &amp;p) const &#123;return x * p.x + y * p.y;&#125; // dot T operator ^ (letp &amp;p) const &#123;return x * p.y - y * p.x;&#125; // cross // P rot(double ang) const &#123; // counterclockwise rotation (ang) angle // double cosa = cos(ang), sina = sin(ang); // return &#123;x * cosa - y * sina, x * sina + y * cosa&#125;; // &#125; bool operator == (letp &amp;p) const &#123;return z(x - p.x) &amp;&amp; z(y - p.y);&#125; bool operator != (letp &amp;p) const &#123;return ! operator == (p);&#125; bool operator &lt; (letp &amp;p) const &#123;return z(x - p.x) ? y &lt; p.y : x &lt; p.x;&#125; bool operator &gt; (letp &amp;p) const &#123;return !(*this &lt; p || *this == p);&#125; // left(counterclockwise) = 1 | on = 0 | right(clockwise) = -1 int ori(letp &amp;p) const &#123;T t = (*this) ^ p; return (t &gt; eps) - (t &lt; -eps);&#125; T norm() const &#123;return x * x + y * y;&#125;&#125; zero;double abs(letp &amp;p) &#123;return sqrt(p.norm());&#125;P normalize(letp &amp;p) &#123;return p / abs(p);&#125;P perp(letp &amp;p) &#123;return &#123;-p.y, p.x&#125;;&#125; // turn pi / 2 leftP perpr(letp &amp;p) &#123;return &#123;p.y, -p.x&#125;;&#125; // turn pi / 2 rightbool orth(letp &amp;p, letp &amp;q) &#123;return (p | q) == 0;&#125;bool para(letp &amp;p, letp &amp;q) &#123;return (p ^ q) == 0;&#125;struct Polygon &#123; vector&lt;P&gt; p; // counterclockwise Polygon(const vector&lt;P&gt; p = &#123;&#125;) : p(p) &#123;&#125; size_t nxt(const size_t i) const &#123;return i == p.size() - 1 ? 0 : i + 1;&#125; size_t pre(const size_t i) const &#123;return i == 0 ? p.size() - 1 : i - 1;&#125; T double_area() const &#123; T sum = 0; for (size_t i = 0; i &lt; p.size(); ++i) sum += (p[i] ^ p[nxt(i)]); return sum; &#125;&#125;;struct C : Polygon &#123; C (const vector&lt;P&gt; &amp;p = &#123;&#125;) : Polygon(p) &#123;&#125;&#125;;C convexHull(vector&lt;P&gt; p) &#123; vector&lt;P&gt; st; sort(p.begin(), p.end()); const auto check = [](const vector&lt;P&gt; &amp;st, letp &amp;u) &#123; const auto back1 = st.back(), back2 = *prev(st.end(), 2); return (back1 - back2).ori(u - back2) &lt;= 0; &#125;; for (letp &amp;u : p) &#123; while (st.size() &gt; 1 &amp;&amp; check(st, u)) st.pop_back(); st.push_back(u); &#125; size_t k=st.size(); p.pop_back(); reverse(p.begin(),p.end()); for (letp &amp;u : p) &#123; while (st.size() &gt; k &amp;&amp; check(st, u)) st.pop_back(); st.push_back(u); &#125; st.pop_back(); return &#123;st&#125;;&#125;C c;vector&lt;P&gt; p;inline void work() &#123; p.clear(); int n = rd(), q = rd(); p.resize(n); for (int i = 0; i &lt; n; ++i) &#123;p[i].x = rd(); p[i].y = rd();&#125; c = convexHull(p); ll s = c.double_area(); ll dlt = 0; for (size_t i = 0; i &lt; c.p.size(); ++i) &#123; P cur = c.p[c.nxt(i)] - c.p[i]; dlt += max(abs(cur.x), abs(cur.y)); &#125; for (int i = 1; i &lt;= q; ++i) &#123; ll t = rd(); ll ans = s + 4 * t * t + 2 * t * dlt; printf(&quot;%lld&quot;, ans / 2); puts((ans &amp; 1) ? &quot;.5&quot; : &quot;.0&quot;); &#125;&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125;","categories":[{"name":"Misc Solutions","slug":"Misc-Solutions","permalink":"http://blog.gyx.me/categories/Misc-Solutions/"}],"tags":[{"name":"Geometry","slug":"Geometry","permalink":"http://blog.gyx.me/tags/Geometry/"}]},{"title":"2022 NowCoder Multi-University Training Contest 7","slug":"misc/2022summer-7","date":"2022-08-08T14:24:33.000Z","updated":"2023-03-20T16:38:58.500Z","comments":true,"path":"misc/2022summer-7/","link":"","permalink":"http://blog.gyx.me/misc/2022summer-7/","excerpt":"","text":"B. Rotate Sum 3 ç»™ä¸€ä¸ªå‡¸åŒ…ï¼Œæ¯æ¬¡æ“ä½œå°†å‡¸åŒ…æŒ‰æŸä¸ªå¯¹ç§°è½´åœ¨ä¸‰ç»´ç©ºé—´é‡Œæ—‹è½¬ä»»æ„è§’åº¦ï¼Œæ±‚æ— æ•°æ¬¡æ“ä½œåæ‰«è¿‡çš„ä½“ç§¯ã€‚ å¦‚æœåªæœ‰ä¸€ä¸ªå¯¹ç§°è½´ï¼Œç­”æ¡ˆå°±æ˜¯è‹¥å¹²ä¸ªåœ†å°çš„ä½“ç§¯ä¹‹å’Œã€‚ å¦‚æœæœ‰è¶…è¿‡ä¸€ä¸ªå¯¹ç§°è½´ï¼Œç”±äºæ‰€æœ‰å¯¹ç§°è½´éƒ½è¿‡é‡å¿ƒï¼Œæœ€ç»ˆçš„æ—‹è½¬ä½“ä¼šå½¢æˆä¸€ä¸ªçƒï¼ŒåŠå¾„æ˜¯å‡¸åŒ…é¡¶ç‚¹å’Œé‡å¿ƒçš„æœ€è¿œè·ç¦»ã€‚ æ‰¾å¯¹ç§°è½´ï¼šå°†å‡¸åŒ…å±•å¼€æˆè§’åº¦å’Œè¾¹é•¿çš„åºåˆ—ï¼Œç„¶åå¤åˆ¶ä¸€éè·‘ manacher ï¼Œå¦‚æœæŸä¸ªä¸­å¿ƒçš„å›æ–‡åŠå¾„å¤§äº 2n å³ä¸ºå¯¹ç§°è½´ã€‚ æ„é€ åºåˆ—ï¼šè§’ \\(ABC\\) ç”¨ç‚¹ç§¯ \\(|BA||BC|\\cos \\alpha\\) ä»£æ›¿ï¼ˆ \\(\\cos\\alpha\\) å¯ä»¥åŒºåˆ† \\([0,\\pi)\\) çš„æ‰€æœ‰è§’åº¦ï¼Œ æ­¤å¤–å¯¹ç§°è¦æ±‚ä¸¤ä¾§è¾¹ä¹Ÿä¸€æ ·é•¿ï¼Œæ‰€ä»¥ä¸ç”¨é™¤æ‰æ¨¡é•¿ï¼‰ï¼Œè¾¹é•¿ç”¨é•¿åº¦å¹³æ–¹ä»£æ›¿ï¼Œè¿™æ ·å°±éƒ½æ˜¯æ•´æ•°ï¼Œæ²¡æœ‰ç²¾åº¦é—®é¢˜äº†ã€‚ è®¡æ•°å¯¹ç§°è½´ï¼šç”±äºä¸€ä¸ªå¯¹ç§°è½´å¯èƒ½ä¼šè¢«æ‰¾åˆ°ä¸¤æ¬¡ï¼Œéœ€è¦å»é‡ï¼Œå› ä¸ºéƒ½è¿‡é‡å¿ƒï¼Œæ‰€ä»¥æ–¹å‘å‘é‡å‰ç§¯ä¸ç­‰äº \\(0\\) å³ä¸ºä¸åŒã€‚ ç®—ä½“ç§¯ï¼šå–ç›´çº¿ä¸€ä¾§çš„ç‚¹ï¼ŒæŒ‰ç…§é€†æ—¶é’ˆé¡ºåºä¾æ¬¡ç®—ã€‚ä»£ç é‡Œå·æ‡’ï¼Œç›´æ¥å¤åˆ¶å‡ºæ¥ä¸€éåšï¼Œä¸€å®šæœ‰ä¸€æ®µæ˜¯åŒ…å«å®Œæ•´çš„ç‚¹é›†ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include&lt;bits/stdc++.h&gt;using namespace std;using ll = long long;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;typedef long double T;#define lett const T#define letp const P // P for point#define lets const S // S for segment#define letl const L // L for line#define letc const C // C for convex#define z(x) (abs((x)) &lt;= eps) // is zeroconst T eps = 1e-8;const T inf = 1e18;constexpr long double pi = 3.1415926535897932384;struct P &#123; T x, y; P (T x = 0, T y = 0) : x(x), y(y) &#123;&#125; P operator + (letp &amp;p) const &#123;return &#123;x + p.x, y + p.y&#125;;&#125; P operator - (letp &amp;p) const &#123;return &#123;x - p.x, y - p.y&#125;;&#125; P operator * (lett &amp;d) const &#123;return &#123;x * d, y * d&#125;;&#125; P operator / (lett &amp;d) const &#123;return &#123;x / d, y / d&#125;;&#125; T operator | (letp &amp;p) const &#123;return x * p.x + y * p.y;&#125; // dot T operator ^ (letp &amp;p) const &#123;return x * p.y - y * p.x;&#125; // cross bool operator == (letp &amp;p) const &#123;return z(x - p.x) &amp;&amp; z(y - p.y);&#125; bool operator != (letp &amp;p) const &#123;return ! operator == (p);&#125; bool operator &lt; (letp &amp;p) const &#123;return z(x - p.x) ? y &lt; p.y : x &lt; p.x;&#125; bool operator &gt; (letp &amp;p) const &#123;return !(*this &lt; p || *this == p);&#125; int ori(letp &amp;p) const &#123;T t = (*this) ^ p; return (t &gt; eps) - (t &lt; -eps);&#125; T norm() const &#123;return x * x + y * y;&#125; P proj (letp &amp;p) const &#123;return (*this) * (((*this) | p) / norm());&#125; P refl (letp &amp;p) const &#123;return proj(p) * 2 - p;&#125;&#125; zero;long double abs(letp &amp;p) &#123;return sqrt(p.norm());&#125;P normalize(letp &amp;p) &#123;return p / abs(p);&#125;P perp(letp &amp;p) &#123;return &#123;-p.y, p.x&#125;;&#125; // turn pi / 2 leftP perpr(letp &amp;p) &#123;return &#123;p.y, -p.x&#125;;&#125; // turn pi / 2 rightbool orth(letp &amp;p, letp &amp;q) &#123;return (p | q) == 0;&#125;bool para(letp &amp;p, letp &amp;q) &#123;return (p ^ q) == 0;&#125;struct L &#123; P p, v; int ori (letp &amp;a) const &#123;return v.ori(a - p);&#125; P inter(letl &amp;l) const &#123;return p + v * ((l.v ^ (p - l.p)) / (v ^ l.v));&#125; L shift(letp &amp;d) const &#123;return &#123;p + d, v&#125;;&#125; L shiftl(double d) const &#123;return &#123;p + perp(v) * d / abs(v), v&#125;;&#125; long double dis(letp &amp;a) const &#123;return abs(v ^ (a - p)) / abs(v);&#125; &#125;;vector&lt;P&gt; c;#define N 400007long double a[N];int p[N];#define pre(x) (x == 0 ? n - 1 : x - 1)#define nxt(x) (x == n - 1 ? 0 : x + 1)vector&lt;int&gt; s;long double v(long double r, long double R, long double h) &#123; return 1 / 3.0 * pi * h * (r * r + R * R + r * R);&#125;int main() &#123; int n = rd(); P cent; cent.x = cent.y = 0; for (int i = 1; i &lt;= n; ++i) &#123; long double x = rd(), y = rd(); cent.x += x; cent.y += y; c.pb(&#123;x, y&#125;); &#125; cent = cent / n; int tot = 0; for (int i = 0; i &lt; n; ++i) &#123; a[++tot] = ((c[pre(i)] - c[i]) | (c[nxt(i)] - c[i])); a[++tot] = (c[nxt(i)] - c[i]).norm(); &#125; for (int i = 2 * n + 1; i &lt;= 4 * n; ++i) a[i] = a[i - 2 * n]; tot = 4 * n; int pos = 0, R = 0; for (int i = 1; i &lt;= 2 * n; ++i) &#123; if (i &lt; R) p[i] = min(p[(pos &lt;&lt; 1) - i], R - i); else p[i] = 1; while (1 &lt;= i - p[i] &amp;&amp; i + p[i] &lt;= tot &amp;&amp; z(a[i - p[i]] - a[i + p[i]])) ++p[i]; if (i + p[i] &gt; R) pos = i, R = i + p[i]; if (2 * p[i] - 1 &gt;= 2 * n) s.pb(i); &#125; long double d = 0; for (int i = 0; i &lt; n; ++i) d = max(d, abs(cent - c[i])); long double ball = 4.0 / 3.0 * pi * d * d * d; bool fl = 0; P dir; for (auto i : s) &#123; if (i &amp; 1) &#123; // node int cur = i / 2; P dr = c[cur] - cent; if (!fl) &#123;dir = dr; fl = 1;&#125; else &#123; if (!z(dir ^ dr)) &#123;printf(&quot;%.12Lf\\n&quot;, ball); return 0;&#125; &#125; &#125; else &#123; int cur = i / 2 - 1; P ct = (c[cur] + c[nxt(cur)]) / 2; P dr = ct - cent; if (!fl) &#123;dir = dr; fl = 1;&#125; else &#123; if (!z(dir ^ dr)) &#123;printf(&quot;%.12Lf\\n&quot;, ball); return 0;&#125; &#125; &#125; &#125; if (!fl) &#123;puts(&quot;0&quot;); return 0;&#125; L l&#123;cent, dir&#125;; fl = 0; for (int i = 0; i &lt; n; ++i) c.pb(c[i]); long double ans = 0, tmp = 0; P lstp; for (auto nw : c) &#123; if (l.ori(nw) &gt;= 0) &#123; if (fl) &#123; tmp += v(l.dis(lstp), l.dis(nw), fabs(((lstp - nw) | l.v) / abs(l.v))); &#125; fl = 1; lstp = nw; &#125; else &#123;ans = max(ans, tmp); fl = 0; tmp = 0;&#125; &#125; ans = max(ans, tmp); printf(&quot;%.12Lf\\n&quot;, ans); return 0;&#125; ä¸€é“ç±»ä¼¼çš„å¤šè¾¹å½¢æ‰¾å¯¹ç§°è½´é¢˜ï¼š[POI 2007] Axes of Symmetry F. Candies \\(n\\) ä¸ªæ•°å­—å½¢æˆä¸€ä¸ªç¯ï¼Œæ¯æ¬¡å¯ä»¥åˆ æ‰ä¸¤ä¸ªç›¸é‚»çš„ç›¸åŒæˆ–å’Œä¸º \\(a\\) çš„ä¸¤ä¸ªæ•°å­—ï¼Œé—®æœ€å¤šèƒ½åˆ å‡ æ¬¡ã€‚ æ¯æ¬¡æš´åŠ›æ‰¾åˆ°ä¸€ä¸ªä½ç½®åˆ é™¤å³å¯ã€‚è¯æ˜æ¯”è¾ƒå·§å¦™ï¼š å¯¹äºæ‰€æœ‰çš„ \\(x\\in [a / 2, a]\\) å°† \\(x\\) å˜ä¸º \\(a-x\\) ï¼Œå¯ä»¥å‘ç°åŸæœ¬å…è®¸æ¶ˆé™¤çš„æ•°å¯¹ç°åœ¨ä¾ç„¶å…è®¸æ¶ˆé™¤ã€‚ å› æ­¤åªå‰©ä¸‹ç›¸é‚»ä¸”ç›¸åŒçš„æ•°å­—æ‰å¯ä»¥æ¶ˆé™¤ï¼Œæ­¤æ—¶è´ªå¿ƒæ˜¾ç„¶æ˜¯å¯¹çš„ï¼Œåˆ é™¤é¡ºåºä¸ä¼šæ”¹å˜ç­”æ¡ˆå¤§å°ã€‚ 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;deque&lt;int&gt; s;int main() &#123; int n = rd(), a = rd(), ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; s.push_back(rd()); while (s.size() &gt;= 2) &#123; int x = s[s.size() - 1], y = s[s.size() - 2]; if (x != y &amp;&amp; x + y != a) break; ++ans; s.pop_back(); s.pop_back(); &#125; &#125; while (s.size() &gt;= 2) &#123; if (s.front() == s.back() || s.front() + s.back() == a) &#123; ++ans; s.pop_front(); s.pop_back(); &#125; else break; &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125; K. Great Party æœ‰ \\(n\\) å †çŸ³å­ï¼Œæ¯å † \\(a_i\\) ä¸ªï¼Œæ¯æ¬¡é€‰ä¸€å †æ‹¿èµ°è‹¥å¹²ä¸ªï¼Œå‰©ä½™çš„å¯ä»¥é€‰æ‹©åˆå¹¶åˆ°æŸä¸€å †ç°å­˜çš„ä¸­ã€‚ æ¯æ¬¡è¯¢é—®ä¸€ä¸ªåŒºé—´ï¼Œé—®æœ‰å¤šå°‘ä¸ªå­åŒºé—´å…ˆæ‰‹å¿…èƒœã€‚ å°‘è§çš„åšå‡ºæ¥çš„åšå¼ˆé¢˜ï¼ŒæŒ‰å †æ•°ä»å°åˆ°å¤§è€ƒè™‘ã€‚ åªæœ‰ä¸€å †ï¼Œå¿…èƒœï¼›åªæœ‰ä¸¤å †ï¼Œå¦‚æœä¸€æ ·çš„è¯ï¼Œå› ä¸ºä¸æ•¢åˆå¹¶ï¼Œæ‰€ä»¥å¯ä»¥å¯¹ç§°æ“ä½œï¼Œå¿…è´¥ï¼Œå¦åˆ™å¿…èƒœï¼›ä¸‰å †çš„å¿…èƒœï¼Œå› ä¸ºå¯ä»¥é€šè¿‡æ‹¿+åˆå¹¶å˜æˆä¸¤å †ä¸€æ ·å¤šçš„ï¼›å››å †çš„æƒ…å†µè°æ‹¿æˆä¸‰å †å°±è¾“ï¼Œå› ä¸ºä¸‰å †å¿…èƒœï¼Œæ‰€ä»¥å››å †çš„æ—¶å€™å¯ä»¥çœ‹æˆæ˜¯ \\(a_i-1\\) çš„ NIM æ¸¸æˆï¼Œå› ä¸ºéƒ½æ‹¿åˆ° \\(1\\) å°±ä¸å¾—ä¸åˆå¹¶äº†ã€‚äº”å †çš„æ—¶å€™ä¸€å®šå¯ä»¥å¯¹æœ€å¤§çš„æ“ä½œä½¿å¾—å˜æˆå››å †ä¸” NIM å’Œä¸º \\(0\\) ã€‚å› æ­¤ï¼š å¶æ•°ä¸ªå³ä¸º \\(a_i - 1\\) çš„ NIM æ¸¸æˆï¼Œå› ä¸ºè½¬æ¢æˆå¥‡æ•°çš„é‚£ä¸ªäººå¿…è´¥ã€‚ å¥‡æ•°å…ˆæ‰‹å¿…èƒœï¼Œå…ˆæ‰‹å¯¹æœ€å¤§é‚£å †çŸ³å­æ“ä½œï¼Œä½¿å¾—å‰©å¶æ•°ä¸ªä¸”çŸ³å­ä¸ªæ•°å‡ä¸€çš„å¼‚æˆ–å’Œä¸º0çš„å±€é¢ã€‚ æ‰€ä»¥å˜æˆäº†æŸ¥è¯¢åŒºé—´å†…æœ‰å¤šå°‘ä¸ªå¶æ•°é•¿åº¦çš„å­åŒºé—´å¼‚æˆ–å’Œä¸º \\(0\\) ï¼Œè«é˜Ÿåˆ†å¥‡å¶ç»Ÿè®¡å³å¯ã€‚ï¼ˆè®©èƒ–èƒ–å†™çš„ï¼‰ L. Maximum Range","categories":[{"name":"Misc Solutions","slug":"Misc-Solutions","permalink":"http://blog.gyx.me/categories/Misc-Solutions/"}],"tags":[{"name":"Constructive Algorithm","slug":"Constructive-Algorithm","permalink":"http://blog.gyx.me/tags/Constructive-Algorithm/"},{"name":"Geometry","slug":"Geometry","permalink":"http://blog.gyx.me/tags/Geometry/"},{"name":"Game Theory","slug":"Game-Theory","permalink":"http://blog.gyx.me/tags/Game-Theory/"}]},{"title":"2022 NowCoder Multi-University Training Contest 3","slug":"misc/2022summer-3","date":"2022-07-26T00:41:33.000Z","updated":"2023-03-20T16:38:53.931Z","comments":true,"path":"misc/2022summer-3/","link":"","permalink":"http://blog.gyx.me/misc/2022summer-3/","excerpt":"","text":"A. Ancestor ç»™ä¸¤æ£µ \\(n\\) ä¸ªèŠ‚ç‚¹çš„æ ‘ \\(A,B\\) å’Œä¸€ä¸ªæ•°é›† \\(S\\) ï¼Œé—®æœ‰å¤šå°‘ä¸ªæ•°æ»¡è¶³ \\(\\{S\\setminus a_i\\}\\) åœ¨ \\(A\\) ä¸­çš„ LCA çš„ç‚¹æƒæ¯” \\(B\\) ä¸­çš„å¤§ã€‚ \\(\\mathcal O(n\\log n)\\) çš„åšæ³•æ˜¯æš´åŠ›æ±‚å‡ºæ¥ç»™å®šèŠ‚ç‚¹åºåˆ—åœ¨ä¸¤æ£µæ ‘ä¸­å‰åç¼€çš„ LCA ï¼Œæœ€åæ¯ä¸ªåˆå¹¶ä¸€ä¸‹ä¸¤ä¾§å³å¯ã€‚ æœ‰ä¸€ä¸ªæ¯”è¾ƒå¦™çš„ \\(\\mathcal O(n)\\) åšæ³•ï¼šè€ƒè™‘å“ªäº›ç‚¹ä¼šä½œä¸º \\(|S|-1\\) ä¸ªç‚¹çš„ LCA ã€‚ æˆ‘ä»¬å°†æ•°é›†é‡Œæ¯ä¸ªç‚¹çš„ç‚¹æƒè®¾ä¸º \\(1\\) ï¼Œè‡³å¤šå­˜åœ¨ä¸€ä¸ªç‚¹ \\(u\\) ï¼Œæ»¡è¶³ \\(u\\) å­æ ‘å’Œä¸º \\(|S|-1\\) ä¸”æ·±åº¦æœ€æ·±ã€‚ å¦‚æœåˆ æ‰çš„æ˜¯è¿™ \\(|S|-1\\) ä¸ªç‚¹ä¸­çš„æŸä¸€ä¸ªï¼Œå‰©ä½™çš„ç‚¹çš„ LCA å°±æ˜¯ \\(S\\) ä¸­æ‰€æœ‰ç‚¹çš„ LCA ã€‚ å¦åˆ™å‰©ä½™çš„ç‚¹å°±æ˜¯è¿™ \\(|S| -1\\) ä¸ªç‚¹ï¼Œç­”æ¡ˆå°±æ˜¯ \\(u\\) å¦‚æœä¸å­˜åœ¨è¿™æ ·çš„ \\(u\\) ï¼Œé‚£ä¹ˆç­”æ¡ˆæ°¸è¿œéƒ½æ˜¯ \\(S\\) ä¸­æ‰€æœ‰ç‚¹çš„ LCA ã€‚ ç»¼ä¸Šå¯ä»¥å‘ç°ï¼Œåˆ æ‰æŸä¸ªç‚¹ä¹‹åå‰©ä½™ç‚¹çš„ LCA å¯èƒ½çš„ç»“æœè‡³å¤šä¸¤ç§ï¼Œå› æ­¤å¯ä»¥ä¸€é DFS ä¹‹å \\(\\mathcal O(1)\\) æŸ¥è¯¢ã€‚ ç‰¹æ®Šæƒ…å†µæ˜¯ \\(k=2\\) çš„æ—¶å€™ \\(u\\) ä¼šæœ‰ä¸¤ä¸ªï¼Œæ‰€ä»¥å•ç‹¬åˆ¤ä¸€ä¸‹ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;#define pb push_back#define rep(i, x, y) for (int i = (x); i &lt;= (y); ++i)#define per(i, x, y) for (int i = (x); i &gt;= (y); --i)inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 100007int n, k, tot, x[N];struct tree &#123; int lca, sub, cur; int sz[N], sum[N], val[N]; vector&lt;int&gt; son[N]; void dfs(int u) &#123; for (auto v : son[u]) dfs(v); for (auto v : son[u]) &#123;sz[u] += sz[v]; sum[u] ^= sum[v];&#125; if (!lca &amp;&amp; sz[u] == k) lca = u; if (!sub &amp;&amp; sz[u] == k - 1) &#123;sub = u; cur = sum[u] ^ tot;&#125; &#125; int query(int u) &#123;return u == cur ? val[sub] : val[lca];&#125;&#125; tr[2];int main() &#123; n = rd(); k = rd(); rep(i, 1, k) tot ^= (x[i] = rd()); rep(id, 0, 1) &#123; rep(i, 1, n) tr[id].val[i] = rd(); rep(i, 2, n) tr[id].son[rd()].pb(i); rep(i, 1, k) &#123;++tr[id].sz[x[i]]; tr[id].sum[x[i]] ^= x[i];&#125; &#125; int ans = 0; if (k &gt; 2) &#123; rep(id, 0, 1) tr[id].dfs(1); rep(i, 1, k) ans += tr[0].query(x[i]) &gt; tr[1].query(x[i]); &#125; else &#123; rep(i, 1, 2) ans += (tr[0].val[x[i]] &gt; tr[1].val[x[i]]); &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125; B. Boss æœ‰ \\(n\\) ä¸ªå‘˜å·¥è¦æ´¾åˆ° \\(m\\) ä¸ªåŸå¸‚, æ¯ä¸ªåŸå¸‚éœ€è¦ \\(a_{i}\\) ä¸ªå‘˜å·¥ï¼Œä¸” \\(\\sum_{i=1}^{m} a_{i}=n\\ (n \\leq 10^{5}, m \\leq 10)\\), æ±‚æœ€å°è´¹ç”¨ã€‚ ï¼ˆå€Ÿé‰´æŸ´è€å¸ˆåšå®¢ï¼‰ æœ€å°è´¹ç”¨æµæ¨¡ç‰ˆé¢˜ï¼Œä½†æ˜¯ç›´æ¥è·‘è´¹ç”¨æµå¤æ‚åº¦ä¸å¯¹ï¼Œè¦æ ¹æ®å›¾çš„æ€§è´¨ä¼˜åŒ–æ±‚æœ€çŸ­è·¯çš„ç®—æ³•ã€‚ å·¦è¾¹æ˜¯åŸå¸‚, å³è¾¹æ˜¯å‘˜å·¥, æ¯æ¬¡æ‰¾ä¸€æ¡æœ€çŸ­è·¯, å¿…ç„¶æ˜¯å…ˆèµ°åˆ°å·¦è¾¹çš„ç‚¹, å†ç»è¿‡è‹¥å¹²æ¬¡åæ‚”, æœ€åèµ°åˆ°å³è¾¹çš„ç‚¹ã€‚ ä¸€æ¬¡åæ‚”, æŒ‡å…ˆä»å·¦è¾¹èµ°åˆ°å³è¾¹, å†ä»å³è¾¹èµ°åˆ°å·¦è¾¹ï¼Œä¹Ÿå°±æ˜¯ \\(dis_{u,x}+dis_{x,v}\\) ã€‚ æ‰€ä»¥è·¯å¾„å¯ä»¥æ‹†æˆä¸¤éƒ¨åˆ†ï¼šåœ¨å·¦ä¾§ä» \\(u\\) å¼€å§‹ç»è¿‡è‹¥å¹²æ¬¡åˆ° \\(v\\) ï¼Œç„¶åä» \\(v\\) é€‰æ‹©å³ä¾§ä¸€ä¸ªå¯ä»¥èµ°çš„ç‚¹èµ°æ‰ã€‚ å¯¹äºå·¦ä¾§çš„ç‚¹ä¹‹é—´ç»´æŠ¤ \\(m^2\\) ä¸ªå †ä»£è¡¨å½“å‰ä» \\(u\\) ç»è¿‡ä¸€æ¬¡åæ‚”åˆ° \\(v\\) çš„æœ€çŸ­è·ç¦»ï¼Œæ¯æ¬¡å¢å¹¿ç”¨å †é¡¶çš„ç›´è·‘ä¸€é floyd ã€‚ å¯¹äºæ¯ä¸ªå·¦ä¾§çš„ç‚¹ç»´æŠ¤ä¸€ä¸ªå †ä»£è¡¨åˆ°å³ä¾§æ‰€æœ‰å¯è¡Œçš„è·ç¦»é‡Œæœ€çŸ­çš„ï¼Œç¬¬äºŒéƒ¨åˆ†çš„è·ç¦»å°±æ˜¯å †é¡¶çš„å€¼ã€‚ æ±‚æœ€çŸ­è·¯å°±æšä¸¾æ‰€æœ‰çš„å¯èƒ½çš„ \\(u,v\\) ï¼Œå› æ­¤å•æ¬¡å¢å…‰å¤æ‚åº¦ä¸º \\(\\mathcal O(m^2\\log n+m^3)\\) ï¼Œä¸€å…±å¢å¹¿ \\(n\\) æ¬¡ã€‚ ç¬¬ä¸€éƒ¨åˆ†çš„å †ç»´æŠ¤çš„æ—¶å€™è¦è€ƒè™‘é€€æµï¼Œæ±‚é€”å¾„çš„èŠ‚ç‚¹éœ€è¦å†floyd çš„æ—¶å€™è®°ä¸€ä¸ª pre ï¼Œç„¶å dfs å¾€å›æ‰¾ï¼Œç»†èŠ‚è§ä»£ç ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define K 11#define N 100007bool use[N];ll ans;int rem[K], dis[K][K], pre[K][K], mn[K][K];int c[K][N], n, k;bool go[K][N], back[N][K];bool vis[K][K][N];priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt; &gt; q[K][K], p[K];vector&lt;int&gt; s;void dfs(int u, int v) &#123; if (!pre[u][v]) &#123; go[u][mn[u][v]] = back[mn[u][v]][v] = false; back[mn[u][v]][u] = go[v][mn[u][v]] = true; s.pb(mn[u][v]); return; &#125; dfs(u, pre[u][v]); dfs(pre[u][v], v);&#125;inline void work() &#123; memset(dis, 0x3f, sizeof(dis)); for (int u = 1; u &lt;= k; ++u) &#123; dis[u][u] = 0; while (!p[u].empty() &amp;&amp; use[p[u].top().second]) p[u].pop(); for (int v = 1; v &lt;= k; ++v) &#123; while (!q[u][v].empty()) &#123; int x = q[u][v].top().second; if (!go[u][x] || !back[x][v]) &#123;vis[u][v][x] = false; q[u][v].pop();&#125; else break; &#125; if (q[u][v].size()) &#123; dis[u][v] = q[u][v].top().first; mn[u][v] = q[u][v].top().second; pre[u][v] = 0; &#125; &#125; &#125; for (int t = 1; t &lt;= k; ++t) for (int u = 1; u &lt;= k; ++u) for (int v = 1; v &lt;= k; ++v) if (dis[u][v] &gt; dis[u][t] + dis[t][v]) &#123; pre[u][v] = t; dis[u][v] = dis[u][t] + dis[t][v]; &#125; int mnu, mnv, cst = 1e9; for (int u = 1; u &lt;= k; ++u) if (rem[u]) for (int v = 1; v &lt;= k; ++v) &#123; int nw = dis[u][v] + p[v].top().first; if (nw &lt; cst) &#123;cst = nw; mnu = u; mnv = v;&#125; &#125; ans += cst; --rem[mnu]; s.clear(); if (mnu != mnv) dfs(mnu, mnv); s.pb(p[mnv].top().second); go[mnv][p[mnv].top().second] = false; back[p[mnv].top().second][mnv] = true; use[p[mnv].top().second] = true; for (auto t : s) &#123; for (int u = 1; u &lt;= k; ++u) for (int v = 1; v &lt;= k; ++v) if (go[u][t] &amp;&amp; back[t][v] &amp;&amp; !vis[u][v][t]) &#123; vis[u][v][t] = true; q[u][v].push(mp(c[u][t] - c[v][t], t)); &#125; &#125;&#125;int main() &#123; n = rd(); k = rd(); for (int i = 1; i &lt;= k; ++i) rem[i] = rd(); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= k; ++j) &#123; c[j][i] = rd(); go[j][i] = true; p[j].push(mp(c[j][i], i)); &#125; for (int i = 1; i &lt;= n; ++i) work(); printf(&quot;%lld\\n&quot;, ans); return 0;&#125; D. Directed èƒ–èƒ–è¡¥çš„ï¼Œæˆ³æˆ‘å›´è§‚ F. Fief æ— å‘å›¾æ¯æ¬¡è¯¢é—®ä¸¤ä¸ªç‚¹ \\(x,y\\) ï¼Œé—®æ˜¯å¦å­˜åœ¨ä¸€ä¸ªç‚¹ç¼–å·çš„æ’åˆ—ä»¥ \\(x\\) å¼€å¤´ä»¥ \\(y\\) ç»“å°¾ï¼Œä¸”ä»»æ„ä½ç½®æ–­å¼€å¾—åˆ°çš„ä¸¤æ®µéƒ½è¿é€šã€‚ è¿™ä¸ªé—®é¢˜çš„å­¦åå« â€œåŒæå®šå‘â€ï¼Œå­˜ä¸€ç¯‡åšå®¢ æµ…è°ˆåŒæå®šå‘åŠå…¶åº”ç”¨ - zx2003 æœ€åæˆ‘ä»¬å¾—å‡ºçš„ç»“è®ºæ˜¯å›¾å¿…é¡»è”é€šï¼Œåœ†æ–¹æ ‘ä¸Šçš„æ–¹ç‚¹å¿…é¡»æˆä¸€æ¡é“¾ï¼Œè¯¢é—®çš„ç‚¹ä¸èƒ½æ˜¯å‰²ç‚¹ã€‚ æ­¤å¤– \\(n=2\\) çš„æ—¶å€™å›¾ä¸è¿é€šä¹Ÿæ˜¯æ­£ç¡®çš„ï¼Œå®åœ¨å¤ªç»†èŠ‚äº†ã€‚è®©èƒ–èƒ–å»å†™çš„ï¼Œå›å¤´è¡¥å®Œå†è´´ä»£ç ã€‚ G. Geometry ç»™ä¸¤ä¸ªä¸äº¤çš„å‡¸åŒ… \\(A,B\\) ï¼Œæ¯ä¸ªå‡¸åŒ…æœ‰ä¸ªé€Ÿåº¦å‘é‡ \\(v\\) ï¼Œé—®ä¸¤å‡¸åŒ…ç¢°æ’çš„æ—¶é—´ã€‚ é¦–å…ˆè¿åŠ¨æ˜¯ç›¸å¯¹çš„ï¼Œæ‰€ä»¥å¯ä»¥å›ºå®šå‡¸åŒ… \\(A\\) ï¼Œå‡¸åŒ… \\(B\\) çš„é€Ÿåº¦å‘é‡å˜ä¸º \\(v_B - v_A\\) ã€‚ æ¥ä¸‹æ¥å°±æ˜¯å¥—è·¯é¢˜ï¼ŒåŒ [JSOI 2018] æˆ˜äº‰ï¼Œæ‰¾ä¸€æ¡å°„çº¿ä¸ \\(A+(-B)\\) çš„äº¤ç‚¹ï¼Œç„¶åè®¡ç®—åˆ°äº¤ç‚¹çš„æ—¶åˆ»å³å¯ã€‚ å› ä¸ºåªè¯¢é—®ä¸€æ¬¡ï¼Œæ‰€ä»¥æšä¸¾é—µå¯å¤«æ–¯åŸºå’Œä¸Šçš„æ¯ä¸€æ¡è¾¹ç›´æ¥å’Œå°„çº¿æ±‚äº¤æ›´æ–°ï¼Œå…¶å®å¯ä»¥ä¼˜åŒ–åˆ° \\(\\mathcal O(\\log n)\\) æŸ¥è¯¢ã€‚ å› ä¸ºæ•°æ®èŒƒå›´æœ‰ \\(10^9\\) ï¼Œæ‰€ä»¥ç‚¹ç§¯å‰ç§¯çš„èŒƒå›´æœ‰ \\(10^{18}\\) ï¼Œç›´æ¥åˆ¤æ–­äº¤ç‚¹æ˜¯å¦åœ¨çº¿æ®µä¸Šå¯èƒ½ä¼šå‡ºä¸€äº›é—®é¢˜ã€‚ ä¸€ä¸ªåˆ¤æ–­é˜¶æ®µæ— ç²¾åº¦è¯¯å·®çš„æ–¹æ³•ï¼šåˆ†æˆç«¯ç‚¹åœ¨å°„çº¿ä¸Šã€ç«¯ç‚¹åœ¨å°„çº¿ä¸¤ä¾§ä¸¤ç§æƒ…å†µæ›´æ–°ç­”æ¡ˆã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203#include&lt;bits/stdc++.h&gt;using namespace std;using ll = long long;#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;#define rep(i, x, y) for (int i = (x); i &lt;= (y); ++i)#define per(i, x, y) for (int i = (x); i &gt;= (y); --i)inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;typedef double T;#define lett const T&amp;#define letp const P&amp; // P for point#define lets const S&amp; // S for segment#define letl const L&amp; // L for line#define letc const C&amp; // C for convex#define z(x) (abs((x)) &lt;= eps) // is zeroconst T eps = 1e-8;constexpr long double PI=3.1415926535897932384;struct P &#123; T x, y; P (T x = 0, T y = 0) : x(x), y(y) &#123;&#125; P operator + (letp p) const &#123;return &#123;x + p.x, y + p.y&#125;;&#125; P operator - (letp p) const &#123;return &#123;x - p.x, y - p.y&#125;;&#125; P operator * (lett d) const &#123;return &#123;x * d, y * d&#125;;&#125; P operator / (lett d) const &#123;return &#123;x / d, y / d&#125;;&#125; T operator | (letp p) const &#123;return x * p.x + y * p.y;&#125; // dot T operator ^ (letp p) const &#123;return x * p.y - y * p.x;&#125; // cross P rot(double ang) const &#123; // rotation (ang) angle, need T = double double cosa = cos(ang), sina = sin(ang); return &#123;x * cosa - y * sina, x * sina + y * cosa&#125;; &#125; bool operator == (letp p) const &#123;return z(x - p.x) &amp;&amp; z(y - p.y);&#125; bool operator != (letp p) const &#123;return ! operator == (p);&#125; bool operator &lt; (letp p) const &#123;return z(x - p.x) ? y &lt; p.y : x &lt; p.x;&#125; bool operator &gt; (letp p) const &#123;return !(*this &lt; p || *this == p);&#125; int ori(letp p) const &#123;T t = (*this) ^ p; return (t &gt; eps) - (t &lt; -eps);&#125; T norm() const &#123;return x * x + y * y;&#125; P proj (letp p) const &#123;return (*this) * (((*this) | p) / norm());&#125; P refl (letp p) const &#123;return proj(p) * 2 - p;&#125;&#125; zero;double abs(letp p) &#123;return sqrt(p.norm());&#125;P normalize(letp p) &#123;return p / abs(p);&#125;P perp(letp p) &#123;return &#123;-p.y, p.x&#125;;&#125; // turn pi / 2 leftP perpr(letp p) &#123;return &#123;p.y, -p.x&#125;;&#125; // turn pi / 2 rightbool orth(letp p, letp q) &#123;return (p | q) == 0;&#125;bool para(letp p, letp q) &#123;return (p ^ q) == 0;&#125;struct argcmp &#123; // compared by polar angle bool operator() (letp a, letp b) const &#123; const auto quad = [](letp a) &#123; if (a.y &lt; -eps) return 1; // halfplane with negative y if (a.y &gt; eps) return 4; // halfplane with positive y if (a.x &lt; -eps) return 5; // negative x-axis if (a.x &gt; eps) return 3; // positive x-axis return 2; // origin &#125;; const int qa = quad(a), qb = quad(b); if (qa != qb) return qa &lt; qb; const auto t = a ^ b; //in the same quad // sorted by length in increasing order when parallel // if (z(t)) return norm(a) &lt; norm(b) - eps; return t &gt; eps; &#125; &#125;;struct L &#123; P p, v; int ori (letp a) const &#123;return v.ori(a - p);&#125; P inter(letl l) const &#123;return p + v * ((l.v ^ (p - l.p)) / (v ^ l.v));&#125; &#125;;struct S &#123; P a, b; // on = -1 | out = 0 | in = 1 int is_on(letp p) const &#123; if (p == a || p == b) return -1; return (p - a).ori(p - b) == 0 &amp;&amp; ((p - a) | (p - b)) &lt; -eps; &#125; // cross on endpoints = -1 | not inter = 0 | inside = 1 int is_inter(lets s) const &#123; if (is_on(s.a) || is_on(s.b) || s.is_on(a) || s.is_on(b)) return -1; letl l&#123;a, b - a&#125;, ls&#123;s.a,s.b - s.a&#125;; return l.ori(s.a) * l.ori(s.b) == -1 &amp;&amp; ls.ori(a) * ls.ori(b) == -1; &#125;&#125;;struct Polygon &#123; vector&lt;P&gt; p; // counterclockwise Polygon(const vector&lt;P&gt; p = &#123;&#125;) : p(p) &#123;&#125; size_t nxt(const size_t i) const &#123;return i == p.size() - 1 ? 0 : i + 1;&#125; size_t pre(const size_t i) const &#123;return i == 0 ? p.size() - 1 : i - 1;&#125; &#125;;struct C : Polygon &#123; C (const vector&lt;P&gt; &amp;p = &#123;&#125;) : Polygon(p) &#123;&#125; C operator + (letc c) const &#123; const auto &amp;p = this -&gt; p; vector&lt;S&gt; e1(p.size()), e2(c.p.size()); vector&lt;S&gt; edge(p.size() + c.p.size()); vector&lt;P&gt; res; res.reserve(p.size() + c.p.size()); const auto cmp = [](lets u, lets v) &#123; return argcmp()(u.b - u.a, v.b - v.a); &#125;; for (size_t i = 0; i &lt; p.size(); ++i) e1[i] = &#123;p[i], p[this -&gt; nxt(i)]&#125;; for (size_t i = 0; i &lt; c.p.size(); ++i) e2[i] = &#123;c.p[i], c.p[c.nxt(i)]&#125;; rotate(e1.begin(), min_element(e1.begin(), e1.end(), cmp), e1.end()); rotate(e2.begin(), min_element(e2.begin(), e2.end(), cmp), e2.end()); merge(e1.begin(), e1.end(), e2.begin(), e2.end(), edge.begin(), cmp); const auto check = [](const vector&lt;P&gt; &amp;res, letp u) &#123; const auto b1 = res.back(), b2 = *prev(res.end(), 2); return (b1 - b2).ori(u - b1) == 0 &amp;&amp; ((b1 - b2) | (u - b1)) &gt;= -eps; &#125;; auto u = e1[0].a + e2[0].a; for (const auto &amp;v : edge) &#123; while (res.size() &gt; 1 &amp;&amp; check(res, u)) res.pop_back(); res.push_back(u); u = u + v.b - v.a; &#125; if (res.size() &gt; 1 &amp;&amp; check(res, res[0])) res.pop_back(); return &#123;res&#125;; &#125; // O(log n) : on = -1 | out = 0 | in = 1 int is_in(letp a) const &#123; const auto &amp;p = this -&gt; p; if (p.size() == 1) return a == p[0] ? -1 : 0; if (p.size() == 2) return S&#123;p[0], p[1]&#125;.is_on(a) ? -1 : 0; if (a == p[0]) return -1; if ((p[1] - p[0]).ori(a - p[0]) == -1) return 0; if ((p.back() - p[0]).ori(a - p[0]) == 1) return 0; const auto cmp = [&amp;](letp u, letp v) &#123;return (u - p[0]).ori(v - p[0]) == 1;&#125;; const size_t i = lower_bound(p.begin() + 1, p.end(), a, cmp) - p.begin(); if (i == 1) return S&#123;p[0], p[i]&#125;.is_on(a) ? -1 : 0; if (i == p.size() - 1 &amp;&amp; S&#123;p[0], p[i]&#125;.is_on(a)) return -1; if (S&#123;p[i - 1], p[i]&#125;.is_on(a)) return -1; return (p[i] - p[i-1]).ori(a - p[i - 1]) &gt; 0; &#125;&#125; c, c_;int main() &#123; int n = rd(); c.p.resize(n); for (int i = 0; i &lt; n; ++i) &#123; T x = rd(), y = rd(); c.p[i] = &#123;x, y&#125;; &#125; n = rd(); c_.p.resize(n); for (int i = 0; i &lt; n; ++i) &#123; T x = -rd(), y = -rd(); c_.p[i] = &#123;x, y&#125;; &#125; c = c + c_; P v; v.x = -rd(); v.y = -rd(); v.x += rd(); v.y += rd(); if (c.is_in(zero)) &#123;puts(&quot;0&quot;); return 0;&#125; if (v == zero) &#123;puts(&quot;-1&quot;); return 0;&#125; L l&#123;zero, v&#125;; double ans = 1e20; for (size_t i = 0; i &lt; c.p.size(); ++i) &#123; const P a = c.p[i], b = c.p[c.nxt(i)]; const int oa = v.ori(a), ob = v.ori(b); if (oa == 0 &amp;&amp; (a | v) &gt; eps) ans = min(ans, abs(a) / abs(v)); if (ob == 0 &amp;&amp; (b | v) &gt; eps) ans = min(ans, abs(b) / abs(v)); if (oa != 0 &amp;&amp; ob != 0 &amp;&amp; oa != ob) &#123; P p = l.inter(L&#123;a, b - a&#125;); if ((p | v) &gt; eps) ans = min(ans, abs(p) / abs(v)); &#125; &#125; if (ans &lt; 1e20) printf(&quot;%.10lf\\n&quot;, ans); else puts(&quot;-1&quot;); return 0;&#125; J. Journey æœ‰ \\(n\\) ä¸ªå››é€šè·¯å£è¿æ¥è‹¥å¹²æ¡åŒå‘é“è·¯ï¼ˆè§†ä¸ºä¸¤æ¡ï¼‰ï¼Œæ¯æ¬¡åˆ°è·¯å£å³è½¬æ— ä»£ä»·ï¼Œå…¶ä»–æ–¹å‘ä»£ä»·éƒ½æ˜¯ \\(1\\) ã€‚ é—®ä» \\(s_1\\) åˆ° \\(s_2\\) çš„è·¯å‡ºå‘ï¼Œåˆ° \\(t_1\\) åˆ° \\(t_2\\) çš„è·¯çš„æœ€å°ä»£ä»·ã€‚ ä»¥æ¯æ¡è·¯ï¼ˆå•å‘ï¼‰ä¸ºç‚¹å»ºå›¾ï¼Œ01-BFS å³å¯ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 2000007unordered_map&lt;ll, int&gt; f;inline ll ha(int u, int v) &#123;return 1ll * u * 1e9 + v;&#125;int tot, dis[N];vector&lt;int&gt; e0[N], e1[N];bool vis[N];deque&lt;int&gt; q;void bfs(int s) &#123; memset(dis, 0x3f, sizeof(dis)); dis[s] = 0; q.push_back(s); while (!q.empty()) &#123; int u = q.front(); q.pop_front(); if (vis[u]) continue; vis[u] = 1; for (auto v : e0[u]) if (dis[v] &gt; dis[u]) &#123; dis[v] = dis[u]; q.push_front(v); &#125; for (auto v : e1[u]) if (dis[v] &gt; dis[u] + 1) &#123; dis[v] = dis[u] + 1; q.push_back(v); &#125; &#125; &#125;int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; int c[4]; for (int j = 0; j &lt; 4; ++j) &#123; c[j] = rd(); if (!c[j]) continue; if (!f[ha(i, c[j])]) f[ha(i, c[j])] = ++tot; if (!f[ha(c[j], i)]) f[ha(c[j], i)] = ++tot; &#125; for (int j = 0; j &lt; 4; ++j) if (c[j]) &#123; if (c[(j + 1) % 4]) e0[f[ha(c[j], i)]].push_back(f[ha(i, c[(j + 1) % 4])]); for (int w = 2; w &lt;= 4; ++w) &#123; int t = (j + w) % 4; if (c[t]) e1[f[ha(c[j], i)]].push_back(f[ha(i, c[t])]); &#125; &#125; &#125; int x = rd(), y = rd(); if (!f[ha(x, y)]) f[ha(x, y)] = ++tot; int u = f[ha(x, y)]; x = rd(), y = rd(); if (!f[ha(x, y)]) f[ha(x, y)] = ++tot; int v = f[ha(x, y)]; bfs(u); printf(&quot;%d\\n&quot;, dis[v] &gt;= 1e9 ? -1 : dis[v]); return 0;&#125;","categories":[{"name":"Misc Solutions","slug":"Misc-Solutions","permalink":"http://blog.gyx.me/categories/Misc-Solutions/"}],"tags":[{"name":"01-BFS","slug":"01-BFS","permalink":"http://blog.gyx.me/tags/01-BFS/"},{"name":"Flows","slug":"Flows","permalink":"http://blog.gyx.me/tags/Flows/"},{"name":"Minkowski Sum","slug":"Minkowski-Sum","permalink":"http://blog.gyx.me/tags/Minkowski-Sum/"},{"name":"Connectivity","slug":"Connectivity","permalink":"http://blog.gyx.me/tags/Connectivity/"}]},{"title":"AtCoder Beginner Contest 259","slug":"atcoder/abc259","date":"2022-07-13T13:58:14.000Z","updated":"2023-03-20T16:28:18.055Z","comments":true,"path":"atcoder/abc259/","link":"","permalink":"http://blog.gyx.me/atcoder/abc259/","excerpt":"","text":"A - Growth Record ä¸»äººå…¬ \\(N\\) å²çš„æ—¶å€™èº«é«˜æ˜¯ \\(T\\) , å·²çŸ¥ä»– \\([1,X]\\) æœŸé—´æ¯å¹´é•¿ \\(D\\) ï¼Œåé¢ä¸é•¿ä¸ªå­ï¼Œé—® \\(M\\) å²çš„æ—¶å€™èº«é«˜å¤šå°‘ \\(0\\) å²çš„èº«é«˜æ˜¯ \\(Tâˆ’X\\times D\\) ï¼Œç„¶ååˆ†æƒ…å†µè®¨è®ºã€‚ 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;int main() &#123; int n = rd(), m = rd(), x = rd(), t = rd(), d = rd(); int st = t - x * d; if (m &gt; x) printf(&quot;%d\\n&quot;, t); else printf(&quot;%d\\n&quot;, st + m * d); return 0;&#125; B - Counterclockwise Rotation ç»™å®šåæ ‡ \\((x,y)\\) é—®ç»•åŸç‚¹é€†æ—¶é’ˆæ—‹è½¬ \\(d\\) è§’åº¦åçš„åæ ‡ã€‚ åæ ‡ä¸º \\(x^{\\prime}=x * \\cos d-y * \\sin d, y^{\\prime}=x * \\sin d+y * \\cos d\\)ï¼Œå¯ä»¥ç”¨å„ç§æ–¹æ³•(è¯±å¯¼å…¬å¼/æ—‹è½¬çŸ©é˜µ)æ¨ã€‚ 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;using ld = long double;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;const ld PI = 3.1415926535;struct vec &#123; ld x, y; vec turn (ld ang) &#123; // é€†æ—¶é’ˆæ—‹è½¬ ang è§’åº¦ ld cosa = cos(ang), sina = sin(ang); return (vec)&#123;x * cosa - y * sina, x * sina + y * cosa&#125;; &#125;&#125;;int main() &#123; vec a; a.x = rd(); a.y = rd(); ld d = rd() / 180.0 * PI; a = a.turn(d); printf(&quot;%.10Lf %.10Lf\\n&quot;, a.x, a.y); return 0;&#125; C - XX to XXX ç»™å®šä¸¤ä¸ªä¸² \\(S\\) å’Œ \\(T\\), æ¯æ¬¡å¯ä»¥å‘ \\(S\\) ä¸­ç›¸é‚»ä¸”ç›¸åŒçš„ä¸¤ä¸ªå­—ç¬¦ä¸­é—´å¡ä¸€ä¸ªç›¸åŒçš„å­—ç¬¦ã€‚é—®è‹¥å¹²æ¬¡æ“ä½œå \\(S\\) æ˜¯å¦èƒ½å˜æˆ \\(T\\) ã€‚ è€ƒè™‘åŒæŒ‡é’ˆ \\(\\left(p t r_s, p t r_t\\right)\\), ä»å¤´å¯¹é½å¾€åæ‰«æï¼Œæ¯æ¬¡å…ˆä¸è€ƒè™‘æ‰©å¼ , èƒ½ä¸èƒ½åŒ¹é…ä¸Šã€‚ å¦‚æœä¸èƒ½åŒ¹é…ä¸Šï¼Œå³ \\(S\\left[p t r_s\\right] \\neq T\\left[p t r_t\\right]\\), é‚£ä¹ˆ \\(T\\left[p t r_t\\right]\\) åªèƒ½å¾€å›çœ‹ï¼Œå°è¯•ç”¨ \\(S\\left[p t r_s-1\\right]\\) å’Œ \\(S\\left[p t r_s-2\\right]\\) æ¥æ‰©å¼ , å¦åˆ™æ— è§£ã€‚ è®°å¾—æœ€åè¦åˆ¤æ–­ä¸€ä¸‹ä¸¤ä¸ªä¸²çš„æŒ‡é’ˆæ˜¯å¦éƒ½èµ°åˆ°äº†ç»“å°¾ã€‚ 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;#define N 200007char s[N], t[N];int main() &#123; scanf(&quot;%s&quot;, s + 1); scanf(&quot;%s&quot;, t + 1); int n = strlen(s + 1); int m = strlen(t + 1); int ptr = 1; for (int i = 1; i &lt;= m; ++i) &#123; if (s[ptr] == t[i]) &#123;++ptr; continue;&#125; if (s[ptr - 1] != t[i]) &#123;puts(&quot;No&quot;); return 0;&#125; if (ptr &lt;= 1 || s[ptr - 1] != s[ptr - 2]) &#123; puts(&quot;No&quot;); return 0; &#125; &#125; puts(ptr == n + 1 ? &quot;Yes&quot; : &quot;No&quot;); return 0;&#125; D - Circumferences ç»™å®šäºŒç»´å¹³é¢ä¸Šçš„ \\(n\\) ä¸ªåœ†, ä»¥åŠæŸä¸ªåœ†ä¸Šçš„èµ·ç‚¹å’ŒæŸä¸ªåœ†ä¸Šçš„ç»ˆç‚¹ã€‚ åªèƒ½èµ°åœ†çš„è¾¹ç•Œ (å¯ä»¥é€š è¿‡ä¸¤åœ†äº¤ç‚¹æ›´æ¢æ‰€åœ¨çš„åœ†ï¼‰ï¼Œé—®èƒ½å¦ä»èµ·ç‚¹èµ°åˆ°ç»ˆç‚¹? å¹¶æŸ¥é›†åˆ¤è¿é€šæ€§, æ•°æ®èŒƒå›´åªéœ€è¦ \\(n^2\\) æš´åŠ›æšä¸¾åˆ¤æ–­æ˜¯å¦æœ‰äº¤ç‚¹å³å¯ã€‚ åˆ¤æ–­ä¸¤åœ†æœ‰äº¤ç‚¹ï¼šä¸ç›¸ç¦»ä¹Ÿä¸åŒ…å«ã€‚ ç›¸ç¦»ï¼šåœ†å¿ƒè·å¤§äºä¸¤åœ†åŠå¾„ä¹‹å’Œã€‚ åŒ…å«ï¼šåœ†å¿ƒè·å°äºä¸¤åœ†åŠå¾„ä¹‹å·®çš„ç»å¯¹å€¼ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 3007ll x[N], y[N], r[N];int f[N];int find(int x) &#123; return x == f[x] ? x : (f[x] = find(f[x]));&#125;inline ll sqr(ll x) &#123;return x * x;&#125;int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) f[i] = i; int sx = rd(), sy = rd(); int tx = rd(), ty = rd(); for (int i = 1; i &lt;= n; ++i) &#123; x[i] = rd(); y[i] = rd(); r[i] = rd(); &#125; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) &#123; if (sqr(x[i] - x[j]) + sqr(y[i] - y[j]) &gt; sqr(r[i] + r[j])) continue; if (sqr(x[i] - x[j]) + sqr(y[i] - y[j]) &lt; sqr(r[i] - r[j])) continue; int u = find(i), v = find(j); f[u] = v; &#125; int px, py; for (int i = 1; i &lt;= n; ++i) &#123; if (sqr(sx - x[i]) + sqr(sy - y[i]) == sqr(r[i])) px = i; if (sqr(tx - x[i]) + sqr(ty - y[i]) == sqr(r[i])) py = i; &#125; puts(find(px) == find(py) ? &quot;Yes&quot; : &quot;No&quot;); return 0;&#125; E - LCM on Whiteboard ç»™å®š \\(n\\) ä¸ªæ•°å­—çš„æ ‡å‡†åˆ†è§£, å°†å…¶ä¸­çš„æŸä¸€ä¸ªå˜æˆ \\(1\\) , é—®æ“ä½œåæ‰€æœ‰æ•°å­—çš„æœ€å°å…¬å€æ•°æœ‰å¤šå°‘ç§ä¸åŒçš„å¯èƒ½æ€§? ç»“è®ºæ˜¯æ‰€æœ‰æ•°å­—çš„æœ€å°å…¬å€æ•°ç­‰äº æ¯ä¸ªè´¨å› æ•°çš„æŒ‡æ•° å– æ‰€æœ‰æ•°å­—å¯¹åº”è´¨å› æ•°æŒ‡æ•°çš„ \\(\\max\\)ã€‚ ä¸€ä¸ªæ•°å­—å˜æˆ \\(1\\) ç›¸å½“äºå¯¹äº LCM ä»€ä¹ˆéƒ½ä¸æä¾›, é‚£ä¹ˆä»€ä¹ˆæ—¶å€™ä¼šå¯¼è‡´ LCM å˜åŒ–å‘¢? é¦–å…ˆä»–çš„æŸä¸€ä¸ªè´¨å› æ•°æŒ‡æ•°è¦å’Œ LCM å¯¹åº”çš„ç›¸åŒ, å…¶æ¬¡è¿™ä¸ªæœ€å¤§å€¼åœ¨æ‰€æœ‰æ•°å­—ä¸­æ˜¯å”¯ä¸€çš„ã€‚ ä¸¤ä¸ª unordered_map å®ç°ï¼š mx[i] è®°å½•è´¨å› æ•° \\(i\\) å‡ºç°è¿‡çš„æœ€å¤§æŒ‡æ•°æ˜¯å¤šå°‘, cnt[i] è®°å½•æœ‰å¤šå°‘ä¸ªæ•°å­—å¯¹åº”è¿™ä¸ªæœ€å¤§æŒ‡æ•°ã€‚ é‚£ä¹ˆä¸€ä¸ªæ•°å­—æœ‰è´¡çŒ®ä¹Ÿå°±å¯¹åº”äº e[i]==mx[i] &amp;&amp; cnt[i]==1 ã€‚ æ­¤å¤–æ²¡æœ‰å½±å“çš„æ‰€æœ‰æ•°å­—æ€»ä½“ä¼šå¯¹ç­”æ¡ˆäº§ç”Ÿä¸€ä¸ªè´¡çŒ®, å³åŸæœ¬æ‰€æœ‰æ•°çš„ LCM ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;using ld = long double;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 200007#define fr first#define sc second#define pb push_back#define mp make_pair#define pii pair&lt;int, int&gt;unordered_map&lt;int, int&gt; mx, cnt;vector&lt;pii&gt; s[N];int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; int m = rd(); for (int j = 1; j &lt;= m; ++j) &#123; int a = rd(), b = rd(); s[i].pb(mp(a, b)); if (mx[a] &lt; b) &#123;mx[a] = b; cnt[a] = 1;&#125; else if (mx[a] == b) ++cnt[a]; &#125; &#125; bool fl = 0; int ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; bool tag = 0; for (auto [a, b] : s[i]) &#123; if (mx[a] == b &amp;&amp; cnt[a] == 1) &#123;tag = 1; break;&#125; &#125; if (tag) ++ans; else fl = 1; &#125; ans += fl; printf(&quot;%d\\n&quot;, ans); return 0;&#125; F - Select Edges ç»™å®šä¸€æ£µæ ‘, æ¯æ¡è¾¹æœ‰ä¸€ä¸ªè¾¹æƒ \\(w\\), æ¯ä¸ªç‚¹æœ‰ä¸€ä¸ªé™åˆ¶ \\(d_i\\) ã€‚ é€‰ä¸€ä¸ªè¾¹é›†, ä½¿å¾—æ¯ä¸ªç‚¹ç›¸é‚»çš„è¾¹åœ¨è¿™ä¸ªé›†åˆé‡Œçš„ä¸ªæ•°ä¸è¶…è¿‡ \\(d_i\\), å¹¶ä¸”æœ€å¤§åŒ–é›†åˆé‡Œè¾¹çš„ \\(\\sum w\\) ã€‚ è®¾ \\(f[i][0 / 1]\\) è¡¨ç¤ºèŠ‚ç‚¹ \\(i\\) åŠå…¶å­æ ‘å†…, æ˜¯å¦è¦é€‰ \\(i\\) åˆ°çˆ¶äº²çš„è¾¹ \\((0/1)\\) ï¼Œ èƒ½å¾—åˆ°çš„æœ€å¤§ä»·å€¼ã€‚ ä¸é€‰åˆ°çˆ¶äº²çš„è¾¹: å°±æ˜¯æœ€å¤šæŠŠ \\(d_i\\) ä¸ªå„¿å­çš„è´¡çŒ®ä» \\(f [son] [0]\\) æ”¹ä¸º \\(f[s o n] [1] +w[u][son]\\) ï¼ŒæŒ‘èƒ½è´¡çŒ®æœ€å¤šçš„é€‰ï¼ˆä¿®æ”¹åè¾ƒä¿®æ”¹å‰å·®å€¼æœ€å¤§çš„ \\(d_i\\) ä¸ª) é€‰åˆ°çˆ¶äº²çš„è¾¹ï¼š å°±æ˜¯æœ€å¤šæŠŠ \\(d_i-1\\) ä¸ªå„¿å­çš„è´¡çŒ®ä» \\(f [son] [0]\\) æ”¹ä¸º \\(f[s o n] [1] +w[u][son]\\) ; ç‰¹æ®Šçš„å¦‚æœ \\(d_i=0\\) åˆ™ \\(f[i][1]=-\\mathrm{inf}\\) ç›´æ¥ DP å°±å¥½äº†, å¤æ‚åº¦æ˜¯ \\(O(n \\log n)\\) çš„ï¼ˆå› ä¸ºæ¶‰åŠåˆ°å„¿å­è´¡çŒ®çš„æ’åºï¼‰ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;using ld = long double;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 300007#define fr first#define sc second#define pb push_back#define mp make_pair#define pii pair&lt;int, int&gt;vector&lt;pii&gt; e[N];vector&lt;ll&gt; tmp;int d[N];ll f[N][2];void dfs(int u, int fa) &#123; ll sum = 0; for (auto [v, w] : e[u]) if (v != fa) dfs(v, u); tmp.clear(); for (auto [v, w] : e[u]) if (v != fa) &#123; sum += f[v][0]; tmp.push_back(f[v][1] + w - f[v][0]); &#125; sort(tmp.begin(), tmp.end()); reverse(tmp.begin(), tmp.end()); if (d[u] == 0) &#123; f[u][0] = sum; f[u][1] = -1e18; &#125; else &#123; f[u][0] = f[u][1] = sum; int len = tmp.size(); for (int i = 0; i &lt; len; ++i) &#123; if (tmp[i] &lt; 0) break; if (i &lt; d[u]) f[u][0] += tmp[i]; if (i &lt; d[u] - 1) f[u][1] += tmp[i]; &#125; &#125;&#125;int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) d[i] = rd(); for (int i = 1; i &lt; n; ++i) &#123; int u = rd(), v = rd(), w = max(0, rd()); e[u].pb(mp(v, w)); e[v].pb(mp(u, w)); &#125; dfs(1, 1); printf(&quot;%lld\\n&quot;, max(f[1][0], f[1][1])); return 0;&#125; G - Grid Card Game ç»™å®šä¸€ä¸ªæ•°å­—çŸ©é˜µ \\((1\\le H,W\\le 100)\\) ï¼Œé€‰å®šä¸€äº›è¡Œä¸€äº›åˆ—ï¼Œä½¿å¾—ï¼š è´Ÿæ•°çš„ä½ç½®æ‰€åœ¨è¡Œåˆ—ä¸èƒ½åŒæ—¶é€‰ä¸­ã€‚ å®šä¹‰ä¸€ä¸ªä½ç½®è¢«è¦†ç›–å½“ä¸”ä»…å½“æ‰€åœ¨è¡Œ/åˆ—è¢«è¦†ç›–ï¼Œæœ€å¤§åŒ–è¢«è¦†ç›–çš„ä½ç½®æƒå€¼å’Œã€‚ å‡è®¾æŠŠæ‰€æœ‰éè´Ÿæ•°éƒ½é€‰äº†ï¼Œè€ƒè™‘æœ€å°å‰²è¡¨ç¤ºé€‰æ‹©éœ€è¦äº§ç”Ÿçš„ä»£ä»·ï¼Œä¸¤æ’ç‚¹å·¦è¾¹è¡¨ç¤ºè¡Œå³è¾¹è¡¨ç¤ºåˆ—ã€‚ å‡å¦‚é€‰ç¬¬ \\(i\\) è¡Œï¼Œä»£ä»·å°±æ˜¯è¯¥è¡Œçš„è´Ÿå€¼çš„å’Œ \\((S, R_i,-\\sum_j\\left[A_{i, j}&lt;0\\right] A_{i j})\\) å‡å¦‚é€‰ç¬¬ \\(i\\) åˆ—ï¼Œä»£ä»·å°±æ˜¯è¯¥åˆ—çš„è´Ÿå€¼çš„å’Œ \\((C_i, T,-\\sum_j\\left[A_{j, i}&lt;0\\right] A_{j i})\\) æ¥ä¸‹æ¥ä¸¤æ’ç‚¹ä¹‹é—´çš„è¾¹è¡¨ç¤ºå¯¹åº”æ ¼å­çš„çŠ¶æ€ï¼Œå‰²æ‰è¡¨ç¤ºé€‰æ‹©äº†å¯¹åº”è¡Œåˆ—éƒ½æœªé€‰ è‹¥ \\(A_{x,y}\\ge 0\\) ï¼Œåˆ™è¡Œåˆ—éƒ½æœªé€‰çš„ä»£ä»·å°±æ˜¯æ‰£æ‰è¿™ä¸ªä½ç½®çš„è´¡çŒ® \\((R_i, C_j,A_{i j})\\) è‹¥ \\(A_{x,y}&lt;0\\) ï¼Œåˆ™æ‰€åœ¨è¡Œåˆ—ä¸èƒ½åŒæ—¶é€‰ï¼Œå³ä¸å…è®¸å·¦å³éƒ½è¢«å‰²æ‰ï¼Œé‚£ä¹ˆé™åˆ¶çš„æ–¹æ³•å°±æ˜¯å¼ºåˆ¶ä¸­é—´çš„è¾¹è¢«å‰²ï¼Œå³ Ex - Yet Another Path Counting ç»™å®šä¸€ä¸ªçŸ©é˜µ \\(A_{n \\times n}(1 \\leq n \\leq 400)\\), ä»æŸä¸ªæ ¼å­å‡ºå‘, æ¯æ¬¡å¯ä»¥å‘å³æˆ–å‘ä¸‹èµ°ã€‚é—®èµ·ç‚¹ç»ˆç‚¹çš„æ•°å­—ç›¸åŒçš„è·¯å¾„æœ‰å¤šå°‘æ¡? é¦–å…ˆæšä¸¾æ•°å­—æ˜¯å¤šå°‘ï¼Œç„¶åè€ƒè™‘è®¡ç®—è¿™ä¸ªæ•°å­—å¯¹åº”çš„æ‰€æœ‰ç‚¹ä¹‹é—´çš„è´¡çŒ®ã€‚æ ¹æ®æ¯ç§æ•°å­—å‡ºç°æ¬¡æ•°è®¨è®º: å¦‚æœå‡ºç°æ¬¡æ•°ä¸è¶…è¿‡ \\(n\\), é‚£ä¹ˆç›´æ¥æš´åŠ›æšä¸¾ä»»æ„ä¸¤ä¸ªä½ç½®ç®—è´¡çŒ®, ç­”æ¡ˆæ˜¯ \\(\\left(\\begin{array}{c}\\Delta x+\\Delta y \\\\ \\Delta x\\end{array}\\right)\\) ã€‚ å¤æ‚åº¦æ˜¯ \\(O\\left(\\sum_{\\sum c n t_i=n^2, c n t_i \\leq n} c n t_i^2\\right) \\leq O\\left(n \\times n^2\\right)=O\\left(n^3\\right)\\) ï¼Œç”¨ \\(a^2+b^2 \\leq(a+b)^2\\) æ”¾ç¼©ä¸€ä¸‹ã€‚ å¦‚æœå‡ºç°æ¬¡æ•°è¶…è¿‡ \\(n\\), é‚£ä¹ˆç§ç±»æ•°ä¸ä¼šè¶…è¿‡ \\(n\\) ä¸ª, å¯¹æ¯ç§é¢œè‰²è·‘ä¸€ä¸ª \\(O\\left(n^2\\right)\\) çš„ DPï¼š è¿™ä¸ª DP å’Œ AGC001E çš„æ–¹æ³•æ˜¯ä¸€æ ·çš„ï¼Œè®¾ f[i][j] è¡¨ç¤ºæ‰€æœ‰å¯èƒ½çš„èµ·ç‚¹èµ°åˆ° \\((i,j)\\) çš„æ€»æ–¹æ¡ˆæ•°ã€‚ f[i][j] = f[i - 1][j] + f[i][j - 1] ï¼Œæ­¤å¤–å¦‚æœè¿™ä¸ªç‚¹æ˜¯æˆ‘ä»¬è¦çš„é¢œè‰²è¿˜è¦ f[i][j]++ ã€‚ å› æ­¤æ€»å¤æ‚åº¦ä¹Ÿæ˜¯ \\(O(n^3)\\) çš„ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;using ld = long double;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 1007#define NN 407#define M 160007#define mod 998244353#define pb push_back#define mp make_pair#define pii pair&lt;int, int&gt;int n, c[N][N], a[NN][NN], f[NN][NN], ans;vector&lt;pii&gt; pos[M];inline void calc(int col) &#123; memset(f, 0, sizeof(f)); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) &#123; f[i][j] = (f[i - 1][j] + f[i][j - 1]) % mod; if (a[i][j] == col) &#123; f[i][j] = (f[i][j] + 1) % mod; ans = (ans + f[i][j]) % mod; &#125; &#125;&#125;int main() &#123; c[0][0] = 1; for (int i = 1; i &lt; N; ++i) &#123; c[i][0] = 1; for (int j = 1; j &lt;= i; ++j) c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % mod; &#125; n = rd(); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) &#123; a[i][j] = rd(); pos[a[i][j]].push_back(mp(i, j)); &#125; for (int i = n * n; i; --i) &#123; if (pos[i].size() &gt; n) calc(i); else &#123; int sz = pos[i].size(); for (int j = 0; j &lt; sz; ++j) for (int k = 0; k &lt; sz; ++k) &#123; auto [sx, sy] = pos[i][j]; auto [tx, ty] = pos[i][k]; if (tx &lt; sx || ty &lt; sy) continue; ans = (ans + c[tx - sx + ty - sy][tx - sx]) % mod; &#125; &#125; &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125;","categories":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://blog.gyx.me/categories/AtCoder/"},{"name":"AtCoder Beginner Contest","slug":"AtCoder/AtCoder-Beginner-Contest","permalink":"http://blog.gyx.me/categories/AtCoder/AtCoder-Beginner-Contest/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"},{"name":"Number Theory","slug":"Number-Theory","permalink":"http://blog.gyx.me/tags/Number-Theory/"},{"name":"Threshold Optimization","slug":"Threshold-Optimization","permalink":"http://blog.gyx.me/tags/Threshold-Optimization/"},{"name":"Counting","slug":"Counting","permalink":"http://blog.gyx.me/tags/Counting/"}]},{"title":"Sophomore Year","slug":"life/sophomore","date":"2022-07-05T14:14:43.000Z","updated":"2023-03-20T16:56:01.716Z","comments":true,"path":"life/sophomore/","link":"","permalink":"http://blog.gyx.me/life/sophomore/","excerpt":"","text":"ä»Šå¤©æ˜¯ 2021 å¹´ 7 æœˆ 6 æ—¥ï¼Œæ˜ŸæœŸä¸‰ã€‚ ä¸¤å¹´å‰çš„ä»Šå¤©ï¼Œé«˜è€ƒçš„å‰å¤œã€‚æ‹…å¿ƒæ„Ÿå†’ä¸æ•¢å¼€ç©ºè°ƒï¼Œç‡¥çƒ­åœ°èººåœ¨åºŠä¸Šï¼Œè¾—è½¬åä¾§ã€‚ ç¢°å·§æ˜¨æ™šåˆæ¢¦åˆ°äº†è¿˜åœ¨é«˜ä¸­ï¼Œå›°æ‰°åœ¨æ—¶æ—¶åˆ»åˆ»çš„ææƒ§ä¸­ï¼ŒæƒŠé†’åä¹…ä¹…æ‰ååº”è¿‡æ¥ï¼Œå·²ç»ä¸Šäº†ä¸¤å¹´å¤§å­¦äº†ã€‚ æ­£å¥½ä»Šå¤© 22 çº§ç­åŠ©çš„è˜ç”¨æ­£å¼ç¡®å®šä¸‹æ¥äº†ï¼Œå¤§äºŒçš„ç”Ÿæ´»ç®—æ˜¯å°˜åŸƒè½å®šï¼Œå›é¡¾ä¸€ä¸‹è¿™ä¸€å¹´ã€‚ ç®—æ³•ç«èµ› é¦–å…ˆè°ˆç«èµ›ï¼Œè¿™ä¸€å¹´ç®—æ˜¯ç»å†äº†å¾ˆå¤šäº‹æƒ…ï¼Œæ‰“äº†ä¸€å¹´çš„é“¶ï¼Œä½†æ˜¯å¯¹ç«èµ›çš„æ„Ÿæƒ…ç»å†äº†å¾ˆå¤šå˜åŒ–ã€‚ å¤§æ¦‚ä»å»å¹´ 7 æœˆä»½çš„æ²ˆé˜³é“¶é¦–å¼€å§‹ï¼Œè‡ªå·±è¿›å…¥äº†ä¸€ä¸ªç›®æ ‡å¾ˆä¸æ˜ç¡®çš„æ—¶æœŸã€‚ æš‘å‡å¤šæ ¡æ‰“çš„ä¸€èˆ¬ï¼Œé™¤æ­¤å¤–ä¹Ÿæ²¡æœ‰è¿›è¡Œå¤ªå¤šçš„è®­ç»ƒã€‚é˜Ÿå†…æ’ååŸºæœ¬ç¨³å®šåœ¨ç¬¬ä¸‰åçš„ä½ç½®ï¼ˆå’Œå‰åéƒ½æœ‰ä¸€å®šè·ç¦»ï¼‰ã€‚ æ¸©æ°´ç…®é’è›™ï¼Œæ²¡æœ‰ç´§å¼ æ„Ÿï¼Œä¹Ÿæ²¡æœ‰ä»€ä¹ˆå¤ªå…·ä½“çš„ç›®æ ‡ã€‚å°±è¿™æ ·æµ‘æµ‘å™©å™©çš„æ‰“äº†ç½‘ç»œèµ›ã€CCPC æ¡‚æ—é“¶ã€ICPC æ²ˆé˜³é“¶ã€‚ å¯’å‡å®‰æ’çš„å¾ˆç´§ï¼Œé™¤äº†ç®—æ³•ç«èµ›è¿˜æ’äº†æ•°æ¨¡ç¾èµ›é›†è®­ã€DL &amp; CV çš„å‡æœŸäº¤æµè¯¾ç¨‹ã€å…¼èŒæ•™å°å­© C è¯­è¨€ã€‚ ä½†å°±æœ€åçš„ç»“æœæ¥çœ‹ï¼Œå¯’å‡å¯ä»¥è¯´ç¢Œç¢Œæ— ä¸ºã€‚ç¾èµ›æ‹¿äº† S å¥–ï¼Œçº¿ä¸Šäº¤æµæ²¡å­¦åˆ°å¤ªå¤šï¼Œç«èµ›çš„åˆ·é¢˜é‡åªèƒ½è¯´ä¿æŒæ°´å¹³ã€‚ å¦‚ä½•è¯„ä»· 2022 å¹´ ICPC æ˜†æ˜èµ›åŒºï¼Ÿ å¼€å­¦ä¹‹åä¸ºäº†å¤‡æˆ˜çœèµ›å’Œæ˜†æ˜ï¼Œè®­ç»ƒé‡åŠ äº†ä¸å°‘ï¼Œä¹Ÿæ˜¯æœ‰ç‚¹é­”æ€”çš„ä¸€æ®µæ—¶é—´ã€‚ 3 æœˆæŸå¤©çœ‹åˆ°äº†ä¸€ä¸ªäººçš„ CodeForces æ»¡å±ç»¿è‰²ï¼Œæœ‰ç‚¹å—åˆºæ¿€ï¼Œäºæ˜¯è‡ªå·±ä¹Ÿç¦»è°±åœ°è¿ç»­æ‰“å¡äº†è¿‘ 50 å¤©ã€‚ æœŸé—´è¯¾å‡ ä¹éƒ½æ²¡å¬ï¼Œä½œä¸šéƒ½å°½é‡ç”¨æœ€çŸ­çš„æ—¶é—´è§£å†³æ‰äº†ï¼Œè®¡ç»„å®éªŒä¹Ÿå’Œå†¯è€å¸ˆè¯´å…¨éƒ¨éƒ½å †åˆ°æ¯”èµ›åéªŒæ”¶ã€‚ äºæ˜¯åˆ°äº†æµ™æ±Ÿçœèµ›å’Œæ˜†æ˜ã€‚å› ä¸ºç–«æƒ…å„ç§å»¶æœŸï¼Œä¸¤ä¸ªæ¯”èµ›åœ¨åŒä¸€ä¸ªå‘¨æœ«çš„ä¸¤å¤©ä¸¾åŠã€‚ çœèµ›æ‰“çš„å¾ˆé¡ºåˆ©ï¼Œå‰ä¸¤ä¸ªå°æ—¶å‡ æ¬¡æ¦œä¸€ï¼Œæœ€åå› ä¸ºåšä¸åŠ¨æœŸæœ›é¢˜ E æ‹¿äº†ç¬¬å››ï¼Œä¸è¿‡ä¹Ÿç®—æ˜¯ä¸é”™çš„æˆç»©ã€‚ æ˜†æ˜æ‰“ä¹‹å‰è§‰å¾—ä¸€åˆ‡å‡†å¤‡çš„éƒ½è¿˜ä¸é”™ï¼Œç”šè‡³è¿˜æœ‰ Eva åœ¨åšå¿—æ„¿è€…ï¼Œåº”è¯¥ä¼šå¾ˆè¸å®ã€‚ ç„¶è€Œæ­£èµ›å¼€å§‹ä¹‹åå°±å‚»çœ¼äº†ã€‚é¦–å…ˆæ˜¯å¤§é‡çš„æœŸæœ›æ¦‚ç‡é¢˜ç›®ï¼Œç­¾åˆ°æƒ³ä¸å‡ºæ¥ï¼›æ¥ä¸‹æ¥æ¯”èµ›èŠ‚å¥å®Œå…¨æ²¡ä½“éªŒè¿‡ï¼Œ1h è¿‡äº†ä¸€é¢˜ï¼Œç„¶åä¸€ç›´æŒç»­åˆ° 4h æ‰æœ‰è¿‡é¢˜ã€‚æœŸé—´ä¸€ç›´è®©è‡ªå·±å†·é™ä¸‹æ¥ï¼Œå®‰æ…°è‡ªå·±æŠŠæœ‰æƒ³æ³•çš„é¢˜éƒ½è¿‡äº†å°±æ²¡é—®é¢˜ï¼Œä½†æ˜¯å¿ƒé‡Œä¸€ç›´å¾ˆæ…Œã€‚ç›´åˆ°æœ€åçœŸçš„ä¸‰é¢˜ç»“æŸäº†ï¼Œè‡ªå·±è¿˜æ²¡æœ‰ååº”è¿‡æ¥å‘ç”Ÿäº†ä»€ä¹ˆã€‚ å°è±¡å¾ˆæ·±çš„æ˜¯ Eva èµ°è¿‡æ¥ååœ¨æˆ‘æ—è¾¹ï¼Œå“­äº†å‡ºæ¥ï¼Œæˆ‘é—®å¥¹ä¸ºä»€ä¹ˆå“­ï¼Œå¥¹è¯´çœŸçš„æ›¿æˆ‘å¾ˆä¼¤å¿ƒã€‚ ååº”è¿‡æ¥ä¹‹åï¼Œæƒ³æƒ³è‡ªå·±èŠ±äº†å¤§åŠä¸ªå­¦æœŸè®­ç»ƒï¼Œè¯¾ç¨‹éƒ½å¿«ç»“æŸäº†ï¼Œä»€ä¹ˆéƒ½æ²¡å¼€å§‹å­¦ï¼›ç«èµ›ä¹Ÿæ²¡æ‹¿åˆ°æƒ³è¦çš„å¥–é¡¹ï¼Œç”šè‡³å·®ä¸¤åå°±è¦æ‰“é“œï¼›æ­£é€¢å½“å¤©æ˜¯ 2022 çš„å¤šçœè”åˆçœé€‰ã€‚ä¸€åˆ‡éƒ½è®©æˆ‘å›å¿†èµ·äº†å½“å¹´çœé€‰é€€å½¹æ—¶é‚£æ®µé»‘æš—çš„æ—¥å­ï¼Œæ— åŠ›æŒ£æ‰ï¼Œä¹Ÿå¾ˆæƒ³å“­ã€‚ å½“æ™šè‡ªç„¶æ˜¯åˆåšäº†å™©æ¢¦ï¼Œæ—¶é—´çº¿ååˆ†çš„æ··ä¹±ï¼Œåˆæ˜¯åˆšé€€å½¹å›å»å­¦æ–‡åŒ–è¯¾ï¼Œåˆæ˜¯èµ›åœºä¸Šè‡ªå·±ä¸€ä¸ªåˆä¸€ä¸ªé”™è¯¯çš„å†³å®šã€‚ ä»¿ä½›è‡ªå·±åˆè¦é¢å¯¹ç«èµ›æ‰“çš„ä¸å¥½å°±ä¼šé€€å½¹ï¼Œé€€å½¹å°±è¦å›å»é¢å¯¹é‚£æ®µæ•´æ—¥æ‹…æƒŠå—æ€•ã€ç”Ÿæ´»åœ¨é«˜å‹å’Œææƒ§ä¸­çš„æ–‡åŒ–è¯¾ç”Ÿæ´»ã€‚ æ˜†æ˜ä¹‹åç»å†çš„ç”Ÿæ´»ä¹Ÿç¡®å®åƒé«˜ä¸­é€€å½¹åè¡¥æ¬ ä¸‹çš„å€ºï¼Œä¸Šè¯¾å¬ä¸æ‡‚ï¼Œä½œä¸šä¸ä¼šåšï¼Œè®¡ç®—æœºç»„æˆåŸç†å››äº”ä¸ªå¤§å®éªŒä¸€ç‚¹è¿˜æ²¡å¼€å§‹å†™ï¼ˆç”šè‡³æ˜¯è¿˜æ²¡å­¦ä¼šï¼‰ã€‚æœ€å™©æ¢¦çš„æ˜¯æœŸæœ«å­£ä¹Ÿå¼€å§‹äº†ï¼Œåœ¨å¤§å®¶éƒ½å¼€å§‹å¤ä¹ çš„æ—¶å€™ï¼Œè‡ªå·±ä»å¤´å¼€å§‹ã€‚ ä¹‹åäº”æœˆçš„æŸå¤©ï¼Œå› ä¸ºè¦å®£ä¼ è¿™ä¸ªèµ›å­£çš„ç»“æœï¼Œé›†è®­é˜Ÿå¼€äº†ä¸€æ¬¡ä¼šï¼Œç„¶åæ‹é›†ä½“ç…§ã€‚ å¼€ä¼šçš„æ—¶å€™ï¼Œåˆ˜è€å¸ˆè°ˆåˆ°äº†æš‘å‡ç»„é˜Ÿçš„äº‹æƒ…ï¼šâ€œåŸåˆ™ä¸Šè‡ªç”±ç»„é˜Ÿï¼Œå¤§å®¶æ•å¼€è¯´ï¼ŒåŸæœ‰çš„é˜Ÿä¼ä¹Ÿå¯ä»¥é‡ç»„ï¼Œä¸è¦æ‹¿é˜Ÿä¼ç£¨åˆçš„å¥½è¯´äº‹æƒ…ï¼Œç•™ç»™ç£¨åˆçš„æ—¶é—´æœ‰å¾ˆå¤šã€‚â€ å¬å®Œæˆ‘çªç„¶æœ‰äº†é‡ç»„çš„æƒ³æ³•ï¼Œè™½ç„¶æ˜†æ˜çˆ†ç‚¸çš„ä¸»è¦åŸå› æ˜¯æˆ‘å†³ç­–å¤±è¯¯ï¼Œä½†æ˜¯è¿™ä¸ªèµ›å­£çš„é˜Ÿä¼ç¡®å®ä¹Ÿæœ‰æ˜æ˜¾çš„é—®é¢˜ã€‚ ä¹‹åä¹Ÿæœ‰ä¸¤ä¸ªæ¯”è¾ƒå·§åˆçš„äº‹æƒ…è®©æˆ‘çœŸçš„å¼€å§‹æ€è€ƒè¿™ä»¶äº‹æƒ…ã€‚ä¸€ä¸ªæ˜¯åœ¨é«˜çº§æ•°æ®ç»“æ„è¯¾ä¸Šï¼Œåˆ˜è€å¸ˆçªç„¶é—®æˆ‘ï¼Œæˆ‘ä»¬é˜Ÿè¦ä¸è¦é‡ç»„ã€‚å¦ä¸€ä¸ªæ˜¯æ°å¥½æœ‰ä¸€ä¸ªå®åŠ›æ¯”è¾ƒå¼ºçš„é˜Ÿä¼ä¼šæ‹†æ•£ï¼Œå…¶ä¸­ä¸€ä¸ªé˜Ÿå‘˜çš„é•¿å¤„æˆ‘è®¤ä¸ºæ¯”è¾ƒäº’è¡¥ã€‚ ä½†æ˜¯æå‡ºæ¢é˜Ÿå‹è¿™ä¸ªäº‹æƒ…ç¡®å®æ¯”è¾ƒå°´å°¬ï¼Œé¦–å…ˆæ‰“äº†ä¸€å¹´é“¶å¹¶ä¸æ˜¯æŸä¸€ä¸ªäººçš„é—®é¢˜ï¼Œå…¶æ¬¡ç¡®å®è¿™åªæ˜¯æˆ‘è‡ªå·±çš„æƒ³æ³•ã€‚è‡ªå·±æ ¹æœ¬ä¸çŸ¥é“è¯¥å¦‚ä½•å¼€å£å•†é‡è¿™ä¸ªäº‹æƒ…ï¼Œå¦‚æœçœŸçš„æ¢äº†ï¼Œæˆ‘ä¹Ÿä¸çŸ¥é“åº”è¯¥æ€ä¹ˆé¢å¯¹è¢«æ¢å‡ºå»çš„é˜Ÿå‹ã€‚ ç»å†äº†å¾ˆé•¿ä¸€æ®µçš„æƒè¡¡åï¼Œæˆ‘ç»ˆäºè¿˜æ˜¯å’Œåˆ˜è€å¸ˆå•†é‡äº†è¿™ä¸ªäº‹æƒ…ã€‚ç¬¬äºŒå¤©åˆ˜è€å¸ˆç»™æˆ‘çš„ç­”å¤æ˜¯ï¼šå¦‚æœæ‰€æœ‰äººéƒ½åŒæ„ï¼Œä»–å¯ä»¥åŒæ„ã€‚é‚£å¤©çº ç»“äº†å¾ˆä¹…ï¼Œæœ€åä¸€å£æ°”å’Œç›¸å…³çš„æ‰€æœ‰äººéƒ½èŠå®Œäº†ã€‚ä¸­é—´èŠå¤©çš„è¿‡ç¨‹çœŸçš„å¾ˆå®³æ€•ï¼Œè‡ªå·±ä¸çŸ¥é“æ€ä¹ˆå¼€å£ï¼Œä¹Ÿä¸å¥½æ„æ€å¼€å£ã€‚ä½†å¥½åœ¨æœ€åæ‰€æœ‰äººéƒ½åŒæ„äº†ï¼Œæ›´æ¢çš„é˜Ÿå‹ä¹Ÿå’Œå¦å¤–ä¸¤ä¸ªå¾ˆå¼ºçš„é€‰æ‰‹é‡æ–°ç»„äº†é˜Ÿä¼ã€‚ çœŸçš„å¾ˆæ„Ÿè°¢æ¶‰åŠåˆ°è¿™ä¸ªè‰°éš¾çš„è¿‡ç¨‹çš„æ‰€æœ‰äººï¼Œå¤§å®¶éƒ½å› ä¸ºæˆ‘çš„é€‰æ‹©æˆ–å¤šæˆ–å°‘å—åˆ°äº†ä¸€äº›å½±å“ï¼Œå°¤å…¶æ˜¯è¢«æ¢å‡ºå»çš„é˜Ÿå‹ã€‚åˆ°ç°åœ¨æˆ‘è¿˜æ˜¯å¾ˆå†…ç–šï¼ŒçœŸçš„å¾ˆæ„Ÿè°¢ä»–èƒ½ç†è§£æˆ‘çš„æƒ³æ³•ã€‚ æ¥ä¸‹æ¥çš„æ¯”èµ›åªå‰©ä¸‹äº†æ ¡èµ›ï¼Œç¬¬ 26 æ¬¡ CSP å’Œè“æ¡¥æ¯çš„å›½èµ›ã€‚è¿™æ®µæ—¶é—´å‡ ä¹éƒ½åœ¨åšæœŸæœ«å¤§ä½œä¸šï¼Œå¶å°”åšå‡ é“é¢˜ä¿æŒæ°´å¹³ã€‚ ä½†æ„å¤–çš„æ˜¯è¿™å‡ åœºæ¯”èµ›æ‰“çš„éƒ½è¿˜å¯ä»¥ï¼Œæ­ç”µæ ¡èµ›é æ‰‹é€Ÿæ‹¿åˆ°äº†ä¸€ç­‰å¥–ï¼ŒCSP - 26 é å¡å¸¸ AK äº†ã€‚å¦‚ä½•è¯„ä»· CSP - 26 æ­¤å¤– 5 æœˆåº•çš„æ—¶å€™åˆ˜è€å¸ˆæ‰¾åˆ°æˆ‘ï¼Œè®©æˆ‘ä½œä¸ºè´Ÿè´£äººç»„ç»‡ä¸€ä¸‹ä»Šå¹´å¹¿è¥¿çœèµ›çš„å‡ºé¢˜ï¼Œå…´å¥‹åˆæœ‰ç‚¹ç´§å¼ ã€‚ äºæ˜¯åœ¨æœŸæœ«å‰çš„å‡ ä¸ªæ˜ŸæœŸï¼Œæ‹‰äº†å‡ºé¢˜å›¢é˜Ÿï¼Œå¤§å®¶ä¸€èµ·æŒ¤æ—¶é—´å‡ºé¢˜é€ é¢˜ï¼Œè¿˜åœ¨è€ƒè¯•å‘¨æœŸé—´æ‹‰äº†å‡ ä¸ªé›†è®­é˜Ÿå‘˜éªŒé¢˜ã€‚ æœŸæœ«æœ€åä¸€é—¨è€ƒå®Œå½“æ™šå¼€å§‹èµ¶å·¥é¢˜ç›®çš„æœ€åä¸€éƒ¨åˆ†ï¼Œé…ç½®spj åˆ°äº†åŠå¤œä¸¤ç‚¹å¤šï¼Œç¬¬äºŒå¤©æ—©ä¸Šä¿® pdf ç‰ˆé¢˜é¢åˆå‘ç°äº†å¥½å¤šè¯­æ³•é”™è¯¯ï¼Œæ”¹å®Œåå¤è¯»äº†å¥½å‡ éä¹‹åç»ˆäºåœ¨ ddl å‰æ•´ç†å¥½äº†ã€‚ å¥½åœ¨æœ€åä¸¤å¤©çš„æ¯”èµ›éƒ½å¾ˆåœ†æ»¡ï¼Œç¬¬ä¸€æ¬¡åšæ­£å¼æ¯”èµ›çš„è´Ÿè´£äººï¼Œæ„Ÿè§‰æ”¶è·å¾ˆå¤šï¼ˆ è‡³å°‘å­¦ä¼šäº†ç”¨ PTA å’Œ Polygon ï¼‰ã€‚ æŠŠ Colin å’Œ Eva çš„åå­—ç•™åœ¨ä¸€åœºæ­£å¼èµ›çš„é¢˜é¢é‡Œï¼Œä»¥åŠç»™å¥½å¤šäººè®²é¢˜éƒ½æ˜¯æ›¾ç»çš„æ¢¦æƒ³å•Šã€‚å¦‚ä½•è¯„ä»·ç¬¬äº”å±ŠGXCPC æ€»è€Œè¨€ä¹‹ï¼Œè¿™ä¸€å¹´çš„ç«èµ›ç»å†è™½ç„¶æ¯”è¾ƒæ›²æŠ˜ï¼Œä½†ä¹Ÿç¡®å®è®©æˆ‘è®¤çœŸåœ°æ€è€ƒäº†è‡ªå·±åˆ°åº•æƒ³è¦ä»€ä¹ˆã€‚ ä¸‹ä¸€ä¸ªèµ›å­£å¤§æ¦‚ç‡æ˜¯æœ€åä¸€å¹´å‚èµ›äº†ï¼Œå¸Œæœ›è‡ªå·±åœ¨æƒ³è¦æ‘†çƒ‚çš„æ—¶å€™èƒ½ä»è¿™ä¸€å¹´çš„ç»å†ä¸­æ±²å–åŠ¨åŠ›ï¼ŒåŠ æ²¹ã€‚ è¯¾å†…å­¦ä¹  å•ä»æˆç»©ä¸Šæ¥çœ‹ï¼Œå’Œå¤§ä¸€ç›¸æ¯”å¯èƒ½è¯¾ç¨‹éš¾åº¦é™ä½äº†ï¼Œæ‰€ä»¥æˆç»©æ¯”å¤§ä¸€è¦å¥½ä¸€äº›ã€‚ å¤§äºŒä¸Šæ„å¤–åœ°æ‰“å‡ºäº†å†å²æœ€é«˜ç»©ç‚¹ï¼›å¤§äºŒä¸‹æŸé—¨å­¦åˆ†å¾ˆé‡çš„è¯¾å› ä¸ºæŸäº›åŸå› çˆ†ç‚¸äº†ï¼Œç»©ç‚¹æ²¡ç¨³ä½ï¼Œä¸è¿‡ä¹Ÿè¿‡å»äº†ã€‚ æˆç»©æ’‡å¼€ä¸è°ˆï¼Œè®°å½•å‡ é—¨æˆ‘è§‰å¾—å¾ˆæ”¶è·å¾ˆå¤šæˆ–å€¼å¾—æ¨èçš„è¯¾ç¨‹å’Œè€å¸ˆï¼Œä»…ä¾›å‚è€ƒã€‚ å½¢å¼è¯­è¨€ä¸è‡ªåŠ¨æœºï¼ˆé»„å­å–œè€å¸ˆï¼‰ï¼šæ”¶è·ä¸»è¦æ˜¯æ­¤å‰å¯¹è¿™ä¸ªé¢†åŸŸäº†è§£å¾ˆå°‘ï¼Œä¸Šå®Œèƒ½æ¯”è¾ƒå……åˆ†çš„äº†è§£åˆ°è¿™ä¸ªé¢†åŸŸçš„ä¸€äº›åŸºç¡€æ¨¡å‹ï¼Œå­¦ç¼–è¯‘çš„æ—¶å€™ä¹Ÿèƒ½è½»æ¾äº›ã€‚è¯¾ç¨‹ä¸­æ¶‰åŠåˆ°å¾ˆå¤šéå¸¸å¥½ç©çš„å°ç®—æ³•ï¼Œå…¶ä¸­çš„æ„é€ æ€è·¯ä¹Ÿæ˜¯æ¯”è¾ƒæœ‰æ„ä¹‰çš„ã€‚æˆ‘æœ€åæœŸæœ«è€ƒå‰è¿˜åœ¨æ²‰è¿·æ„é€ å›¾çµæœºæ— æ³•è‡ªæ‹”ï¼ˆè™½ç„¶éå¸¸é—æ†¾æœŸæœ«ä¸è€ƒï¼‰ æ•°å­—ç”µè·¯/è®¡ç®—æœºç»„æˆåŸç†ï¼ˆå†¯å»ºæ–‡è€å¸ˆï¼‰ï¼šä½œä¸ºä¸€ä¸ªå¯¹ç¡¬ä»¶ååˆ†åæ„Ÿçš„äººæ¥è¯´çœŸçš„å¾ˆæ„Ÿè°¢å†¯è€å¸ˆç¡¬é€¼ç€æˆ‘æŠŠåç¡¬çš„è¿™ä¸¤é—¨è¯¾å­¦å®Œäº†ã€‚ä½œä¸šå’Œå®éªŒçš„ä»»åŠ¡é‡éƒ½æ¯”è¾ƒå¤§ï¼Œä½†æ˜¯å†¯è€å¸ˆçœŸçš„éå¸¸è´Ÿè´£ï¼Œæœ‰ä»€ä¹ˆé—®é¢˜åŸºæœ¬éƒ½ä¼šä¸åŒå…¶çƒ¦çš„å›ç­”å®Œã€‚å¯¹æˆ‘è€Œè¨€ä¸»è¦æ”¶è·æ˜¯å­¦åˆ°äº†ä¸€ä¸ªè®¡ç®—æœºç³»çš„å­¦ç”Ÿåº”è¯¥çŸ¥é“çš„ç¡¬ä»¶ç›¸å…³å†…å®¹ã€‚ æ¦‚ç‡è®ºä¸æ•°ç†ç»Ÿè®¡ï¼ˆå¼ å®‰è€å¸ˆï¼‰ï¼šè€å¸ˆäººè¶…å¥½ï¼Œæˆè¯¾å¾ˆæ¸…æ™°ï¼Œè¦æ±‚å¾ˆæ˜ç¡®ï¼Œä½œä¸šé‡ä¸å¤§ï¼Œæ²»å¥½äº†æˆ‘çš„ç§¯åˆ†ææƒ§ç—‡ã€‚ å¯†ç å­¦ï¼ˆèƒ¡è€¿ç„¶è€å¸ˆï¼‰ï¼šæ¯”è¾ƒå…¨é¢çš„ä»‹ç»å¯†ç å­¦çš„åŸºç¡€å†…å®¹ï¼Œä¸Šè¯¾ä¹Ÿå¾ˆè½»æ¾ï¼Œå¯¹æ•°è®ºæœ‰ä¸€äº›è¦æ±‚ï¼ˆå¿«é€Ÿå¹‚å’Œé€†å…ƒï¼‰ã€‚ å½±è§†éŸ³ä¹é‰´èµï¼ˆå¾è‰³è€å¸ˆï¼‰ï¼šä¸Šè¯¾ä¸»è¦æ˜¯çœ‹ç”µå½±ï¼Œå¾ˆé€‚åˆåœ¨ç¹å¿™çš„è¯¾ç¨‹å®‰æ’ä¸­æ”¾æ¾ä¸€ä¸‹ã€‚éœ€è¦åšçš„äº‹æƒ…éå¸¸éå¸¸å°‘ï¼Œåªè¦åšå®Œè¦æ±‚çš„äº‹æƒ…å°±å¯ä»¥æ”¾å¿ƒæ‹¿å¾ˆå¥½å¾ˆå¥½çš„æˆç»©ï¼ˆä¸èƒ½å†æ˜è¯´äº†ï¼Œæ‡‚å¾—éƒ½æ‡‚å§ï¼‰ ç”µå­é’¢ç´ï¼ˆç››æ™¨è€å¸ˆï¼‰ï¼šè¿™ä¸ªè¯¾åé’¢ç´æ™®åŠå‘ï¼Œè¯¾ç¨‹è€ƒæ ¸ä¹Ÿä¸»è¦æ ¹æ®æ¯ä¸ªäººçš„åŸºç¡€å†³å®šï¼ŒæœŸæœ«è€ƒè¯•å°±æ˜¯ä¸€é¦–è‡ªé€‰æ›²ç›®ã€‚å› ä¸ºæˆ‘å’Œ Eva éƒ½æœ‰ä¸€äº›åº•å­ï¼Œæ‰€ä»¥ä¸Šè¯¾åŸºæœ¬å°±æ˜¯ä¸¤ä¸ªäººå¼¹æƒ³å¼¹çš„æ›²å­ï¼Œä¸€ä¸ªå­¦æœŸå¼¹äº†å¾ˆå¤šå››æ‰‹è”å¼¹éå¸¸å¼€å¿ƒï¼ŒæœŸæœ«ä¹Ÿé€‰æ‹©äº†å››æ‰‹è”å¼¹çš„æ–¹å¼ï¼Œé€‰çš„ã€Šæ‘‡ç¯®æ›²ã€‹ã€‚æ¨èçš„åŸå› ä¸»è¦æ˜¯å¾ˆéš¾æœ‰å…¶ä»–æ–¹å¼å¯ä»¥å¦‚æ­¤æ–¹ä¾¿çš„æ‘¸åˆ°é”®ç›˜ï¼Œæ‰€ä»¥æ¯”è¾ƒæ„Ÿå…´è¶£çš„åŒå­¦æ¨èè¯•ä¸€è¯•ï¼Œæ²¡å‘ï¼Œä½†æ˜¯å¦‚æœåœ¨æ„æˆç»©çš„è¯æœ€å¥½è¿˜æ˜¯æœ‰ä¸€ç‚¹é’¢ç´åŸºç¡€ã€‚ ä½“è‚²èˆè¹ˆï¼ˆè‘£æ™“æ³¢è€å¸ˆï¼‰ï¼šæ¯å‘¨éƒ½èƒ½å’Œ Eva å»è·³ä¸€æ¬¡èˆéå¸¸å¼€å¿ƒï¼ä¸Šè¯¾æ¯”è¾ƒè½»æ¾ï¼Œè€å¸ˆæ•™çš„å¾ˆå¥½ï¼Œè¿åŠ¨é‡å³ä½¿æ˜¯æˆ‘ä¹Ÿèƒ½æ’‘å¾—ä½ï¼Œæˆç»©å¯¹æˆ‘æ¥è¯´ä¹Ÿéå¸¸æ»¡æ„äº†ã€‚æ­¤å¤–è²Œä¼¼æœ‰å‡ ç»„åŒå­¦ç»è¿‡ä¸€ä¸ªå­¦æœŸçœŸçš„æˆäº†æƒ…ä¾£ï¼Œæœ‰éœ€æ±‚çš„åŒå­¦å¯ä»¥å»è¯•è¯•æ¡ƒèŠ±è¿ï¼ˆ æœªæ¥ å¤§äºŒè¿™ä¸€å¹´ä¸€ç›´åœ¨è€ƒè™‘æœªæ¥çš„å‘å±•ï¼Œå¦‚æœå†³å®šè¿›ä¼ä¸šçš„è¯ï¼Œå¯¹æˆ‘è€Œè¨€å…¶å®æœ¬ç§‘æ¯•ä¸šç›´æ¥ä¸Šç­å¯èƒ½æ¯”è¯»ç ”æ›´æœ‰æ•ˆã€‚ å€ŸåŠ©ä¸€äº›å¥‘æœºå’Œå°è¯•ï¼Œä¹Ÿè®©æˆ‘æ˜ç™½è‡ªå·±è¿˜æ˜¯æœ‰çƒ­çˆ±çš„ï¼Œæ‰€ä»¥å†³å®šè¯•ä¸€è¯•ï¼Œæœ¬ç§‘æ¯•ä¸šä¹‹åç»§ç»­è¯»ä¹¦ï¼Œå…ˆä¸å»å·¥ä½œå•¦ã€‚ å…³äºæ–¹å‘ï¼Œè¿˜æ˜¯å†³å®šç¦»å¼€æœºå™¨å­¦ä¹ è¿™ä¸ªé¢†åŸŸäº†ï¼Œéå¸¸æ„Ÿè°¢å¯¼å¸ˆèƒ½å¤Ÿç†è§£å’Œæ”¯æŒæˆ‘çš„æƒ³æ³•ã€‚ æ¯•ç«Ÿè¿˜å¹´è½»ï¼Œè¿˜æœ‰è¯•é”™çš„æœºä¼šï¼Œæ­¤æ—¶èƒ½æ¯”è¾ƒè½»æ¾åœ°æ”¾ä¸‹å¯¹å¤±è´¥çš„é¡¾è™‘ï¼Œå»è¿½æ±‚è‡ªå·±çš„å­¦æœ¯ç†æƒ³ä½•å°ä¸æ˜¯ä¸€ä»¶å¤§å¹¸äº‹ã€‚ æˆ‘ä»¬ æˆ‘ä»¬çš„çˆ±æƒ…åœ¨è¿™ä¸€å¹´é‡Œæœ‰å¾ˆå¤šå¾ˆæ„ŸåŠ¨çš„æ—¶åˆ»ï¼Œä¹Ÿæœ‰å¾ˆå¤šæ¬¡åµæ¶èµ°åˆ°ä½è°·ã€‚ æ—¶é—´é•¿äº†ä¸åƒåˆšå¼€å§‹è°ˆæ‹çˆ±é‚£æ ·æ¿€çƒˆï¼Œä½†æ˜¯æ—¥å¸¸å¹³é™ç”Ÿæ´»ä¸­çš„ä¸€æ¬¡æ¬¡ç›¸äº’æ‰¶æŒï¼Œæ¶¦ç‰©æ— å£°ã€‚ å…³äºçˆ±æƒ…ï¼Œè¿˜æ˜¯æ²¡æœ‰ä»€ä¹ˆå¤ªå¤šå¯ä»¥è®²å‡ºæ¥çš„ï¼Œæ‰€ä»¥åˆ†äº«å‡ ä¸ªè¿™ä¸€å¹´ä¸­æˆ‘è§‰å¾—å€¼å¾—çºªå¿µçš„äº‹æƒ…å§ï¼š ä¸€èµ·é€‰ä¿®äº†ç”µå­é’¢ç´ï¼ŒæœŸæœ«è€ƒæ ¸æ›²ç›®é€‰æ‹©äº†å››æ‰‹è”å¼¹ã€Šæ‘‡ç¯®æ›²ã€‹ æˆ‘é€šè¿‡å¤§äºŒä¸Šçš„ä½“æµ‹ï¼Œå¤§äºŒä¸‹ä¸€èµ·é€‰ä¿®äº†ä½“è‚²èˆè¹ˆï¼Œä½œä¸ºèˆä¼´ä¸€èµ·ä¸Šè¯¾å’Œè€ƒè¯• å°è±¡å¾ˆæ·±çš„æ˜¯å¤§äºŒä¸Šä½“æµ‹çš„æœ€åä¸€é¡¹ä¸€åƒç±³ï¼ŒEva æœ€åä¸¤åœˆå…¨ç¨‹é™ªæˆ‘è·‘å®Œï¼ŒæŒ‰ç…§å•†é‡å¥½çš„æ–¹æ¡ˆæ¯ 10 ç§’ç»™æˆ‘æŠ¥ä¸€æ¬¡æ—¶é—´ã€‚ æœ€åçš„ä¸€æ®µå†²åˆºçœŸçš„æ²¡æœ‰åŠ›æ°”äº†ï¼Œå®Œå…¨ç›¯ç€ç»ˆç‚¹çº¿çš„ Eva åœ¨è·‘ã€‚æœ€åä½“æµ‹åˆ†æ•°æ­£å¥½ 60 åˆ†ï¼Œ0.1 éƒ½æ²¡å¤šã€‚ å¤§äºŒä¸¤æ¬¡æœŸæœ«çš„çªå‡»å¤ä¹ ï¼Œèƒ½ä¸€èµ·æ‰¿å—ä½æœŸæœ«çš„å‹åŠ›ï¼Œæ¯”è¾ƒå¹³ç¨³çš„åº¦è¿‡ã€‚ å…¶å®ä¸»è¦æ˜¯å¸®æˆ‘å¤ä¹ ï¼Œå› ä¸ºæœ‰çš„è¯¾æˆ‘è€ƒè¯•å‰ä¸€å¤©è¿˜å•¥éƒ½ä¸ä¼šï¼Œ Eva ç»å¸¸å› ä¸ºå‹åŠ›å¤ªå¤§ä¼šå“­å‡ºæ¥ã€‚ å¤ä¹ æœŸé—´å‹åŠ›å¾ˆå¤§çš„ç¯å¢ƒä¸‹å¾ˆå®¹æ˜“å‘ç”Ÿäº‰åµï¼ŒçœŸçš„å¾ˆæ„ŸåŠ¨æˆ‘ä»¬èƒ½ä¸€èµ·æŒºè¿‡æ¥é‚£æ®µæ—¶é—´ï¼Œç”Ÿæ°”ä¹Ÿèƒ½å¿«é€Ÿè°ƒæ•´æƒ…ç»ªã€‚ æ•™ Eva å­¦ç®—æ³•ï¼Œ Eva èƒ½è¿›æ­ç”µå¥³é˜Ÿï¼Œå‚åŠ ä¸‹ä¸€ä¸ªèµ›å­£çš„å¥³ç”Ÿèµ›ï¼ˆEva è¿›é˜Ÿçš„æ—¶å€™æˆ‘çœŸçš„å¾ˆæ¿€åŠ¨ï¼‰ã€‚ ä¸€èµ·å»å½“ä¸‹ä¸€å±Šè‹±æ‰ç­çš„ç­åŠ©ï¼ˆå¤§ä¸€åˆšè°ˆæ‹çˆ±çš„æ—¶å€™å°±èŠèµ·æ¥è¿‡è¿™ä¸ªäº‹æƒ…ï¼Œå‘ç°æˆ‘ä»¬éƒ½æŒºå–œæ¬¢å¸¦å­¦å¼Ÿå­¦å¦¹çš„ï¼‰ã€‚ æœ€åå¾ˆæƒ³åˆ†äº«ä¸€å¥è¯ï¼Œåœ¨ä¸¤ä¸ªäººçš„æ„Ÿæƒ…é‡åˆ°é—®é¢˜çš„æ—¶å€™ï¼Œæˆ‘è§‰å¾—è¿™æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„è¡¡é‡è‡ªå·±åšçš„æ˜¯å¦æ­£ç¡®çš„æ ‡å‡†ã€‚","categories":[{"name":"Life & Blog","slug":"Life-Blog","permalink":"http://blog.gyx.me/categories/Life-Blog/"}],"tags":[]},{"title":"AtCoder Regular Contest 061","slug":"atcoder/arc061","date":"2022-07-01T09:20:14.000Z","updated":"2023-03-20T16:28:47.966Z","comments":true,"path":"atcoder/arc061/","link":"","permalink":"http://blog.gyx.me/atcoder/arc061/","excerpt":"","text":"C - Many Formulas ç»™å®šä¸€ä¸ªæ•°å­—ä¸²ï¼Œå¯ä»¥åœ¨ä»»æ„ä½ç½®æ·»åŠ åŠ å·ï¼Œé—®æ‰€æœ‰è¡¨è¾¾å¼ç»“æœçš„å’Œæ˜¯å¤šå°‘ã€‚ è€ƒè™‘ä¸€ä¸ªå‰ç¼€åé¢è¡¥ä¸€ä¸ªæ–°çš„æ•°å­—ï¼š + å¦‚æœæ–­å¼€ï¼Œé‚£ä¹ˆå‰ç¼€çš„è´¡çŒ®æ˜¯å‰é¢çš„ç»“æœ + å¦‚æœä¸æ–­å¼€ï¼Œé‚£ä¹ˆå‰ç¼€çš„è´¡çŒ®æ˜¯å‰é¢é™¤å»æœ€åä¸€æ®µ + æœ€åä¸€æ®µ \\(\\times 10\\) + æœ€åä¸€ä¸ªæ•°å­—çš„è´¡çŒ®å°±æ˜¯æ•°å€¼ \\(\\times 2^{len}\\) ï¼Œå³å¯èƒ½çš„åˆ’åˆ†æ–¹æ¡ˆæ•° è®° \\(f_i\\) è¡¨ç¤ºå‰ç¼€ \\(i\\) çš„ç­”æ¡ˆï¼Œ\\(g_i\\) è¡¨ç¤ºå‰ç¼€ \\(i\\) æœ€åä¸€æ®µçš„ç­”æ¡ˆï¼Œæœ‰ï¼š \\[ \\begin{array}{l} f_i &amp;= 2^i * digit_i + f_{i-1} + (f_{i-1} - g_{i-1}) + g_{i-1} \\times 10\\\\ g_i &amp;= 2^i * digit_i + g_{i-1} \\times 10 \\end{array} \\] 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt; using namespace std; using ll = long long; inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x; &#125; char s[11]; ll f[11], g[11]; int main() &#123; scanf(&quot;%s&quot;, s + 1); int len = strlen(s + 1); for (int i = 1, pw = 1; i &lt;= len; ++i, pw = pw * 2) &#123; f[i] = pw * (s[i] - &#x27;0&#x27;) + f[i - 1] * 2 + g[i - 1] * 9; g[i] = pw * (s[i] - &#x27;0&#x27;) + g[i - 1] * 10; &#125; printf(&quot;%lld\\n&quot;, f[len]); return 0; &#125; D - Snuke's Coloring ç»™å®šä¸€ä¸ª \\(H\\times W\\) çš„ç½‘æ ¼ï¼Œåˆå§‹æ‰€æœ‰ä½ç½®éƒ½æ˜¯ç™½è‰²ï¼Œç„¶åç»™å®š \\(n\\) ä¸ªç‚¹æŸ“æˆé»‘è‰²ã€‚ é—®æ‰€æœ‰çš„ä¹å®«æ ¼é‡Œï¼Œé»‘è‰²ç‚¹æ•°ä¸º \\(0\\dots 9\\) çš„ä¹å®«æ ¼åˆ†åˆ«æœ‰å¤šå°‘ä¸ªã€‚ åˆå§‹æ‰€æœ‰çš„ä¹å®«æ ¼éƒ½æ˜¯ç™½è‰²ï¼Œç„¶åæ¯æ¬¡åŠ å…¥ä¸€ä¸ªç‚¹æ¨¡æ‹Ÿä¸€ä¸‹å³å¯ã€‚ 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt; using namespace std; using ll = long long; inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x; &#125; unordered_map&lt;ll, bool&gt; vis; inline ll pos(int x, int y) &#123;return 1ll * x * 1000000000 + y;&#125; ll ans[10]; int main() &#123; int h = rd(), w = rd(); ans[0] = 1ll * (h - 2) * (w - 2); for (int n = rd(); n; --n) &#123; int x = rd(), y = rd(); for (int a = max(1, x - 2); a &lt;= min(x, h - 2); ++a) for (int b = max(1, y - 2); b &lt;= min(y, w - 2); ++b) &#123; int cnt = 0; for (int dx = 0; dx &lt; 3; ++dx) for (int dy = 0; dy &lt; 3; ++dy) cnt += vis[pos(a + dx, b + dy)]; --ans[cnt]; ++ans[cnt + 1]; &#125; vis[pos(x, y)] = 1; &#125; for (int i = 0; i &lt; 10; ++i) printf(&quot;%lld\\n&quot;, ans[i]); return 0; &#125; E - Snuke's Subway Trip \\(n\\) ä¸ªç‚¹ \\(m\\) æ¡è¾¹çš„æ— å‘å›¾ï¼Œæ¯ä¸ªè¾¹æœ‰ä¸€ä¸ªé¢œè‰²ã€‚ ä¸€ä¸ªè·¯å¾„çš„åˆå§‹ä»£ä»·æ˜¯ \\(1\\) ï¼Œæ¯æ¢ä¸€æ¬¡é¢œè‰²ä»£ä»· \\(+1\\) ï¼Œæ±‚ \\(1\\) åˆ° \\(n\\) çš„æœ€çŸ­è·¯ã€‚ è€ƒè™‘ç›´æ¥å»ºåˆ†å±‚å›¾ï¼ˆæ¯ä¸ªç‚¹çš„å®ç‚¹å»ºç«‹ \\(m\\) ä¸ªè™šç‚¹ï¼Œè™šç‚¹é—´è¿åŸå›¾çš„è¾¹ï¼‰ã€‚ çœŸå®çš„ç‚¹å‘å¯¹åº”çš„è™šç‚¹è¿è¾¹æƒä¸º \\(1\\) ï¼Œè™šç‚¹ä¹‹é—´è¿åŸå›¾çš„è¾¹è¾¹æƒä¸º \\(0\\) ï¼Œæœ€ç»ˆç­”æ¡ˆé™¤ \\(2\\) å³å¯ã€‚ å¯ä»¥å‘ç°æœ‰ç”¨çš„ç‚¹å…¶å®åªæœ‰ \\(\\mathcal{O}(n+m)\\) ï¼Œå› æ­¤å¯ä»¥ç›´æ¥å»ºå›¾åšï¼ˆç”¨ä¸€ä¸ª unordered_map ï¼‰ã€‚ ç„¶ååœ¨å›¾ä¸Šè·‘ 01-BFS å³å¯ï¼Œå¤æ‚åº¦ \\(\\mathcal{O}(n+m)\\) ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt; using namespace std; using ll = long long; inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x; &#125; #define N 500007 #define M 2000007 unordered_map&lt;int, int&gt; id[N]; int tot, hd[N]; struct node&#123;int to, nxt; bool w;&#125; e[M]; inline void add(int u, int v, bool w) &#123; e[++tot].to = v; e[tot].w = w; e[tot].nxt = hd[u]; hd[u] = tot; e[++tot].to = u; e[tot].w = w; e[tot].nxt = hd[v]; hd[v] = tot; &#125; int dis[N]; bool vis[N]; deque&lt;int&gt; q; int main() &#123; int n = rd(), m = rd(); int totn = n; for (int i = 1; i &lt;= m; ++i) &#123; int u = rd(), v = rd(), c = rd(); if (!id[u][c]) &#123;id[u][c] = ++totn; add(u, totn, 1);&#125; if (!id[v][c]) &#123;id[v][c] = ++totn; add(v, totn, 1);&#125; add(id[u][c], id[v][c], 0); &#125; memset(dis, 0x3f, sizeof(dis)); dis[1] = 0; q.push_back(1); while (!q.empty()) &#123; int u = q.front(); q.pop_front(); if (vis[u]) continue; vis[u] = 1; for (int i = hd[u], v; i; i = e[i].nxt) &#123; if (dis[u] + e[i].w &lt; dis[v = e[i].to]) &#123; dis[v] = dis[u] + e[i].w; e[i].w ? q.push_back(v) : q.push_front(v); &#125; &#125; &#125; printf(&quot;%d\\n&quot;, dis[n] == dis[0] ? -1 : dis[n] / 2); return 0; &#125; F - Card Game for Three ä¸‰ä¸ªäºº A,B,C ï¼Œæ¯ä¸ªäººåˆ†åˆ«æœ‰ \\(n,m,k\\) å¼ å¡ï¼Œæ¯å¼ å¡çš„å¡é¢éƒ½å¯èƒ½æ˜¯ A/B/C ä¹‹ä¸€ã€‚ ä» A å¼€å§‹ç¿»ç‰Œï¼Œæ¯æ¬¡ç¿»åˆ°çš„ç‰Œå­ä¸Šå†™çš„æ˜¯è°ï¼Œä¸‹ä¸€ä¸ªç¿»ç‰Œçš„å°±æ˜¯è°ã€‚ è½®åˆ°æŸä¸ªäººæ—¶ï¼Œå¦‚æœä»–æ²¡æœ‰ç‰Œäº†å°±èƒœåˆ©ï¼Œé—®æ€»å…± \\(3^{n+m+k}\\) ç§æ–¹æ¡ˆä¸­ï¼ŒA èƒœåˆ©çš„æ–¹æ¡ˆæ•°æœ‰å¤šå°‘ã€‚ è¿™é“é¢˜ç›®çš„å‡ºå‘ç‚¹å®Œå…¨æƒ³é”™äº†ï¼Œä¸èƒ½å°†ä¸‰ä¸ªäººåˆ†å¼€æƒ³ï¼Œå› ä¸ºæœ‰å¯èƒ½ä¼šæœ‰ A - B - C - A å¾ªç¯ã€‚ è€ƒè™‘å°†æ•´ä¸ªæ“ä½œåºåˆ—è¿èµ·æ¥ï¼ˆé•¿åº¦ \\(n+m+k\\) ï¼‰ï¼Œæ¯ä¸ªæ“ä½œåºåˆ—ä¸€å®šå¯¹åº”äºä¸€ç§ç‰Œåºã€‚ é‚£ä¹ˆä¹Ÿå°±æ˜¯è¦æ±‚ï¼šæŸä¸ªå‰ç¼€æœ‰ \\(n\\) ä¸ª A ï¼Œä¸”è¿™æ®µå‰ç¼€å†… B, C çš„æ•°é‡å¯¹åº”ä¸è¶…è¿‡ \\(m,k\\) ã€‚ å‰ä¸€ä¸ªæ¡ä»¶é¿å…æ•°é‡ï¼Œå¼ºåˆ¶æœ€åä¸€ä¸ªæ˜¯ A å³å¯ã€‚ åä¸€ä¸ªæ¡ä»¶è€ƒè™‘å®¹æ–¥åšï¼Œç”±äºé•¿åº¦é™åˆ¶å®¹æ˜“å‘ç°ä¸¤ä¸ªåä¾‹åªä¼šå‡ºç°ä¸€ä¸ªï¼š \\[ \\begin{array}{l} ans &amp;= \\displaystyle \\sum_{len=n}^{n+m+k} {len - 1\\choose n - 1}\\bigg({2^{len - n} - \\sum_{a = m+1}^{len - n}{len - n\\choose a}-\\sum_{b=k+1}^{len - n}{len - n\\choose b}}\\bigg)3^{n+m+k-len} \\end{array} \\] è®¾ \\(f_x=\\sum_{i=m}^x{x\\choose i}\\) ï¼Œç„¶åç”¨ç»„åˆæ•°å®šä¹‰ä¼˜åŒ–è¿™ä¸ªä¸œè¥¿ï¼š \\[ f_x = \\sum_{i=m}^x{x\\choose i} = \\sum_{i=m}^x \\bigg({x-1\\choose i}+{x-1\\choose i - 1}\\bigg) = 2f_{x-1} + {x - 1\\choose m - 1} \\] å°±å˜æˆ \\(\\mathcal{O}(n+m+k)\\) çš„äº†ã€‚ã€‚ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt; using namespace std; using ll = long long; inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x; &#125; #define N 1000007 #define mod 1000000007 namespace Comb &#123; int fac[N], ifac[N]; inline int fpow(int x, int t) &#123; int res = 1; for (; t; t &gt;&gt;= 1, x = 1ll * x * x % mod) if (t &amp; 1) res = 1ll * res * x % mod; return res; &#125; inline void init() &#123; fac[0] = ifac[0] = 1; for (int i = 1; i &lt; N; ++i) fac[i] = 1ll * fac[i - 1] * i % mod; ifac[N - 1] = fpow(fac[N - 1], mod - 2); for (int i = N - 2; i; --i) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % mod; &#125; inline ll C(int n, int m) &#123; if (n &lt; m) return 0; return 1ll * fac[n] * ifac[m] % mod * ifac[n - m] % mod; &#125; &#125; using namespace Comb; ll pw2[N] = &#123;1&#125;, pw3[N] = &#123;1&#125;, f1[N], f2[N]; int main() &#123; init(); ll ans = 0; int n = rd(), m = rd(), k = rd(); for (int i = 1; i &lt; N; ++i) &#123; pw2[i] = (pw2[i - 1] &lt;&lt; 1) % mod; pw3[i] = pw3[i - 1] * 3 % mod; f1[i] = (2 * f1[i - 1] + C(i - 1, m)) % mod; f2[i] = (2 * f2[i - 1] + C(i - 1, k)) % mod; &#125; for (int l = n; l &lt;= n + m + k; ++l) &#123; ll w = ((pw2[l - n] - f1[l - n] - f2[l - n]) % mod + mod) % mod; ans = (ans + C(l - 1, n - 1) * w % mod * pw3[n + m + k - l]) % mod; &#125; printf(&quot;%lld\\n&quot;, ans); return 0; &#125;","categories":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://blog.gyx.me/categories/AtCoder/"},{"name":"AtCoder Regular Contest","slug":"AtCoder/AtCoder-Regular-Contest","permalink":"http://blog.gyx.me/categories/AtCoder/AtCoder-Regular-Contest/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"},{"name":"STL","slug":"STL","permalink":"http://blog.gyx.me/tags/STL/"},{"name":"Combinatorics","slug":"Combinatorics","permalink":"http://blog.gyx.me/tags/Combinatorics/"},{"name":"01-BFS","slug":"01-BFS","permalink":"http://blog.gyx.me/tags/01-BFS/"}]},{"title":"AtCoder Regular Contest 060","slug":"atcoder/arc060","date":"2022-06-30T09:20:14.000Z","updated":"2023-03-20T16:28:42.899Z","comments":true,"path":"atcoder/arc060/","link":"","permalink":"http://blog.gyx.me/atcoder/arc060/","excerpt":"","text":"C - Tak and Cards ç»™å®š \\(n\\) ä¸ªæœ‰åºæ•°å­—ï¼Œæ±‚æœ‰å¤šå°‘ä¸ªä¸‹æ ‡é›†ï¼Œå¯¹åº”çš„æ•°å­—å¹³å‡æ•°æ˜¯ \\(A\\) æ•°æ®èŒƒå›´å¾ˆå°ï¼Œç”¨èƒŒåŒ…è®¡æ•°å°±å¥½äº†ï¼Œæ³¨æ„æšä¸¾çš„ä¸Šä¸‹ç•Œã€‚ 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 57#define M 5007#define B 2500ll f[N][M];int main() &#123; int n = rd(), A = rd(); f[0][B] = 1; for (int i = 1; i &lt;= n; ++i) &#123; int w = rd() - A; for (int v = max(-B, -B + w); v &lt;= min(B, B + w); ++v) f[i][v + B] = f[i - 1][v + B] + f[i - 1][v - w + B]; &#125; printf(&quot;%lld\\n&quot;, f[n][B] - 1); return 0;&#125; D - Digit Sum ç»™å®šä¸¤ä¸ªæ•°å­— \\(n\\ (n\\le 10^{11})\\) å’Œ \\(s\\) ï¼Œæ±‚æœ€å°çš„è¿›åˆ¶ \\(b\\) ï¼Œä½¿å¾— \\(n\\) åœ¨ \\(b\\) è¿›åˆ¶ä¸‹çš„æ•°ä½å’Œç­‰äº \\(s\\) ã€‚ ä¸€é“å…¸å‹çš„æ ¹å·è®¨è®ºé¢˜ç›®ã€‚ å½“ \\(b\\le \\sqrt{n}\\) æ—¶ï¼Œç›´æ¥æš´åŠ›éªŒè¯ã€‚ å½“ \\(b\\ge \\sqrt{n}\\) æ—¶ï¼Œæ•°å­—æœ€å¤šæ˜¯ä¸¤ä½æ•°ï¼Œå¯ä»¥å†™æˆ \\(n=pb+q,s=p+q\\) ï¼Œè”ç«‹å¾— \\(n-s=p(b-1)\\) æ³¨æ„åä¸€ç§æƒ…å†µåˆ¤æ–­è¦æ±‚ï¼š\\(b\\ge \\sqrt{n},\\ 0\\le q&lt; b\\) 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt; using namespace std; using ll = long long; inline ll calc(ll n, ll b) &#123; ll ans = 0; for (; n; ans += n % b, n /= b); return ans; &#125; int main() &#123; ll n, s; cin &gt;&gt; n &gt;&gt; s; if (n &lt; s) &#123;puts(&quot;-1&quot;); return 0;&#125; if (n == s) &#123;printf(&quot;%lld\\n&quot;, n + 1); return 0;&#125; ll lim = sqrt(n); for (ll i = 2; i &lt;= lim; ++i) if (calc(n, i) == s) &#123;printf(&quot;%lld\\n&quot;, i); return 0;&#125; n -= s; ll ans = 1e18; for (ll i = sqrt(n); i &gt;= 1; --i) if (n % i == 0) &#123; if (i &gt;= lim &amp;&amp; s - n / i &lt; i + 1 &amp;&amp; s &gt;= n / i) ans = min(ans, i + 1); if (n / i &gt;= lim &amp;&amp; s - i &lt; n / i + 1 &amp;&amp; s &gt;= i) ans = min(ans, n / i + 1); &#125; printf(&quot;%lld\\n&quot;, ans == 1e18 ? -1 : ans); return 0; &#125; E - Tak and Hotels ç»™å®šæ•°è½´ä¸Šçš„ \\(n\\) ä¸ªç‚¹ï¼Œæ¯æ¬¡æŸ¥è¯¢ä¸¤ä¸ªç‚¹ \\(a,b\\) ï¼š é—®ä» \\(a\\) åˆ° \\(b\\) ï¼Œåœ¨ç»™å®šçš„ç‚¹ä¹‹é—´è·³è·ƒï¼Œæ¯æ¬¡è·ç¦»ä¸è¶…è¿‡ \\(L\\) ï¼Œæœ€å°‘å¤šå°‘æ¬¡ã€‚ è€ƒè™‘å€å¢ï¼Œè®¾ \\(mx_{i,j}\\) è¡¨ç¤ºä» \\(i\\) å‘å³è·³ \\(2^j\\) æ­¥ï¼Œæœ€å¤šèƒ½è·³åˆ°å“ªé‡Œï¼Œç»„åˆçš„æ—¶å€™è®°å¾—åˆ¤ä¸€ä¸‹æœ€åä¸€æ­¥å³å¯ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt; using namespace std; using ll = long long; inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x; &#125; #define N 100007 int r[N][18], x[N]; int main() &#123; int n = rd(); int t = log2(n) + 1; for (int i = 1; i &lt;= n; ++i) x[i] = rd(); int l = rd(), q = rd(); for (int i = 1, rpos = 1; i &lt;= n; ++i) &#123; while (rpos &lt; n &amp;&amp; x[rpos + 1] - x[i] &lt;= l) ++rpos; r[i][0] = rpos; &#125; for (int i = 1; i &lt;= t; ++i) for (int l = 1; l &lt;= n; ++l) r[l][i] = r[r[l][i - 1]][i - 1]; for (; q; --q) &#123; int a = rd(), b = rd(); if (a &gt; b) swap(a, b); int ans = 0; for (int i = t; ~i; --i) if (r[a][i] &lt; b) &#123; ans += (1 &lt;&lt; i); a = r[a][i]; &#125; printf(&quot;%d\\n&quot;, ans + 1); &#125; return 0; &#125; F - Best Representation å®šä¹‰æ— å¾ªç¯èŠ‚ï¼ˆå®Œæ•´è¡¥é½ï¼‰çš„å­—ç¬¦ä¸²æ˜¯å¥½çš„ã€‚ å®šä¹‰å°†ä¸€ä¸ªä¸²åˆ’åˆ†ä¸ºè‹¥å¹²å¥½çš„å­—ç¬¦ä¸²ï¼Œè¿™ä¸ªåˆ’åˆ†æ˜¯å¥½çš„ã€‚ å®šä¹‰ä¸€ä¸ªåˆ’åˆ†æ˜¯æœ€ä¼˜çš„ï¼Œå½“ä¸”ä»…å½“åˆ’åˆ†æ˜¯å¥½çš„å¹¶ä¸”åˆ’åˆ†çš„å­ä¸²æ•°æœ€å°‘ã€‚ ç»™å®šä¸² \\(S\\ (|S|\\le 5\\times 10^5)\\) æ±‚æœ€ä¼˜åˆ’åˆ†æ‰€éœ€çš„å­ä¸²æ•°å’Œæœ€ä¼˜åˆ’åˆ†ä¸ªæ•°ã€‚ å¦‚æœ \\(S\\) è‡ªå·±æœ¬èº«æ— å¾ªç¯èŠ‚ï¼Œä¸¤ä¸ªç­”æ¡ˆéƒ½æ˜¯ \\(1\\) å¦‚æœ \\(S\\) æ‰€æœ‰å­—æ¯éƒ½ç›¸åŒï¼Œç¬¬ä¸€ä¸ªç­”æ¡ˆæ˜¯ \\(n\\) ï¼Œç¬¬äºŒä¸ªæ˜¯ \\(1\\) å¦‚æœ \\(S\\) æœ‰å¾ªç¯èŠ‚ä¸”æ‰€æœ‰å­—æ¯éƒ½ä¸åŒï¼Œç¬¬ä¸€ä¸ªç­”æ¡ˆæ˜¯ \\(2\\) ï¼ˆåœ¨ä»»æ„å¾ªç¯èŠ‚ä¸­é—´åˆ‡å¼€ï¼‰ å¯¹äºç¬¬ä¸‰ç§æƒ…å†µæšä¸¾åˆ†å‰²ç‚¹è®¡æ•°ï¼Œéœ€è¦å¿«é€Ÿåˆ¤æ–­ä¸€ä¸ªå‰ç¼€/åç¼€æœ‰æ— å¾ªç¯èŠ‚ã€‚ å¯¹æ­£åä¸¤ä¸ªä¸²éƒ½åšä¸€ä¸‹ kmp å°±å¯ä»¥äº†ï¼Œè‹¥ \\((n-nxt[n])\\ |\\ n\\) åˆ™æœ‰å¾ªç¯èŠ‚ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;#define N 500007char s[N];int nxt[N], nxtr[N];inline bool pre(int x) &#123; return (nxt[x] == 0) || (x % (x - nxt[x]) &gt; 0);&#125;inline bool suf(int x) &#123; return (nxtr[x] == 0) || (x % (x - nxtr[x]) &gt; 0);&#125;int main() &#123; scanf(&quot;%s&quot;, s + 1); int len = strlen(s + 1); bool fl = 0; for (int i = 2, pos; i &lt;= len; ++i) &#123; if (s[i] != s[i - 1]) fl = 1; pos = nxt[i - 1]; while (pos &amp;&amp; s[pos + 1] != s[i]) pos = nxt[pos]; if (pos != 0) nxt[i] = pos + 1; else nxt[i] = (s[1] == s[i]); &#125; if (!fl) &#123;printf(&quot;%d\\n1\\n&quot;, len); return 0;&#125; if (pre(len)) &#123;puts(&quot;1\\n1&quot;); return 0;&#125; puts(&quot;2&quot;); reverse(s + 1, s + 1 + len); for (int i = 2, pos; i &lt;= len; ++i) &#123; pos = nxtr[i - 1]; while (pos &amp;&amp; s[pos + 1] != s[i]) pos = nxtr[pos]; if (pos != 0) nxtr[i] = pos + 1; else nxtr[i] = (s[1] == s[i]); &#125; int ans = 0; for (int i = 1; i &lt; len; ++i) if (pre(i) &amp;&amp; suf(len - i)) ++ans; printf(&quot;%d\\n&quot;, ans); return 0;&#125;","categories":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://blog.gyx.me/categories/AtCoder/"},{"name":"AtCoder Regular Contest","slug":"AtCoder/AtCoder-Regular-Contest","permalink":"http://blog.gyx.me/categories/AtCoder/AtCoder-Regular-Contest/"}],"tags":[{"name":"Knapsack Problem","slug":"Knapsack-Problem","permalink":"http://blog.gyx.me/tags/Knapsack-Problem/"},{"name":"Greedy","slug":"Greedy","permalink":"http://blog.gyx.me/tags/Greedy/"},{"name":"Threshold Optimization","slug":"Threshold-Optimization","permalink":"http://blog.gyx.me/tags/Threshold-Optimization/"},{"name":"Binary Lifting","slug":"Binary-Lifting","permalink":"http://blog.gyx.me/tags/Binary-Lifting/"},{"name":"String","slug":"String","permalink":"http://blog.gyx.me/tags/String/"}]},{"title":"AtCoder Regular Contest 059","slug":"atcoder/arc059","date":"2022-06-29T09:20:14.000Z","updated":"2023-03-20T16:28:35.805Z","comments":true,"path":"atcoder/arc059/","link":"","permalink":"http://blog.gyx.me/atcoder/arc059/","excerpt":"","text":"C - Be Together ç›´æ¥æšä¸¾æœ€ç»ˆç»“æœæ˜¯è°å°±è¡Œäº†ï¼ŒC è¯­è¨€é¢˜ã€‚ 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 107int n, a[N];inline int sqr(int x) &#123;return x * x;&#125;inline int calc(int x) &#123; int ans = 0; for (int i = 1; i &lt;= n; ++i) ans += sqr(a[i] - x); return ans;&#125;int main() &#123; n = rd(); for (int i = 1; i &lt;= n; ++i) a[i] = rd(); int ans = 2e9; for (int w = -100; w &lt;= 100; ++w) ans = min(ans, calc(w)); printf(&quot;%d\\n&quot;, ans); return 0;&#125; D - Unbalanced ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œæ‰¾ä¸€ä¸ªä¸å¹³è¡¡å­ä¸²ï¼Œå­ä¸²ä¸­å‡ºç°æ¬¡æ•°æœ€å¤šçš„å­—ç¬¦æ¬¡æ•°è¶…è¿‡é•¿åº¦çš„ä¸€åŠã€‚ é•¿åº¦ä¸º \\(2n\\) çš„ä¸å¹³è¡¡ä¸²ï¼Œè¯¥å­—ç¬¦ä¸€å®šå‡ºç°äº†è‡³å°‘ \\(n+1\\) æ¬¡ï¼Œå› æ­¤ä¸€å®šæœ‰è¿ç»­ä¸¤ä¸ªå­—ç¬¦ç›¸åŒï¼› é•¿åº¦ä¸º \\(2n+1\\) çš„ä¸å¹³è¡¡ä¸²ï¼Œå”¯ä¸€ç‰¹æ®Šçš„æƒ…å†µæ˜¯å½¢å¦‚ abacada è¿™ç§ï¼Œä¸€å®šå­˜åœ¨é•¿åº¦ä¸º \\(3\\) çš„ä¸å¹³è¡¡å­ä¸²ï¼› ç»¼ä¸Šï¼Œå¦‚æœå­˜åœ¨ä¸å¹³è¡¡ï¼Œé‚£ä¹ˆæœ€å°çš„é•¿åº¦ä¸ä¼šè¶…è¿‡ \\(3\\) ï¼Œç›´æ¥æ‰«æå³å¯ã€‚ 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 100007char s[N];int main() &#123; scanf(&quot;%s&quot;, s + 1); int n = strlen(s + 1); if (s[n - 1] == s[n]) &#123;printf(&quot;%d %d\\n&quot;, n - 1, n); return 0;&#125; for (int i = 1; i &lt;= n - 2; ++i) &#123; if (s[i] == s[i + 1]) &#123;printf(&quot;%d %d\\n&quot;, i, i + 1); return 0;&#125; if (s[i] == s[i + 2]) &#123;printf(&quot;%d %d\\n&quot;, i, i + 2); return 0;&#125; &#125; puts(&quot;-1 -1&quot;); return 0;&#125; E - Children and Candies \\[ \\begin{array}{l} ans &amp;= \\displaystyle\\sum_{x_1 = a_1}^{b_1}\\sum_{x_2 = a_2}^{b_2}\\cdots\\sum_{x_n = a_n}^{b_n} \\sum_{\\substack{\\sum c_i=C\\\\c_i\\ge 0}}\\prod_{i=1}^n x_i^{c_i}\\\\ &amp;\\displaystyle= \\sum_{\\substack{\\sum c_i=C\\\\c_i\\ge 0}} \\sum_{x_1 = a_1}^{b_1} x_1^{c_1}\\sum_{x_2 = a_2}^{b_2}x_2^{c_2}\\cdots\\sum_{x_n = a_n}^{b_n} x_n^{c_n}\\\\ &amp;\\displaystyle= \\sum_{\\substack{\\sum c_i=C\\\\c_i\\ge 0}}\\prod_{i=1}^n\\bigg(\\sum_{x_i = a_i}^{b_i} x_i^{c_i}\\bigg)\\\\ \\end{array} \\] æˆ‘ä»¬å¯ä»¥é¢„å¤„ç†å‡º \\(pw_{i,k} =\\sum_{x_i=a_i}^{b_i} x_i^k\\) ï¼Œæœ‰ \\[ ans = \\sum_{\\substack{\\sum c_i=C\\\\c_i\\ge 0}}\\prod_{i=1}^n\\bigg(\\sum_{x_i = a_i}^{b_i} x_i^{c_i}\\bigg) =\\displaystyle\\sum_{c_1=0}^C pw_{1,c_1}\\sum_{\\substack{c_2+\\cdots + c_n=C-c_1\\\\c_i\\ge 0}}\\prod_{i=2}^n pw_{i,c_i} \\] æŒ‰ç…§è¿™ä¸ªæ€è·¯ç»§ç»­æ‹†åˆ† \\(c_2,\\cdots, c_n\\) ï¼Œæœ¬è´¨ä¸Šå°±æ˜¯ä¸€ä¸ªèƒŒåŒ…çš„åŠ¨æ€è§„åˆ’ã€‚ è®¾ \\(f_{i,j}\\) è¡¨ç¤ºè€ƒè™‘å‰ \\(i\\) ä¸ªå˜é‡ï¼ŒæŒ‡æ•°çš„å’Œæ˜¯ \\(j\\) ï¼Œå¯¹ \\(ans\\) çš„è´¡çŒ®æ˜¯å¤šå°‘ã€‚ æšä¸¾ç¬¬ \\(i\\) ä¸ªæŒ‡æ•°å ç”¨äº† \\(k\\ (k\\le j)\\) ï¼Œåˆ™è½¬ç§»æ–¹ç¨‹ï¼š \\[ f_{i,j}\\leftarrow \\sum_{k=0}^j f_{i-1,j-k}\\times pw_{i,k} \\] æ—¶é—´å¤æ‚åº¦ \\(\\mathcal{O}(n^3)\\) ï¼Œç©ºé—´å¤æ‚åº¦ \\(\\mathcal{O}(n^2)\\) ã€‚ 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 407#define mod 1000000007int a[N], b[N], pw[N][N], f[N][N];int main() &#123; int n = rd(), c = rd(); for (int i = 1; i &lt;= n; ++i) a[i] = rd(); for (int i = 1; i &lt;= n; ++i) b[i] = rd(); for (int i = 1; i &lt;= n; ++i) for (int j = a[i]; j &lt;= b[i]; ++j) for (int t = 0, nw = 1; t &lt;= c; ++t, nw = 1ll * nw * j % mod) pw[i][t] = (pw[i][t] + nw) % mod; f[0][0] = 1; for (int i = 1; i &lt;= n; ++i) for (int j = 0; j &lt;= c; ++j) for (int k = 0; k &lt;= j; ++k) f[i][j] = (f[i][j] + 1ll * f[i - 1][j - k] * pw[i][k]) % mod; printf(&quot;%d\\n&quot;, f[n][c]); return 0;&#125; F - Unhappy Hacking æ±‚ \\(n\\) æ¬¡æ“ä½œç”Ÿæˆä¸€ä¸ªç»™å®šä¸² \\(s\\) çš„æ–¹æ¡ˆæ•°ï¼š æ¯æ¬¡æ“ä½œä¸‰é€‰ä¸€ï¼šç»“å°¾åŠ  \\(0\\) ï¼Œç»“å°¾åŠ  \\(1\\) ï¼Œåˆ é™¤ç»“å°¾ä¸€ä¸ªå­—ç¬¦ï¼ˆè‹¥ç©ºå°±ä»€ä¹ˆéƒ½ä¸åšï¼‰ å†·é™ä¸€ä¸‹è¿™ä¸ªè®¡æ•°å’Œä¸²æ˜¯ä»€ä¹ˆæ²¡å…³ç³»ï¼Œå› ä¸ºæ‰€æœ‰é•¿åº¦ç›¸åŒçš„ä¸²ç”Ÿæˆçš„æ¦‚ç‡ç›¸åŒã€‚ è®¾ \\(f_{i,j}\\) è¡¨ç¤º \\(i\\) æ¬¡æ“ä½œç”Ÿæˆé•¿åº¦ä¸º \\(j\\) çš„ä¸²çš„æ–¹æ¡ˆæ•°ï¼Œæœ‰ï¼š + åˆ é™¤ï¼š\\(f_{i,j} \\leftarrow f_{i-1,j+1}+[j == 0]f_{i-1,j}\\) + æ·»åŠ ï¼š\\([j&gt;0] f_{i,j}\\leftarrow f_{i-1,j-1}\\times 2\\) ç­”æ¡ˆå°±æ˜¯ \\(f_{n,|s|}\\times 2^{-|s|}\\) ï¼Œå¤æ‚åº¦ä¸º \\(\\mathcal{O}(n^2)\\) ï¼Œæ„Ÿè§‰å¯èƒ½è¿˜èƒ½ä¼˜åŒ–ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt; using namespace std; using ll = long long; #define N 5007 #define mod 1000000007 inline int fpow(int x, int t) &#123; int res = 1; for (; t; t &gt;&gt;= 1, x = 1ll * x * x % mod) if (t &amp; 1) res = 1ll * res * x % mod; return res; &#125; char s[N]; int f[N][N], pw[N] = &#123;1&#125;; inline void add(int &amp;a, int b) &#123;a = (a + b) % mod;&#125; int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); scanf(&quot;%s&quot;, s + 1); f[0][0] = 1; for (int i = 1; i &lt;= n; ++i) pw[i] = (pw[i - 1] &lt;&lt; 1) % mod; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 0; j &lt;= n; ++j) &#123; add(f[i][j], f[i - 1][j + 1]); if (!j) add(f[i][j], f[i - 1][j]); else add(f[i][j], (f[i - 1][j - 1] &lt;&lt; 1) % mod); &#125; &#125; int m = strlen(s + 1); int ans = 1ll * f[n][m] * fpow(pw[m], mod - 2) % mod; printf(&quot;%d\\n&quot;, ans); return 0; &#125;","categories":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://blog.gyx.me/categories/AtCoder/"},{"name":"AtCoder Regular Contest","slug":"AtCoder/AtCoder-Regular-Contest","permalink":"http://blog.gyx.me/categories/AtCoder/AtCoder-Regular-Contest/"}],"tags":[{"name":"Knapsack Problem","slug":"Knapsack-Problem","permalink":"http://blog.gyx.me/tags/Knapsack-Problem/"},{"name":"Counting","slug":"Counting","permalink":"http://blog.gyx.me/tags/Counting/"},{"name":"Combinatorics","slug":"Combinatorics","permalink":"http://blog.gyx.me/tags/Combinatorics/"}]},{"title":"AtCoder Beginner Contest 253","slug":"atcoder/abc253","date":"2022-05-29T00:38:14.000Z","updated":"2023-03-20T16:28:12.328Z","comments":true,"path":"atcoder/abc253/","link":"","permalink":"http://blog.gyx.me/atcoder/abc253/","excerpt":"","text":"A, B æ¯”è¾ƒç®€å•å°±ä¸å†™äº†ã€‚ æˆ‘çš„ä»£ç  : All Submissions - SGColin C. Max - Min Query ç»´æŠ¤ä¸€ä¸ª multiset ï¼Œæ”¯æŒæ’å…¥ä¸€ä¸ª \\(x\\) ï¼Œåˆ é™¤ \\(\\min(c_i,s.count(x))\\) ä¸ª \\(x\\) ï¼ŒæŸ¥è¯¢æœ€å¤§å€¼-æœ€å°å€¼ã€‚ å¼€å§‹æƒ³æƒ³ç›´æ¥æ¨¡æ‹Ÿå¤æ‚åº¦æ˜¯å¯¹çš„å°±å†™äº† multisetï¼Œæ²¡æƒ³åˆ° multiset çš„ lower_bound å¤ªæ…¢äº† T äº†å‡ ä¸ªç‚¹ã€‚ Upd : ç»æé†’åº”è¯¥æ˜¯ count å‡½æ•°å¤ªæ…¢äº†ï¼Œå®˜ç½‘æè¿°æ˜¯ \"Logarithmic in size and linear in the number of matches\" ï¼Œä¹Ÿå°±æ˜¯è¯´å¤æ‚åº¦æ˜¯ \\(\\mathcal{O}(k+\\log n)\\) ï¼Œå…¶ä¸­ \\(k\\) æ˜¯æŸ¥è¯¢æ•°å­—çš„å‡ºç°æ¬¡æ•°ï¼Œæ‰€ä»¥åŠ å…¥ \\(10^5\\) ä¸ªç‚¹ä¹‹åï¼Œå¤šæŸ¥å‡ æ¬¡å°±è¶…æ—¶äº†ã€‚ æ‰€ä»¥æ”¹ä¸ºç”¨ map ç»´æŠ¤ä¸€ä¸ªè®¡æ•°å™¨ï¼Œæ¯æ¬¡æŸä¸ªæ•°å­—æ–°å‡ºç°/æ¶ˆå¤±çš„æ—¶å€™å†å¯¹ set æ“ä½œã€‚ 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;map&lt;int, int&gt; cnt;set&lt;int&gt; s;int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; int op = rd(); if (op == 1) &#123; int x = rd(); ++cnt[x]; if (cnt[x] == 1) s.insert(x); &#125; else if (op == 2) &#123; int x = rd(); int t = min(rd(), cnt[x]); cnt[x] -= t; if (cnt[x] == 0) s.erase(x); &#125; else printf(&quot;%d\\n&quot;, (*--s.end()) - (*s.begin())); &#125; return 0;&#125; D. FizzBuzz Sum Hard ç»™å®š \\(n,a,b\\) æ‰¾å‡º \\([1,n]\\) å†…ä¸æ˜¯ \\(a\\) æˆ– \\(b\\) å€æ•°çš„æ•°å­—çš„å’Œã€‚ ç®€å•çš„å®¹æ–¥åŸç†ï¼Œæ‰£æ‰ \\(a,b\\) çš„å€æ•°ï¼ŒåŠ ä¸Š \\(\\text{lcm}(a,b)\\) çš„å€æ•°ã€‚ 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;int gcd(int a, int b) &#123; return b ? gcd(b, a % b) : a;&#125;int main() &#123; int n = rd(), a = rd(), b = rd(); ll sum = 1ll * n * (n + 1) / 2; int ka = n / a; int kb = n / b; sum -= 1ll * a * ka * (ka + 1) / 2; sum -= 1ll * b * kb * (kb + 1) / 2; ll lcm = 1ll * a * b / gcd(a, b); ll kl = n / lcm; sum += 1ll * lcm * kl * (kl + 1) / 2; printf(&quot;%lld\\n&quot;, sum); return 0;&#125; E. Distance Sequence è®¡æ•°é•¿åº¦ä¸º \\(n\\) çš„åºåˆ— \\(\\{a_i\\}\\) ï¼š(1) \\(a_i\\in[1,m]\\) ; (2) \\(\\forall i\\in[2,n], |a_i-a_{i-1}|\\ge k\\) . ç›´æ¥ DP ï¼Œè®¾ \\(f_{i,j}\\) è¡¨ç¤ºé•¿åº¦ä¸º \\(i\\) çš„åºåˆ—ï¼Œç»“å°¾æ˜¯ \\(j\\) çš„æ–¹æ¡ˆæ•°ï¼Œæœ‰ï¼š \\[ f_{i,j}=\\sum_{w\\in[1,j-k]\\cup[j+k,m]} f_{i-1,w} \\] ç”¨ä¸€ä¸ªå‰ç¼€å’Œä¼˜åŒ–å³å¯ï¼Œæ³¨æ„ä¸‹ \\(k=0\\) æ—¶ä¸è¦ç®—é‡ï¼Œå¤æ‚åº¦ \\(O(nm)\\) 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 1007#define M 5007#define mod 998244353int f[N][M], sum[N][M];inline int fpow(int x, int t) &#123; int res = 1; for (; t; t &gt;&gt;= 1, x = 1ll * x * x % mod) if (t &amp; 1) res = 1ll * res * x % mod; return res;&#125;int main() &#123; int n = rd(), m = rd(), k = rd(); if (k == 0) &#123;printf(&quot;%d\\n&quot;, fpow(m, n)); return 0;&#125; for (int i = 1; i &lt;= m; ++i) &#123; f[1][i] = 1; sum[1][i] = i; &#125; for (int i = 2; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; int l = max(0, j - k); int r = min(m, j + k - 1); f[i][j] = (sum[i - 1][m] - sum[i - 1][r] + mod) % mod; f[i][j] = (f[i][j] + sum[i - 1][l]) % mod; &#125; for (int j = 1; j &lt;= m; ++j) sum[i][j] = (sum[i][j - 1] + f[i][j]) % mod; &#125; printf(&quot;%d\\n&quot;, sum[n][m]); return 0;&#125; F. Operations on a Matrix ç»´æŠ¤ä¸€ä¸ªåˆå§‹æ˜¯å…¨ \\(0\\) çš„ \\(n\\times m\\ (n,m\\le 2\\ast 10^5)\\) çš„çŸ©é˜µï¼Œæ”¯æŒï¼š å¯¹ \\([l_i,r_i]\\) è¿™äº›åˆ—çš„æ¯ä¸€ä¸ªå…ƒç´ åŠ  \\(x\\) å°†ç¬¬ \\(i\\) è¡Œå…¨éƒ¨èµ‹å€¼ä¸º \\(x\\) æŸ¥è¯¢çŸ©é˜µä¸­ \\((x_i,y_i)\\) çš„å€¼ è®°å½•æ¯è¡Œæœ€åä¸€æ¬¡è¢«èµ‹å€¼çš„æ—¶é—´æˆ³ \\(lst_i\\) å’Œèµ‹å€¼ \\(x_i\\) ï¼Œåˆ™ç­”æ¡ˆä¸º \\(x_i\\) + \\([lst,now]\\) è¿™æ®µæ“ä½œé‡Œå¯¹ \\(y_i\\) åŠ çš„å€¼ã€‚ åœ¨çº¿çš„åšæ³•å°±æ˜¯å†™ä¸€ä¸ªä¸»å¸­æ ‘ + æ ‡è®°æŒä¹…åŒ–ï¼› ç¦»çº¿çš„åšæ³•å°±æ˜¯æŠŠåé¢çš„è´¡çŒ®å†™åšå‰ç¼€å’Œå·®åˆ†ï¼Œç„¶åä¸¤ä¸ªæ—¶åˆ»ç»´æŠ¤ä¸€ä¸‹ã€‚ å­¦åˆ°äº†ç®€è€å¸ˆçš„ä¸»å¸­æ ‘å†™æ³• OwO 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define mid ((l + r) &gt;&gt; 1)#define N 200007int tot, rttot;struct node &#123; int ls, rs; ll sum;&#125; c[N &lt;&lt; 6];int rot[N], lst[N];ll x[N];int copy(int rt) &#123; c[++tot] = c[rt]; return tot;&#125;void upd(int &amp;rt, int l, int r, int L, int R, int x) &#123; rt = copy(rt); if (L &lt;= l &amp;&amp; r &lt;= R) &#123; c[rt].sum += x; return; &#125; if (L &lt;= mid) upd(c[rt].ls, l, mid, L, R, x); if (R &gt; mid) upd(c[rt].rs, mid + 1, r, L, R, x);&#125;ll query(int rtl, int rtr, int l, int r, int p) &#123; ll res = c[rtr].sum - c[rtl].sum; if (l == r) return res; if (p &lt;= mid) res += query(c[rtl].ls, c[rtr].ls, l, mid, p); else res += query(c[rtl].rs, c[rtr].rs, mid + 1, r, p); return res;&#125;int main() &#123; int n = rd(), m = rd(), q = rd(); for (int i = 1; i &lt;= q; ++i) &#123; int op = rd(); if (op == 1) &#123; ++rttot; rot[rttot] = rot[rttot - 1]; int l = rd(), r = rd(), v = rd(); upd(rot[rttot], 1, m, l, r, v); &#125; else if (op == 2) &#123; int p = rd(); x[p] = rd(); lst[p] = rttot; &#125; else &#123; int row = rd(), col = rd(); printf(&quot;%lld\\n&quot;, x[row] + query(rot[lst[row]], rot[rttot], 1, m, col)); &#125; &#125; return 0;&#125; G. Swap Many Times å¯¹äº \\(n\\) ï¼Œåˆå§‹åŒ–ä¸€ä¸ªåºåˆ— \\(a_1,\\cdots,a_n\\) ï¼Œæ»¡è¶³ \\(a_i=i\\) ã€‚ å¯¹äº \\(n\\) ï¼Œæœ‰ \\(\\frac{n(n+1)}{2}\\) ä¸ªå½¢å¦‚ \\((x,y)\\) çš„æ»¡è¶³ \\(1\\le x&lt;y\\le n\\) çš„æ•°å¯¹ï¼ŒæŒ‰ç…§ pair çš„è§„åˆ™æ’åºã€‚ ç»™å®š \\(L,R\\) ï¼Œå¯¹äºè¿™ä¸ª pair åºåˆ—çš„ç¬¬ \\(L\\) ä¸ªåˆ°ç¬¬ \\(R\\) ä¸ªï¼Œä¾æ¬¡æ“ä½œï¼šäº¤æ¢ \\(a_x\\) å’Œ \\(a_y\\) æ±‚æœ€ç»ˆçš„åºåˆ—ã€‚ è§‚å¯Ÿè¿™ä¸ªåºåˆ—ï¼Œ \\(x\\) ç›¸åŒçš„ pair æ˜¯è¿ç»­å‡ºç°çš„ï¼Œè€ƒè™‘å¯¹äºåŒä¸€ä¸ª \\(x\\) æŠŠæ‰€æœ‰æ“ä½œéƒ½åšæ‰ã€‚ å‡è®¾ä»¥ \\(x\\) ä¸º first çš„åœ¨ \\([L,R]\\) å†…çš„æ“ä½œä¸º \\((x,y_a),(x,y_a+1),\\cdots,(x,y_b)\\) é‚£ä¹ˆå®é™…æ“ä½œçš„ç»“æœå°±æ˜¯æŠŠåºåˆ—ä¸­ \\(x,y_a,y_a+1,\\cdots,y_b\\) è¿™äº›ä½ç½®æ•´ä½“å‘å³ shift ä¸€ä¸ªä½ç½®ã€‚ æšä¸¾ \\(x\\) ï¼Œç„¶ååªéœ€è¦ä¸€ä¸ªæ”¯æŒæŸä¸ªä½ç½®æ’å…¥åˆ é™¤çš„æ•°æ®ç»“æ„å°±å¯ä»¥äº†ã€‚ ç„¶åæ˜¨å¤©è¶æœºå­¦äº†ä¸€ä¸‹ rope ï¼Œå†…æ ¸æ˜¯å—çŠ¶é“¾è¡¨ï¼Œç†è®ºå¤æ‚åº¦ \\(\\mathcal{O}(n\\sqrt{n})\\) ï¼Œå®é™…è¡¨ç°é€Ÿåº¦å¾ˆå¿«ã€‚ åªèƒ½è¯´éå¸¸å¥½ç”¨ï¼Œå¯æƒœ Clang ç¼–è¯‘ä¸äº†ï¼Œæ˜¯åœ¨ Custom Test æ‰‹åŠ¨è°ƒè¯•çš„ã€‚ p.s. é¢˜è§£çš„åšæ³•è²Œä¼¼ä¸éœ€è¦æ•°æ®ç»“æ„ï¼Œå¥½åƒå¾ˆç²¾å¦™ 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;#include &lt;ext/rope&gt;using namespace std;using namespace __gnu_cxx;typedef long long ll;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;rope&lt;int&gt; s;int main() &#123; int n = rd(); ll L = rd(), R = rd(); ll l = 0, r = 0; for (int i = 0; i &lt;= n; ++i) s.push_back(i); for (int i = 1; i &lt;= n; ++i) &#123; l = r + 1; r = l + n - i - 1; if (L &lt;= r &amp;&amp; R &gt;= l) &#123; int ll = max(l, L), rr = min(r, R); int pl = i + 1 + ll - l; int pr = i + 1 + rr - l; int x = s[pr]; s.erase(pr, 1); s.insert(pl, s[i]); s.erase(i, 1); s.insert(i, x); &#125; &#125; for (int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, s[i]); return 0;&#125;","categories":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://blog.gyx.me/categories/AtCoder/"},{"name":"AtCoder Beginner Contest","slug":"AtCoder/AtCoder-Beginner-Contest","permalink":"http://blog.gyx.me/categories/AtCoder/AtCoder-Beginner-Contest/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"},{"name":"Persistent Data Structure","slug":"Persistent-Data-Structure","permalink":"http://blog.gyx.me/tags/Persistent-Data-Structure/"},{"name":"STL","slug":"STL","permalink":"http://blog.gyx.me/tags/STL/"}]},{"title":"Two Identical Machines Scheduling with Agreement Graphs","slug":"paper-notes/machine-scheduling-with-agreement-graph","date":"2022-05-25T14:03:18.000Z","updated":"2023-03-20T16:53:31.151Z","comments":true,"path":"paper-notes/machine-scheduling-with-agreement-graph/","link":"","permalink":"http://blog.gyx.me/paper-notes/machine-scheduling-with-agreement-graph/","excerpt":"","text":"New results in two identical machines scheduling with agreement graphs æ”¶å½•äº TCS 2019 çš„ä¸€ç¯‡æ–‡ç« ï¼ŒåŸºäºè®¸å¯å›¾çš„ç‹¬ç«‹åŒæœºæµæ°´å®‰æ’é—®é¢˜çš„ä¸€äº›æ–°è¿›å±•ã€‚ é—®é¢˜æ¨¡å‹ æœ‰ \\(n\\) ä¸ªä»»åŠ¡ï¼Œç¬¬ \\(i\\) ä¸ªä»»åŠ¡éœ€è¦çš„æ—¶é—´æ˜¯ \\(p_i\\) ã€‚ ä¸€å…±æœ‰ä¸¤å°æœºå™¨ï¼Œæ¯ä¸ªä»»åŠ¡éƒ½éœ€è¦è¢«è¿ç»­åœ°å®‰æ’åˆ°æŸä¸€ä¸ªæœºå™¨ä¸Šå®Œæˆã€‚ å°†ä»»åŠ¡æŠ½è±¡æˆç‚¹ï¼Œç»™å®šä¸€ä¸ªè®¸å¯å›¾ï¼Œä¸¤ä¸ªä»»åŠ¡æœ‰è¾¹åˆ™å¯ä»¥åˆ†åˆ«åœ¨ä¸¤ä¸ªæœºå™¨ä¸ŠåŒæ—¶æ‰§è¡Œã€‚ æ±‚ä¸€ä¸ªå®‰æ’æ–¹æ¡ˆï¼Œæœ€å°åŒ–æœ€åä¸€ä¸ªè¢«åšå®Œçš„ä»»åŠ¡å®Œæˆæ—¶é—´ã€‚ ç°æœ‰ç»“è®ºï¼š è®¸å¯å›¾æ˜¯æ ‘çš„æƒ…å†µä¸‹ï¼Œæ­¤é—®é¢˜æ˜¯ NP-Hard çš„ è®¸å¯å›¾æ˜¯æ¯›æ¯›è™«çš„æƒ…å†µä¸‹ï¼Œå­˜åœ¨ \\(\\mathcal{O}(n)\\) æ±‚æœ€ä¼˜è§£çš„æ–¹æ³• æ¯›æ¯›è™« æ¯›æ¯›è™«æ˜¯ä¸€ç§ç‰¹æ®Šçš„æ ‘ï¼Œç”±ä¸€ä¸ªæ ¸å¿ƒè·¯å¾„å’Œè‹¥å¹²åˆ°è·¯å¾„è·ç¦»ä¸º \\(1\\) çš„ç‚¹æ„æˆã€‚ Notation Meaning Notation Processing time \\(p\\) Maximum weighted independent set of the agreement graph \\(G\\) \\(I_p(G)\\) Weight of \\(I_p(G)\\) (a lower bound on the optimal makespan) \\(\\overline{I_p}(G) =\\sum_{j\\in I_p(G)} p_j\\) Set of neighbors of a job \\(j\\) (generalized for a subset \\(J&#39;\\)) \\(N(j)/N(J&#39;)\\) Set of leaves connected to job \\(j\\) \\(Lv(j)\\) Starting time of a job \\(j\\) \\(t_j\\) Minimum starting time of a subset \\(J&#39;\\) \\(t_j(J&#39;)=\\min_{k\\in J&#39;}\\{t_k\\}\\) Algorithm è§åŸæ–‡ [4.2] Caterpillar scheduling algorithmã€‚ Polynomiality and Optimality Proof ä¸ºäº†ç®€å•æè¿°ï¼Œæˆ‘ä»¬ç§°åœ¨ MWIS é‡Œçš„ç‚¹ä¸ºé»‘ç‚¹ï¼Œå…¶ä½™ç‚¹ä¸ºç™½ç‚¹ã€‚ å¯ä»¥å‘ç°æ–­æ‰ç™½ç‚¹ä¹‹é—´çš„æ‰€æœ‰è¾¹åï¼Œè¿™ä¸ªæ–°çš„å›¾çš„æ€§è´¨æ˜¯æ‰€æœ‰çš„è¾¹éƒ½æ˜¯é»‘-ç™½è¾¹ã€‚ Claim 1. å¯¹äºæ¯ä¸ªæ–°çš„è¿é€šå— \\(CAT_i\\) ï¼Œå…¶å†…çš„é»‘ç‚¹é›† \\(S_i^*\\) ä»ç„¶æ˜¯ \\(CAT_i\\) çš„ MWIS å‡è®¾å­˜åœ¨å…¶ä»–çš„ MWIS \\(I_p(CAT_i)\\) ä½¿å¾— \\(\\overline{I_p}(CAT_i) &gt; \\sum_{j\\in S_i^*} p_j\\) ï¼Œé‚£ä¹ˆæˆ‘ä»¬è€ƒè™‘å°† \\(CAT_i\\) è¿™ä¸€éƒ¨åˆ†çš„ MWIS æ¢æˆè¿™ä¸ªæ–°çš„é›†åˆï¼Œå…¶ä»–éƒ¨åˆ†çš„ MWIS ä¸å˜ï¼Œé‚£ä¹ˆè¿˜åŸå›ä»æ˜¯åŸå›¾çš„ä¸€ä¸ª ISï¼Œè€Œè¿™ä¸ªæ–°çš„ IS æ¯”åŸæ¥çš„ MWIS æƒå€¼è¿˜å¤§ï¼Œæ‰€ä»¥çŸ›ç›¾äº†ã€‚ \\[ \\sum_{j \\in S^{\\prime}} p_{j}=\\overline{I_{p}}(C A T)-\\sum_{j \\in S_{i}^{*}} p_{j}+\\overline{I_{p}}\\left(C A T_{i}\\right)&gt;\\overline{I_{p}}(C A T) \\] Claim 2. å¯¹äºæ¯ä¸ªæ–°çš„è¿é€šå— \\(CAT_i\\) çš„ç‚¹é›† \\(J_i\\) ï¼Œå…¶å†…ä»»ä½•ä¸€ä¸ªç™½ç‚¹å­é›†çš„ç‚¹æƒå’Œä¸ä¼šè¶…è¿‡å…¶é‚»å±…é»‘ç‚¹çš„ç‚¹æƒå’Œ å‡è®¾å­˜åœ¨è¿™æ ·çš„ä¸€ä¸ªç™½ç‚¹é›† \\(W\\) æ»¡è¶³ \\(\\sum_{j \\in W} p_{j} &gt; \\sum_{j \\in N(W)} p_{j}\\) ï¼Œé‚£ä¹ˆè€ƒè™‘å°† \\(S_i^*\\) æ¢æˆ \\(S&#39;= (S_i^*\\setminus N(W))\\cup W\\) ï¼Œæ˜“è¯\\(S&#39;\\) ä¹Ÿæ˜¯ä¸€ä¸ªç‹¬ç«‹é›†ï¼Œä¸”æ¯” \\(S_i^*\\) æƒå€¼å’Œè¿˜è¦å¤§ï¼ŒçŸ›ç›¾ã€‚ \\[ \\sum_{j \\in S^{\\prime}} p_{j}=\\sum_{j \\in S_{i}^{*}} p_{j}-\\sum_{j \\in N(W)} p_{j}+\\sum_{j \\in W} p_{j}&gt;\\sum_{j \\in S_{i}^{*}} p_{j} \\] Claim 3. å¯¹äºä»»æ„ç™½ç‚¹ \\(\\beta\\) ï¼Œå…¶é‚»å±…é»‘ç‚¹éƒ½ä¼šè¢«è¿ç»­åœ°å®‰æ’åœ¨ç¬¬ä¸€ä¸ªæœºå™¨ä¸Š åˆ†ç±»è®¨è®ºä¸€ä¸‹ï¼Œå¦‚æœæ˜¯å¶å­æ˜¾ç„¶ï¼›å¦‚æœä¸æ˜¯å¶å­ï¼Œå‡è®¾é“¾ä¸Šçš„é¡ºåºæ˜¯ \\(\\alpha-\\beta-\\gamma\\) ï¼Œé‚£ä¹ˆé»‘ç‚¹é¡ºåºæ˜¾ç„¶æ˜¯ \\(\\alpha-(\\beta\\) çš„å¶å­ \\()-\\gamma\\) Claim 4. å¯¹äºä»»æ„ä¸¤ä¸ªç™½ç‚¹ \\(\\alpha,\\beta\\) ï¼Œå¦‚æœä»–ä»¬è¢«è¿ç»­åœ°å®‰æ’åœ¨äº†æŸä¸€ä¸ªæœºå™¨ä¸Šï¼Œé‚£ä¹ˆä»–ä»¬ä¸€å®šæœ‰å…¬å…±é‚»å±…ã€‚ åŒæ ·åˆ†ç±»è®¨è®º \\(\\alpha\\) å’Œ \\(\\beta\\) çš„ä½ç½®å…³ç³»ï¼ˆåˆ†åˆ«æ˜¯ä¸»å¹²/å¶å­ï¼‰å³å¯ã€‚ Claim 5. å¯¹äºä»»æ„è¿ç»­å®‰æ’çš„ç™½ç‚¹é›†ï¼Œå…¶é‚»å±…ä¸€å®šæ˜¯è¢«è¿ç»­å®‰æ’åœ¨ä¸€ä¸ªåŒºé—´å†…çš„ å‰ä¸¤æ¡çš„è‡ªç„¶ç»“æœï¼Œå½“ç„¶ä¹Ÿéœ€è¦ç¬¬äºŒæ¡è¾…åŠ©ç†è§£ä¸€ä¸‹ï¼Œè¯æ˜é»‘è‰²ä¸€å®šæ˜¯è¿ç»­çš„ã€‚ Lemma 1. æ¯ä¸€ä¸ªç™½ç‚¹éƒ½ä¼šè¢«å®‰æ’åœ¨é‚»å±…å¯¹åº”çš„åŒºé—´é‡Œ åè¯æ³•ï¼Œä¸ç¬¦åˆçš„å°±ä¸¤ç§æƒ…å†µï¼š \\(t_\\beta &lt; t(N(\\beta ))\\) ï¼šè¿™ç§æƒ…å†µä¸å­˜åœ¨ï¼Œå› ä¸ºç®—æ³•ä¸­æ¯ä¸ªé»‘ç‚¹æ˜¯è¿ç»­å®‰æ’çš„ï¼Œå¦‚æœå‡ºç°è¯¥æƒ…å†µï¼Œè¿™ä¸ªç™½ç‚¹ä¼šä¸éé‚»æ¥çš„é»‘ç‚¹é‡åˆï¼Œä¸è®¸å¯å›¾çš„è¦æ±‚ç›¸å†²çªã€‚ \\(t_\\beta+p_\\beta &gt; t(N(\\beta )) + \\sum_{j\\in N(\\beta)} p_j\\) ï¼šè¿™ç§æƒ…å†µä¸å­˜åœ¨ï¼Œè€ƒè™‘ä» \\(\\beta\\) å¾€å‰çš„ç¬¬ä¸€ä¸ªæ»¡è¶³ \\(t_\\alpha=t_{N(\\alpha)}\\) çš„ä»»åŠ¡ \\(\\alpha\\) ï¼Œé‚£ä¹ˆä» \\(\\alpha\\) åˆ° \\(\\beta\\) è¿™ä¸€æ®µæ˜¯è¿ç»­å®‰æ’çš„ï¼Œç”±äº‹å® \\(5\\) ï¼Œè¿ç»­å®‰æ’çš„ç™½ç‚¹é›†ï¼Œå…¶é‚»å±…ä¸€å®šæ˜¯è¢«è¿ç»­å®‰æ’åœ¨ä¸€ä¸ªåŒºé—´å†…çš„ï¼Œå› æ­¤ç™½ç‚¹çš„åŒºé—´å°±æ˜¯ \\([t_\\alpha,t_\\alpha+\\sum_{j\\in[\\alpha,\\beta]} p_j]\\) ï¼Œé»‘ç‚¹çš„åŒºé—´å°±æ˜¯ \\([t(N([\\alpha,\\beta])),t(N([\\alpha,\\beta])) + \\sum_{j\\in N([\\alpha,\\beta])} p_j]\\) ; åˆç”±äº‹å® \\(2\\) ï¼Œå¯¹äº \\(J_i\\) å†…ä»»ä½•ä¸€ä¸ªç™½ç‚¹å­é›†ï¼Œå…¶ç‚¹æƒå’Œä¸ä¼šè¶…è¿‡å…¶é‚»å±…é»‘ç‚¹çš„ç‚¹æƒå’Œï¼Œå› æ­¤æœ‰ \\(t_\\alpha+\\sum_{j\\in[\\alpha,\\beta]} p_j \\le \\sum_{j\\in N([\\alpha,\\beta])} p_j\\) ï¼Œå› æ­¤ \\([\\alpha, \\beta]\\) è¿™ä¸€æ®µçš„ç™½ç‚¹ç»ˆæ­¢æ—¶é—´ä¸è¶…è¿‡é»‘ç‚¹ï¼Œå› æ­¤ä½œä¸ºæœ€åä¸€ä¸ªå®Œæˆçš„ç™½ç‚¹ \\(\\beta\\) ï¼Œæœ‰ \\(t_\\beta+p_\\beta \\le t(N(\\beta )) + \\sum_{j\\in N(\\beta)} p_j\\) Theorithm 2. æœ¬ç®—æ³•æ±‚å‡ºçš„å®‰æ’æ–¹æ¡ˆä¸ºæœ€ä¼˜è§£ã€‚ ç”±å¼•ç† \\(1\\) ï¼Œæ¯ä¸ª \\(\\sigma_i\\) æ‰€éœ€è¦çš„æ—¶é—´å°±æ˜¯å…¶ä¸­é»‘ç‚¹æ‰€éœ€çš„æ—¶é—´ï¼Œå³ \\(\\overline{I_p}(CAT_i)\\) ï¼Œå› æ­¤æ€»æ–¹æ¡ˆ \\(\\sigma\\) æ‰€éœ€çš„æ—¶é—´ \\(\\sum_{i} \\overline{I_p}(CAT_i) = \\overline{I_p}(CAT)\\) ï¼Œå³ç­”æ¡ˆä¸‹ç•Œã€‚ æ€»ç»“ æœ€åæ”¾ä¸€ä¸ª pdf ç‰ˆçš„æ€»ç»“ï¼š","categories":[{"name":"Summary","slug":"Summary","permalink":"http://blog.gyx.me/categories/Summary/"}],"tags":[{"name":"Greedy","slug":"Greedy","permalink":"http://blog.gyx.me/tags/Greedy/"},{"name":"Graphs","slug":"Graphs","permalink":"http://blog.gyx.me/tags/Graphs/"},{"name":"Scheduling","slug":"Scheduling","permalink":"http://blog.gyx.me/tags/Scheduling/"}]},{"title":"Codeforces Round #787 (Div. 3)","slug":"codeforces/1675","date":"2022-05-06T12:01:00.000Z","updated":"2023-03-20T16:26:03.759Z","comments":true,"path":"codeforces/1675/","link":"","permalink":"http://blog.gyx.me/codeforces/1675/","excerpt":"","text":"A. Food for Animals \\(a\\) ä¸ªç‹—ç²®ï¼Œ\\(b\\) ä¸ªçŒ«ç²®ï¼Œ\\(c\\) ä¸ªé€šç”¨ç²®ï¼ˆéƒ½èƒ½åƒï¼‰ï¼Œèƒ½ä¸èƒ½ä¿è¯ \\(n\\) ä¸ªç‹— \\(m\\) ä¸ªçŒ«éƒ½æœ‰çš„åƒï¼Ÿ æ¯ä¸ªéƒ½å…ˆå‡æ‰ä¸“ç”¨çš„é£Ÿç‰©ï¼Œå‰©ä¸‹çš„çœ‹é€šç”¨çš„å¤Ÿä¸å¤Ÿåˆ†å³å¯ã€‚ 12345inline void work() &#123; int a = rd(), b = rd(), c = rd(); int n = max(0, rd() - a), m = max(0, rd() - b); puts(n + m &gt; c ? &quot;NO&quot; : &quot;YES&quot;);&#125; B. Make It Increasing ç»™ä¸€ä¸ªæ•°åˆ—ï¼Œæ¯æ¬¡æ“ä½œæŠŠä¸€ä¸ªä½ç½®æ•´é™¤ \\(2\\) ï¼Œæœ€å°‘æ“ä½œå¤šå°‘æ¬¡ä½¿å¾—æ•°åˆ—ä¸¥æ ¼é€’å¢ï¼Ÿ ä»åå¾€å‰å€’æ¨ï¼Œç­”æ¡ˆæ˜¯å›ºå®šçš„ï¼Œä¸€ç›´åšåˆ°ç¬¦åˆè¦æ±‚å³å¯ã€‚ 1234567891011int a[57];inline void work() &#123; int n = rd(), ans = 0; for (int i = 1; i &lt;= n; ++i) a[i] = rd(); for (int i = n - 1; i; --i) if (a[i] &gt;= a[i + 1]) &#123; if (a[i + 1] == 0) &#123;puts(&quot;-1&quot;); return;&#125; while (a[i] &gt;= a[i + 1]) &#123;++ans; a[i] = a[i] / 2;&#125; &#125; printf(&quot;%d\\n&quot;, ans);&#125; C. Detective Task æœ‰ä¸€å¹…ç”»ï¼Œ \\(n\\) ä¸ªäººçœ‹ï¼Œä¸­é—´æŸä¸€æ—¶åˆ»è¢«æŸä¸€ä¸ªäººå·èµ°äº†ã€‚ é—®æ¯ä¸ªäººä»–çœ‹çš„æ—¶å€™ç”»è¿˜åœ¨ä¸åœ¨ï¼Œç­”æ¡ˆå¯èƒ½æ˜¯æœ‰ (1) / æ—  (0) / å¿˜è®°äº† (?)ã€‚ å¥½äººä¼šè¯´å®è¯/å¿˜è®°äº†ï¼Œå·èµ°çš„äººä¼šéšæœºé€‰ä¸€ä¸ªç­”æ¡ˆï¼Œæ±‚æœ‰å¤šå°‘ä¸ªå«Œç–‘äººã€‚ æœ€åä¸€ä¸ªè¯´æœ‰ï¼ˆ1ï¼‰çš„äººï¼Œå‰é¢çš„äººéƒ½ä¸ä¼šæ˜¯å«Œç–‘äººï¼šå¦‚æœå‰é¢çš„äººæ˜¯å«Œç–‘äººï¼Œé‚£ä¹ˆä»–è¿›å»çš„æ—¶å€™åº”è¯¥å·²ç»è¢«å·äº†ï¼Œä»–å°±è¯´è°äº†ã€‚ ç¬¬ä¸€ä¸ªè¯´æ— ï¼ˆ0ï¼‰çš„äººï¼Œåé¢çš„äººéƒ½ä¸ä¼šæ˜¯å«Œç–‘äººï¼šå¦‚æœåé¢çš„äººæ˜¯å«Œç–‘äººï¼Œé‚£ä¹ˆä»–è¿›å»çš„æ—¶å€™è¿˜æ²¡è¢«å·ï¼Œä»–å°±è¯´è°äº† å› æ­¤ç­”æ¡ˆæ˜¯ä»æœ€åä¸€ä¸ªè¯´æœ‰çš„äººåˆ°ç¬¬ä¸€ä¸ªè¯´æ— çš„äººè¿™ä¸€æ®µçš„äººæ•°ã€‚ 1234567891011string s;inline void work() &#123; cin &gt;&gt; s; int n = s.length(); int l = 0, r = n - 1; for (int i = 0; i &lt; n; ++i) if (s[i] == &#x27;1&#x27;) l = i; for (int i = l; i &lt; n; ++i) if (s[i] == &#x27;0&#x27;) &#123;r = i; break;&#125; printf(&quot;%d\\n&quot;, r - l + 1);&#125; D. Vertical Paths ç»™ä¸€æ£µæ ‘ï¼Œé—®æœ€å°‘åˆ†æˆå¤šå°‘ä¸ªä»ä¸Šåˆ°ä¸‹çš„é“¾ï¼Œå¹¶è¾“å‡ºæ–¹æ¡ˆã€‚ æ˜¾ç„¶æ¯ä¸ªå¶å­éƒ½éœ€è¦ä¸€ä¸ªé“¾ï¼Œæ¯ä¸ªéå¶å­æŒ‘ä¸€ä¸ªå¶å­æŒ‚ä¸Šå°±è¡Œäº†ï¼Œçº¯è€ƒå®ç°ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 200007bool vis[N];int n, rt, f[N], cnt;vector&lt;int&gt; res[N], son[N];void dfs(int u, int bel) &#123; res[bel].push_back(u); if (son[u].empty()) &#123;++cnt; return;&#125; dfs(son[u][0], bel); for (int i = 1; i &lt; son[u].size(); ++i) dfs(son[u][i], son[u][i]);&#125;inline void work() &#123; n = rd(); cnt = 0; for (int i = 1; i &lt;= n; ++i) &#123;res[i].clear(); son[i].clear();&#125; for (int i = 1; i &lt;= n; ++i) &#123; f[i] = rd(); if (f[i] == i) rt = i; else son[f[i]].push_back(i); &#125; dfs(rt, rt); printf(&quot;%d\\n&quot;, cnt); for (int i = 1; i &lt;= n; ++i) if (!res[i].empty()) &#123; printf(&quot;%d\\n&quot;, (int)res[i].size()); for (auto j : res[i]) printf(&quot;%d &quot;, j); puts(&quot;&quot;); &#125; &#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; E. Replace With the Previous, Minimize ç»™ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œæ¯æ¬¡æ“ä½œä½ å¯ä»¥é€‰å®šä¸€ä¸ªå­—ç¬¦ï¼Œå¹¶æŠŠä¸²ä¸­çš„æ‰€æœ‰è¿™ä¸ªå­—ç¬¦æ¢æˆå­—å…¸åºå‰ä¸€ä¸ªï¼ˆa å˜æˆ z ï¼‰ é—® \\(k\\) æ¬¡æ“ä½œå†…ï¼Œå­—ç¬¦ä¸²å¯èƒ½çš„å­—å…¸åºæœ€å°çš„ç»“æœæ˜¯ä»€ä¹ˆï¼Ÿ é¦–å…ˆå¦‚æœ \\(k&gt;25\\) ï¼Œé‚£ä¹ˆæˆ‘ä» z åˆ° b éƒ½æ“ä½œä¸€éå°±éƒ½å˜æˆ aaaaaaa è¿™æ ·å­äº†ã€‚ å¦åˆ™ä¹Ÿä¸€å®šä¸ä¼šå¯¹ a æ“ä½œï¼Œå› ä¸ºæ¬¡æ•°ä¸å¤Ÿå˜å›æ¥äº†ï¼Œå› æ­¤æ“ä½œæ˜¯å•å‘çš„ï¼Œæ²¡æœ‰å¾ªç¯çš„ã€‚ å› æ­¤æŒ‰ç…§å­—å…¸åºè´ªå¿ƒå°±å®Œäº‹äº†ï¼Œç»´æŠ¤ä¸€ä¸ª \\(\\Sigma\\to \\Sigma\\) çš„è½¬ç§»è¡¨ï¼Œæ¯æ¬¡å¯ä»¥çš„è¯å¾€å‰ç§»åŠ¨ä¸€ä¸‹ã€‚ éœ€è¦æ³¨æ„çš„æ˜¯åˆ©ç”¨æ­¤å‰çš„ç»“æœï¼Œä¹Ÿå°±æ˜¯æ¯æ¬¡åšå®Œä¹‹åè®°å¾—æŠŠå‰ç¼€è¦†ç›–ä¸€ä¸‹ã€‚ 12345678910111213141516string s;unordered_map&lt;char, char&gt; tr;inline void work() &#123; int n = rd(), k = rd(); cin &gt;&gt; s; for (char i = &#x27;a&#x27;; i &lt;= &#x27;z&#x27;; ++i) tr[i] = i; for (auto i : s) &#123; while (k &amp;&amp; tr[i] &gt; &#x27;a&#x27;) &#123; --tr[i]; --k; tr[i] = tr[tr[i]]; &#125; for (char j = i; j &gt;= tr[i]; --j) tr[j] = min(tr[j], tr[i]); if (k == 0) break; &#125; for (auto i : s) putchar(tr[i]); puts(&quot;&quot;);&#125; F. Vlad and Unfinished Business ç»™ä¸€æ£µæ ‘ï¼Œæ ‘ä¸Šçš„ä¸¤ä¸ªç‚¹ \\(x, y\\) ï¼Œä»¥åŠä¸€ç³»åˆ—ç‚¹ \\(a_1, a_2, \\dots,a_k\\) æ±‚ä¸€ä¸ªæœ€çŸ­è·¯å¾„ï¼Œä» \\(x\\) å‡ºå‘ï¼Œä»¥ä»»æ„é¡ºåºéå†å®Œ \\(a_1, a_2, \\dots,a_k\\) ï¼Œæœ€åèµ°åˆ° \\(y\\) é¦–å…ˆä¸€ä¸ªå¸¸è§çš„å¥—è·¯ï¼ˆè™šæ ‘ï¼‰æ˜¯ï¼Œæ ‘ä¸Šéå†ä¸€ä¸ªç‚¹é›†çš„æœ€çŸ­å›è·¯ï¼Œå°±æ˜¯æ‰€æœ‰ç‚¹æŒ‰ç…§dfsåºä¸€æ¬¡æ€§è®¿é—®ã€‚ ç°åœ¨è€ƒè™‘è®©æ ‘ä»¥ \\(x\\) ä¸ºæ ¹ï¼Œç°åœ¨éœ€è¦éå† \\(a_1,a_2,\\dots,a_k\\) è¿™äº›ç‚¹ï¼Œæœ€åå†èµ°åˆ° \\(y\\) ã€‚ å…¶å®å¯ä»¥çœ‹æˆå›è·¯éå†ç‚¹é›† \\(x, a_1, a_2,\\dots, a_k,y\\) ï¼Œæœ€åå†æŠŠ \\(x\\) åˆ° \\(y\\) çš„è·ç¦»ï¼ˆä¹Ÿå°±æ˜¯ \\(y\\) çš„æ·±åº¦ï¼‰æ‰£æ‰ã€‚ æ‰€ä»¥æŒ‰ç…§ dfs åºä¾æ¬¡è®¿é—®å³å¯ï¼Œå¯èƒ½æ¯”è¾ƒéš¾å†™ã€‚ å¦å¤–ä¸€ç§ç®€å•çš„å†™æ³•æ˜¯æš´åŠ›å¾€æ ¹è·³ï¼Œè·³åˆ°ç¬¬ä¸€ä¸ªè®¿é—®åˆ°çš„ç‚¹å³å¯ï¼Œå¾€ç­”æ¡ˆé‡Œç´¯åŠ æ–°å¢çš„ç‚¹æ•° * 2 ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 200007vector&lt;int&gt; e[N], seq;bool vis[N];int n, k, x, y, f[N], ans;void dfs(int u, int fa, int dep) &#123; f[u] = fa; if (u == y) ans = -dep; for (auto v : e[u]) if (v != fa) dfs(v, u, dep + 1);&#125;inline void work() &#123; seq.clear(); n = rd(); k = rd(); x = rd(); y = rd(); for (int i = 1; i &lt;= n; ++i) vis[i] = 0, e[i].clear(); for (int i = 1; i &lt;= k; ++i) seq.push_back(rd()); seq.push_back(y); for (int i = 1; i &lt; n; ++i) &#123; int u = rd(), v = rd(); e[u].push_back(v); e[v].push_back(u); &#125; dfs(x, x, 0); vis[x] = 1; for (auto i : seq) for (int u = i; !vis[u]; u = f[u]) vis[u] = 1, ans += 2; printf(&quot;%d\\n&quot;, ans);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; G. Sorting Pancakes ç»™ä½ ä¸€ä¸ªåºåˆ—ï¼Œæ¯æ¬¡æ“ä½œå¯ä»¥é€‰ä¸¤ä¸ªç›¸é‚»çš„ä¸¤ä¸ªä½ç½®ä¸€ä¸ª \\(-1\\) ä¸€ä¸ª \\(+1\\) ï¼Œé—®æœ€å°æ“ä½œå¤šå°‘æ¬¡æ˜¯çš„åºåˆ—å•å‡ã€‚ çœ‹åˆ°è¿™ç§é—®é¢˜ä¸€èˆ¬éƒ½æ˜¯ dp ï¼Œå°±æ˜¯çŠ¶æ€è®¾è®¡éœ€è¦å¥½å¥½è€ƒè™‘ä¸€ä¸‹ã€‚ è®¾ \\(f_{i,j}\\) è¡¨ç¤ºè€ƒè™‘äº†å‰ \\(i\\) ä½ï¼Œå‰ç¼€å’Œæ˜¯ \\(j\\) çš„æœ€å°æ“ä½œæ•°ï¼Œé‚£ä¹ˆè½¬ç§»å°±æ˜¯æšä¸¾åºåˆ—æœ€ç»ˆä¸‹ä¸€ä¸ªä½ç½®çš„æ•°å­— \\(k\\) ã€‚ å³ \\(f_{i+1,j+k}=\\min\\{f_{i+1,j+k}, f_{i,j} + cost (i + 1, j+k)\\}\\) å…¶ä¸­ \\(cost(x, w)\\) è¡¨ç¤ºå‰ç¼€ \\(x\\) åœ¨æ­¤å‰åŸºç¡€ä¸Šå˜æˆæ€»å’Œ \\(w\\) çš„æœ€å°ä»£ä»·ã€‚ è€ƒè™‘ \\(f_{i,j}\\) é‡Œå·²ç»åŒ…å«äº†è®©å‰ç¼€ \\(i\\) åˆæ³•çš„ä»£ä»·ï¼Œç°åœ¨å…¶å®åªéœ€è¦è€ƒè™‘æ–°ä¸€ä½æ˜¯ \\(k\\) çš„ä»£ä»·ã€‚ æœ¬è´¨ä¸Šæˆ‘ä»¬åªéœ€è¦è€ƒè™‘ç¬¬ \\(i+1\\) ä½å’Œåé¢çš„åç¼€äº¤æµçš„å¤šå°‘æ¬¡ï¼Œå³ \\(cost(i+1,j+k)=|\\sum_{p=1}^{i+1}a_p-(j+k)|\\) é‚£ä¹ˆæ€ä¹ˆä¿è¯åºåˆ—å•å‡å‘¢ï¼ŸæŠŠæšä¸¾ \\(k\\) çš„å¾ªç¯æ”¾åˆ°æœ€å¤–é¢ï¼Œä»å¤§åˆ°å°ï¼Œè¿™æ ·è½¬ç§»æ˜¯ä»å¤§åˆ°å°çš„ï¼Œæ¯”è¾ƒå¦™ã€‚ 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 257int a[N], s[N], f[N][N];int main() &#123; int n = rd(), m = rd(); for (int i = 1; i &lt;= n; ++i) s[i] = s[i - 1] + (a[i] = rd()); memset(f, 0x3f, sizeof(f)); f[0][0] = 0; for (int k = m; ~k; --k) for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt;= m - k; ++j) f[i + 1][j + k] = min(f[i + 1][j + k], f[i][j] + abs(j + k - s[i + 1])); printf(&quot;%d\\n&quot;, f[n][m]); return 0;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://blog.gyx.me/categories/Codeforces/"},{"name":"Codeforces Round","slug":"Codeforces/Codeforces-Round","permalink":"http://blog.gyx.me/categories/Codeforces/Codeforces-Round/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"},{"name":"DFS and Similar","slug":"DFS-and-Similar","permalink":"http://blog.gyx.me/tags/DFS-and-Similar/"}]},{"title":"Dynamic Programming on Intervals","slug":"algorithms/dp-interval","date":"2022-04-26T00:13:35.000Z","updated":"2023-03-20T16:50:02.320Z","comments":true,"path":"algorithms/dp-interval/","link":"","permalink":"http://blog.gyx.me/algorithms/dp-interval/","excerpt":"","text":"Normal Problems åŒºé—´åŠ¨æ€è§„åˆ’çš„ä¸€èˆ¬å½¢å¼ï¼šæšä¸¾é•¿åº¦ï¼ˆé˜¶æ®µï¼‰ï¼Œæšä¸¾å·¦ç«¯ç‚¹ï¼Œéœ€è¦çš„è¯å†æšä¸¾åˆ†å‰²ç‚¹ Unlock the Padlock Source:Google Kick Start 2022 Round Bä¸€ä¸ªæ»šè½®å¯†ç é”ç”± \\(n\\)ä¸ªæ»šè½®ç»„æˆï¼Œæ¯ä¸ªçš„èŒƒå›´éƒ½æ˜¯ \\([0, D-1]\\)ï¼ˆå¾ªç¯ï¼‰ï¼Œåˆå§‹æ˜¯ \\(a_i\\) ã€‚æ¯æ¬¡æ“ä½œé€‰å–ä¸€ä¸ªåŒºé—´ \\(1 \\le l_i \\le r_i\\le n\\) ï¼Œå°†åŒºé—´å†…æ‰€æœ‰æ»šè½®éƒ½å‘ä¸Šæˆ–å‘ä¸‹æ‹¨ä¸€ä¸ªä½ç½®ã€‚è¦æ±‚ \\([l_i,r_i]\\subseteq[l_{i+1},r_{i+1}]\\) ï¼Œé—®æœ€å°‘å¤šå°‘æ¬¡æŠŠæ‰€æœ‰ä½ç½®éƒ½å˜æˆ \\(0\\) ã€‚ åŒºé—´åªèƒ½æ‰©å¼ ä¸èƒ½æ”¶ç¼©ï¼Œå› æ­¤ä»»æ„æ—¶åˆ»æ‹¨åŠ¨çš„åŒºé—´å†…çš„æ•°å­—ä¸€å®šè¦ç›¸åŒã€‚ å¦‚æœ \\(D\\) å¾ˆå°ï¼Œå¯ä»¥è®¾ \\(f[l][r][k]\\) è¡¨ç¤ºåŒºé—´ \\([l,r]\\) éƒ½è°ƒæˆ \\(k\\) çš„æœ€å°ä»£ä»·ï¼Œç›´æ¥ \\(\\mathcal O(n^2D^2)\\) æ±‚è§£ã€‚ é‚£ä¹ˆä»€ä¹ˆæ—¶å€™åŒºé—´èƒ½çœŸçš„æ‰©å¼ ï¼Ÿå½“ä¸”ä»…å½“åŒºé—´å†…çš„å€¼å’Œ \\(a_{l-1}\\) æˆ– \\(a_{r+1}\\) ä¸€æ ·ï¼Œæ‰èƒ½å‘å·¦æˆ–å‘å³æ‰©å±•ä¸€ä½ã€‚ å› æ­¤ ä»»æ„æ—¶åˆ»æ“ä½œåŒºé—´çš„å€¼ä¸€å®šå’ŒæŸä¸ªç«¯ç‚¹ç›¸åŒ ï¼Œè®¾ \\(f[l][r][0/1]\\) è¡¨ç¤ºæŠŠ \\([l,r]\\) éƒ½è°ƒæˆå·¦/å³ç«¯ç‚¹çš„æœ€å°æ“ä½œæ¬¡æ•°ã€‚ ç›´æ¥æ¯æ¬¡åŒºé—´é•¿åº¦æ‰©å±• \\(1\\) è½¬ç§»å³å¯ï¼Œå¤æ‚åº¦ \\(\\mathcal O(n^2)\\) ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 407int testcase;ll n, d, f[N][N][2], a[N];inline ll dis(ll a, ll b) &#123; ll w = abs(a - b); return min(w, d - w);&#125;inline void getmin(ll &amp;a, ll b) &#123;a = (a &lt; b ? a : b);&#125;inline void work() &#123; n = rd(); d = rd(); memset(f, 0x3f, sizeof(f)); for (int i = 1; i &lt;= n; ++i) &#123; a[i] = rd(); f[i][i][0] = f[i][i][1] = 0; &#125; for (int len = 1; len &lt; n; ++len) &#123; for (int l = 1; l &lt;= n - len + 1; ++l) &#123; int r = l + len - 1; getmin(f[l - 1][r][0], f[l][r][0] + dis(a[l], a[l - 1])); getmin(f[l - 1][r][0], f[l][r][1] + dis(a[r], a[l - 1])); getmin(f[l][r + 1][1], f[l][r][0] + dis(a[l], a[r + 1])); getmin(f[l][r + 1][1], f[l][r][1] + dis(a[r], a[r + 1])); &#125; &#125; ll ans = min(f[1][n][0] + dis(a[1], 0), f[1][n][1] + dis(a[n], 0)); printf(&quot;Case #%d: %lld\\n&quot;, ++testcase, ans);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; Sue çš„å°çƒ Source: SDOI2008æœ‰ \\(n\\) ä¸ªçƒå¾€ä¸‹è½ï¼Œåˆå§‹åæ ‡æ˜¯\\(x_i\\) ï¼Œé«˜åº¦æ˜¯ \\(h_i\\) ï¼Œä¸‹è½é€Ÿåº¦ \\(v_i\\) ï¼Œå¯ä»¥ä¸‹è½åˆ°æ­£æ— ç©·ã€‚åˆå§‹åæ ‡åœ¨ \\(x_0\\)ï¼Œæ¯ç§’å¯ä»¥å‘å·¦/å‘å³ç§»åŠ¨ \\(1\\)ï¼Œç»è¿‡æŸä¸ªçƒçš„åæ ‡æ—¶å°±æŠŠè¿™ä¸ªçƒæ‹¿èµ°ï¼Œè·å¾—å½“å‰é«˜åº¦çš„å¾—åˆ†ã€‚é—®æ‹¿åˆ°æ‰€æœ‰çƒçš„å‰æä¸‹ï¼Œæœ€å¤§å¾—åˆ†æ˜¯å¤šå°‘ã€‚ å¾—åˆ† \\(=\\sum h_i-\\sum\\) ä¸‹é™çš„é«˜åº¦ï¼Œè€ƒè™‘åŠ¨æ€è§„åˆ’æ±‚ \\(\\min\\sum\\) ä¸‹é™çš„é«˜åº¦ã€‚ é—®é¢˜å˜ä¸ºç¬¬ \\(i\\) ä¸ªä½ç½®æ¯ç§’ä¼šæ¶ˆè€— \\(v_i\\) ï¼Œåˆ°ä¸€ä¸ªä½ç½®å°±ä¼šåœæ­¢æ¶ˆè€—ï¼Œæ˜¯ å…³è·¯ç¯ è¿™ä¸ªæ¨¡å‹ã€‚ è€ƒè™‘æŠŠåæ ‡æ’åºä¹‹åç¦»æ•£åŒ–ï¼Œæ‹¿èµ°çš„çƒä¸€å®šæ˜¯ä¸€ä¸ªè¿ç»­çš„åŒºé—´ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥è®©çŠ¶æ€åœåœ¨æŸä¸€ä¸ªç«¯ç‚¹ã€‚ çŠ¶æ€è®¾è®¡æ¯”è¾ƒç‰¹æ®Šï¼šè®¾ \\(f[l][r][0/1]\\) è¡¨ç¤ºæŠŠ \\([l,r]\\) å…¨éƒ¨æ‹¿èµ°ï¼Œæœ€ååœåœ¨å·¦/å³ç«¯ç‚¹ï¼Œä»å¼€å§‹åˆ°è¿™ä¸ªæ—¶åˆ»çš„æœ€å°æ€»æ¶ˆè€— é‚£ä¹ˆè€ƒè™‘æ¯æ¬¡æ‰©å±•ä¸€ä¸ªä½ç½®ï¼Œé‚£ä¹ˆæ‰€è€—çš„æ—¶é—´å°±æ˜¯ä¸¤ç‚¹è·ç¦»ï¼Œæ¯ä¸€ç§’çš„ä»£ä»·å°±æ˜¯ \\(\\sum_{i\\notin [l,r]} v_i\\) ï¼ˆæ‰€æœ‰æ²¡æ¥åˆ°çš„çƒï¼‰ éœ€è¦æ³¨æ„æŠŠåˆå§‹åæ ‡ç¦»æ•£åŒ–è¿›å»ã€‚æšä¸¾åŒºé—´åŠ¨æ€è§„åˆ’å¤æ‚åº¦ \\(\\mathcal O(n^2)\\) ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;typedef double db;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 1007#define fr first#define sc secondpair&lt;int, double&gt; p[N];db ans, sum[N], f[N][N][2];inline void getmin(db &amp;a, db b) &#123;a = (a &lt; b ? a : b);&#125;int main() &#123; int n = rd(), c = rd(); for (int i = 1; i &lt;= n; ++i) p[i].fr = rd(); for (int i = 1; i &lt;= n; ++i) ans += rd() / 1000.0; for (int i = 1; i &lt;= n; ++i) p[i].sc = rd() / 1000.0; p[++n] = make_pair(c, 0); sort(p + 1, p + 1 + n); for (int l = 1; l &lt;= n; ++l) for (int r = 1; r &lt;= n; ++r) for (int k = 0; k &lt; 2; ++k) f[l][r][k] = 1e18; for (int i = 1; i &lt;= n; ++i) &#123; sum[i] = sum[i - 1] + p[i].sc; if (p[i].fr == c) f[i][i][0] = f[i][i][1] = 0; &#125; for (int len = 1; len &lt; n; ++len) for (int l = 1; l &lt;= n - len + 1; ++l) &#123; int r = l + len - 1; db rsum = sum[n] - sum[r] + sum[l - 1]; getmin(f[l - 1][r][0], f[l][r][0] + (p[l].fr - p[l - 1].fr) * rsum); getmin(f[l - 1][r][0], f[l][r][1] + (p[r].fr - p[l - 1].fr) * rsum); getmin(f[l][r + 1][1], f[l][r][0] + (p[r + 1].fr - p[l].fr) * rsum); getmin(f[l][r + 1][1], f[l][r][1] + (p[r + 1].fr - p[r].fr) * rsum); &#125; printf(&quot;%.3lf\\n&quot;, ans - min(f[1][n][0], f[1][n][1])); return 0;&#125; Cities Source: The45th ICPC Asia Kunming Regionalæœ‰ \\(n\\) ä¸ªç‚¹ï¼Œç¬¬ \\(i\\) ä¸ªç‚¹çš„é¢œè‰²æ˜¯ \\(c_i\\) ï¼Œä¿è¯æ¯ç§é¢œè‰²æœ€å¤šå‡ºç° \\(15\\) æ¬¡ã€‚æ¯æ¬¡æ“ä½œå¯ä»¥æŠŠä¸€æ®µè¿ç»­ä¸”é¢œè‰²ç›¸åŒçš„ç‚¹éƒ½æ”¹æˆæŸä¸ªé¢œè‰²ï¼Œé—®æœ€å°‘æ“ä½œå¤šå°‘æ¬¡ä½¿å¾—æ‰€æœ‰ç‚¹é¢œè‰²ç›¸åŒã€‚ å…ˆæŠŠåŒæ ·é¢œè‰²ä¸”è¿ç»­çš„ç¼©æˆä¸€æ®µï¼Œè¿™æ ·ç›¸é‚»ä¸¤ä¸¤é¢œè‰²éƒ½ä¸åŒï¼Œå‡è®¾æœ‰ \\(m\\) æ®µã€‚ å¦‚æœæ‰€æœ‰çš„é¢œè‰²éƒ½ä¸åŒçš„è¯ï¼Œé‚£ä¹ˆç­”æ¡ˆå°±æ˜¯ \\(m-1\\) ï¼Œå› ä¸ºæ¯æ¬¡åªèƒ½æ”¹é¢œè‰²ç›¸åŒçš„ã€‚ ä½†æ˜¯åºåˆ—ä¸­ä¾æ—§æœ‰é¢œè‰²ç›¸åŒçš„ï¼Œå› æ­¤éœ€è¦åŠ¨æ€è§„åˆ’æ±‚ï¼Œè®¾ \\(f[l][r]\\) è¡¨ç¤ºæŠŠ \\([l,r]\\) å˜æˆç›¸åŒçš„æ‰€éœ€çš„æœ€å°‘æ¬¡æ•°ã€‚ è½¬ç§»è€ƒè™‘ \\(c_l\\) æœ‰æ²¡æœ‰å•ç‹¬æ¶ˆè€—ä¸€æ¬¡åˆå¹¶ï¼š å¦‚æœå•ç‹¬æ¶ˆè€—äº†ä¸€æ¬¡å°±æ˜¯ \\(f[l][r] = f[l + 1][r] + 1\\) å¦‚æœä¸æ¶ˆè€—ï¼Œé‚£ä¹ˆæšä¸¾ç›¸åŒçš„å¦ä¸€ä¸ªæ˜¯ \\(k\\) ï¼Œé‚£ä¹ˆ \\(f[l][r] = f[l + 1][k - 1] + f[k][r] + 1\\) åé¢è¿™ä¸ªæ–¹ç¨‹æˆç«‹çš„åŸå› æ˜¯ï¼Œæˆ‘ä»¬å‘ç°æ“ä½œæ€»æ˜¯å¯ä»¥ç­‰æ•ˆåˆ°æŠŠåŒºé—´å˜æˆå’Œç«¯ç‚¹é¢œè‰²ç›¸åŒã€‚ éœ€è¦ç¼©ç‚¹çš„åŸå› æ˜¯ï¼Œåä¸€ç§æ–¹ç¨‹é‡Œçš„ \\(+1\\) æ˜¯ä¸ºäº†æŠŠ \\([l + 1][k - 1]\\) å˜æˆå’Œ \\(c_l\\) ç›¸åŒçš„ï¼Œä¸ç¼©ä¼šæ±‚é”™ã€‚ æšä¸¾åŒºé—´ï¼Œå†æšä¸¾ç›¸åŒé¢œè‰²ï¼Œå› ä¸ºé¢˜ç›®é™åˆ¶æ¯ç§é¢œè‰²æœ€å¤šå‡ºç° \\(15\\) æ¬¡ï¼Œå¤æ‚åº¦ \\(O(15n^2)\\) ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;typedef double db;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;inline void getmin(int &amp;a, int b) &#123;a = (a &lt; b ? a : b);&#125;#define N 5007int a[N], f[N][N], lst[N], nxt[N];inline void work() &#123; int n = rd(), tot = 0; for (int i = 1, x; i &lt;= n; ++i) &#123; x = rd(); if (!tot || x != a[tot]) a[++tot] = x; lst[i] = n + 1; &#125; n = tot; for (int i = n; i; --i) &#123; nxt[i] = lst[a[i]]; lst[a[i]] = i; &#125; for (int len = 2; len &lt;= n; ++len) for (int l = 1; l &lt;= n - len + 1; ++l) &#123; int r = l + len - 1; f[l][r] = f[l + 1][r] + 1; for (int j = nxt[l]; j &lt;= r; j = nxt[j]) getmin(f[l][r], f[l + 1][j - 1] + f[j][r] + 1); &#125; printf(&quot;%d\\n&quot;, f[1][n]);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; Dire Wolf Source:2014 ICPC Asia Beijing Regionalæœ‰ \\(n\\) ä¸ªæç‹¼å…ˆé”‹æ’æˆä¸€æ’ï¼Œç¬¬\\(i\\) ä¸ªæœ‰ \\(a_i\\) åˆå§‹æ”»å‡»åŠ›ï¼Œå¹¶ä¸”ä¼šä¸ºä¸¤ä¾§çš„æç‹¼ä¸´æ—¶å¢åŠ  \\(b_i\\)æ”»å‡»åŠ›ï¼ˆæ­»äº†å°±æ²¡äº†ï¼‰æ¯æ¬¡æ€æ‰ä¸€ä¸ªéœ€è¦æ‰¿å—ä»–å½“å‰æ”»å‡»åŠ›çš„ä¼¤å®³ï¼Œé—®æ€æ‰æ‰€æœ‰çš„ç‹¼ï¼Œæ‰¿å—æœ€å°‘ä¼¤å®³æ˜¯å¤šå°‘ã€‚ è®¾ \\(f[l][r]\\) è¡¨ç¤ºæŠŠ \\([l,r]\\) è¿™ä¸ªåŒºé—´çš„æ‰€æœ‰ç‹¼æ€æ‰æ‰€éœ€çš„æœ€å°ä»£ä»·ã€‚ æšä¸¾æœ€åä¸€åªæ€æ‰çš„ç‹¼ \\(k\\) ï¼Œè€ƒè™‘æ­¤æ—¶ä»–ä¸¤ä¾§çš„ç‹¼æ˜¯è°ï¼Ÿ ç­”æ¡ˆæ˜¯ \\(l-1\\) å’Œ \\(r+1\\) ï¼Œè€ƒè™‘åŒºé—´ DP çš„é˜¶æ®µæ€§ï¼Œæˆ‘åªéœ€è¦æ€æ­»å½“å‰æšä¸¾çš„åŒºé—´çš„ç‹¼ï¼Œæ‰€ä»¥ä¸¤ä¾§çš„ç‹¼éƒ½æ²¡æœ‰æ­»è¿‡ã€‚ æ‰€ä»¥æœ€åä¸€åªç‹¼çš„æ”»å‡»åŠ›æ˜¯ \\(a_k+b_{l-1}+b_{r + 1}\\) ï¼Œæšä¸¾ \\(k\\) æ›´æ–°ï¼Œå¤æ‚åº¦æ˜¯ \\(\\mathcal O(n^3)\\) çš„ã€‚ \\[ f[l][r] = \\min_{l\\le k\\le r} \\bigg\\{f[l][k-1]+f[k+1][r]+a_k+b_{l-1}+b_{r+1}\\bigg\\} \\] 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 207int a[N], b[N], testcase;ll f[N][N];inline void work() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) a[i] = rd(); for (int i = 1; i &lt;= n; ++i) b[i] = rd(); b[n + 1] = 0; for (int len = 1; len &lt;= n; ++len) for (int l = 1; l &lt;= n - len + 1; ++l) &#123; int r = l + len - 1; f[l][r] = 1e18; for (int p = l; p &lt;= r; ++p) f[l][r] = min(f[l][r], f[l][p - 1] + f[p + 1][r] + a[p] + b[l - 1] + b[r + 1]); &#125; printf(&quot;Case #%d: %lld\\n&quot;, ++testcase, f[1][n]);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; You Are the One Source:2012 ICPC Asia Tianjin Regional Online\\(n\\)ä¸ªäººæ’æˆä¸€é˜Ÿä¾æ¬¡å…¥æ ˆï¼Œä»»æ„æ—¶åˆ»éƒ½å¯ä»¥æŒ‰æ ˆåºå¼¹å‡ºæ ˆå†…çš„ä»»æ„äººæ•°ã€‚ç¬¬ \\(i\\) ä¸ªäººå¦‚æœæ˜¯ç¬¬ \\(k\\) ä¸ªå‡ºåœºçš„ï¼Œä»£ä»·æ˜¯ \\(D_i\\ast (k-1)\\)ï¼Œæ±‚æ‰€æœ‰äººä»£ä»·å’Œæœ€å°å¯èƒ½æ˜¯å¤šå°‘ã€‚ è®¾ \\(f[l][r]\\) è¡¨ç¤ºåºåˆ—é‡Œåªæœ‰ \\([l,r]\\) è¿™äº›äººï¼ˆå‡è®¾åŒºé—´å‰åçš„äººä¸å­˜åœ¨ï¼‰ï¼Œæœ€å°ä»£ä»·æ˜¯å¤šå°‘ã€‚ è§‚å¯Ÿè¿™äº›äººçš„å‡ºå…¥æ ˆçš„é¡ºåºï¼Œå‘ç°åºåˆ—ä¼šè¢«ç¬¬ä¸€ä¸ªäººä½•æ—¶å‡ºæ ˆåˆ’åˆ†ä¸ºä¸¤ä¸ªé˜¶æ®µã€‚ ç¬¬ä¸€ä¸ªäººç¬¬ä¸€ä¸ªå…¥æ ˆï¼Œå‡è®¾ç¬¬ \\(k\\) ä¸ªå‡ºæ ˆï¼ˆä»–å‡ºæ ˆå‰åªå‹å…¥ç¬¬ \\(2\\sim k\\) ä¸ªäººï¼‰é‚£ä¹ˆåºåˆ—è¡¨ç°ä¸ºï¼š ç¬¬ \\(2\\sim k\\) ä¸ªäººå‡ºå…¥æ ˆï¼Œè¿™äº›äººå‰é¢æ²¡æœ‰å…¶ä»–äººï¼Œä»£ä»·æ˜¯ \\(f[l+1][l+k-1]\\) ç¬¬ä¸€ä¸ªäººå‡ºæ ˆï¼Œå‰é¢æœ‰ \\(k-1\\) ä¸ªäººï¼Œä»£ä»·æ˜¯ \\(D_l\\ast(k-1)\\) ç¬¬ \\(k+1\\sim n\\) ä¸ªäººå‡ºå…¥æ ˆï¼Œè¿™äº›äººå‰é¢éƒ½å¢åŠ  \\(k\\) ä¸ªäººï¼Œä»£ä»·æ˜¯ \\(f[l+k][r]+\\sum_{i=l+k+1}^rD_i\\ast k\\) æšä¸¾ \\(k\\) æ›´æ–°ï¼Œå¤æ‚åº¦æ˜¯ \\(\\mathcal O(n^3)\\) çš„ã€‚ \\[ f[l][r] =\\min_{1\\le k\\le r-l+1} \\bigg\\\\{f[l + 1][l + k-1]+D_l\\ast(k-1)+f[l+k][r] + \\sum_{i=l+k}^r D_i\\ast k\\bigg\\\\} \\] 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 107int testcase;ll d[N], sum[N], f[N][N];inline void getmin(ll &amp;a, ll b) &#123;a = (a &lt; b ? a : b);&#125;inline void work() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; d[i] = rd(); sum[i] = sum[i - 1] + d[i]; &#125; for (int len = 2; len &lt;= n; ++len) for (int l = 1; l &lt;= n - len + 1; ++l) &#123; int r = l + len - 1; f[l][r] = 1e18; for (int k = 1; k &lt;= len; ++k) getmin(f[l][r], f[l + 1][l + k - 1] + d[l] * (k - 1) + f[l + k][r] + (sum[r] - sum[l + k - 1]) * k); &#125; printf(&quot;Case #%d: %lld\\n&quot;, ++testcase, f[1][n]);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; äºŒå‰æŸ¥æ‰¾æ ‘ Source: NOI2009ç»™å®š \\(n\\) ä¸ªèŠ‚ç‚¹çš„key,value,times ï¼Œä¿®æ”¹ä¸€ä¸ªç‚¹çš„ value ä»£ä»·æ˜¯\\(K\\) ï¼Œä¿®æ”¹åè¦ä¿è¯ä¸¤ä¸¤value ä¸åŒã€‚ç„¶åæŠŠè¿™äº›ç‚¹å»ºå‡ºä¸€ä¸ª Treapï¼Œå®šä¹‰è®¿é—®ä»£ä»· \\(\\sum_{i} depth_i\\ast times_{i}\\)ï¼Œæœ€å°åŒ–ä¿®æ”¹ä»£ä»· + è®¿é—®ä»£ä»·ã€‚ æ ¸å¿ƒç‚¹æ˜¯ key ä¸èƒ½ä¿®æ”¹ï¼Œæ‰€ä»¥ä¸­åºéå†æ˜¯å›ºå®šçš„ï¼Œæ ¹å·¦ä¾§æ˜¯å·¦å­æ ‘ï¼Œæ ¹å³ä¾§æ˜¯å³å­æ ‘ã€‚ è€ƒè™‘åœ¨ä¸­åºéå†ä¸ŠåšåŒºé—´ DP ï¼Œæšä¸¾è°åšæ ¹ï¼Œé‚£ä¹ˆæ ¹çš„ value åº”å½“æ¯”å·¦å³å­æ ‘çš„èŠ‚ç‚¹ value è¦å°ã€‚ æ‰€ä»¥çŠ¶æ€é‡Œæˆ‘ä»¬è¿˜è¦è®°ä¸€ä¸‹å½“å‰å­æ ‘çš„æœ€å° value æ˜¯å¤šå°‘ã€‚ è®¾ \\(f[l][r][k]\\) è¡¨ç¤ºä¸­åºéå†åŒºé—´ \\([l,r]\\) å†…çš„ç‚¹å»ºæ ‘ï¼Œé‡Œé¢çš„ç‚¹ value æƒå€¼ \\(\\ge k\\) ï¼Œçš„æœ€å°ä»£ä»·ã€‚ å¦‚æœè¿™ä¸ªç‚¹çš„æƒå€¼ä¸éœ€è¦æ”¹ï¼ˆå‰æ \\(value_{rt}\\ge k\\) ï¼‰ï¼Œé‚£ä¹ˆå­æ ‘é‡Œçš„æƒå€¼è¦æ¯”ä»–å¤§ \\[ f[l][r][k] = \\min_{l\\le rt\\le r}\\bigg\\{f[l][rt - 1][value_{rt}]+f[rt + 1][r][value_{rt}] + \\sum_{i=l}^r times_i\\bigg\\} \\] å¦‚æœè¿™ä¸ªç‚¹æƒå€¼éœ€è¦æ”¹ï¼Œé‚£ä¹ˆå­æ ‘çš„æƒå€¼ä¸‹ç•Œä¹Ÿæ˜¯ \\(k\\) \\[ f[l][r][k] = \\min_{l\\le rt\\le r}\\bigg\\{f[l][rt - 1][k]+f[rt + 1][r][k] + \\sum_{i=l}^r times_i + K\\bigg\\} \\] å› ä¸ºåˆå§‹ä¸¤ä¸¤èŠ‚ç‚¹ value å°±ä¸åŒï¼Œè€Œä¸”å¯ä»¥è°ƒæ•´æˆä»»æ„å®æ•°ï¼Œæ‰€ä»¥æ–¹ç¨‹ä¸­å¯¹å­æ ‘æƒå€¼çš„çº¦æŸä¸ç”¨ä¿®æ”¹ã€‚ ç­”æ¡ˆæ˜¯ \\(\\min_k f[1][n][k]\\) ï¼ŒæŠŠæƒå€¼ç¦»æ•£åŒ–ä¸€ä¸‹ï¼ŒDP å¤æ‚åº¦æ˜¯ \\(\\mathcal O(n^4)\\) çš„ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;vector&lt;int&gt; s;unordered_map&lt;int, int&gt; tr;#define N 73struct node &#123;int k, v, t;&#125; c[N];ll f[N][N][N], sumt[N];inline void getmin(ll &amp;a, ll b) &#123;a = (a &lt; b ? a : b);&#125;int main() &#123; int n = rd(), w = rd(); for (int i = 1; i &lt;= n; ++i) c[i].k = rd(); for (int i = 1; i &lt;= n; ++i) s.push_back(c[i].v = rd()); for (int i = 1; i &lt;= n; ++i) c[i].t = rd(); sort(s.begin(), s.end()); int cnt = 0; for (auto i : s) tr[i] = ++cnt; for (int i = 1; i &lt;= n; ++i) c[i].v = tr[c[i].v]; sort(c + 1, c + 1 + n, [](node x, node y)&#123;return x.k &lt; y.k;&#125;); for (int i = 1; i &lt;= n; ++i) sumt[i] = sumt[i - 1] + c[i].t; for (int len = 1; len &lt;= n; ++len) for (int l = 1; l &lt;= n - len + 1; ++l) &#123; int r = l + len - 1; for (int k = 0; k &lt;= n; ++k) &#123; f[l][r][k] = 1e18; for (int rt = l; rt &lt;= r; ++rt) &#123; if (c[rt].v &gt;= k) getmin(f[l][r][k], f[l][rt - 1][c[rt].v] + f[rt + 1][r][c[rt].v]); getmin(f[l][r][k], f[l][rt - 1][k] + f[rt + 1][r][k] + w); &#125; f[l][r][k] += sumt[r] - sumt[l - 1]; &#125; &#125; ll ans = 1e18; for (int k = 0; k &lt;= n; ++k) ans = min(ans, f[1][n][k]); printf(&quot;%lld\\n&quot;, ans); return 0;&#125; Pre-Order Source :AtCoder Beginner Contest 252 Gå®šä¹‰ dfsåºï¼šä»æ ¹å¼€å§‹ï¼Œæ¯æ¬¡é€‰æ‹©æœªè®¿é—®è¿‡çš„æœ€å°å„¿å­è®¿é—®ï¼Œæ¯ä¸ªç‚¹ç¬¬ä¸€æ¬¡è¢«è®¿é—®æ—¶è®°å…¥åºåˆ—å°¾ã€‚ç°ç»™å®š dfs åºï¼Œé—®æœ‰å¤šå°‘æ£µæ ‘ç¬¦åˆã€‚ \\(n\\le500\\) è€ƒè™‘å¤šå‰æ ‘è½¬äºŒå‰æ ‘ï¼ˆå·¦å„¿å­å³å…„å¼Ÿï¼Œè¿™æ˜¯ä¸€ä¸ªåŒå°„ï¼‰ï¼Œé‚£ä¹ˆè¦æ±‚å°±å˜ä¸ºå³å„¿å­ä¸€å®šè¦å°äºçˆ¶èŠ‚ç‚¹çš„ç¼–å·ã€‚ è®¾ \\(f_{l, r}\\) è¡¨ç¤º \\([l,r]\\) è¿™æ®µåŒºé—´ï¼Œä»¥ \\(l\\) ä¸ºæ ¹å½¢æˆè¿™æ ·ä¸€æ£µäºŒå‰æ ‘çš„æ–¹æ¡ˆæ•°ã€‚ æšä¸¾å³å„¿å­æ˜¯ \\(k\\in[l + 1, r], a[k] &gt; a[l]\\) ï¼Œæœ‰è½¬ç§» \\(f_{l, r} = \\sum_k f_{l,k - 1} \\times f_{k, r}\\) 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 507#define mod 998244353ll a[N], f[N][N];int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; a[i] = rd(); f[i][i] = 1; &#125; for (int len = 2; len &lt; n; ++len) &#123; for (int l = 2; l &lt;= n - len + 1; ++l) &#123; int r = l + len - 1; f[l][r] = f[l + 1][r]; for (int k = l + 1; k &lt;= r; ++k) if (a[k] &gt; a[l]) f[l][r] = (f[l][r] + 1ll * max(1ll, f[l + 1][k - 1]) * f[k][r]) % mod; &#125; &#125; printf(&quot;%lld\\n&quot;, f[2][n]); return 0;&#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://blog.gyx.me/categories/Algorithms/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"}]},{"title":"AtCoder Grand Contest 001","slug":"atcoder/agc001","date":"2022-04-12T02:08:12.000Z","updated":"2023-03-20T16:29:03.628Z","comments":true,"path":"atcoder/agc001/","link":"","permalink":"http://blog.gyx.me/atcoder/agc001/","excerpt":"","text":"å®˜æ–¹é¢˜è§£ï¼šhttps://img.atcoder.jp/agc001/editorial.pdf å¬è¯´å¤šåš AGC å¯ä»¥æå‡æ™ºåŠ›ï¼Œäºæ˜¯æ¥å°è¯•æå‡ä¸€ä¸‹æ™ºåŠ›ï¼ˆè™½ç„¶éƒ½æ˜¯æŠ„çš„é¢˜è§£ï¼‰ã€‚ A - BBQ Easy \\(2n\\) ä¸ªæ•°ï¼Œæœ€å¤§åŒ–ä¸¤ä¸¤ä¸€ç»„åˆ†ç»„åï¼Œæ¯ç»„ä¸¤ä¸ªæ•°å– \\(\\min\\) çš„å’Œã€‚ ä»å°åˆ°å¤§æ’åºä¹‹åï¼Œä¸¤ä¸¤ç»„åˆï¼Œç­”æ¡ˆæ˜¯å¥‡æ•°ä½ç½®çš„å’Œã€‚ 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;vector&lt;int&gt; a;int main() &#123; int n = (rd() &lt;&lt; 1); for (int i = 1; i &lt;= n; ++i) a.push_back(rd()); sort(a.begin(), a.end()); int ans = 0; for (int i = 0; i &lt; n; i += 2) ans += a[i]; printf(&quot;%d\\n&quot;, ans); return 0;&#125; B - Mysterious Light è¾¹é•¿ä¸º \\(n\\) çš„æ­£ä¸‰è§’å½¢ ABC çš„è¾¹ AB ä¸Š \\(x\\) å¤„å¹³è¡Œ BC å°„å‡ºä¸€æ¡æ¿€å…‰ã€‚ ç¢°åˆ°è¾¹ç•Œåå°„ï¼Œç¢°åˆ°æ­¤å‰çš„å…‰çº¿ä¹Ÿåå°„ï¼Œæ±‚å›åˆ°èµ·ç‚¹çš„è·¯å¾„é•¿åº¦ã€‚ æ²¡çœ‹æ‡‚å®˜æ–¹é¢˜è§£çš„ç®€å•åšæ³•ã€‚ é¦–å…ˆå‰ä¸¤æ®µå…‰è·¯é•¿åº¦å’Œæ˜¯ \\(n\\) ï¼Œä¼šåˆ‡æ‰ä¸¤ä¸ªè§’ï¼Œå˜æˆä¸€ä¸ªå¹³è¡Œå››è¾¹å½¢ã€‚ å¯¹äºå¹³è¡Œå››è¾¹å½¢ï¼ˆè¾¹é•¿åˆ†åˆ«ä¸º \\(a\\) å’Œ \\(b\\) ï¼‰ï¼Œå…‰çº¿ä»ä¸€ä¸ª \\(120^\\circ\\) è§’å‡ºå‘ï¼Œæ²¿è§’å¹³åˆ†çº¿å°„å‡ºè·ç¦»ä¸º \\(f(a,b)\\) æœ‰ \\(f(a,0)=-a, f(a,b) = 2 \\ast \\displaystyle\\lfloor \\frac{a}{b}\\rfloor \\ast b +f(b, a \\% b)\\) ï¼Œä¹Ÿå°±æ˜¯æ¯æ¬¡éƒ½åˆ‡çŸ­è¾¹ç›´åˆ°é•¿çŸ­è¾¹äº¤æ¢ï¼Œå‡æ‰æœ€åä¸€æ¬¡å¤šç®—çš„ã€‚ ç­”æ¡ˆå°±æ˜¯ \\(n+f(x,n-x)\\) ï¼Œé€’å½’å½¢å¼å’Œ gcd ç›¸åŒï¼Œæ‰€ä»¥å¤æ‚åº¦æ˜¯ \\(\\mathcal O(\\log n)\\) ã€‚ 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;inline ll f(ll a, ll b) &#123; return b ? 2 * (a / b) * b + f(b, a % b) : -a;&#125;int main() &#123; ll n = rd(), x = rd(); printf(&quot;%lld\\n&quot;, n + f(x, n - x)); return 0;&#125; C - Shorten Diameter ç»™ä¸€æ£µæ ‘ï¼Œæ¯æ¬¡å¯ä»¥åˆ æ‰ä¸€ä¸ªå¶å­ï¼Œé—®æœ€å°‘åˆ å¤šå°‘æ¬¡ä½¿å¾—ç›´å¾„ä¸è¶…è¿‡ \\(k\\) æœ¬æ¥æƒ³è´ªå¿ƒæ¯æ¬¡åˆ ä¸€ä¸ªç›´å¾„çš„ç«¯ç‚¹ï¼Œä½†æ˜¯ä¸å¯¹ï¼Œå› ä¸ºæœ‰å¯èƒ½è¿™ä¸ªç‚¹ä¼šè¢«ä¿ç•™åˆ°æœ€åã€‚ å› ä¸º \\(n\\) åªæœ‰ \\(2000\\) ï¼Œæ‰€ä»¥å¯ä»¥ \\(\\mathcal{O}(n^2)\\) æš´åŠ›ï¼Œé‚£ä¹ˆæšä¸¾ä¸­å¿ƒå°±å¥½äº†ã€‚ å¦‚æœ \\(k\\) æ˜¯å¥‡æ•°ï¼Œæšä¸¾ä¸­å¿ƒçš„è¾¹ï¼ŒæŠŠæ ‘åˆ†æˆä¸¤æ£µï¼Œæ ¹å°±æ˜¯è¿™æ¡è¾¹çš„ä¸¤ä¸ªç«¯ç‚¹ï¼Œæ¯æ£µåªä¿ç•™æ·±åº¦å°äº \\(\\lfloor k/2\\rfloor\\) çš„ç‚¹ å¦‚æœ \\(k\\) æ˜¯å¶æ•°ï¼Œæšä¸¾ä¸­å¿ƒçš„ç‚¹ï¼Œä»¥è¿™ä¸ªç‚¹ä¸ºæ ¹ï¼Œåªä¿ç•™æ·±åº¦å°äº \\(\\lfloor k/2\\rfloor\\) çš„ç‚¹ æ‰¾åˆ°ä¸Šè¿°æƒ…å†µé‡Œéœ€è¦åˆ é™¤çš„ç‚¹æœ€å°‘çš„æƒ…å†µå³å¯ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 2007#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;vector&lt;pii&gt; r;vector&lt;int&gt; e[N];int dep[N];void dfs(int u) &#123; for (auto v : e[u]) if (dep[v] &lt; 0) &#123;dep[v] = dep[u] + 1; dfs(v);&#125;&#125;int main() &#123; int n = rd(), k = rd(); for (int i = 1, u, v; i &lt; n; ++i) &#123; u = rd(); v = rd(); e[u].pb(v); e[v].pb(u); if (k &amp; 1) r.pb(mp(u, v)); &#125; int ans = 0; if (k &amp; 1) &#123; for (auto [u, v] : r) &#123; memset(dep, -1, sizeof(dep)); dep[u] = 0; dep[v] = 0; dfs(u); dfs(v); int tmpans = 0; for (int j = 1; j &lt;= n; ++j) tmpans += (dep[j] &lt;= k / 2); ans = max(ans, tmpans); &#125; &#125; else &#123; for (int i = 1; i &lt;= n; ++i) &#123; memset(dep, -1, sizeof(dep)); dep[i] = 0; dfs(i); int tmpans = 0; for (int j = 1; j &lt;= n; ++j) tmpans += (dep[j] &lt;= k / 2); ans = max(ans, tmpans); &#125; &#125; printf(&quot;%d\\n&quot;, n - ans); return 0;&#125; D - Arrays and Palindrome ç»™å®šåºåˆ— \\(\\{A_i\\}\\) ï¼Œæ»¡è¶³ \\(\\sum A_i=N\\) ï¼Œéœ€è¦é‡æ’ \\(\\{A_i\\}\\) ï¼Œå¹¶ä¸”æ„é€  \\(\\{B_i\\}\\) ï¼Œæ»¡è¶³ \\(\\sum B_i=N\\) ï¼Œä¸”æ»¡è¶³ï¼š å¦‚æœä¸€ä¸ªé•¿åº¦ä¸º \\(N\\) çš„ä¸² \\(S\\) æ»¡è¶³ï¼ˆ \\(S[l,r]\\) è¡¨ç¤º \\(S[l]S[l+1]\\dots S[r]\\) è¿™ä¸€æ®µå­ä¸²ï¼‰ï¼š \\(\\forall i,\\ S[\\sum_{j=1}^{i-1}A_j+1, \\sum_{j=1}^i A_j]\\) æ˜¯å›æ–‡çš„ï¼ˆä¹Ÿå°±æ˜¯æŒ‰ç…§ \\(A_i\\) åˆ†å‰²æˆè‹¥å¹²æ®µå­ä¸²ï¼Œéƒ½æ˜¯å›æ–‡çš„ï¼‰ \\(\\forall i,\\ S[\\sum_{j=1}^{i-1}B_j+1, \\sum_{j=1}^i B_j]\\) æ˜¯å›æ–‡çš„ï¼ˆä¹Ÿå°±æ˜¯æŒ‰ç…§ \\(B_i\\) åˆ†å‰²æˆè‹¥å¹²æ®µå­ä¸²ï¼Œéƒ½æ˜¯å›æ–‡çš„ï¼‰ é‚£ä¹ˆ ä¸€å®šèƒ½æ¨å‡º \\(S\\) ä¸­å…¨éƒ¨å­—ç¬¦éƒ½ç›¸åŒã€‚ å¥½æœ‰æ„æ€çš„é¢˜ç›®å•Šï¼ï¼å»ºè®®å…ˆçœ‹å®˜æ–¹é¢˜è§£ã€‚ å‡å¦‚æˆ‘ä»¬ç¡®å®šäº† \\(\\{A\\}\\) çš„é¡ºåºï¼Œé‚£ä¹ˆ \\(\\{A\\}\\) æŠŠåºåˆ—åˆ†æˆè‹¥å¹²æ®µï¼Œæ¯æ®µå¯¹ç§°çš„ä½ç½®å­—ç¬¦è¦ç›¸åŒã€‚ æˆ‘ä»¬å¦‚æœæŠŠ \\(N\\) ä¸ªä½ç½®çœ‹ä½œ \\(N\\) ä¸ªç‚¹ï¼Œé‚£ä¹ˆå¯ä»¥æŠŠ \\(A\\) çš„æ‰€æœ‰è¦æ±‚å¯¹ç§°çš„ä½ç½®è¿ä¸€æ¡è¾¹ã€‚ ç°åœ¨ \\(B\\) ç›¸å½“äºæ˜¯è¦è¡¥ä¸€äº›è¾¹ï¼Œä½¿å¾—æ‰€æœ‰ç‚¹éƒ½è¿é€šã€‚ å‡è®¾æ‰€æœ‰çš„ \\(A_i\\) å‡ä¸ºå¶æ•°ï¼Œé‚£ä¹ˆä»¤\\(|\\{B\\}|=|\\{A\\}|\\) ï¼Œå…ˆè®© \\(B_i=A_i\\) ï¼Œç„¶å $B_1 B_1-1,B_{|{B}|}B_{|{B}|}+1 $é‚£ä¹ˆï¼ˆé™¤ç¬¬ä¸€æ®µå¤–ï¼‰æ¯ä¸€æ®µçš„æœ€åä¸€ä¸ªéƒ½å’Œå‰ä¸€æ®µçš„æœ€åä¸€ä¸ªè¿è¾¹ï¼Œè¿é€šäº†ä¸¤æ®µï¼›æ­¤å¤–æ¯ä¸€æ®µå†…çš„è¿è¾¹éƒ½æ˜¯å¥‡å¶ä½ç½®é”™å¼€çš„ï¼Œæ‰€ä»¥æ•´ä¸ªå›¾æ˜¯è¿é€šçš„ã€‚ ç„¶åè€ƒè™‘ \\(A_i\\) æœ‰å¥‡æ•°ï¼Œå¯ä»¥è¯æ˜æœ€å¤šå…è®¸æœ‰ä¸¤æ®µå¥‡æ•°ï¼ŒæŠŠè¿™ä¸¤æ®µæ”¾åœ¨ä¸¤è¾¹ï¼Œè¿˜æ˜¯ä¸å½±å“ç­”æ¡ˆçš„ã€‚ å¦‚æœå¥‡æ•°é•¿åº¦æ®µè¶…è¿‡ä¸¤ä¸ªï¼Œä¸€å®šæ— è§£ï¼Œå…·ä½“è¯æ˜çœ‹å®˜æ–¹é¢˜è§£ï¼Œå¤§æ¦‚æ–¹æ³•å°±æ˜¯è¯æ˜äº†è¾¹æ•°å‡‘ä¸åˆ° \\(n-1\\) ã€‚ æ„Ÿè§‰è¿™ä¸ªæ„é€ çœŸçš„å¾ˆ useful å•Šï¼ˆ 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define ppb pop_back#define psb push_back#define ppf pop_front#define psf push_frontdeque&lt;int&gt; s, odd;int main() &#123; int m = rd(), n = rd(); for (int i = 1, x; i &lt;= n; ++i) &#123; x = rd(); (x &amp; 1) ? odd.psb(x) : s.psb(x); &#125; if (odd.size() &gt; 2) &#123;puts(&quot;Impossible&quot;); return 0;&#125; if (odd.size() &gt; 0) s.psf(odd[0]); if (odd.size() &gt; 1) s.psb(odd[1]); for (auto x : s) printf(&quot;%d &quot;, x); puts(&quot;&quot;); //éœ€è¦æ³¨æ„åªæœ‰ä¸€ä¸ªå…ƒç´ å’Œç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯1çš„æƒ…å†µ if (s.size() == 1) s.psb(0); --s.front(); ++s.back(); if (s.front() == 0) s.ppf(); printf(&quot;%d\\n&quot;, s.size()); for(auto x : s) printf(&quot;%d &quot;, x); return 0;&#125; E - BBQ Hard ç»™å®š \\(N\\) ä¸ª \\((A_i,B_i)\\) ï¼Œæ±‚ï¼š \\[ \\sum_{i=1}^{n-1}\\sum_{j=i+1}^n {A_i+A_j+B_i+B_j\\choose A_i+A_j} \\mod 10^9+7 \\] æ•°æ®èŒƒå›´ \\(2\\le n\\le 2\\times 10^5,1\\le a_i,b_i\\le 2000\\) åªèƒ½å¾€å³å’Œå¾€ä¸Šèµ°ï¼Œè®¡æ•°ä» \\((x_0,y_0)\\) åˆ° \\((x_1,y_1)\\)çš„è·¯å¾„æ–¹æ¡ˆæ•°ï¼Œè€ƒè™‘å“ªäº›æ­¥æ˜¯æ¨ªå‘èµ°ï¼Œæ˜¯ \\(\\displaystyle{ {x_1-x_0+y_1-y_0} \\choose {x_1-x_0}}\\) ã€‚å½“ç„¶ä¹Ÿå¯ä»¥ç”¨ä¸€ä¸ªäºŒç»´é€’æ¨ï¼Œä»¤ f[x0][y0]=1 ï¼Œæ¯æ¬¡f[i][j] = f[i - 1][j] + f[i][j - 1] ï¼Œç­”æ¡ˆf[x1][y1] ã€‚ æŠŠå¼ä¸­ \\(\\displaystyle{A_i+A_j+B_i+B_j\\choose A_i+A_j}\\) å˜å½¢ä¸º \\(\\displaystyle {A_i-(-A_j)+B_i-(-B_j)\\choose A_i-(-A_j)}\\) ï¼Œå¯è§£è¯»ä¸ºä» \\((-A_j,-B_j)\\) åˆ° \\((A_i,B_i)\\) çš„è·¯å¾„æ•°ã€‚ é‚£ä¹ˆæŠŠæ±‚å’Œæ”¹ä¸€ä¸‹å½¢å¼ï¼Œä¸¤ä¸ªå¾ªç¯éƒ½æ”¹æˆä» \\(1\\) åˆ° \\(n\\) ï¼Œç„¶åæ‰£æ‰è‡ªå·±åˆ°è‡ªå·±çš„è´¡çŒ®ï¼Œå†é™¤ \\(2\\) å°±æ˜¯ç­”æ¡ˆã€‚ \\[ ans = \\frac{\\sum_{i=1}^{N} \\sum_{j=1}^{N} \\displaystyle{A_{i} +B_{i}+A_{j}+B_{j} \\choose A_{i}+B_{i}}-\\sum_{i=1}^{N} {2\\ast A_{i}+2\\ast B_{i} \\choose 2 \\ast A_{i}}}{2} \\mod 10^9+7 \\] å‰ä¸€åŠè€ƒè™‘ç”¨ä¸Šé¢æåˆ°çš„é€’æ¨æ–¹æ³•æ•´ä½“ä¸€èµ·æ±‚ï¼ˆåŠ ä¸ªåç§»é‡æŠŠåæ ‡è°ƒæˆæ­£çš„ï¼‰ï¼š å…ˆç»™æ‰€æœ‰çš„ f[-a[i]][-b[i]] += 1 ï¼Œç„¶åé€’æ¨å®ŒæŸ¥æ‰€æœ‰çš„ f[a[i]][b[i]] å³å¯ã€‚ åä¸€åŠç”¨ç»„åˆæ•°ç›´æ¥ç®—å°±å¥½äº†ã€‚æ€»å¤æ‚åº¦ \\(\\mathcal{O}(n+4\\ast \\max a_i\\ast \\max b_i)\\) ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define A 4007#define G 2001#define M 8007#define N 200007#define mod 1000000007#define inv2 500000004int f[A][A], fac[M], ifac[M], x[N], y[N];inline int fpow(int x, int t = mod - 2) &#123; int res = 1; for (; t; t &gt;&gt;= 1, x = 1ll * x * x % mod) if (t &amp; 1) res = 1ll * res * x % mod; return res;&#125;inline int mo(int x) &#123; for (; x &lt; 0; x += mod); for (; x &gt;= mod; x -= mod); return x;&#125;inline int C(int n, int m) &#123; if (n &lt; m) return 0; return 1ll * fac[n] * ifac[m] % mod * ifac[n - m] % mod;&#125;int main() &#123; fac[0] = ifac[0] = 1; for (int i = 1; i &lt; M; ++i) fac[i] = 1ll * fac[i - 1] * i % mod; ifac[M - 1] = fpow(fac[M - 1]); for (int i = M - 2; i; --i) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % mod; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; x[i] = rd(); y[i] = rd(); ++f[-x[i] + G][-y[i] + G]; &#125; for (int i = 1; i &lt; A; ++i) for (int j = 1; j &lt; A; ++j) f[i][j] = mo(f[i][j] + f[i - 1][j] + f[i][j - 1]); int ans = 0; for (int i = 1; i &lt;= n; ++i) ans = mo(ans + f[x[i] + G][y[i] + G] - C(2 * (x[i] + y[i]), 2 * x[i])); printf(&quot;%lld\\n&quot;, 1ll * ans * inv2 % mod); return 0;&#125; F - Wide Swap ç»™å®šä¸€ä¸ª \\(\\{1,2,\\dots,n\\}\\) çš„æ’åˆ— \\(\\{P\\}\\) ï¼Œæ¯æ¬¡æ“ä½œï¼š é€‰å–ä¸¤ä¸ªè·ç¦»è‡³å°‘ä¸º \\(k\\) çš„ä½ç½® \\(i,j\\) ä¸” \\(|P_i-P_j|=1\\) ï¼Œäº¤æ¢ \\(i,j\\) ä¸¤ä¸ªä½ç½®ä¸Šçš„æ•°ã€‚ ä½ å¯ä»¥ä»»æ„æ¬¡æ•°æ“ä½œï¼Œé—®å¯èƒ½å¾—åˆ°çš„æœ€å°å­—å…¸åºæ’åˆ—æ˜¯ä»€ä¹ˆã€‚ æ’åˆ—æ±‚ä¸ªé€†ï¼ˆå³ \\(Q_{P_i}=i\\) ï¼‰ï¼Œ\\(Q_i\\) çš„å«ä¹‰å°±æ˜¯æ•°å­— \\(i\\) çš„ä½ç½®ã€‚ é—®é¢˜è½¬åŒ–ä¸ºï¼šç›¸é‚»å¹¶ä¸”å·®å€¼è‡³å°‘ä¸º \\(k\\) çš„ä¸¤ä¸ª \\(Q\\) å¯ä»¥äº¤æ¢ï¼Œ\\(Q\\) å¯èƒ½æœ€å°å­—å…¸åºæ˜¯ä»€ä¹ˆï¼ˆå°çš„æ•°å­—ä½ç½®é å‰ï¼‰ã€‚ å¦‚æœ \\(|Q_i-Q_j|&lt;k\\) ï¼Œé‚£ä¹ˆ \\(Q_i\\) å’Œ \\(Q_j\\)åœ¨åºåˆ—é‡Œçš„ç›¸å¯¹é¡ºåºæ°¸è¿œéƒ½ä¸èƒ½æ”¹å˜ï¼ˆæ¢åˆ°ç›¸é‚»å°±ä¸èƒ½æ“ä½œäº†ï¼‰ã€‚åä¹‹å¦‚æœä¸¤ä¸ªä½ç½®å·®å€¼ \\(\\ge k\\)ï¼Œåªè¦èƒ½æ¢åˆ°ç›¸é‚»ï¼Œå°±ä¸€å®šå¯ä»¥äº¤æ¢ï¼Œå¦‚æœæ¢ä¸åˆ°ç›¸é‚»ï¼Œä¸€å®šæ˜¯ä¸Šé¢çš„çº¦æŸå¯¼è‡´çš„ã€‚æ‰€ä»¥å¦‚æœ \\(|Q_i-Q_j|\\ge k\\) ï¼Œé‚£ä¹ˆ\\(Q_i\\) å’Œ \\(Q_j\\) åœ¨åºåˆ—é‡Œçš„é¡ºåºæ²¡æœ‰ä»»ä½•è¦æ±‚ã€‚ åªæœ‰ \" \\(a\\) ä¸€å®šè¦åœ¨ \\(b\\) å‰\" è¿™ç§çº¦æŸçš„æœ€å°å­—å…¸åºæ’åˆ—æ˜¾ç„¶å¯ä»¥ç”¨ä¼˜å…ˆé˜Ÿåˆ—çš„æ‹“æ‰‘æ’åºæ±‚ã€‚ ä½†æ˜¯è¾¹çš„çº§åˆ«æ˜¯ \\(\\mathcal{O}(n^2)\\) çš„ï¼š \\(Q_i\\) ä¼šå‘ \\(\\forall j&gt;i,Q_j\\in[Q_i-k + 1,Q_i + k-1]\\) çš„æ‰€æœ‰ \\(Q_j\\) è¿è¾¹ã€‚ è€ƒè™‘å»æ‰ä¸€äº›æ²¡æœ‰æ„ä¹‰çš„è¾¹ï¼šå‡è®¾ \\((x,y),(y,z),(x,z)\\) éƒ½å­˜åœ¨ï¼Œé‚£ä¹ˆ \\((x,z)\\) æ˜¾ç„¶æ˜¯æ²¡å¿…è¦å­˜çš„ã€‚ æŠŠåŒºé—´æ‹†æˆä¸¤å— \\([Q_i-k+1,Q_i],[Q_i,Q_i+k-1]\\) ï¼Œè¿™ä¸¤ä¸ªåŒºé—´å†…éƒ¨æœ‰çº¦æŸçš„è‚¯å®šä¼šä¸¤ä¸¤è¿è¾¹ï¼ˆå•å‘ï¼‰ã€‚ å› æ­¤ \\(Q_i\\) å¹¶ä¸éœ€è¦å‘è¿™é‡Œé¢çš„å…¨éƒ¨ç‚¹è¿è¾¹ï¼Œå®Œå…¨å¯ä»¥ç»§æ‰¿åŒºé—´é‡Œæœ€é å‰çš„ä½ç½®çš„æ‰€æœ‰è¾¹ï¼Œç„¶åè®©è‡ªå·±æŒ‡å‘è¿™ä¸ªä½ç½®å³å¯ã€‚ å½¢å¼åŒ–çš„è¯´ï¼Œå¯¹äºæŸä¸ªåŒºé—´ï¼Œæ‰¾åˆ° \\(pos = \\min_{Q_j\\in [\\text{interval}]} j\\) ï¼Œé‚£ä¹ˆåªéœ€è¦è¿ \\(Q_i\\to Q_{pos}\\) ï¼Œå…¶ä½™è¾¹éƒ½é—´æ¥ç»§æ‰¿ \\(Q_{pos}\\) çš„ã€‚ è¿™æ ·è¾¹çš„çº§åˆ«ï¼ˆä¹Ÿå°±æ˜¯æ‹“æ‰‘æ’åºå¤æ‚åº¦ï¼‰å°±æ˜¯ \\(\\mathcal{O}(n)\\) çš„ï¼Œæ‰¾ \\(pos\\) éœ€è¦å•ç‚¹æ›´æ–°æŸ¥åŒºé—´ \\(\\min\\) ï¼Œç”¨çº¿æ®µæ ‘å¤æ‚åº¦ \\(\\mathcal{O}(n\\log n)\\) ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 500007#define ls (rt &lt;&lt; 1)#define rs (rt &lt;&lt; 1 | 1)#define mid ((l + r) &gt;&gt; 1)int mn[N &lt;&lt; 2];void pushup(int rt) &#123; mn[rt] = min(mn[ls], mn[rs]);&#125;void upd(int rt, int l, int r, int k, int v) &#123; if (l == r) &#123; mn[rt] = v; return; &#125; if (k &lt;= mid) upd(ls, l, mid, k, v); else upd(rs, mid + 1, r, k, v); pushup(rt);&#125;int qmn(int rt, int l, int r, int L, int R) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) return mn[rt]; int ans = 1e9; if (L &lt;= mid) ans = min(ans, qmn(ls, l, mid, L, R)); if (R &gt; mid) ans = min(ans, qmn(rs, mid + 1, r, L, R)); return ans;&#125;int p[N], q[N], deg[N];vector&lt;int&gt; e[N];#define pb push_backpriority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;que;int main() &#123; int n = rd(), k = rd(); memset(mn, 0x3f, sizeof(mn)); for (int i = 1; i &lt;= n; ++i) q[p[i] = rd()] = i; for (int i = n; i; --i) &#123; int j = qmn(1, 1, n, q[i], min(n, q[i] + k - 1)); if (j &lt;= n) &#123;e[q[i]].pb(q[j]); ++deg[q[j]];&#125; j = qmn(1, 1, n, max(1, q[i] - k + 1), q[i]); if (j &lt;= n) &#123;e[q[i]].pb(q[j]); ++deg[q[j]];&#125; upd(1, 1, n, q[i], i); &#125; for (int i = 1; i &lt;= n; ++i) if (!deg[i]) que.push(i); for (int i = 1; i &lt;= n; ++i) &#123; int u = q[i] = que.top(); que.pop(); for (auto v : e[u]) if (!(--deg[v])) que.push(v); &#125; for (int i = 1; i &lt;= n; ++i) p[q[i]] = i; for (int i = 1; i &lt;= n; ++i) printf(&quot;%d\\n&quot;, p[i]); return 0;&#125;","categories":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://blog.gyx.me/categories/AtCoder/"},{"name":"AtCoder Grand Contest","slug":"AtCoder/AtCoder-Grand-Contest","permalink":"http://blog.gyx.me/categories/AtCoder/AtCoder-Grand-Contest/"}],"tags":[{"name":"Constructive Algorithm","slug":"Constructive-Algorithm","permalink":"http://blog.gyx.me/tags/Constructive-Algorithm/"}]},{"title":"AtCoder Beginner Contest 244","slug":"atcoder/abc224","date":"2022-03-29T07:46:14.000Z","updated":"2023-03-20T16:28:01.907Z","comments":true,"path":"atcoder/abc224/","link":"","permalink":"http://blog.gyx.me/atcoder/abc224/","excerpt":"","text":"A, B, C æ¯”è¾ƒç®€å•å°±ä¸å†™äº†ã€‚ æˆ‘çš„ä»£ç  : All Submissions - SGColin D. Swap Hats ç»™å®šä¸¤ä¸ª \"RGB\" è¿™ä¸ªå­—ç¬¦ä¸²çš„æ’åˆ— \\(A,B\\) ï¼Œæ¯æ¬¡æ“ä½œå¯ä»¥äº¤æ¢ä¸¤ä¸ªä½ç½®ã€‚ é—®èƒ½å¦æ­£å¥½æ“ä½œ \\(10^{18}\\) æŠŠ \\(A\\) å˜æˆ \\(B\\) ã€‚ å‡è®¾ R=1,G=2,B=3 ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡é€†åºæ•°å¥‡/å¶æŠŠæ‰€æœ‰æ’åˆ—åˆ†ä¸¤ç±»ã€‚ å› ä¸ºåªæœ‰ä¸‰ä¸ªä½ç½®ï¼Œå¯ä»¥å‘ç°è½¬æ¢å…³ç³»çš„è¿è¾¹æ˜¯ä¸ªå®Œå…¨äºŒåˆ†å›¾ã€‚ æ‰€ä»¥æ ¹æ® \\(A\\) å’Œ \\(B\\) ä¸åŒçš„ä½æ•° \\(cnt\\) å³å¯åˆ¤å®šæ˜¯å“ªç§æƒ…å†µã€‚ \\(cnt=0\\) å®Œå…¨ç›¸åŒï¼Œä¸€ç›´äº¤æ¢æŸä¸¤ä½å³å¯ã€‚ \\(cnt=2\\) é€†åºæ•°ç›¸åŒï¼Œä½†æ’åˆ—ä¸åŒï¼Œä¸å¯èƒ½é€šè¿‡å¶æ•°æ¬¡äº¤æ¢å¾—åˆ°ã€‚ \\(cnt=3\\) é€†åºæ•°ä¸åŒï¼Œå› ä¸ºæ˜¯å®Œå…¨äºŒåˆ†å›¾ï¼Œä¸€å®šå¯ä»¥é€šè¿‡ä¸¤æ¬¡æ“ä½œæŠŠ \\(A\\) å˜æˆ \\(B\\) ï¼Œåé¢å‚è€ƒ \\(cnt=0\\) æ“ä½œå³å¯ã€‚ 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;char a[3], b[3];inline char gc() &#123; char c = getchar(); while (!isalpha(c)) c = getchar(); return c;&#125;int main() &#123; for (int i = 0; i &lt; 3; ++i) a[i] = gc(); for (int i = 0; i &lt; 3; ++i) b[i] = gc(); int cnt = 0; for (int i = 0; i &lt; 3; ++i) cnt += (a[i] != b[i]); puts((cnt == 0 || cnt == 3) ? &quot;Yes&quot; : &quot;No&quot;); return 0;&#125; E. King Bombee å®šä¹‰æ— å‘å›¾ \\(G=(V,E)\\) çš„ä¸€ä¸ªé•¿åº¦ä¸º \\(K\\) çš„è·¯å¾„åºåˆ— \\(\\{A\\}\\) ï¼š ç”± \\(K+1\\) ä¸ªç‚¹ç¼–å· \\(A_0,\\dots,A_K\\in V\\) æ„æˆï¼Œ\\(A_0\\) æ˜¯èµ·ç‚¹ï¼Œ\\(A_K\\) æ˜¯ç»ˆç‚¹ï¼Œä¸” \\(\\forall 0\\le i &lt; K, (A_i, A_{i+1})\\in E\\) ç»™å®šæ— å‘å›¾ \\(G\\ (|V|\\le 2000,|E|\\le 2000)\\) æ±‚æœ‰å¤šå°‘ä¸ªé•¿åº¦ä¸º \\(K\\ (K\\le 2000)\\) çš„è·¯å¾„åºåˆ—ï¼Œæ»¡è¶³ï¼š èµ·ç‚¹ä¸º \\(S\\) ï¼Œç»ˆç‚¹ä¸º \\(T\\) ï¼Œä¸”ç‚¹ \\(X\\) åœ¨åºåˆ—ä¸­å‡ºç°å¶æ•°æ¬¡ï¼ˆå¯ä»¥ä¸º \\(0\\) ) ã€‚ æ„Ÿè§‰æœ€è¿‘ ABC æ¯åœºéƒ½ä¼šæœ‰ä¸€é“æ¯”è¾ƒæš´åŠ›çš„ DPï¼Œå°±çœ‹æ•¢ä¸æ•¢å†™ï¼ˆ è®¾ f[i][u][0/1] è¡¨ç¤ºå½“å‰è€ƒè™‘é•¿åº¦ä¸º \\(i\\) çš„è·¯å¾„ï¼Œèµ·ç‚¹æ˜¯ \\(S\\) ï¼Œç»ˆç‚¹æ˜¯ \\(u\\) ï¼Œå½“å‰èŠ‚ç‚¹ \\(X\\) åœ¨å…¶ä¸­å‡ºç°å¶æ•°/å¥‡æ•°æ¬¡çš„æ–¹æ¡ˆæ•°ã€‚ åˆå§‹çŠ¶æ€ f[0][S][S==X] = 1 ï¼Œç­”æ¡ˆ f[K][T][0] ã€‚ è½¬ç§»æš´åŠ›åšå°±å¯ä»¥äº†ï¼Œæšä¸¾ä¸‹ä¸€æ­¥èµ°å“ªé‡Œï¼ˆ \\(u\\to v\\) ï¼‰ ï¼šf[i+1][v][k^(v == X)] += f[i][u][k] ã€‚ è¿™ä¸ªé¢˜çš„æ ¸å¿ƒåœ¨å¤æ‚åº¦è®¡ç®—ï¼Œå¤–å±‚æšä¸¾ \\(i\\) æ˜¯ \\(\\mathcal O(n)\\) çš„ï¼Œå†…å±‚æšä¸¾ \\(u\\) æ˜¯ \\(\\mathcal O(n)\\) çš„ï¼Œæšä¸¾ \\(v\\) å¤æ‚åº¦æ€ä¹ˆç®—ï¼Ÿ æŠŠåä¸¤ä¸ªçš„å¤æ‚åº¦æ”¾åˆ°ä¸€èµ·è€ƒè™‘ï¼Œå°±æ˜¯ \\(\\sum_{u=1}^n deg(u) = \\mathcal O(m)\\) æ‰€ä»¥æ€»å¤æ‚åº¦æ˜¯ \\(\\mathcal O(nm)\\) çš„ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 2007#define mod 998244353#define add(a, b) (a) = ((a) + (b)) % modvector&lt;int&gt; e[N];int f[N][N][2];int main() &#123; int n = rd(), m = rd(); int k = rd(), s = rd(), t = rd(), x = rd(); for (int i = 1; i &lt;= m; ++i) &#123; int u = rd(), v = rd(); e[u].push_back(v); e[v].push_back(u); &#125; f[0][s][x == s] = 1; for (int i = 0; i &lt; k; ++i) for (int u = 1; u &lt;= n; ++u) for (int k = 0; k &lt;= 1; ++k) &#123; if (!f[i][u][k]) continue; for (auto v : e[u]) &#123; int tar = (k ^ (v == x)); add(f[i + 1][v][tar], f[i][u][k]); &#125; &#125; printf(&quot;%d\\n&quot;, f[k][t][0]); return 0;&#125; F. Shortest Good Path é¢˜æ„æ¯”è¾ƒå¤æ‚ï¼Œæˆ‘ç®€å•æè¿°ä¸€ä¸‹ã€‚ å®šä¹‰æ— å‘å›¾ \\(G=(V,E)\\) çš„ä¸€ä¸ªé•¿åº¦ä¸º \\(K+1\\) çš„è·¯å¾„åºåˆ— \\(\\{A\\}\\) ï¼š ç”± \\(K+1\\) ä¸ªç‚¹ç¼–å· \\(A_0,\\dots,A_K\\in V\\) æ„æˆï¼Œ\\(A_0\\) æ˜¯èµ·ç‚¹ï¼Œ\\(A_K\\) æ˜¯ç»ˆç‚¹ï¼Œä¸” \\(\\forall 0\\le i &lt; K, (A_i, A_{i+1})\\in E\\) å®šä¹‰è·¯å¾„åºåˆ— \\(\\{A\\}\\) ç¬¦åˆè¦æ±‚åºåˆ— \\(S\\ (|S| = n, S_i = 0/1)\\) ï¼Œå½“ä¸”ä»…å½“ï¼š è‹¥ \\(S_u = 0\\) ï¼Œåˆ™ \\(u\\) åœ¨ \\(\\{A\\}\\) ä¸­å‡ºç°äº†å¶æ•°æ¬¡ï¼ˆå¯ä»¥ä¸º \\(0\\) ï¼‰ è‹¥ \\(S_u = 1\\) ï¼Œåˆ™ \\(u\\) åœ¨ \\(\\{A\\}\\) ä¸­å‡ºç°äº†å¥‡æ•°æ¬¡ é‚£ä¹ˆå¯¹äºæ‰€æœ‰çš„ \\(S=0,\\cdots,2^n-1\\) ï¼Œéƒ½ä¼šå­˜åœ¨ä¸€ä¸ªè·¯å¾„åºåˆ—æ»¡è¶³ \\(S\\) çš„è¦æ±‚ã€‚ è®°æ»¡è¶³ \\(S\\) è¦æ±‚çš„è·¯å¾„åºåˆ—æœ€çŸ­ä¸º \\(f(S)\\) ï¼Œæ±‚ \\(\\sum_{S=0}^{2^n-1}f(S)\\) çœ‹åˆ° ABC å‡º \\(n\\le 17\\) å°±æ˜¯çŠ¶å‹æˆ–è€…è¶…çº§æš´åŠ›äº†ã€‚ è€ƒè™‘è·¯å¾„ä¹‹é—´äº’ç›¸æ›´æ–°è½¬ç§»ï¼Œé‚£ä¹ˆçŠ¶æ€ä¹‹é—´éœ€è¦åŒºåˆ†çš„ï¼Œé™¤äº†å½“å‰æ¯ä¸ªç‚¹å‡ºç°å¥‡æ•°/å¶æ•°æ¬¡ä»¥å¤–ï¼Œè¿˜æœ‰æœ€åä¸€ä¸ªç‚¹çš„ç¼–å·ã€‚ å®šä¹‰ç¬¦åˆåºåˆ— \\(S\\) ä¸”æœ€åä¸€ä¸ªç‚¹æ˜¯ \\(u\\) çš„çŠ¶æ€é›†ç¼–å·ä¸º sta[S][u] ã€‚ é‚£ä¹ˆå¯¹äºæ¯ä¸€ä¸ª \\(u\\to v\\) ï¼Œå¯¹æ‰€æœ‰çš„ \\(S\\) è¿è¾¹ sta[S][u] -&gt; sta[S ^ (1 &lt;&lt; v)][v] æœ€åè¡¥ä¸Šåˆå§‹çŠ¶æ€çš„è¿è¾¹ source -&gt; sta[1 &lt;&lt; u][u] é‚£ä¹ˆè·‘ BFS å°±å¯ä»¥æ±‚å‡ºæ¥æ¯ä¸ªçŠ¶æ€æ‰€éœ€çš„æœ€å°é•¿åº¦äº†ï¼ˆä» source å‡ºå‘çš„è·ç¦»ï¼‰ é‚£ä¹ˆ \\(f(S) = \\min_{u} dis[sta[S][u]]\\) å³å¯ï¼Œå¤æ‚åº¦å³çŠ¶æ€æ•°ä¹˜è½¬ç§»æ•° \\(\\mathcal O(n^2\\ast 2^n)\\) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 17#define M 5000007#define pb push_backint id[1 &lt;&lt; N][N], cnt, dis[M];vector&lt;int&gt; e[M];queue&lt;int&gt; q;int main() &#123; int n = rd(), m = rd(); int S = (1 &lt;&lt; n) - 1; for (int s = 0; s &lt;= S; ++s) for (int u = 0; u &lt; n; ++u) id[s][u] = ++cnt; for (int i = 1; i &lt;= m; ++i) &#123; int u = rd() - 1, v = rd() - 1; for (int s = 0; s &lt;= S; ++s) &#123; e[id[s][u]].pb(id[s ^ (1 &lt;&lt; v)][v]); e[id[s][v]].pb(id[s ^ (1 &lt;&lt; u)][u]); &#125; &#125; for (int i = 0; i &lt; n; ++i) e[0].pb(id[1 &lt;&lt; i][i]); memset(dis, 0x3f, sizeof(dis)); dis[0] = 0; q.push(0); while (!q.empty()) &#123; int u = q.front(); q.pop(); for (auto v : e[u]) if (dis[v] &gt; dis[u] + 1) &#123;dis[v] = dis[u] + 1; q.push(v);&#125; &#125; ll ans = 0; for (int s = 1, tmp; s &lt;= S; ++s) &#123; tmp = 1e9; for (int u = 0; u &lt; n; ++u) &#123; tmp = min(tmp, dis[id[s][u]]); &#125; ans += tmp; &#125; printf(&quot;%lld\\n&quot;, ans); return 0;&#125; G. Construct Good Path å®šä¹‰æ— å‘å›¾ \\(G=(V,E)\\) çš„ä¸€ä¸ªé•¿åº¦ä¸º \\(K+1\\) çš„è·¯å¾„åºåˆ— \\(\\{A\\}\\) ï¼š ç”± \\(K+1\\) ä¸ªç‚¹ç¼–å· \\(A_0,\\dots,A_K\\in V\\) æ„æˆï¼Œ\\(A_0\\) æ˜¯èµ·ç‚¹ï¼Œ\\(A_K\\) æ˜¯ç»ˆç‚¹ï¼Œä¸” \\(\\forall 0\\le i &lt; K, (A_i, A_{i+1})\\in E\\) å®šä¹‰è·¯å¾„åºåˆ— \\(\\{A\\}\\) ç¬¦åˆè¦æ±‚åºåˆ— \\(S\\ (|S| = n, S_i = 0/1)\\) ï¼Œå½“ä¸”ä»…å½“ï¼š è‹¥ \\(S_u = 0\\) ï¼Œåˆ™ \\(u\\) åœ¨ \\(\\{A\\}\\) ä¸­å‡ºç°äº†å¶æ•°æ¬¡ï¼ˆå¯ä»¥ä¸º \\(0\\) ï¼‰ è‹¥ \\(S_u = 1\\) ï¼Œåˆ™ \\(u\\) åœ¨ \\(\\{A\\}\\) ä¸­å‡ºç°äº†å¥‡æ•°æ¬¡ ç»™å®šè¿é€šæ— å‘å›¾ \\(G\\) å’Œè¦æ±‚åºåˆ— \\(S\\) ï¼Œæ„é€ ä¸€ä¸ªé•¿åº¦ä¸è¶…è¿‡ \\(4\\ast |V|\\) çš„åºåˆ—ç¬¦åˆ \\(S\\) å›¾åªæœ‰è¿é€šçš„æ€§è´¨ï¼Œé‚£ä¹ˆå¯ä»¥è€ƒè™‘æ ‘æ€ä¹ˆè§£å†³ï¼Œå…¶ä»–æƒ…å†µæ‰¾ä¸€æ£µç”Ÿæˆæ ‘å°±å¯ä»¥äº†ã€‚ è®¾ \\(A_u\\) ä¸º \\(u\\) å­æ ‘çš„åˆæ³•åºåˆ—ï¼šæ»¡è¶³ \\(u\\) å­æ ‘å†…ï¼Œé™¤äº† \\(u\\) ä»¥å¤–å…¶ä»–ç‚¹éƒ½ç¬¦åˆè¦æ±‚çš„ä¸€ä¸ªåºåˆ—ã€‚ å¼ºåˆ¶å¶å­ \\(v\\) å¯¹åº”çš„ \\(A_v=(v)\\) ã€‚ å…¶ä»–æƒ…å†µå¦‚æœä»¤ \\(A_u=(u)+A_{son1}+(u)+A_{son2}+\\cdots+(u)\\) ï¼Œé‚£ä¹ˆåªæœ‰ \\(son\\) è¿™äº›èŠ‚ç‚¹ä¼šä¸åˆæ³•ã€‚ é‚£ä¹ˆå¯¹äºæ¯ä¸ªå¯¼è‡´ä¸åˆæ³•çš„ \\(son\\) ï¼Œç»™åºåˆ—æœ€åæ¥ä¸Šä¸€ä¸ª \\((son,u)\\) å°±å¯ä»¥ä¿è¯ \\(son\\) åˆæ³•ã€‚ ç”¨æ•°å­¦å½’çº³æ³•åšæ­£ç¡®æ€§è¯æ˜ï¼š\\(|A_u|\\le 4 \\astsize_u-3\\) ï¼Œå…¶ä¸­ \\(size_u\\) ä¸º\\(u\\) å­æ ‘å¤§å°ã€‚å¯¹äºå¶å­ï¼Œ\\(|A_u|=1=4\\ast1-3\\)å‡è®¾å¯¹äºä¸€ä¸ªç‚¹ \\(u\\)ï¼Œæ‰€æœ‰å„¿å­èŠ‚ç‚¹ \\(son\\)éƒ½ç¬¦åˆï¼Œé‚£ä¹ˆè¿™ä¸ªç‚¹çš„åºåˆ—ï¼šå¿…é¡»æ·»åŠ  \\(cntson + 1\\) ä¸ª \\((u)\\) ï¼Œè¿˜æœ‰æ‰€æœ‰çš„ \\(A_{son}\\)ï¼Œå…¶ä½™çš„æ¯ä¸ªè¡¥å……ä¼šå¢åŠ ä¸¤ä¸ªç‚¹ã€‚\\[\\begin{array}{ll}|A_u| &amp; \\le \\sum_{son} A_{son} + cntson + 1 + 2 \\ast cntson\\\\\\\\\\ &amp; \\le \\sum_{son} (4 \\ast size_{son} - 3) + 3\\ast cntson +1\\\\\\\\\\ &amp; = 4 \\ast \\sum_{son} size_{son} - 3\\ast cntson + 3\\ast cntson+ 1\\\\\\\\\\ &amp; = 4 \\ast (size_u - 1) + 1\\\\\\\\\\ &amp; = 4 \\ast size_u - 3\\end{array}\\] è¿™æ ·å°±è¯æ˜äº†ï¼Œæœ€åæ ¹çš„åºåˆ—å¤§å°ä¸è¶…è¿‡ \\(4N - 3\\) ã€‚ æœ€ååºåˆ—ä¸­å¦‚æœæ ¹èŠ‚ç‚¹å¥‡å¶æ€§ä¸å¯¹ï¼Œé‚£ä¹ˆéšä¾¿æ‰¾ä¸€ä¸ªæ ¹èŠ‚ç‚¹çš„å„¿å­ \\(son\\) ï¼Œè¡¥ä¸€ä¸ª \\((son,u,son)\\) å³å¯ä¿®æ­£ã€‚ è¿™æ ·å­åºåˆ—é•¿åº¦çš„ä¸Šé™åˆšå¥½æ˜¯ \\(4N\\) ï¼Œå¤æ‚åº¦ \\(\\mathcal{O}(n)\\)ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;inline bool gn() &#123; char c = getchar(); for (; !isdigit(c); c = getchar()); return c - &#x27;0&#x27;;&#125;#define N 100007#define pb push_backvector&lt;int&gt; e[N], res;bool vis[N], s[N];void add(int x) &#123; s[x] ^= 1; res.pb(x);&#125;void dfs(int u) &#123; vis[u] = 1; add(u); for (auto v : e[u]) if (!vis[v]) &#123; //å½“å‰ç‚¹æ²¡åœ¨æ ‘é‡Œå‡ºç°è¿‡ dfs(v); add(u); if (s[v]) &#123;add(v); add(u);&#125; &#125;&#125;int main() &#123; int n = rd(), m = rd(); for (int i = 1; i &lt;= m; ++i) &#123; int u = rd(), v = rd(); e[u].pb(v); e[v].pb(u); &#125; for (int i = 1; i &lt;= n; ++i) s[i] = gn(); dfs(1); if (s[1]) &#123; int son = e[1][0]; add(son); add(1); add(son); &#125; printf(&quot;%d\\n&quot;, (int)res.size()); for (auto x : res) printf(&quot;%d &quot;, x); return 0;&#125; Ex. Linear Maximization ç»´æŠ¤ä¸€ä¸ªäºŒç»´å‘é‡é›†ï¼Œæ”¯æŒï¼š æ’å…¥ä¸€ä¸ªäºŒç»´å‘é‡ \\((x, y)\\) æŸ¥è¯¢é›†åˆä¸­å’Œç»™å®šå‘é‡ \\((u, v)\\) ç‚¹ç§¯çš„æœ€å¤§å€¼ [SDOI2014]å‘é‡é›† å¼±åŒ–ç‰ˆï¼Œçº¿æ®µæ ‘ç»´æŠ¤å‡¸åŒ…å³å¯ã€‚","categories":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://blog.gyx.me/categories/AtCoder/"},{"name":"AtCoder Beginner Contest","slug":"AtCoder/AtCoder-Beginner-Contest","permalink":"http://blog.gyx.me/categories/AtCoder/AtCoder-Beginner-Contest/"}],"tags":[{"name":"Constructive Algorithm","slug":"Constructive-Algorithm","permalink":"http://blog.gyx.me/tags/Constructive-Algorithm/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"},{"name":"Bitmask","slug":"Bitmask","permalink":"http://blog.gyx.me/tags/Bitmask/"}]},{"title":"Google Code Jam to I/O for Women 2022","slug":"misc/codejamio2022","date":"2022-03-27T16:00:00.000Z","updated":"2023-03-20T16:39:07.930Z","comments":true,"path":"misc/codejamio2022/","link":"","permalink":"http://blog.gyx.me/misc/codejamio2022/","excerpt":"","text":"A. Inversions Organize ç»™ä½ ä¸€ä¸ª \\(2n\\times 2n\\) çš„ 01 çŸ©é˜µï¼Œé—®ä½ æœ€å°‘åè½¬å¤šå°‘ä¸ªä½ç½®ï¼Œèƒ½å¤Ÿåšåˆ°ä¸Šä¸‹ä¸¤åŠ1çš„ä¸ªæ•°ç›¸åŒï¼Œå·¦å³ä¸¤åŠ1çš„ä¸ªæ•°ç›¸åŒã€‚ ä»¥ä¸­ç‚¹ä¸ºåŸç‚¹ï¼Œè®¾æœ€åå››ä¸ªè±¡é™çš„ 1 çš„ä¸ªæ•°åˆ†åˆ«ä¸º \\(a,b,c,d\\) ã€‚ éœ€è¦æ»¡è¶³ï¼š\\(a+b=b+c=c+d=d+a\\) ï¼Œå¯ä»¥æ¨å‡º \\(a=c,b=d\\) ã€‚ å› æ­¤æŠŠä¸€ä¸‰è±¡é™ 1 çš„ä¸ªæ•°è°ƒæ•´åˆ°ç›¸åŒã€äºŒå››è±¡é™ 1 çš„ä¸ªæ•°è°ƒæ•´åˆ°ç›¸åŒå³å¯ã€‚ ç­”æ¡ˆå°±æ˜¯ \\(|cnt_1-cnt_3|+|cnt_2-cnt_4|\\) ï¼Œå¤æ‚åº¦ \\(\\mathcal O(n^2)\\)ã€‚ 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;inline int gc() &#123; char c = getchar(); while (!isalpha(c)) c = getchar(); return c == &#x27;I&#x27;;&#125;int testcase;inline void work() &#123; printf(&quot;Case #%d: &quot;, ++testcase); int n; cin &gt;&gt; n; int m = n * 2; int a = 0, b = 0; for (int i = 1; i &lt;= m; ++i) for (int j = 1; j &lt;= m; ++j) &#123; int x = gc(); if (i &lt;= n &amp;&amp; j &lt;= n) a += x; else if (i &lt;= n &amp;&amp; j &gt; n) b += x; else if (i &gt; n &amp;&amp; j &lt;= n) b -= x; else a -= x; &#125; printf(&quot;%d\\n&quot;, abs(a) + abs(b));&#125;int main() &#123; int t; cin &gt;&gt; t; for (; t; t--) work(); return 0;&#125; B. Ingredient Optimization æœ‰ \\(n\\) æ‰¹è´§ç‰©ï¼Œç¬¬ \\(i\\) æ‰¹è´§ç‰©æœ‰ \\(L_i\\) ä¸ªï¼Œ\\(M_i\\) æ—¶åˆ»é€è¾¾ï¼Œ\\(M_i+E_i\\) æ—¶åˆ»èµ·å°±ä¸èƒ½å†ç”¨äº†ã€‚ æœ‰ \\(q\\) ä¸ªè®¢å•ï¼Œç¬¬ \\(i\\) ä¸ªåœ¨ \\(O_i\\) æ—¶åˆ» \\((O_{i-1}&lt;O_i)\\) ï¼Œéœ€è¦ \\(U\\) ä¸ªè´§ç‰©åˆ¶ä½œã€‚ æŸä¸€æ¬¡åšä¸äº†å•†åº—å°±å€’é—­äº†ï¼ˆåé¢è®¢å•éƒ½ä¸åšï¼‰ï¼Œé—®æœ€ä¼˜ç­–ç•¥ä¸‹èƒ½å®Œæˆå¤šå°‘ä¸ªè®¢å•ã€‚ è´ªå¿ƒå³å¯ï¼Œæ‰«æè®¢å•ï¼Œæ¯æ¬¡å…ˆæŠŠå½“å‰å¯ç”¨çš„é›†åˆç”¨ä¸€ä¸ªå †ç»´æŠ¤ä¸€ä¸‹ã€‚ ç„¶åä¼˜å…ˆå–ç”¨æœ€æ—©è¿‡ä¿è´¨æœŸçš„å•†å“å³å¯ï¼Œå¤„ç†éœ€è¦ä¸€äº›ç»†èŠ‚ï¼Œå¤æ‚åº¦ \\(\\mathcal{O}((n+q)\\log n)\\)ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 107#define fr first#define sc second#define pb push_back#define mp make_pair#define pii pair&lt;int, int&gt;vector&lt;pii&gt; q;int testcase, a[N], b[N];struct node &#123; int id; inline bool operator &lt; (const node &amp;obj) const&#123; return b[id] &gt; b[obj.id]; &#125;&#125;;priority_queue&lt;node&gt; s;inline void work() &#123; q.clear(); while (!s.empty()) s.pop(); printf(&quot;Case #%d: &quot;, ++testcase); int n = rd(), m = rd(), u = rd(); for (int i = 1; i &lt;= n; ++i) &#123; int t = rd(); a[i] = rd(); b[i] = t + rd(); q.pb(mp(t, i)); q.pb(mp(b[i], -i)); &#125; sort(q.begin(), q.end()); int ans = 0, fl = 1; for (int i = 1, ptr = 0; i &lt;= m; ++i) &#123; int t = rd(); while (ptr &lt; 2 * m &amp;&amp; q[ptr].fr &lt;= t) &#123; if (q[ptr].sc &lt; 0) a[-q[ptr].sc] = 0; else s.push((node)&#123;q[ptr].sc&#125;); ++ptr; &#125; int tmp = u; while (tmp &amp;&amp; !s.empty()) &#123; int id = s.top().id; int del = min(a[id], tmp); tmp -= del; a[id] -= del; if (a[id] == 0) s.pop(); &#125; if (tmp) fl = 0; ans += fl; &#125; printf(&quot;%d\\n&quot;, ans);&#125;int main() &#123; int t; cin &gt;&gt; t; for (; t; t--) work(); return 0;&#125; C. Interesting Outing ç»™ä¸€æ£µæ ‘ï¼Œæœ‰è¾¹æƒï¼Œæ±‚ä¸€ä¸ªæœ€çŸ­çš„è·¯å¾„ï¼Œä½¿å¾—æ‰€æœ‰ç‚¹éƒ½è‡³å°‘è¢«è®¿é—®åˆ°ä¸€æ¬¡ã€‚ å®šä¹‰ \\(f_{i,0/1}\\) è¡¨ç¤º \\(i\\) çš„å­æ ‘å…¨éƒ¨è®¿é—®å®Œï¼Œå›åˆ° / ä¸å›åˆ° \\(i\\) çš„æœ€çŸ­è·¯å¾„é•¿åº¦ï¼Œç­”æ¡ˆå°±æ˜¯ \\(f_{root,1}\\) è½¬ç§»æ–¹ç¨‹ï¼šè®¾ \\(w_{i, son}\\) è¡¨ç¤º \\(i\\) å’Œå„¿å­ \\(son\\) ä¹‹é—´çš„è¾¹æƒã€‚ \\(f_{i,0}=\\sum_{son}(f_{son,0}+w_{i, son})\\) ï¼Œ \\(f_{i,1}=f_{i,0}-\\max_{son}(f_{son,0}-f_{son,1} + w_{i,son})\\) å¤æ‚åº¦ \\(\\mathcal{O}(n)\\) ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 1007int testcase, hd[N], tot;struct edge &#123;int to, nxt, w;&#125;e[N &lt;&lt; 1];ll f[N][2];void dfs(int u, int fa) &#123; ll mx = 0; for (int i = hd[u], v; i; i = e[i].nxt) if ((v = e[i].to) != fa) &#123; dfs(v, u); f[u][0] += f[v][0] + 2 * e[i].w; mx = max(mx, f[v][0] - f[v][1] + e[i].w); &#125; f[u][1] = f[u][0] - mx;&#125;inline void work() &#123; printf(&quot;Case #%d: &quot;, ++testcase); tot = 0; memset(hd, 0, sizeof(hd)); int n = rd(); for (int i = 1; i &lt; n; ++i) &#123; int u = rd(), v = rd(), w = rd(); e[++tot].to = v; e[tot].w = w; e[tot].nxt = hd[u]; hd[u] = tot; e[++tot].to = u; e[tot].w = w; e[tot].nxt = hd[v]; hd[v] = tot; &#125; ll ans = 1e18; for (int i = 1; i &lt;= n; ++i) &#123; memset(f, 0, sizeof(f)); dfs(i, i); ans = min(ans, min(f[i][0], f[i][1])); &#125; printf(&quot;%lld\\n&quot;, ans);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; D. Inventor Outlasting ç»™å®šä¸€ä¸ª \\(R\\times C\\) çš„åœ°å›¾ï¼Œä¸Šé¢æœ‰é»„è‰²å’Œç»¿è‰²çš„ç‚¹ã€‚ ä¸¤ä¸ªäººåšå¼ˆï¼Œæ¯æ¬¡å¯ä»¥é€‰æ‹©ä¸€ä¸ªé»„è‰²çš„ç‚¹æ“ä½œï¼Œä¸èƒ½æ“ä½œçš„äººè¾“ã€‚ æ“ä½œå°±æ˜¯æŠŠè¿™ä¸ªç‚¹æŸ“é»‘ï¼Œç„¶åä»ä¸ªç‚¹æŒ‰ç…§ X å½¢å‘æ•£æŸ“é»‘ã€‚å…·ä½“çš„ï¼Œå°±æ˜¯ä»è¿™ä¸ªç‚¹å¼€å§‹æŒ‰ç…§å››ä¸ª \\(45^\\circ\\) æ–¹å‘æ‰©å±•æŠŠæ‰€æœ‰ç‚¹æŸ“é»‘ï¼Œç›´åˆ°ç¢°åˆ°è¾¹ç•Œï¼Œæˆ–å½“å‰è¦æŸ“çš„æ ¼å­å·²ç»è¢«æŸ“é»‘åï¼Œä¸ç»§ç»­å¾€è¿™ä¸ªæ–¹å‘æ‰©å±•ã€‚ é—®å…ˆæ‰‹ç¬¬ä¸€æ­¥æœ‰å¤šå°‘ç§ä¸åŒçš„ä¸‹æ³•ä¿è¯å¿…èƒœã€‚ é¦–å…ˆè§‚å¯Ÿè¿™ä¸ªåœ°å›¾å¯ä»¥æ‹†æˆä¸¤å¼ ï¼ŒæŒ‰ç…§ \\((\\) è¡Œå·+åˆ—å· \\()\\) çš„å¥‡å¶æ€§å¯ä»¥æŠŠå›¾åˆ†å¼€ï¼Œäº’ä¸å½±å“ã€‚ è¿›ä¸€æ­¥çš„ï¼Œå¦‚æœæŠŠåæ ‡ç³»è½¬ \\(45^\\circ\\) ï¼Œå¯ä»¥å‘ç°æ¯æ¬¡æ“ä½œå°±ç›¸å½“äºæŠŠä¸€ä¸ªä»¥é»‘è‰²ä¸ºè¾¹ç•Œçš„çŸ©å½¢æ¨ªç«–å„åˆ‡ä¸€åˆ€ã€‚ æ‰€ä»¥å…¶å®æ˜¯æŠŠå½“å‰çš„æ¸¸æˆè½¬åŒ–æˆäº†å››ä¸ªå­æ¸¸æˆçš„å¹¶ï¼Œæ ¹æ® SG å¼•ç†ï¼Œå½“å‰çŠ¶æ€çš„ SG å€¼å°±æ˜¯å››ä¸ªå­æ¸¸æˆçš„ SG å€¼çš„å¼‚æˆ–ã€‚ æœ¬è´¨ä¸åŒçš„æ¸¸æˆæ•°å–å†³äºå½“å‰â€œçŸ©å½¢â€åœ¨åŸåœ°å›¾ä¸­çš„ä½ç½®ï¼Œæ‰€ä»¥æœ‰ \\(O(R^2\\times C^2)\\) ä¸ªã€‚ æ¯æ¬¡æšä¸¾ä¸‹ä¸€ä¸ªæ“ä½œçš„æ˜¯å“ªä¸ªä½ç½®ï¼Œå¤æ‚åº¦ \\(\\mathcal{O}(R\\times C)\\) ï¼Œæ‰€ä»¥è®°å¿†åŒ–æœç´¢ SG å‡½æ•°æ€»å¤æ‚åº¦ \\(\\mathcal{O}(R^3\\times C^3)\\) ã€‚ éœ€è¦æ³¨æ„ç¬¬ä¸€æ¬¡çš„é€‰æ‹©çš„æ—¶å€™ï¼Œæ˜¯æŠŠæ¸¸æˆåˆ’åˆ†ä¸ºäº”ç§æƒ…å†µçš„å¹¶ï¼Œé™¤äº†å››ä¸ªå­çŸ©å½¢ï¼Œè¿˜æœ‰å¦å¤–ä¸€å¼ å›¾ï¼ˆå¥‡å¶æ€§ä¸åŒï¼‰ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;inline int gc() &#123; char c = getchar(); for (; c != &#x27;.&#x27; &amp;&amp; c != &#x27;X&#x27;; c = getchar()); return c == &#x27;X&#x27;;&#125;#define N 107#define pb push_backbool a[2][N][N];int testcase;unordered_map&lt;ll, int&gt; sg;inline ll hash_scope(ll id, ll a, ll b, ll c, ll d) &#123; return (((a * 200 + b) * 200 + c) * 200 + d) * 2 + id;&#125;int dp(int id, int lx, int rx, int ly, int ry) &#123; if (lx &gt; rx || ly &gt; ry) return 0; ll h = hash_scope(id, lx, rx, ly, ry); if (sg.find(h) != sg.end()) return sg[h]; vector&lt;int&gt; nxt; nxt.clear(); for (int x = lx; x &lt;= rx; ++x) for (int y = ly; y &lt;= ry; ++y) if (a[id][x][y]) &#123; int a = dp(id, lx, x - 1, ly, y - 1); int b = dp(id, lx, x - 1, y + 1, ry); int c = dp(id, x + 1, rx, ly, y - 1); int d = dp(id, x + 1, rx, y + 1, ry); nxt.pb(a ^ b ^ c ^ d); &#125; sort(nxt.begin(), nxt.end()); for (int i = 0, ptr = 0; ; ++i) &#123; if (ptr &gt;= nxt.size() || nxt[ptr] &gt; i) return sg[h] = i; for (; ptr &lt; nxt.size() &amp;&amp; nxt[ptr] == i; ++ptr); &#125;&#125;inline void work() &#123; sg.clear(); memset(a, 0, sizeof(a)); int r = rd(), c = rd(); int lx = 1e9, ly = 1e9; int rx = -1e9, ry = -1e9; for (int i = 1; i &lt;= r; ++i) for (int j = 1; j &lt;= c; ++j) &#123; int id = ((i + j) &amp; 1); int x = (i + j) / 2; int y = (i - j + 100) / 2; if ((a[id][x][y] = gc())) &#123; lx = min(lx, x); rx = max(rx, x); ly = min(ly, y); ry = max(ry, y); &#125; &#125; int ans = 0; for (int id = 0; id &lt;= 1; ++id) for (int x = lx; x &lt;= rx; ++x) for (int y = ly; y &lt;= ry; ++y) if (a[id][x][y]) &#123; int a = dp(id, lx, x - 1, ly, y - 1); int b = dp(id, lx, x - 1, y + 1, ry); int c = dp(id, x + 1, rx, ly, y - 1); int d = dp(id, x + 1, rx, y + 1, ry); ans += ((a ^ b ^ c ^ d ^ dp(id ^ 1, lx, rx, ly, ry)) == 0); &#125; printf(&quot;Case #%d: %d\\n&quot;, ++testcase, ans);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125;","categories":[{"name":"Misc Solutions","slug":"Misc-Solutions","permalink":"http://blog.gyx.me/categories/Misc-Solutions/"}],"tags":[{"name":"Greedy","slug":"Greedy","permalink":"http://blog.gyx.me/tags/Greedy/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"},{"name":"Game Theory","slug":"Game-Theory","permalink":"http://blog.gyx.me/tags/Game-Theory/"}]},{"title":"Codeforces Round #777 (Div. 2)","slug":"codeforces/1647","date":"2022-03-18T16:00:00.000Z","updated":"2023-03-20T16:25:56.818Z","comments":true,"path":"codeforces/1647/","link":"","permalink":"http://blog.gyx.me/codeforces/1647/","excerpt":"","text":"A å’Œ B æ¯”è¾ƒç®€å•å°±ä¸å†™äº†ã€‚ C. Madoka and Childish Pranks ä¸€ä¸ªåˆå§‹æ˜¯å…¨ç™½çš„çŸ©é˜µï¼Œæ¯æ¬¡å¯ä»¥é€‰ä¸€ä¸ªå­çŸ©é˜µæŸ“æˆæ£‹ç›˜ï¼ˆå·¦ä¸Šè§’æ˜¯ç™½è‰²ï¼‰ æ„é€ ä¸€ä¸ªä¸è¶…è¿‡ \\(n*m\\) æ¬¡çš„æ–¹æ³•æŠŠçŸ©é˜µæŸ“æˆç›®æ ‡æ ·å­ï¼Œæˆ–è¾“å‡ºæ— è§£ã€‚ Key ï¼šæ¯æ¬¡æŸ“ä¸€ä¸ª \\(1\\ast 2\\) çš„ï¼Œå¯ä»¥æŠŠå³ä¾§çš„å˜é»‘ï¼Œ\\(2\\ast 1\\) çš„å¯ä»¥æŠŠä¸‹ä¾§çš„å˜é»‘ã€‚ å› æ­¤å¯¹äºæ¯ä¸€è¡Œï¼Œæˆ‘åˆå¯ä»¥ä»å³å¾€å·¦ä¾æ¬¡æŸ“ \\(1\\ast 2\\) ï¼Œé™¤ç¬¬ä¸€åˆ—ä»»ä½•ä½ç½®éƒ½å¯ä»¥æŸ“é»‘ã€‚ å¯¹äºç¬¬ä¸€åˆ—ä»ä¸‹å¾€ä¸Šä¾æ¬¡æŸ“ \\(2\\ast 1\\) ï¼Œé™¤ \\((1,1)\\) ä½ç½®å¤–éƒ½å¯ä»¥æŸ“é»‘ã€‚ æ‰€ä»¥åªè¦ \\((1,1)\\) ä¸æ˜¯é»‘è‰²çš„å°±éƒ½æœ‰è§£ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;inline int gn() &#123; char c = getchar(); for (; !isdigit(c); c = getchar()); return c - &#x27;0&#x27;;&#125;#define N 107#define fr first#define sc second#define mp make_pair#define pb push_back#define pii pair&lt;int, int&gt;int a[N][N];vector&lt;pair&lt;pii,pii&gt;&gt; s;inline void work() &#123; s.clear(); int n = rd(), m = rd(); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) a[i][j] = gn(); if (a[1][1]) &#123;puts(&quot;-1&quot;); return;&#125; for (int i = 1; i &lt;= n; ++i) for (int j = m; j &gt; 1; --j) if (a[i][j]) s.pb(mp(mp(i,j - 1), mp(i, j))); for (int i = n; i &gt; 1; --i) if (a[i][1]) s.pb(mp(mp(i - 1, 1), mp(i, 1))); printf(&quot;%d\\n&quot;, (int)s.size()); for (auto x : s) printf(&quot;%d %d %d %d\\n&quot;, x.fr.fr, x.fr.sc, x.sc.fr, x.sc.sc);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; D. Madoka and the Best School in Russia å®šä¹‰ä¸€ä¸ªæ•°å­— \\(x\\) æ˜¯å¥½çš„ï¼Œå½“ä¸”ä»…å½“ \\(x\\) æ˜¯ \\(d\\) çš„å€æ•°ã€‚ å®šä¹‰ä¸€ä¸ªæ•°å­— \\(x\\) æ˜¯æ¼‚äº®çš„ï¼Œå½“ä¸”ä»…å½“ä»–ä¸èƒ½è¢«æ‹†åˆ†æˆä¸¤ä¸ªå¥½çš„æ•°çš„ä¹˜ç§¯ï¼ˆä¹Ÿå°±æ˜¯åªå«æœ‰ä¸€ä¸ª \\(d\\) ï¼‰ ç»™ä½ ä¸€ä¸ªå¥½çš„æ•° \\(x\\) ï¼Œé—®ä½ æ˜¯å¦æœ‰è‡³å°‘ä¸¤ç§ä¸åŒçš„æ–¹æ³•ï¼ŒæŠŠ \\(x\\) æ‹†æˆè‹¥å¹²ä¸ªæ¼‚äº®çš„æ•°çš„ä¹˜ç§¯ã€‚ æ–¹æ³•ä¸åŒå³æ‹†åˆ†å¾—åˆ°çš„æ•°é›†ä¸åŒã€‚ å› ä¸ºæ¯ä¸ªæ¼‚äº®æ•°æœ‰ä¸”ä»…æœ‰ä¸€ä¸ª \\(d\\) ï¼Œå› æ­¤ \\(x\\) é‡Œæœ‰å‡ ä¸ª \\(d\\) ï¼Œå°±è‡³å¤šè¦æ‹†æˆå‡ ä¸ªæ¼‚äº®æ•°ã€‚ å…ˆè€ƒè™‘æŠŠ \\(x\\) é‡Œçš„ \\(d\\) éƒ½å»æ‰ï¼Œå‰©ä¸‹çš„æ•°æ˜¯ \\(y\\) ï¼Œæˆ‘ä»¬è‡³å°‘å¾—åˆ°ä¸€ç§æ–¹æ¡ˆæ˜¯ \\(d,d,\\dots,d,d\\ast y\\) å¦‚æœ \\(y\\) å¯ä»¥æ‹†åˆ†ï¼ˆä¸æ˜¯ç´ æ•°ï¼‰ï¼Œé‚£ä¹ˆå°±è‚¯å®šæœ‰è§£ï¼› å¦‚æœ \\(y\\) ä¸å¯æ‹†åˆ†ï¼š å¦‚æœ \\(d\\) ä¸å¯æ‹†åˆ†ï¼Œè‚¯å®šæ— è§£ï¼ˆæ²¡æœ‰å¯æ‹†çš„äº†ï¼‰ å¦‚æœ \\(x\\) é‡Œåªæœ‰ä¸¤ä¸ª \\(d\\) ï¼Œè‚¯å®šæ— è§£ï¼ˆæ²¡æœ‰å¯æ‹†çš„äº†ï¼‰ å¦‚æœ \\(x\\) é‡Œæœ‰è¶…è¿‡ä¸‰ä¸ª \\(d\\) ï¼Œè‚¯å®šæœ‰è§£ï¼ˆæŠŠ \\(y\\) å’Œ \\(d\\) æ‹†åˆ†å¾—åˆ°çš„ä¸‰ä¸ªæ•°ï¼Œåˆ†é…ç»™å¦å¤–ä¸‰ä¸ª \\(d\\) ï¼‰ å¦‚æœ \\(x\\) é‡Œæ­£å¥½æœ‰ä¸‰ä¸ª \\(d\\) ï¼Œéœ€è¦æ£€éªŒä¸€ä¸‹æŠŠ \\(d\\) æ‹†å‡ºæ¥çš„ä¸¤éƒ¨åˆ†æŸä¸€éƒ¨åˆ†åˆ†ç»™ \\(y\\) ä¼šä¸ä¼šå½¢æˆæ–°çš„ \\(d\\) 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 107inline void work() &#123; int x = rd(), d = rd(); if (x % d != 0) &#123;puts(&quot;NO&quot;); return;&#125; if (x / d % d != 0) &#123;puts(&quot;NO&quot;); return;&#125; int cnt = 0; for (; x % d == 0; x /= d, ++cnt); int lim = sqrt(x); for (int i = 2; i &lt;= lim; ++i) if (x % i == 0) &#123;puts(&quot;YES&quot;); return;&#125; if (cnt == 2) &#123;puts(&quot;NO&quot;); return;&#125; lim = sqrt(d); for (int i = 2; i &lt;= lim; ++i) if (d % i == 0) &#123; if (cnt &gt; 3) &#123;puts(&quot;YES&quot;); return;&#125; if (1ll * i * x % d != 0 || 1ll * d / i * x % d != 0) &#123;puts(&quot;YES&quot;); return;&#125; &#125; puts(&quot;NO&quot;);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; E. Madoka and the Sixth-graders é¢˜æ„å¤ªå¤æ‚ï¼Œæˆ‘ç®€å•è¯´ä¸€ä¸‹ï¼Œä¸æ¸…æ¥šçš„çœ‹åŸé¢˜ã€‚ ç»™å®šä¸€ä¸ªå…± \\(n\\) ä¸ªç‚¹çš„å†…å‘åŸºç¯æ ‘æ£®æ—ï¼Œå¼€å§‹æ¯ä¸ªç‚¹ä¸Šæœ‰ä¸€ä¸ªæ•°ï¼ˆæ˜¯ \\(n\\) çš„æ’åˆ—ï¼‰ã€‚ æ¯ä¸€ä¸ªæ—¶åˆ»æ‰€æœ‰ç‚¹æŒ‰ç…§æ‰€åœ¨è¾¹ç§»åŠ¨ä¸€æ¬¡ï¼Œå¦‚æœæŸä¸€æ—¶åˆ»æŸä¸ªç‚¹ä¸Šæœ‰å¾ˆå¤šæ•°ï¼Œåªä¿ç•™æœ€å°çš„ã€‚ å¦‚æœæŸä¸€æ—¶åˆ»æŸä¸ªç‚¹ä¸Šæ²¡æ•°äº†ï¼ˆå¶å­ï¼‰ï¼Œé‚£ä¹ˆæŒ‰ç…§èŠ‚ç‚¹ç¼–å·ä»å°åˆ°å¤§ä¾æ¬¡å¾€é‡Œé¢å¡ \\(n+1,n+2,\\dots\\) ç°åœ¨ç»™å‡ºæ£®æ—çš„å½¢æ€ï¼Œå’Œç»è¿‡è‹¥å¹²æ—¶åˆ»åæ¯ä¸ªç‚¹ä¸Šçš„æ•°å­— \\(a_1,\\dots,a_n\\) ã€‚ è¯·ä½ è¿˜åŸå‡ºæ¥ä¸€ä¸ªå­—å…¸åºæœ€å°çš„åˆå§‹çŠ¶æ€ï¼Œä¿è¯æœ‰è§£ã€‚ Key 1 ï¼šå‡è®¾å·²çŸ¥ç»è¿‡çš„æ—¶é—´æ˜¯ \\(t\\) ï¼Œé‚£ä¹ˆæ¯ä¸ªç‚¹æŒ‰ç…§è¾¹ç§»åŠ¨ \\(t\\) æ­¥ä»¥åçš„ä½ç½®ä¸Šçš„æ•°å­—ä¸€å®šæ˜¯ä¸è¶…è¿‡ \\(n\\) çš„ã€‚ è¯æ˜ï¼šå¦‚æœæ˜¯æ ‘çš„éƒ¨åˆ†ï¼Œé‚£ä¹ˆ \\(n\\) ä»¥åçš„æ•°å­—æ°¸è¿œè¿½ä¸ä¸Šï¼›å¦‚æœæ˜¯ç¯çš„éƒ¨åˆ†ï¼Œå› ä¸º \\(n\\) ä»¥åçš„æ•°å­—æ¯” \\(n\\) å¤§ï¼Œæ‰€ä»¥éƒ½ä¼šè¢«èˆå¼ƒã€‚ Key 2 ï¼šä¸¤ä¸ªç‚¹å¦‚æœåœ¨æŸä¸€æ­¥ä¹‹ååŒæ—¶ç§»åŠ¨åˆ°äº†åŒä¸€ä¸ªç‚¹ï¼Œé‚£ä¹ˆåé¢çš„è·¯å¾„éƒ½ç›¸åŒï¼ˆå› ä¸ºæ¯ä¸ªç‚¹åªæœ‰ä¸€ä¸ªå‡ºè¾¹ï¼‰ã€‚ æ‰¾å‡ºç»è¿‡çš„æ—¶é—´ \\(t\\) ï¼šå‡è®¾å¶å­ä¸ªæ•°æ˜¯ \\(cnt\\) ï¼Œåºåˆ—é‡Œæœ€å¤§æ˜¯ \\(mx\\) ï¼Œé‚£ä¹ˆ \\(t=\\frac{mx - n}{cnt}\\) ï¼ˆæ¯ä¸€æ¬¡ç§»åŠ¨ä¼šå¼•è¿› \\(cnt\\) ä¸ªæ•°ï¼‰ã€‚ æ¯ä¸ªä½ç½®å¯èƒ½ä¼šæ”¾å“ªä¸ªæ•°ï¼Ÿ æ ¹æ®å‰é¢æåˆ°çš„ Keyï¼Œå‡è®¾ \\(u\\) èµ° \\(t\\) æ­¥ä¹‹ååˆ°è¾¾çš„ç‚¹æ˜¯ \\(v\\) ï¼Œé‚£ä¹ˆ \\(u\\) ä¸Šå¼€å§‹çš„æ•°å­—è¦ä¹ˆæ˜¯ \\(a_v\\) ï¼Œè¦ä¹ˆæ¯” \\(a_v\\) å¤§ï¼Œåœ¨ç§»åŠ¨çš„è¿‡ç¨‹ä¸­æŸä¸€æ­¥è¢«æŒ¤æ‰äº†ã€‚ ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœä¸€ä¸ªç‚¹é›† \\(S\\) é‡Œæ‰€æœ‰ç‚¹èµ° \\(t\\) æ­¥ä»¥ååˆ°è¾¾çš„ç‚¹éƒ½æ˜¯ \\(v\\) ï¼Œé‚£ä¹ˆè¿™äº›ç‚¹åˆå§‹çŠ¶æ€é‡Œæœ‰ä¸€ä¸ªå¿…å®šæ˜¯ \\(a_v\\) ï¼Œå…¶ä»–éƒ½æ¯” \\(a_v\\) å¤§ã€‚ æ€ä¹ˆæ‰¾ \\(v\\) ï¼šå› ä¸ºæ¯ä¸ªç‚¹éƒ½åªæœ‰ä¸€æ¡å‡ºè¾¹ï¼Œå› æ­¤å¯ä»¥ç›´æ¥å€å¢æ‰¾ æ€ä¹ˆè´ªå¿ƒï¼Ÿ æˆ‘ä»¬å…ˆä»¤ç»“æœåºåˆ— \\(b_u=a_v\\) ï¼Œä¹Ÿå°±æ˜¯å‡è®¾æ¯ä¸ªç‚¹çš„åˆå§‹çŠ¶æ€å°±æ˜¯èµ° \\(t\\) æ­¥ä»¥åçš„ä½ç½®ä¸Šçš„å€¼ã€‚ è®¾ \\(S_x=\\\\{u|b_u=x\\\\}\\) ï¼Œè€ƒè™‘ä»å°åˆ°å¤§æ”¾æ•°å­— \\(x\\) ï¼š å¦‚æœ \\(S_x\\ne \\emptyset\\) ï¼Œé‚£ä¹ˆå°±æŠŠ \\(x\\) æ”¾åˆ° \\(S_x\\) ä¸­ä½ç½®æœ€é å‰çš„ å¦‚æœ \\(S_x=\\emptyset\\) ï¼Œé‚£ä¹ˆå°±æŠŠ \\(x\\) æ”¾åˆ° \\(S_1\\cup S_2\\cup\\dots\\cup S_{x-1}\\) ä¸­æœªä½¿ç”¨çš„æœ€é å‰çš„ä½ç½®é‡Œã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 100007int f[N][40], a[N], res[N];bool vis[N];queue&lt;int&gt; s[N];set&lt;int&gt; S;inline void work() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; f[i][0] = rd(); vis[f[i][0]] = 1; &#125; for (int j = 1; j &lt; 40; ++j) for (int i = 1; i &lt;= n; ++i) f[i][j] = f[f[i][j - 1]][j - 1]; int mx = 0, cnt = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (!vis[i]) ++cnt; a[i] = rd(); mx = max(mx, a[i]); &#125; cnt = (mx - n) / cnt; memset(vis, 0, sizeof(vis)); for (int i = 1; i &lt;= n; ++i) &#123; int u = i; for (int k = 30; k &gt;= 0; --k) if (cnt &amp; (1 &lt;&lt; k)) u = f[u][k]; res[i] = a[u]; s[res[i]].push(i); vis[res[i]] = 1; //Sxä¸ç©º &#125; for (int i = 1; i &lt;= n; ++i) if (vis[i]) s[i].pop(); //æŠŠiæ”¾åˆ°Siæœ€é å‰çš„ä½ç½® int nw = 0; for (int i = 1; i &lt;= n; ++i) if (!vis[i]) &#123; while (nw &lt;= i) &#123; while (s[nw].size()) &#123; S.insert(s[nw].front()); s[nw].pop(); &#125; ++nw; &#125; res[*S.begin()] = i; S.erase(S.begin()); &#125; for (int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, res[i]);&#125;int main() &#123; for (int t = 1; t; --t) work(); return 0;&#125; F. Madoka and Laziness ç»™å®šä¸€ä¸ªæ²¡æœ‰é‡å¤æ•°å€¼çš„æ•°åˆ— \\(\\{a_i\\}\\) ï¼Œé—®æœ‰å¤šå°‘ç§æ–¹å¼å°†æ•°åˆ—åˆ’åˆ†ä¸ºä¸¤ä¸ªå³°åºåˆ—ï¼ˆä¸¥æ ¼å•å¢å†å•å‡ï¼‰ã€‚ ä¸¤ç§åˆ’åˆ†ä¸åŒï¼Œå½“ä¸”ä»…å½“è‡³å°‘æŸä¸€ä¸ªå³°åºåˆ—çš„å³°å€¼ä¸åŒï¼ˆè®¤ä¸º &lt;a,b&gt; å’Œ &lt;b,a&gt; ç›¸åŒï¼‰ã€‚ Key ï¼šæœ€å¤§å€¼ä¸€å®šæ˜¯å…¶ä¸­ä¸€ä¸ªå³°çš„å³°å€¼ã€‚ è¿™ä¸ªè§‚å¯Ÿæœ‰ä»€ä¹ˆç”¨å‘¢ï¼Ÿå› ä¸ºä¸€ä¸ªå³°å€¼å›ºå®šï¼Œæˆ‘ä»¬å¯ä»¥å¾—åˆ°ç­”æ¡ˆæ˜¯ O(n) çš„ã€‚ ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬åªéœ€è¦å»æ£€éªŒï¼Œå…¶ä»–çš„æ¯ä¸€ä¸ªå€¼æ˜¯å¦æœ‰å¯èƒ½æˆä¸ºå³°å€¼å³å¯ã€‚ æ€ä¹ˆæ£€éªŒå‘¢ï¼Ÿåªéœ€è¦åˆ¤æ–­æ˜¯å¦å­˜åœ¨ä¸€ç§æ‹†åˆ†æ–¹å¼ï¼Œä½¿å¾—åˆ°æ¯ä¸ªä½ç½®ä¹‹å‰æ˜¯å‡çš„ï¼Œè¿‡äº†è¿™ä¸ªä½ç½®ä¹‹åæ˜¯é™çš„ï¼Œå¹¶ä¸”æ²¡ç»™è¿™ä¸ªåºåˆ—çš„å…ƒç´ æ‰”ç»™æœ€å¤§å€¼æ‰€åœ¨çš„åºåˆ—éƒ½åˆæ³•ã€‚ æˆ‘ä»¬å¯ä»¥å‡è®¾å¦ä¸€ä¸ªå³°å€¼ï¼ˆå³°å€¼Bï¼‰åœ¨æœ€å¤§å€¼ï¼ˆå³°å€¼Aï¼‰çš„å³ä¾§ï¼Œç„¶åæŠŠåºåˆ—ç¿»è¿‡æ¥å†åšä¸€éå³å¯ã€‚ è¿™æ ·å°±æœ‰ä¸‰ä¸ªé˜¶æ®µï¼š åˆ°å³°å€¼Aå‰ï¼šä¸¤ä¸ªåºåˆ—éƒ½ä¸Šå‡ è¿™ä¸€é˜¶æ®µåºåˆ—Aé‡Œåªè¦å•è°ƒé€’å¢ï¼Œæ”¾å¤šå¤§çš„éƒ½å¯ä»¥ã€‚ æˆ‘ä»¬ä¸ºäº†åé¢åºåˆ—Bè¿˜è¦å¢çš„è€ƒè™‘ï¼Œåº”è¯¥å°½é‡å‡å°‘åºåˆ—Båœ¨è¿™ä¸€éƒ¨åˆ†çš„æœ€å¤§å€¼ã€‚ è®¾ \\(f_i\\) ä¸ºè€ƒè™‘å‰ç¼€ \\(i\\) ï¼Œåˆ™ \\(a_i\\) å¿…å®šä¸ºæŸä¸€ä¸ªåºåˆ—ç»“å°¾ï¼Œåˆ™å¦ä¸€ä¸ªåºåˆ—ç»“å°¾æœ€å°å€¼æ˜¯å¤šå°‘ã€‚ è½¬ç§»å¾ˆç®€å•ï¼Œæ¥åœ¨ \\(a_{i-1}\\) åï¼Œæˆ–æ¥åœ¨ \\(f_{i-1}\\) åã€‚ 12if (a[i] &gt; a[i - 1]) f[i] = min(f[i], f[i - 1]);if (a[i] &gt; f[i - 1]) f[i] = min(f[i], a[i - 1]); å³°å€¼Aåï¼Œå³°å€¼Bå‰ï¼šåºåˆ—Aä¸‹é™ï¼Œåºåˆ—Bä¸Šå‡ è¿™ä¸€é˜¶æ®µå› ä¸ºä¸¤ä¸ªåºåˆ—å•è°ƒæ€§ä¸åŒï¼Œæ‰€ä»¥è´ªå¿ƒç­–ç•¥ä¹Ÿä¸åŒã€‚ è®¾ \\(g_{i,0}\\) è¡¨ç¤ºç¬¬ \\(i\\) ä¸ªå…ƒç´ æ”¾åˆ°åºåˆ—Aé‡Œï¼Œå¦ä¸€ä¸ªåºåˆ—ï¼ˆæ­£åœ¨ä¸Šå‡çš„åºåˆ—Bï¼‰æœ«å°¾æœ€å°æ˜¯å¤šå°‘ã€‚ è®¾ \\(g_{i,1}\\) è¡¨ç¤ºç¬¬ \\(i\\) ä¸ªå…ƒç´ æ”¾åˆ°åºåˆ—Bé‡Œï¼Œå¦ä¸€ä¸ªåºåˆ—ï¼ˆæ­£åœ¨ä¸‹é™çš„åºåˆ—Aï¼‰æœ«å°¾æœ€å¤§æ˜¯å¤šå°‘ã€‚ è½¬ç§»ä¹Ÿå¾ˆç®€å•ï¼Œè®¨è®ºä¸€ä¸‹æ¥åœ¨è°åé¢å°±å¥½äº†ã€‚ 1234if (a[i] &lt; a[i - 1]) g[i][0] = min(g[i][0], g[i - 1][0]);if (a[i] &lt; g[i - 1][1]) g[i][0] = min(g[i][0], a[i - 1]);if (a[i] &gt; a[i - 1]) g[i][1] = max(g[i][1], g[i - 1][1]);if (a[i] &gt; g[i - 1][0]) g[i][1] = max(g[i][1], a[i - 1]); å³°å€¼Båï¼šä¸¤ä¸ªåºåˆ—éƒ½ä¸‹é™ å€’ç€è€ƒè™‘ï¼Œå˜æˆå•å¢çš„ï¼Œé‚£ä¹ˆåœ¨ä¿è¯å³°å€¼Bè·Ÿç€çš„åºåˆ—åˆæ³•çš„å‰æä¸‹ï¼Œå¦ä¸€ä¸ªåºåˆ—ï¼ˆç•™ç»™å³°å€¼Açš„ï¼‰çš„æœ€å¤§å€¼è¦å°½å¯èƒ½å°ã€‚ å› æ­¤å¤„ç†æ–¹æ³•åŒç¬¬ä¸€ä¸ªé˜¶æ®µï¼ˆè®¾ä¸º \\(h\\) æ•°ç»„ï¼‰ã€‚ é‚£ä¹ˆæ€ä¹ˆåˆ¤æ–­æ˜¯å¦åˆæ³•å˜ï¼ŸæŠŠ \\(a_i\\) æ”¾åˆ°åºåˆ—Bé‡Œï¼Œå¦ä¸€ä¸ªåºåˆ—åˆæ³•ï¼ˆ ä¹Ÿå°±æ˜¯æ»¡è¶³ g[i][1] &gt; h[i] ï¼‰ å°±å¯ä»¥å•¦ï½ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 500007#define inf 1e9 + 7int n, a[N], f[N], g[N][2];inline int calc() &#123; int p = 0; //maxpos for (int i = 1; i &lt;= n; ++i) &#123; f[i] = g[i][0] = inf; g[i][1] = -1; if (a[i] &gt; a[p]) p = i; &#125; for (int i = 1; i &lt;= p; ++i) &#123; if (a[i] &gt; a[i - 1]) f[i] = min(f[i], f[i - 1]); if (a[i] &gt; f[i - 1]) f[i] = min(f[i], a[i - 1]); &#125; g[p][0] = f[p]; //æ‰¿æ¥ç¬¬ä¸€é˜¶æ®µçš„æœ€å®½æ¾çº¦æŸ for (int i = p + 1; i &lt;= n; ++i) &#123; if (a[i] &lt; a[i - 1]) g[i][0] = min(g[i][0], g[i - 1][0]); if (a[i] &lt; g[i - 1][1]) g[i][0] = min(g[i][0], a[i - 1]); if (a[i] &gt; a[i - 1]) g[i][1] = max(g[i][1], g[i - 1][1]); if (a[i] &gt; g[i - 1][0]) g[i][1] = max(g[i][1], a[i - 1]); &#125; int ans = 0; for (int i = n; i &gt; p; --i) &#123; if (a[i] &gt; a[i + 1]) f[i] = min(f[i], f[i + 1]); if (a[i] &gt; f[i + 1]) f[i] = min(f[i], a[i + 1]); if (g[i][1] &gt; f[i]) ++ans; &#125; return ans;&#125;int main() &#123; n = rd(); for (int i = 1; i &lt;= n; ++i) a[i] = rd(); int ans = calc(); reverse(a + 1, a + 1 + n); printf(&quot;%d\\n&quot;, ans + calc()); return 0;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://blog.gyx.me/categories/Codeforces/"},{"name":"Codeforces Round","slug":"Codeforces/Codeforces-Round","permalink":"http://blog.gyx.me/categories/Codeforces/Codeforces-Round/"}],"tags":[{"name":"Constructive Algorithm","slug":"Constructive-Algorithm","permalink":"http://blog.gyx.me/tags/Constructive-Algorithm/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"}]},{"title":"AtCoder Beginner Contest 237","slug":"atcoder/abc237","date":"2022-01-31T00:38:14.000Z","updated":"2023-03-20T16:28:06.899Z","comments":true,"path":"atcoder/abc237/","link":"","permalink":"http://blog.gyx.me/atcoder/abc237/","excerpt":"","text":"æ„Ÿè§‰è¿™åœºè´¨é‡è¿˜ä¸é”™ã€‚ C - kasaka ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸² \\(S\\) ï¼Œé—®æ˜¯å¦å¯ä»¥åœ¨å¼€å¤´æ·»åŠ è‹¥å¹²ä¸ª a ä½¿å¾—ä¸²å˜ä¸ºå›æ–‡ä¸²ã€‚ å¦‚æœå­—ç¬¦ä¸²å¼€å¤´ a çš„ä¸ªæ•°æ¯”æœ«å°¾ a çš„ä¸ªæ•°å¤šè‚¯å®šæ— è§£ã€‚ å¦åˆ™é—®é¢˜ç­‰ä»·äºå»æ‰å¼€å¤´å’Œç»“å°¾çš„æ‰€æœ‰çš„ a ï¼Œç„¶ååˆ¤æ–­æ˜¯å¦æ˜¯å›æ–‡ä¸²ã€‚ 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 1000007char s[N];int main() &#123; scanf(&quot;%s&quot;, s + 1); int n = strlen(s + 1); int x = 0, y = 0; for (int i = 1; i &lt;= n; ++i, ++x) if (s[i] != &#x27;a&#x27;) break; for (int i = n; i; --i, ++y) if (s[i] != &#x27;a&#x27;) break; if (x &gt; y) &#123;puts(&quot;No&quot;); return 0;&#125; int L = x + 1, R = n - y; for (int i = L; i &lt;= R; ++i) if (s[i] != s[R - (i - L)]) &#123;puts(&quot;No&quot;); return 0;&#125; puts(&quot;Yes&quot;); return 0;&#125; D - LR insertion ä¸€ä¸ªæ•°åˆ—ï¼Œå¼€å§‹åªæœ‰ \\(0\\) ï¼Œå¯¹ \\(i=1,2,\\cdots,n\\) ä¾æ¬¡æ‰§è¡Œï¼š è‹¥ op[i] = L ï¼Œå°† \\(i\\) æ’å…¥åˆ° \\(i-1\\) çš„å·¦ä¾§ã€‚ è‹¥ op[i] = R ï¼Œå°† \\(i\\) æ’å…¥åˆ° \\(i-1\\) çš„å³ä¾§ã€‚ æ±‚æœ€ç»ˆçš„æ•°åˆ—ã€‚ è€ƒè™‘æŒ‰ç…§ \\(i\\) ä»å¤§åˆ°å°æ‰§è¡Œï¼Œå®¹æ˜“å‘ç°æ“ä½œç­‰ä»·äºæ¯æ¬¡åœ¨å¼€å¤´æˆ–ç»“å°¾æ·»åŠ æ•°å­—ã€‚ 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 200007#define pb push_back#define pf push_frontstring s;deque&lt;int&gt; res;int main() &#123; cin.tie(nullptr) -&gt; sync_with_stdio(false); int n; cin &gt;&gt; n; res.pb(n); cin &gt;&gt; s; for (int i = n - 1; i &gt;= 0; --i) s[i] == &#x27;L&#x27; ? res.pb(i) : res.pf(i); for (auto x : res) printf(&quot;%d &quot;, x); return 0;&#125; E - Skiing \\(n\\) ä¸ªç‚¹æ¯ä¸ªç‚¹æœ‰ä¸€ä¸ªç‚¹æƒ \\(h_i\\) ï¼Œä»¥åŠ \\(M\\) æ¡æœ‰å‘è¾¹ \\((u,v)\\) : è‹¥ \\(h_u&gt;h_v\\) ï¼Œè¾¹æƒä¸º \\(-(h_u-h_v)\\) ï¼›å¦åˆ™ï¼Œè¾¹æƒä¸º \\(2(h_u-h_v)\\) ã€‚ æ±‚ \\(1\\) å·ç‚¹åˆ°æ‰€æœ‰ç‚¹çš„æœ€çŸ­è·¯ã€‚ è´Ÿæƒå›¾ä¸å¯ä»¥è·‘ Dijkstra ï¼›åˆå¾ˆå®¹æ˜“æ„é€ å‡ºç½‘æ ¼å›¾å¡æ‰ SPFA ã€‚ ä¸€ä¸ªæŠŠè´Ÿæƒå›¾å˜æˆæ­£æƒå›¾çš„æ–¹æ³•ï¼š ç»™æ¯ä¸ªç‚¹åˆ†é…ä¸€ä¸ªåŠ¿èƒ½ \\(d_i\\) ï¼Œå¯¹äºä¸€æ¡è¾¹ \\(u\\to v\\) ï¼Œè¾¹æƒå¢åŠ  \\(d_u-d_v\\) ï¼ŒæŠŠæ‰€æœ‰è¾¹éƒ½å˜æˆéè´Ÿæƒå€¼ã€‚ \\(s\\) åˆ° \\(x\\) çš„æœ€çŸ­è·¯å³ \\(dis_x+d_x-d_s\\) ã€‚ æœ¬é¢˜ä¸­ \\(h_i\\) æ°å¥½ç¬¦åˆåŠ¿èƒ½çš„è¦æ±‚ï¼Œå› æ­¤ä¿®æ”¹è¾¹æƒåè¿è¡Œ Dijkstra å³å¯ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 200007int n, m, tot, hd[N];struct edge &#123;int to, nxt, w;&#125; e[N &lt;&lt; 1];inline void add(int u, int v, int w) &#123; e[++tot].to = v; e[tot].w = w; e[tot].nxt = hd[u]; hd[u] = tot;&#125;ll dis[N], h[N];bool vis[N];priority_queue&lt;pair&lt;ll, int&gt; &gt; q;inline void dij(int u) &#123; memset(dis, 0x3f, sizeof(dis)); dis[u] = 0; q.push(make_pair(0, u)); while (!q.empty()) &#123; u = q.top().second; q.pop(); if (vis[u]) continue; vis[u] = 1; for (int i = hd[u], v; i; i = e[i].nxt) if (dis[v = e[i].to] &gt; dis[u] + e[i].w) &#123; dis[v] = dis[u] + e[i].w; q.push(make_pair(-dis[v], v)); &#125; &#125;&#125;int main() &#123; n = rd(); m = rd(); for (int i = 1; i &lt;= n; ++i) h[i] = rd(); for (int i = 1, u, v, w; i &lt;= m; ++i) &#123; u = rd(); v = rd(); if (h[u] &lt; h[v]) swap(u, v); add(u, v, 0); add(v, u, h[u] - h[v]); &#125; dij(1); ll ans = 0; for (int u = 1; u &lt;= n; ++u) ans = max(ans, -(dis[u] + h[u] - h[1])); printf(&quot;%lld\\n&quot;, ans); return 0;&#125; F - |LIS| = 3 è®¡æ•°é•¿åº¦ä¸º \\(n\\ (n\\le 1000)\\) ï¼Œæ¯ä¸ªä½ç½®æ˜¯ \\([1,m]\\ (m\\le 10)\\) ä¸­æ•´æ•°çš„æ•°åˆ—ä¸ªæ•°ï¼Œæ»¡è¶³ LIS é•¿åº¦ä¸è¶…è¿‡ \\(3\\) ã€‚ æ¯”è¾ƒç»å…¸çš„çŠ¶æ€æœº DP ï¼Œè®¾ \\(f[i][x][y][z]\\) è¡¨ç¤ºé•¿åº¦ä¸º \\(i\\) çš„æ•°åˆ—ï¼Œé•¿åº¦ä¸º \\(1\\) çš„ LIS ç»“å°¾æœ€å°æ˜¯ \\(x\\) ï¼Œé•¿åº¦ä¸º \\(2\\) çš„ LIS ç»“å°¾æœ€å°æ˜¯ \\(y\\) ï¼Œé•¿åº¦ä¸º \\(3\\) çš„ LIS ç»“å°¾æœ€å°æ˜¯ \\(z\\) æ—¶çš„æ•°åˆ—ä¸ªæ•°ã€‚ è½¬ç§»ç›´æ¥æšä¸¾ç¬¬ \\(i\\) ä¸ªä½ç½®çš„æ•°å­—å³å¯ï¼Œæ³¨æ„ä¸èƒ½è¶…è¿‡ \\(z\\) ã€‚å¤æ‚åº¦ \\(\\mathcal{O}(nm^4)\\) ã€‚ 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 1007#define mod 998244353int n, m, f[N][12][12][13];#define min(x, y) ((x) &gt; (y) ? (y) : (x))int main() &#123; cin.tie(nullptr) -&gt; sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; ++i) f[1][i][11][12] = 1; for (int i = 1; i &lt; n; ++i) for (int a = 1; a &lt;= m; ++a) for (int b = a + 1; b &lt;= 11; ++b) for (int c = b + 1; c &lt;= 12; ++c) for (int j = 1; j &lt;= min(c, m); ++j) &#123; int tara = min(a, j); int tarb = (j &gt; a ? min(b, j) : b); int tarc = (j &gt; b ? min(c, j) : c); f[i + 1][tara][tarb][tarc] = (f[i + 1][tara][tarb][tarc] + f[i][a][b][c]) % mod; &#125; int ans = 0; for (int i = 1; i &lt;= m; ++i) for (int j = i + 1; j &lt;= m; ++j) for (int k = j + 1; k &lt;= m; ++k) ans = (ans + f[n][i][j][k]) % mod; cout &lt;&lt; ans; return 0;&#125; G - Range Sort Query ä¸€ä¸ª \\(n\\) çš„æ’åˆ—ï¼Œ\\(q\\) æ¬¡æ“ä½œï¼Œæ¯æ¬¡å¯¹ä¸€ä¸ªåŒºé—´å‡åºæˆ–é™åºæ’åºã€‚é—® \\(x\\) æœ€ç»ˆçš„ä½ç½®ã€‚ å› ä¸ºåªå…³å¿ƒ \\(x\\) çš„ä½ç½®ï¼Œæ‰€ä»¥å°†å°äº \\(x\\) çš„è®¤ä¸ºæ˜¯ \\(0\\) ï¼Œå¤§äº \\(x\\) çš„è®¤ä¸ºæ˜¯ \\(2\\) ï¼Œå°† \\(x\\) æ”¹ä¸º \\(1\\) ã€‚ åŒºé—´æ’åºå°±å˜æˆç»Ÿè®¡åŒºé—´ \\(0,1,2\\) çš„ä¸ªæ•°ï¼Œç„¶åè¿›è¡Œè‡³å¤šä¸‰æ®µçš„åŒºé—´èµ‹å€¼ï¼Œçº¿æ®µæ ‘å³å¯ã€‚ å¦è§£ set ç»´æŠ¤åŒºé—´å¤æ‚åº¦æ­£ç¡®ï¼Œæ¯æ¬¡æ“ä½œæœ€å¤šå¸¦æ¥ \\(3\\) ä¸ªåŒºé—´ï¼Œæ¯ä¸ªåŒºé—´è¢«éå†åä¸€å®šä¼šåˆ é™¤ï¼ˆé™¤äº†ä¸¤ä¾§è‡³å¤šç•™ä¸‹ \\(2\\) ä¸ªï¼‰ã€‚ æ³¨æ„ç»´æŠ¤ set çš„æ—¶å€™ä¸èƒ½æŸ¥ \\(l_i\\ge L\\) çš„åŒºé—´ï¼ˆç¬¬ä¸€æ®µæœ‰å¯èƒ½æ‰¾ä¸åˆ°ï¼‰ï¼Œæ‰€ä»¥è¦æŒ‰ \\(r_i\\) ä¸ºç¬¬ä¸€å…³é”®å­—æ’åºã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;#define mt make_tuple#define lb lower_bound#define tri tuple&lt;int, int, int&gt;#define R get&lt;0&gt;#define L get&lt;1&gt;#define V get&lt;2&gt;set&lt;tri&gt; s;int main() &#123; cin.tie(nullptr) -&gt; sync_with_stdio(false); int n, q, k; cin &gt;&gt; n &gt;&gt; q &gt;&gt; k; for (int i = 1, x; i &lt;= n; ++i) &#123; cin &gt;&gt; x; s.insert(mt(i, i, (x == k) + (x &gt; k) * 2)); &#125; for (int i = 1, ty, l, r; i &lt;= q; ++i) &#123; cin &gt;&gt; ty &gt;&gt; l &gt;&gt; r; auto x = mt(l, 0, 0); int cnt[3] = &#123;0, 0, 0&#125;; for (auto nw = s.lb(x); nw != s.end(); nw = s.lb(x)) &#123; auto y = *nw; if (L(y) &gt; r) break; cnt[V(y)] += min(r, R(y)) - max(l, L(y)) + 1; if (L(y) &lt; l) s.insert(mt(l - 1, L(y), V(y))); if (R(y) &gt; r) s.insert(mt(R(y), r + 1, V(y))); s.erase(nw); &#125; if (ty == 1) &#123; for (int v = 0; v &lt;= 2; l += cnt[v], ++v) if (cnt[v]) s.insert(mt(l + cnt[v] - 1, l, v)); &#125; else &#123; for (int v = 2; v &gt;= 0; l += cnt[v], --v) if (cnt[v]) s.insert(mt(l + cnt[v] - 1, l, v)); &#125; &#125; for (auto x : s) if (V(x) == 1) &#123;printf(&quot;%d\\n&quot;, R(x)); break;&#125; return 0;&#125; Ex - Hakata ç»™ä¸€ä¸ªå­—ç¬¦ä¸² \\(S\\ (|S|\\le 200)\\)ï¼Œé—®æœ€å¤šèƒ½é€‰å‡ºå¤šå°‘ä¸ªå›æ–‡å­ä¸²ï¼Œä½¿å¾—ç›¸äº’ä¸åŒ…å«ã€‚ é¦–å…ˆæœ‰ä¸€ä¸ªç»“è®ºæ˜¯ï¼šé•¿åº¦ä¸º \\(n\\) çš„ä¸²æœ¬è´¨ä¸åŒçš„å›æ–‡å­ä¸²ä¸è¶…è¿‡ \\(n\\) ä¸ªã€‚ æ¥ä¸‹æ¥å›æ–‡å­ä¸²ä¹‹é—´çš„åŒ…å«å…³ç³»æ˜¯ä¸€ä¸ªååºï¼Œæ ¹æ® Dilworth å®šç†è§£æœ€å¤§åé“¾å³å¯ã€‚ å®šç†ç»†èŠ‚å’Œä½¿ç”¨æ–¹æ³•è¯¦è§ Dilworth's Theorem - Colin's Blog ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 207#define pb push_backstring str, a[N];set&lt;string&gt; s;inline bool substr(int u, int v) &#123; for (int i = 0; i + a[v].length() &lt;= a[u].length(); ++i) &#123; bool fl = true; for (int j = 0; j &lt; a[v].length(); ++j) if (a[u][i + j] != a[v][j]) &#123;fl = false; break;&#125; if (fl) return true; &#125; return false;&#125;vector&lt;int&gt; e[N];int match[N], vis[N];bool dfs(int u, int t) &#123; for (auto v : e[u]) if (vis[v] != t) &#123; vis[v] = t; if (!match[v] || dfs(match[v], t)) &#123;match[v] = u; return true;&#125; &#125; return false;&#125;int main() &#123; cin &gt;&gt; str; int n = str.length(); for (int l = 0; l &lt; n; ++l) for (int r = l; r &lt; n; ++r) &#123; bool fl = true; int len = r - l + 1; for (int i = 1; i &lt;= len; ++i) if (str[l + i - 1] != str[r - i + 1]) fl = false; if (fl) s.insert(str.substr(l, len)); &#125; int m = 0; for (auto x : s) a[++m] = x; for (int i = 1; i &lt;= m; ++i) for (int j = 1; j &lt;= m; ++j) if (i != j &amp;&amp; substr(j, i)) e[i].pb(j); int ans = m; for (int i = 1; i &lt;= m; ++i) ans -= dfs(i, i); printf(&quot;%d\\n&quot;, ans); return 0;&#125;","categories":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://blog.gyx.me/categories/AtCoder/"},{"name":"AtCoder Beginner Contest","slug":"AtCoder/AtCoder-Beginner-Contest","permalink":"http://blog.gyx.me/categories/AtCoder/AtCoder-Beginner-Contest/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"},{"name":"STL","slug":"STL","permalink":"http://blog.gyx.me/tags/STL/"},{"name":"Graphs","slug":"Graphs","permalink":"http://blog.gyx.me/tags/Graphs/"},{"name":"Shortest Path","slug":"Shortest-Path","permalink":"http://blog.gyx.me/tags/Shortest-Path/"}]},{"title":"2021-2022 ICPC Asia Shenyang Regional","slug":"official/icpc/21-shenyang","date":"2021-11-22T09:21:07.000Z","updated":"2023-03-20T16:36:09.976Z","comments":true,"path":"official/icpc/21-shenyang/","link":"","permalink":"http://blog.gyx.me/official/icpc/21-shenyang/","excerpt":"","text":"Summary æ¯”èµ›åœ°å€ ï¼šCodeforces Gym 103427 è¿˜æ²¡è¡¥å®Œï¼šACGKLM éš¾åº¦ï¼šBEFJ - HIL - DM - ACG - K çƒ­èº«èµ› D - Closest Pair of Segments åŸé¢˜æ˜¯ HDU 6697 ã€‚ äºŒåˆ†ç­”æ¡ˆä¹‹åè€ƒè™‘å°†çº¿æ®µæ‰©å¼ æˆ â€œé¦™è‚ â€ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰ä¸€å¯¹â€œé¦™è‚ â€ç›¸äº¤ã€‚ è€ƒè™‘å¯¹ \\(x\\) æ‰«æçº¿ï¼Œç”¨ set ç»´æŠ¤è¿™äº›é¦™è‚ å…³äº \\(y\\) çš„é¡ºåºï¼Œé‚£ä¹ˆæ€»æ˜¯åªéœ€è¦æ£€æŸ¥ç›¸é‚»çš„ä¸¤ä¸ªé¦™è‚ æ˜¯å¦ç›¸äº¤ã€‚äº¦å³ï¼Œå¯¹äºä¸€ä¸ªæ’å…¥äº‹ä»¶ï¼Œæ£€æŸ¥æ–°çš„é¦™è‚ æ˜¯å¦å’Œä¸Šä¸‹ç›¸é‚»çš„ä¸¤ä¸ªé¦™è‚ ç›¸äº¤ï¼Œå¯¹äºä¸€ä¸ªåˆ é™¤äº‹ä»¶ï¼Œåˆ é™¤é¦™è‚ ä¹‹åæ£€æŸ¥ä¸Šä¸‹ä¸¤ä¸ªç›¸é‚»çš„é¦™è‚ æ˜¯å¦ç›¸äº¤ã€‚å¦‚æœåˆ¤å®šåˆ°ç›¸äº¤è¯´æ˜ç­”æ¡ˆåå¤§ï¼Œå¦åˆ™ç­”æ¡ˆåå°ã€‚ ç”±äºåœ¨åˆ¤å®šåˆ°ç›¸äº¤ä¹‹å‰çš„æ‰«æè¿‡ç¨‹ä¸­ï¼Œé¦™è‚ éƒ½æ˜¯äº’ä¸ç›¸äº¤çš„å‡¸å›¾å½¢ï¼Œå¯ä»¥ç®€å•åœ°ç”¨ä¸€æ¡è¿æ¥é¦™è‚ æœ€å·¦ç‚¹å’Œæœ€å³ç‚¹çš„çº¿æ®µæ¥æè¿°é¦™è‚ åœ¨æ‰«æçº¿ä¸Šçš„ç›¸å¯¹é¡ºåºï¼Œåˆ¤å®šé¦™è‚ ç›¸äº¤ç›´æ¥è®¡ç®—æ‰©å¼ å‰çš„ä¸¤ä¸ªçº¿æ®µçš„è·ç¦»å³å¯ã€‚ å¤æ‚åº¦æ˜¯ \\(O(n\\log n\\log (1/\\epsilon))\\) ã€‚ B - Bitwise Exclusive-OR Sequence æ„é€  \\(n\\) ä¸ªæ•° \\(a_1,\\dots,a_n\\)ï¼Œæ»¡è¶³ \\(m\\) ä¸ªçº¦æŸæ¡ä»¶ï¼Œå½¢å¦‚ \\(a_{p_i}\\oplus a_{q_i} = w_i\\) ï¼Œä¸” \\(\\sum a_i\\) æœ€å°ã€‚ æŒ‰ä½è€ƒè™‘ï¼Œé‚£ä¹ˆæŒ‰ç…§æ¯ä¸€ä½éƒ½å¯ä»¥å»ºå‡ºæ¥ä¸€å¼ å›¾ï¼Œè¾¹æƒä¸º \\(0/1\\) è¡¨ç¤ºä¸¤ä¸ªæ•°åœ¨è¿™ä¸€ä½ç›¸åŒ/ä¸åŒ ã€‚ å›¾å­˜åœ¨çŸ›ç›¾çš„è¾¹åˆ™æ— è§£ï¼Œæœ‰è§£æ—¶å¯ä»¥å°†æ¯ä¸€ä¸ªè¿é€šåˆ†å›¾çš„ç‚¹åˆ’åˆ†ä¸ºä¸¤ç»„ï¼Œè®©ä¸ªæ•°å°‘çš„é‚£ä¸€ç»„è¿™ä¸€ä½å– \\(1\\) å³å¯æœ€å°åŒ–ã€‚ å¤æ‚åº¦ \\(O(n\\log \\max a_i)\\) ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;#define N 200007using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;int n, m;struct node &#123;int a, b, w;&#125; c[N];ll ans = 0;int tot, cnt[2], hd[N], col[N];struct edge &#123;int to, nxt, w;&#125;e[N &lt;&lt; 1];inline void add(int u, int v, int w) &#123; e[++tot].to = u; e[tot].w = w; e[tot].nxt = hd[v]; hd[v] = tot; e[++tot].to = v; e[tot].w = w; e[tot].nxt = hd[u]; hd[u] = tot;&#125;bool fl = 0;void dfs(int u) &#123; ++cnt[col[u]]; for (int i = hd[u], v; i; i = e[i].nxt) &#123; v = e[i].to; if (col[v] != -1) &#123; if (col[v] != (col[u] ^ e[i].w)) &#123;fl = 1; return;&#125; continue; &#125; col[v] = (col[u] ^ e[i].w); dfs(v); if(fl) return; &#125;&#125; inline bool work(int p) &#123; tot = 0; for (int i = 1; i &lt;= n; ++i) hd[i] = 0, col[i] = -1; for (int i = 1; i &lt;= m; ++i) add(c[i].a, c[i].b, ((c[i].w &amp; (1 &lt;&lt; p)) &gt; 0)); for (int i = 1; i &lt;= n; ++i) if (col[i] == -1) &#123; cnt[0] = 0; cnt[1] = 0; col[i] = 0; dfs(i); if (fl) return 1; ans += 1ll * (1 &lt;&lt; p) * min(cnt[0], cnt[1]); &#125; return 0;&#125;int main() &#123; n = rd(); m = rd(); for (int i = 1; i &lt;= m; ++i) &#123; c[i].a = rd(); c[i].b = rd(); c[i].w = rd(); &#125; for (int i = 30; i &gt;= 0; --i) if (work(i)) &#123;puts(&quot;-1&quot;); return 0;&#125; printf(&quot;%lld\\n&quot;, ans); return 0;&#125; D - Cross the Maze E - Edward Gaming, the Champion ç»™å®šä¸€ä¸ªä¸²ï¼Œæ•°ä¸²é‡Œæœ‰å¤šå°‘ä¸ª edgnb 1234567891011121314#include&lt;bits/stdc++.h&gt;#define N 200007using namespace std;int ans;char s[N];int main()&#123; scanf(&quot;%s&quot;, s); for (int i = 0; s[i]; ++i) if (!strncmp(s + i, &quot;edgnb&quot;, 5)) ++ans; printf(&quot;%d\\n&quot;, ans); return 0;&#125; F - Encoded Strings I è®¾ä»åå¾€å‰çœ‹ï¼Œå­—ç¬¦ \\(c\\) ç¬¬ä¸€æ¬¡å‡ºç°ä¹‹å‰å‡ºç°è¿‡ \\(k\\) ä¸ªä¸åŒçš„å­—æ¯ï¼Œåˆ™æ˜ å°„ f(c)='a'+k å®šä¹‰ä¸€ä¸ªä¸² \\(s\\) çš„ Encoded String \\(s&#39;\\) ï¼šå¯¹ \\(\\forall i\\le |s|, s&#39;[i] = f(s[i])\\) æ±‚ç»™å®šä¸²æ‰€æœ‰å‰ç¼€å¯¹åº”çš„ Encoded String ä¸­ï¼Œå­—å…¸åºæœ€å¤§çš„é‚£ä¸ªã€‚ æš´åŠ›æ±‚ï¼Œç„¶åæŒ‰å­—å…¸åºæ’åºã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;#define N 1007using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;char S[N];map&lt;char, int&gt; f;struct node &#123; int len; char a[N];&#125;s[N];inline bool cmp(node a, node b) &#123; int tot = min(a.len, b.len); for (int i = 1; i &lt;= tot; ++i) if (a.a[i] != b.a[i]) return a.a[i] &lt; b.a[i]; return a.len &lt; b.len;&#125;inline void work(int p) &#123; int cnt = 0; f.clear(); s[p].len = p; for (int i = p; i; --i) &#123; if (!f[S[i]]) f[S[i]] = ++cnt; s[p].a[i] =&#x27;a&#x27; - 1 + f[S[i]]; &#125;&#125;int main() &#123; int n = rd(); scanf(&quot;%s&quot;, S + 1); for (int i = 1; i &lt;= n; ++i) work(i); sort(s + 1, s + 1 + n, cmp); for (int i = 1; i &lt;= s[n].len; ++i) putchar(s[n].a[i]); puts(&quot;&quot;); return 0;&#125; H - Line Graph Matching ç»™å®šä¸€ä¸ªå¸¦æƒå›¾ï¼Œæ±‚å¯¹åº”çº¿å›¾çš„æœ€å¤§æƒåŒ¹é…ã€‚ æŒ‰ç…§çº¿å›¾çš„æœ€å¤§åŒ¹é…ç®—æ³•ï¼Œæ¯ä¸ªè¿é€šå—ä¸­ï¼Œå¦‚æœè¾¹æ•°æ˜¯å¶æ•°å°±å¯ä»¥å®Œç¾åŒ¹é…ï¼Œå¦åˆ™åªéœ€è¦æ‰”æ‰ä¸€æ¡è¾¹ã€‚ å¯ä»¥æ‰”æ‰çš„æ¡ä»¶æ˜¯åˆ é™¤åå½¢æˆçš„æ–°è¿é€šå—è¾¹æ•°éƒ½æ˜¯å¶æ•°ï¼Œå³åˆ æ‰éå‰²è¾¹æˆ–ä¸¤ä¾§è¾¹æ•°éƒ½æ˜¯å¶æ•°çš„å‰²è¾¹ã€‚å¤æ‚åº¦ \\(O(n)\\) ã€‚ I - Linear Fractional Transformation å®šä¹‰å¤æ•°å‡½æ•° \\(f(z)=\\frac{az+b}{cz+d}\\ (a,b,c,d\\in \\mathbb{C},ad-bc\\not=0)\\)ï¼Œç»™å®š \\(f(z_1)=w_1,f(z_2)=w_2,f(z_3)=w_3\\) ï¼Œæ±‚ \\(f(z_0)\\) ã€‚ æ•°æ®ä¿è¯ \\(z_1,z_2,z_3,w_1,w_2,w_3\\) ä¸¤ä¸¤ä¸åŒã€‚ è‹¥ \\(c=0\\) ï¼Œåˆ™ \\(f(z)=kz+b\\) ï¼Œç›´æ¥ç”¨ä¸¤ä¸ªæ–¹ç¨‹æŠŠ \\(k,b\\) æ±‚å‡ºåï¼Œåˆ¤æ–­ç¬¬ä¸‰ä¸ªæ–¹ç¨‹æ˜¯å¦æ­£ç¡®ï¼Œç„¶åä»£å…¥å³å¯ã€‚ è‹¥ \\(c\\not = 0\\) ï¼Œåˆ™ \\(zf(z)+k_3f(z)=k_1z+k_2\\) ï¼Œæ‰‹åŠ¨æ¶ˆå…ƒä¸€ä¸‹å¾—ï¼š \\[ k_3=\\displaystyle\\frac{(w_2z_2 - w_1z_1) - \\displaystyle\\frac{z_2-z_1}{z_3-z_1} * (w_3z_3 - w_1z_1)}{\\displaystyle\\frac{z_2-z_1}{z_3-z_1} * (w_3 - w_1) - (w_2 - w_1)} \\] æ¯”èµ›çš„æ—¶å€™æœ¬æ¥æƒ³ç”¨è‡ªå¸¦çš„ complex&lt;double&gt; ç±»ï¼Œä½†æ˜¯å‘ç° real å’Œ imag ä¸èƒ½ç›´æ¥èµ‹å€¼ï¼Œå°±ä¸ä¼šç”¨äº†é‚æ‰‹å†™... 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;#define N 200007using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;inline double sqr(double x) &#123; return x * x;&#125;struct cp &#123; double a, b; inline cp operator + (const cp &amp;obj) const&#123; return (cp)&#123;a + obj.a, b + obj.b&#125;; &#125; inline cp operator - (const cp &amp;obj) const&#123; return (cp)&#123;a - obj.a, b - obj.b&#125;; &#125; inline cp operator * (const cp &amp;obj) const&#123; return (cp)&#123;a * obj.a - b * obj.b, a * obj.b + b * obj.a&#125;; &#125; inline cp operator / (const double x) const &#123; return (cp)&#123;a / x, b / x&#125;; &#125; inline cp operator / (const cp &amp;obj) const&#123; return (cp)&#123;a * obj.a + b * obj.b, b * obj.a - a * obj.b&#125; / (sqr(obj.a) + sqr(obj.b)); &#125; inline bool operator == (const cp &amp;obj) const&#123; return (fabs(a - obj.a) &lt;= 1e-6 &amp;&amp; fabs(b - obj.b) &lt;= 1e-6); &#125;&#125;;inline void work() &#123; cp z0, z1, z2, z3, w1, w2, w3; z1.a = rd(); z1.b = rd(); w1.a = rd(); w1.b = rd(); z2.a = rd(); z2.b = rd(); w2.a = rd(); w2.b = rd(); z3.a = rd(); z3.b = rd(); w3.a = rd(); w3.b = rd(); z0.a = rd(); z0.b = rd(); cp k = (w2 - w1) / (z2 - z1); cp b = w1 - k * z1; if (w3 == k * z3 + b) &#123; cp res = k * z0 + b; printf(&quot;%.10lf %.10lf\\n&quot;, res.a, res.b); return; &#125; cp g1, g2, g3; g1 = z1 * w1; g2 = z2 * w2; g3 = z3 * w3; cp kk = (z2 - z1) / (z3 - z1); cp k3 = ((g2 - g1) - kk * (g3 - g1)) / (kk * (w3 - w1) - (w2 - w1)); cp k1 = ((g2 - g1) + k3 * (w2 - w1)) / (z2 - z1); cp k2 = z1 * w1 + k3 * w1 - k1 * z1; cp res = (k1 * z0 + k2) / (z0 + k3); printf(&quot;%.10lf %.10lf\\n&quot;, res.a, res.b);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; é¢˜è§£æä¾›çš„åšæ³•æ¯”è¾ƒç¥ä»™ï¼Œåˆ†å¼çº¿æ€§å˜æ¢ä¿äº¤æ¢æ¯”ï¼Œæœ‰ï¼š \\[ \\frac{w_0-w_1}{w_0-w_2}\\bigg/\\frac{w_3-w_1}{w_3-w_2}=\\frac{z_0-z_1}{z_0-z_2}\\bigg/\\frac{z_3-z_1}{z_3-z_2} \\] 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;typedef complex&lt;double&gt; C;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;inline C rdc() &#123; int x = rd(), y = rd(); return C(x, y);&#125;inline void work() &#123; C z1 = rdc(), w1 = rdc(), z2 = rdc(), w2 = rdc(), z3 = rdc(), w3 = rdc(), z0 = rdc(); C res = ((z0 - z1) / (z0 - z2)) / ((z3 - z1) / (z3 - z2)) * ((w3 - w1) / (w3 - w2)); res = w2 + (w2 - w1) / (res - C(1, 0)); printf(&quot;%.12lf %.12lf\\n&quot;, res.real(), res.imag());&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; J - Luggage Lock ä¸€ä¸ªå››ä½é”ï¼Œæ¯æ¬¡å¯ä»¥æŠŠä¸€ä¸ªåŒºé—´å¾€ä¸Šæˆ–å¾€ä¸‹æ‹¨åŠ¨ \\(1\\) ï¼Œå¤šæ¬¡è¯¢é—®ï¼š ä» \\(a_1a_2a_3a_4\\) çŠ¶æ€æ‹¨åˆ° \\(b_1b_2b_3b_4\\) çŠ¶æ€æœ€å°‘éœ€è¦æ‹¨åŠ¨çš„æ¬¡æ•°ã€‚ å®¹æ˜“å‘ç°ç­”æ¡ˆåªå’Œå¯¹åº”ä½çš„å·®æœ‰å…³ï¼Œé—®é¢˜å˜ä¸º \\(0000\\) æ‹¨åˆ° \\(x_1x_2x_3x_4\\) æ‰€éœ€çš„æœ€å°‘æ¬¡æ•°ï¼Œbfs æ±‚æœ€çŸ­è·¯ã€‚è®¡ç®—é‡ \\(10^4\\times 10\\times 4\\) ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;inline bool getmin(int &amp;a, int b) &#123;return (a &gt; b ? (a = b, true) : false);&#125;inline bool getmax(int &amp;a, int b) &#123;return (a &lt; b ? (a = b, true) : false);&#125;#define N 10000queue&lt;int&gt; q;int dis[N];int main() &#123; memset(dis, 0x3f, sizeof(dis)); q.push(0); dis[0] = 0; while(!q.empty()) &#123; int u = q.front(); q.pop(); int a[4] = &#123;u / 1000, u % 1000 / 100, u % 100 / 10, u % 10&#125;; for (int x = 1; x &lt;= 4; ++x) &#123; for (int l = 0; l &lt;= 4 - x; ++l) &#123; // up int v = 0; for (int i = 0; i &lt; 4; ++i) if (i &gt;= l &amp;&amp; i &lt; l + x) v = v * 10 + (a[i] + 1) % 10; else v = v * 10 + a[i]; if (dis[v] &gt; dis[u] + 1) &#123;dis[v] = dis[u] + 1; q.push(v);&#125; v = 0; for (int i = 0; i &lt; 4; ++i) if (i &gt;= l &amp;&amp; i &lt; l + x) v = v * 10 + (a[i] + 9) % 10; else v = v * 10 + a[i]; if (dis[v] &gt; dis[u] + 1) &#123;dis[v] = dis[u] + 1; q.push(v);&#125; &#125; &#125; &#125; for (int t = rd(); t; --t) &#123; int u = rd(), v = rd(); int a[4] = &#123;u / 1000, u % 1000 / 100, u % 100 / 10, u % 10&#125;; int b[4] = &#123;v / 1000, v % 1000 / 100, v % 100 / 10, v % 10&#125;; int dlt = 0; for (int i = 0; i &lt; 4; ++i) dlt = dlt * 10 + (b[i] - a[i] + 10) % 10; printf(&quot;%d\\n&quot;, dis[dlt]); &#125; return 0;&#125;","categories":[{"name":"Official Contests","slug":"Official-Contests","permalink":"http://blog.gyx.me/categories/Official-Contests/"}],"tags":[{"name":"Graphs","slug":"Graphs","permalink":"http://blog.gyx.me/tags/Graphs/"},{"name":"Connectivity","slug":"Connectivity","permalink":"http://blog.gyx.me/tags/Connectivity/"}]},{"title":"Programming Ability Test Autumn 2021","slug":"misc/pat2021","date":"2021-09-11T09:43:27.000Z","updated":"2021-10-11T09:43:27.000Z","comments":true,"path":"misc/pat2021/","link":"","permalink":"http://blog.gyx.me/misc/pat2021/","excerpt":"","text":"Background æŸå¤©å¿ƒè¡€æ¥æ½®æ‹‰ä¸Š Eva åŒå­¦ä¸€èµ·æŠ¥åäº† PAT ï½ å¼€å­¦å‰åœ¨ å®˜æ–¹é¢˜åº“ é‡Œåˆ·äº†ä¸¤é“é¢˜çƒ­èº«ï¼å…¶å®æ˜¯æƒ³åˆ·å®Œä½†æ˜¯å¤ªé¸½äº† ç„¶åå°±åˆ°è€ƒè¯•æ—¶é—´å•¦ï¼å€Ÿç€è€ƒè¯•ç¿˜æ‰äº†åŠå¤©çš„å†›è®­ï¼å¥½è€¶ï¼ Solution ( Top Level ) ä»£ç å†™çš„èµ¶æ—¶é—´ï¼Œæ¯”è¾ƒä¸‘ã€‚ A. Sorted Cartesian tree ç»™å®š \\(n\\) ä¸ªpair&lt;priority, key&gt; ï¼Œæ„å»ºä¸€æ£µ \\(n\\) ä¸ªèŠ‚ç‚¹çš„äºŒå‰æ ‘ï¼Œæ»¡è¶³ï¼šèŠ‚ç‚¹ priority å…³é”®å­—æ»¡è¶³å †çš„æ€§è´¨ï¼Œå³priority çˆ¶èŠ‚ç‚¹å°äºå­èŠ‚ç‚¹èŠ‚ç‚¹ key å…³é”®å­—æ»¡è¶³äºŒå‰æœç´¢æ ‘çš„æ€§è´¨ï¼Œå³ä¸­åºéå†key å•è°ƒä¸é™æŠŠæ ‘å»ºå‡ºæ¥ï¼Œè¾“å‡º priority å’Œ key çš„Level-order traversal åºåˆ— æ¨¡æ‹Ÿé¢˜æ„ dfs å»ºæ ‘ï¼Œä¼ ä¸€ä¸ª set&lt;node&gt; å³å¯ã€‚ æ±‚å±‚åºéå†ä¸€ä¸ª bfs å°±å¤Ÿäº† è€ƒåœºä¸Šå†™äº†ä¸ªdfn+depåŒå…³é”®å­—æ’åº 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;#define N 37using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125; struct node &#123;int k, p, id;&#125; c[N];inline bool operator &lt; (const node &amp;a, const node &amp;b) &#123; if (a.p != b.p) return a.p &lt; b.p; if (a.k != b.k) return a.k &lt; b.k; return a.id &lt; b.id;&#125;int ls[N], rs[N], k[N], p[N];set&lt;node&gt; S;int dfs(set&lt;node&gt; s) &#123; if (s.empty()) return 0; node nw = *s.begin(); s.erase(nw); set&lt;node&gt; l, r; for (auto t : s) &#123; if (t.k &lt;= nw.k) l.insert(t); else r.insert(t); &#125; ls[nw.id] = dfs(l); rs[nw.id] = dfs(r); return nw.id;&#125;queue&lt;int&gt; q;int main() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123; c[i].id = i; c[i].k = rd(); c[i].p = rd(); S.insert(c[i]); &#125; int ptr = 0, rt = dfs(S); q.push(rt); while (!q.empty()) &#123; int u = q.front(); q.pop(); if (ls[u]) q.push(ls[u]); if (rs[u]) q.push(rs[u]); k[++ptr] = c[u].k; p[ptr] = c[u].p; &#125; for (int i = 1; i &lt; n; ++i) printf(&quot;%d &quot;, k[i]); printf(&quot;%d\\n&quot;, k[n]); for (int i = 1; i &lt; n; ++i) printf(&quot;%d &quot;, p[i]); printf(&quot;%d&quot;, p[n]); return 0;&#125; B. Unity is Strength ç»™ä¸€å¼ æœ‰æƒæ— å‘å›¾ï¼Œä»¥åŠè‹¥å¹²æ¡å¯ä»¥èŠ± \\(w_i\\) è¿æ¥ \\(u_i,v_i\\) çš„æ— å‘è¾¹ã€‚å…ˆè¾“å‡ºæ¯ä¸ªè”é€šå—çš„ \"å—å†…æœ€å°ç¼–å· - å—å†…æœ€å°è¾¹æƒ\"ï¼ŒæŒ‰ç…§å—å¤§å°-æœ€å°è¾¹æƒ-æœ€å°ç‚¹ç¼–å·çš„é¡ºåºæ’åºç„¶åè®¡ç®—æŠŠæ•´ä¸ªå›¾è”é€šçš„æœ€å°ä»£ä»·ï¼Œé™¤ç»™å®šè¾¹å¤–ï¼Œä»»æ„ä¸¤ç‚¹ä¹‹é—´éƒ½å¯ä»¥èŠ±\\(10^4\\) çš„ä»£ä»·è¿æ¥ä¸€æ¡è¾¹ã€‚ å¹¶æŸ¥é›†æ¨¡æ‹Ÿé¢˜æ„å³å¯ï¼Œç¬¬ä¸€æ­¥æ±‚å‡ºæ¥æ¯ä¸ªé›†åˆçš„è‹¥å¹²ä¿¡æ¯ï¼Œç„¶åæ’åºä¸€ä¸‹ã€‚ ä¹‹åå°±æ˜¯æœ€å°ç”Ÿæˆæ ‘ï¼Œè€ƒè™‘ç»™å®šè¾¹ä¸ä¸€å®šèƒ½è®©æ•´ä¸ªå›¾è”é€šï¼Œæœ€åç­”æ¡ˆåŠ ä¸Šï¼ˆè”é€šå—æ•° \\(-1\\) ï¼‰\\(\\times 10^4\\) å³å¯ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;#define N 100007#define inf 1e9using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125; int f[N], mn[N], mnid[N], sz[N], totr, totc;struct road &#123; int u, v, w;&#125;r[N]; inline bool cmp2(road a, road b) &#123; return a.w &lt; b.w;&#125; inline int find(int x) &#123; return x == f[x] ? x : f[x] = find(f[x]);&#125;inline void merge(int a, int b, int w) &#123; a = find(a); b = find(b); if (a == b) &#123; mn[a] = min(mn[a], w); return; &#125; f[a] = b; sz[b] += sz[a]; mnid[b] = min(mnid[b], mnid[a]); mn[b] = min(mn[b], min(mn[a], w));&#125;struct node &#123; int mnid, sz, str;&#125;c[N]; inline bool cmp1(node a, node b) &#123; if (a.str != b.str) return a.str &gt; b.str; if (a.sz != b.sz) return a.sz &gt; b.sz; return a.mnid &lt; b.mnid;&#125;int main() &#123; int n = rd(); int m = rd(); for (int i = 1; i &lt;= n; ++i) &#123; f[i] = i; mn[i] = inf; mnid[i] = i; sz[i] = 1; &#125; for (int i = 1, u, v, w; i &lt;= m; ++i) &#123; u = rd(); v = rd(); w = rd(); if (w &gt; 0) merge(u, v, w); else r[++totr] = (road)&#123;u, v, -w&#125;; &#125; for (int i = 1; i &lt;= n; ++i) if (f[i] == i) c[++totc] = (node)&#123;mnid[i], sz[i], (mn[i] == inf ? 0 : mn[i])&#125;; sort(c + 1, c + 1 + totc, cmp1); for (int i = 1; i &lt; totc; ++i) printf(&quot;%d-%d &quot;, c[i].mnid, c[i].str); printf(&quot;%d-%d\\n&quot;, c[totc].mnid, c[totc].str); int ans = 0; sort(r + 1, r + 1 + totr, cmp2); for (int i = 1; i &lt;= totr; ++i) &#123; int u = find(r[i].u); int v = find(r[i].v); if (u != v) &#123;merge(u, v, r[i].w); ans += r[i].w;&#125; &#125; int cnt = 0; for (int i = 1; i &lt;= n; ++i) cnt += (f[i] == i); ans += (cnt - 1) * 10000; printf(&quot;%d&quot;, ans); return 0;&#125; C. Manhattan ç»™å®šä¸€ä¸ªåºåˆ— \\(\\{ a_i \\}\\ (1\\le a_i\\le3)\\)ï¼Œä¸¤ä¸ªäººç©ï¼ˆå¼€å§‹åŒæ–¹å‡ä¸º \\(0\\) åˆ†ï¼‰ï¼Œæ¯æ¬¡æŸä¸ªäººå–èµ°æœ€é å‰çš„ \\(a_i\\) åŠ åˆ°å½“å‰çš„å¾—åˆ†é‡Œã€‚è¦æ±‚æ¯ä¸ªäººæ‹¿å®Œä¹‹åï¼Œå½“å‰çš„å¾—åˆ†ä¸å¾—å°‘äºå¯¹æ–¹ï¼Œé—®æœ‰å¤šå°‘ç§åˆ’åˆ†æ–¹æ¡ˆï¼Œç­”æ¡ˆ\\(\\mod 10^ 9 + 7\\) è£¸çš„ DP å°±æ˜¯ f[i][j] è¡¨ç¤ºå½“å‰è€ƒè™‘å‰ \\(i\\) ä¸ªæ•°ï¼Œç¬¬ä¸€ä¸ªäººæ¯”ç¬¬äºŒä¸ªäººå¤š \\(j\\) çš„æ–¹æ¡ˆæ•°ã€‚ å› ä¸º \\(a_i\\le 3\\) ï¼Œæ‰€ä»¥å¦‚æœæŸä¸ªäººæ¯”å¦ä¸€ä¸ªäººå¤šäº†è¶…è¿‡ \\(3\\) åˆ†ï¼Œå¯¹æ‰‹å°±æ— æ³•æ»¡è¶³è¦æ±‚ï¼Œä¹‹åå°±åªèƒ½æ˜¯è¿™ä¸ªäººæ‹¿äº†ã€‚ æ‰€ä»¥ j å¯ä»¥æŠŠç‰¹æ®Šçš„çŠ¶æ€æ”¾åˆ°ä¸€èµ·ï¼ŒèŒƒå›´å°±åªæœ‰ \\(9\\) äº†ï¼Œå¤æ‚åº¦ \\(O (9n)\\) ï¼Œè½¬ç§»è¦æ³¨æ„æ¡ä»¶ã€‚ å®ç°çš„æ—¶å€™æ•´ä½“åç§»äº† \\(5\\) ï¼Œä¹Ÿå°±æ˜¯ \\(j=5\\) æ—¶ä¸¤ä¸ªäººå¾—åˆ†ä¸€æ ·ã€‚ 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;#define N 100007#define mod 1000000007using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125; int f[N][10];#define add(a,b) a = (a + b) % modint main() &#123; f[0][5] = 1; int n = rd(); for (int i = 1, x; i &lt;= n; ++i) &#123; x = rd(); for (int j = 1; j &lt;= 9; ++j) &#123; if (j - x &lt;= 1) add(f[i][1], f[i - 1][j]); if (j + x &gt;= 9) add(f[i][9], f[i - 1][j]); &#125; for (int j = 2; j &lt;= 8; ++j) &#123; if (j - x &gt; 1 &amp;&amp; j - x &lt;= 5) add(f[i][j - x], f[i - 1][j]); if (j + x &lt; 9 &amp;&amp; j + x &gt;= 5) add(f[i][j + x], f[i - 1][j]); &#125; &#125; int ans = 0; for (int i = 1; i &lt;= 9; ++i) add(ans, f[n][i]); printf(&quot;%d&quot;, ans); return 0;&#125; Summary æ¯”èµ›ä¹‹å‰æ¯”è¾ƒç„¦è™‘ï¼ˆæ¯•ç«Ÿå†›è®­ä¸€å‘¨éƒ½æ²¡ç¢°é”®ç›˜ï¼‰ï¼Œåˆ°è€ƒåœºå‘ç°å·¦è¾¹åçš„æ˜¯å­¦é•¿ã€‚ å¼€åœºæŠŠä¸‰ä¸ªé¢˜éƒ½å¼€äº†ï¼Œ é¢˜ç›®æè¿°éƒ½ååˆ†è¿·æƒ‘ï¼ˆè‹±è¯­å¤ªå·®ï¼‰ï¼Œç»“åˆæ ·ä¾‹æšä¸¾é¢˜æ„è¯»é¢˜ã€‚ åˆ†ä¸æ¸…ï¼šPreorder å…ˆåºï¼›Inorder ä¸­åºï¼›Postorder ååºï¼›Level-order traversal å±‚åºéå† è¿‡é¢˜é¡ºåº T2 - T1 - T3 ï¼Œçœ‹æ¦œåº”è¯¥æ˜¯ Rank 2ï¼Œæ‰€æœ‰é¢˜éƒ½æ˜¯ä¸€æ¬¡è¿‡éå¸¸èˆ’é€‚ã€‚ ç„¶åå°±æå‰è·‘è·¯äº†ï¼å› ä¸º Eva åŒå­¦è¿˜åœ¨å¥‹æˆ˜ï¼Œæˆ‘å°±å¼€å§‹å¿«ä¹çš„æµ™ä¼ åŠæ—¥æ¸¸ï½ æµ™ä¼ çš„æ ¡å›­å°±æ¯”è¾ƒæœ‰æ„Ÿè§‰ï¼Œæ€»è§‰å¾—æ­ç”µçš„æ¥¼éƒ½æ˜¯ä¸€ä¸ªæ ·å­çš„ï¼Œç¼ºç‚¹å¤§å­¦çš„æ°”æ¯... äº•ç›–ä¸Šè¶…çº§å¯çˆ±çš„å°ç‹å­å’Œç‹ç‹¸ï½","categories":[{"name":"Misc Solutions","slug":"Misc-Solutions","permalink":"http://blog.gyx.me/categories/Misc-Solutions/"}],"tags":[{"name":"Union-Find Set","slug":"Union-Find-Set","permalink":"http://blog.gyx.me/tags/Union-Find-Set/"},{"name":"Counting","slug":"Counting","permalink":"http://blog.gyx.me/tags/Counting/"},{"name":"DFS and Similar","slug":"DFS-and-Similar","permalink":"http://blog.gyx.me/tags/DFS-and-Similar/"}]},{"title":"AtCoder Beginner Contest 216","slug":"atcoder/abc216","date":"2021-08-29T13:37:14.000Z","updated":"2023-03-20T16:27:55.948Z","comments":true,"path":"atcoder/abc216/","link":"","permalink":"http://blog.gyx.me/atcoder/abc216/","excerpt":"","text":"E. Amusement Park ç»™å®š \\(n\\) ä¸ªæ•°ï¼Œæœ€å¤š \\(k\\) æ¬¡æ“ä½œï¼Œæ¯æ¬¡å¯ä»¥æ‹¿èµ°æŸä¸ªæ•° \\(a_i\\) åŠ å…¥å¾—åˆ†ï¼Œç„¶åæŠŠ \\(a_i-1\\) æ”¾å›ï¼Œé—®å¾—åˆ†æœ€å¤§å€¼ï¼Œ\\(k,a_i\\le 2\\times 10^9\\) äºŒåˆ†æœ€åå‰©ä¸‹çš„æ‰€æœ‰æ•°é‡Œçš„æœ€å¤§å€¼ä¸º \\(x\\) ï¼Œç­”æ¡ˆæ˜¯æŠŠæ‰€æœ‰æ•°éƒ½æ‹¿åˆ° \\(x\\) çš„å¾—åˆ†ï¼Œç„¶ååŠ ä¸Šå‰©ä¸‹æ¬¡æ•°ä¸ª \\(x\\) çš„å¾—åˆ†ã€‚ éœ€è¦æ³¨æ„äºŒåˆ†ä¸Šç•Œ \\(r = 2\\times 10^9\\) ï¼Œæ‰€ä»¥äºŒåˆ† mid = (l + r) / 2 çš„æ—¶å€™å¯èƒ½ä¼šçˆ† int ã€‚å‘æ­»æˆ‘äº† 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;#define N 200007using namespace std;typedef long long ll;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for(; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for(; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;ll n, k, a[N];inline bool valid(ll x) &#123; ll cnt = 0; for (int i = 1; i &lt;= n; ++i) if (a[i] &gt; x) cnt += a[i] - x; return cnt &lt;= k;&#125;inline ll sum(ll l, ll r) &#123; return (l + r) * (r - l + 1) / 2;&#125;int main() &#123; n = rd(); k = rd(); for (int i = 1; i &lt;= n; ++i) a[i] = rd(); ll l = 0, r = 2e9; while (l &lt; r) &#123; ll mid = (l + r) / 2; valid(mid) ? r = mid : l = mid + 1; &#125; ll ans = 0; for (int i = 1; i &lt;= n; ++i) if (a[i] &gt; l) &#123; ans += sum(l + 1, a[i]); k -= a[i] - l; &#125; ans += k * l; printf(&quot;%lld\\n&quot;, ans); return 0;&#125; F. Max Sum Counting æœ‰ \\(n\\) ä¸ªæ•°å¯¹ \\((A_i, B_i)\\)æ„æˆä¸€ä¸ªé›†åˆï¼Œé—®æœ‰å¤šå°‘ä¸ªå­é›†ï¼Œæ»¡è¶³å­é›†å†… \\(A\\) çš„æœ€å¤§å€¼å¤§äº \\(B\\) çš„å’Œã€‚ è€ƒè™‘æšä¸¾æœ€å¤§çš„ \\(A\\) æ˜¯è°ï¼Œå°†æ‰€æœ‰æ•°å¯¹æŒ‰ç…§ \\(A\\) ä»å°åˆ°å¤§æ’åºï¼Œé—®é¢˜è½¬åŒ–ä¸ºé€‰å“ªäº› \\(B\\) ã€‚ å‡è®¾ç°åœ¨è€ƒè™‘æ’åºåç¬¬ \\(i\\) ä¸ªæ•°å¯¹ï¼Œåˆ™ \\(B_i\\) å¿…é€‰ï¼Œç›¸å½“äºè®¡æ•° \\(B_1,\\cdots,B_{i-1}\\) ä¸­é€‰å‡ºè‹¥å¹²ï¼Œä¸”æ€»å’Œä¸è¶…è¿‡ \\(A_i-B_i\\) çš„æ–¹æ¡ˆæ•°ã€‚ å› ä¸º \\(A\\) çš„å€¼åŸŸå¾ˆå°ï¼Œæä¸€ä¸ª 01 èƒŒåŒ…è®¡æ•°å³å¯ï¼Œå¤æ‚åº¦ \\(O(n\\times \\max A_i)\\) ã€‚ 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;#define N 5007#define mod 998244353using namespace std;typedef long long ll;int n, f[N] = &#123;1&#125;;struct node &#123;int a, b;&#125; c[N];inline bool operator &lt; (const node &amp;a, const node &amp;b) &#123; return a.a == b.a ? a.b &lt; b.b : a.a &lt; b.a;&#125;int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;c[i].a); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;c[i].b); sort(c + 1, c + 1 + n); int ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; for (int v = 0; v &lt;= c[i].a - c[i].b; ++v) ans = (ans + f[v]) % mod; for (int v = N - 1; v &gt;= c[i].b; --v) f[v] = (f[v] + f[v - c[i].b]) % mod; &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125; G. 01Sequence æ„é€ é•¿åº¦ä¸º \\(n\\) çš„ \\(01\\) åºåˆ—ï¼Œæ»¡è¶³ \\(k\\) ä¸ªå½¢å¦‚ â€œ \\([l_i,r_i]\\) å†…è‡³å°‘æœ‰ \\(x_i\\) ä¸ª \\(1\\) â€ çš„æ¡ä»¶ï¼Œä¸” \\(1\\) çš„ä¸ªæ•°æœ€å°‘ã€‚ å°†çº¦æŸæ¡ä»¶æŒ‰ç…§å³ç«¯ç‚¹ä»å°åˆ°å¤§æ’åºï¼Œè€ƒè™‘æ¯ä¸ªæ¡ä»¶å½“å‰è¿˜æœªæ»¡è¶³çš„ä¸ªæ•°ã€‚ åˆ™å¯¹äºæ¯ä¸ª \\(1\\) ï¼Œåœ¨å¯è¡Œçš„èŒƒå›´å†…å¾€å³æ”¾çš„è´¡çŒ®ä¸ä½äºå¾€å·¦æ”¾ï¼Œå› æ­¤ä»å³è¾¹ç•Œä¾æ¬¡æ”¾è¿‡æ¥å³å¯ã€‚ æŸ¥è¯¢æœªæ»¡è¶³çš„ä¸ªæ•°éœ€è¦ç»´æŠ¤ä¸€ä¸ªæ ‘çŠ¶æ•°ç»„ï¼Œå¤æ‚åº¦ \\(O(n\\log n)\\) ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;#define N 200007using namespace std;typedef long long ll;inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for(; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for(; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;int cur[N], vis[N];#define lowbit(x) (x &amp; -x)inline void add(int x) &#123; for (; x &lt; N; x += lowbit(x)) ++cur[x];&#125;inline int calc(int x) &#123; int res = 0; for (; x; x -= lowbit(x)) res += cur[x]; return res;&#125;struct node &#123;int l, r, k;&#125; c[N];inline bool operator &lt; (const node &amp;a, const node &amp;b) &#123;return a.r &lt; b.r;&#125;int main() &#123; int n = rd(); int m = rd(); for (int i = 1; i &lt;= m; ++i) &#123; c[i].l = rd(); c[i].r = rd(); c[i].k = rd(); &#125; sort(c + 1, c + 1 + m); for (int i = 1; i &lt;= m; ++i) &#123; int nw = calc(c[i].r) - calc(c[i].l - 1); for (int ptr = c[i].r; nw &lt; c[i].k; --ptr) if (!vis[ptr]) &#123; add(ptr); ++nw; vis[ptr] = 1; &#125; &#125; for (int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, vis[i]); return 0;&#125; H. Random Robots","categories":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://blog.gyx.me/categories/AtCoder/"},{"name":"AtCoder Beginner Contest","slug":"AtCoder/AtCoder-Beginner-Contest","permalink":"http://blog.gyx.me/categories/AtCoder/AtCoder-Beginner-Contest/"}],"tags":[{"name":"Binary Search","slug":"Binary-Search","permalink":"http://blog.gyx.me/tags/Binary-Search/"},{"name":"Knapsack Problem","slug":"Knapsack-Problem","permalink":"http://blog.gyx.me/tags/Knapsack-Problem/"},{"name":"Greedy","slug":"Greedy","permalink":"http://blog.gyx.me/tags/Greedy/"}]},{"title":"Google Kick Start 2021 Round E","slug":"misc/kickstart2021e","date":"2021-08-22T12:57:45.000Z","updated":"2023-03-20T16:39:12.607Z","comments":true,"path":"misc/kickstart2021e/","link":"","permalink":"http://blog.gyx.me/misc/kickstart2021e/","excerpt":"Rank : 69 / Score : 87 / Pen. Time 1:51:16 (+1)","text":"Rank : 69 / Score : 87 / Pen. Time 1:51:16 (+1) A. Shuffled Anagramsa ç»™å®šå­—ç¬¦ä¸² \\(S\\) , é—®èƒ½å¦é€šè¿‡é‡æ’\\(S\\) å¾—åˆ° \\(T\\) , ä½¿å¾—ä»»æ„ä½ç½® \\(i\\) æœ‰ \\(S_i\\not= T_i\\) , å¯ä»¥åˆ™ç»™å‡ºæ„é€ æ–¹æ¡ˆ åšæ³•åŒ AtCoder Beginner Contest 178 F ï¼Œä¸è¿‡éœ€è¦å…ˆå°†å­—ç¬¦æ’åºï¼Œæ„é€ ä¸€ä¸ªä½ç½®æ˜ å°„ã€‚ è®¾ \\(S\\) æŒ‰å­—ç¬¦å‡åºæ’åºåå­—ç¬¦ä¸²ä¸º \\(A\\) ï¼Œé™åºä¸º \\(B\\) ï¼Œè€ƒè™‘è®² \\(B\\) åšè‹¥å¹²è°ƒæ•´ï¼Œä½¿å¾—ä»»æ„ \\(i\\) æœ‰ \\(A_i\\not = B_i\\) ã€‚ ç»“è®ºä¸ºï¼š\\(A\\) å‡åºï¼Œ\\(B\\) é™åºï¼Œè‹¥æœ‰ä¸åˆæ³•ä½ç½®ï¼Œåˆ™ç›¸åŒçš„å­—ç¬¦ä¸€å®šåªæœ‰ä¸€ç±»ã€‚ è®°ç›¸åŒçš„å­—ç¬¦ä¸º \\(x\\) ï¼Œç›¸åŒçš„åŒºé—´ä¸º \\([l, r]\\) ï¼Œè¿™æ˜¯éœ€è¦äº¤æ¢åŒºé—´å†…å’ŒåŒºé—´å¤–çš„å­—ç¬¦ã€‚ è€ƒè™‘å°† \\(B\\) åŒºé—´å¤–æŸä½ç½® \\(i\\) æ¢è¿›åŒºé—´ï¼Œé‚£ä¹ˆéœ€è¦ä¿è¯ \\(A_i \\ne x\\) ä¸” \\(B_i \\ne x\\) ï¼Œå¦åˆ™æ¢åä¾ç„¶ä¸åˆæ³•ã€‚ è®°å½• \\(A\\) å’Œ \\(B\\) ä¸­å‡ºç° \\(x\\) æœ€é å·¦çš„ä½ç½® \\(L\\) ï¼Œå‡ºç° \\(x\\) æœ€é å³çš„ä½ç½® \\(R\\) ã€‚ åˆ™å¯ä»¥äº¤æ¢çš„ä½ç½® \\(i\\notin [L,R]\\) ï¼Œè‹¥ä¸ªæ•° \\(L - 1 + n - R &gt; r-l+1\\) åˆ™æœ‰è§£ï¼Œå’Œä¸¤ä¾§äº¤æ¢å°±å¥½äº†ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;#define N 10007using namespace std;char s[N];int n, a[N], b[N], testcase;vector&lt;int&gt; pos[28];inline void print() &#123; for (int i = 1; i &lt;= n; ++i) &#123; s[pos[a[i]].back()] = b[i] + &#x27;a&#x27; - 1; pos[a[i]].pop_back(); &#125; for (int i = 1; i &lt;= n; ++i) putchar(s[i]); puts(&quot;&quot;);&#125;inline void work() &#123; printf(&quot;Case #%d: &quot;, ++testcase); scanf(&quot;%s&quot;, s + 1); n = strlen(s + 1); for (int i = 1; i &lt; 28; ++i) pos[i].clear(); for (int i = 1; i &lt;= n; ++i) &#123; a[i] = b[i] = s[i] - &#x27;a&#x27; + 1; pos[s[i] - &#x27;a&#x27; + 1].push_back(i); &#125; sort(a + 1, a + 1 + n); sort(b + 1, b + 1 + n); reverse(b + 1, b + 1 + n); int x, l = 0, r, L, R; for (int i = 1; i &lt;= n; ++i) if (a[i] == b[i]) l ? ++r : l = r = i; x = a[l]; if (!l) &#123;print(); return;&#125; for (int i = 1; i &lt;= n; ++i) if (a[i] == x || b[i] == x) &#123;L = i; break;&#125; for (int i = n; i; --i) if (a[i] == x || b[i] == x) &#123;R = i; break;&#125; if (L - 1 + n - R &lt; (r - l + 1)) &#123;puts(&quot;IMPOSSIBLE&quot;); return;&#125; int lim = min(L - 1, r - l + 1); for (int i = 1; i &lt;= lim; ++i) swap(b[i], b[l + i - 1]); if (lim == r - l + 1) &#123;print(); return;&#125; lim = r - l + 1 - lim; for (int i = 1; i &lt;= lim; ++i) swap(b[n - i + 1], b[r - i + 1]); print();&#125; B. Birthday Cake åˆ‡è›‹ç³•ã€‚ C. Palindromic Crossword ç»™å®šä¸€ä¸ªçŸ©é˜µï¼Œæœ‰è‹¥å¹²éšœç¢ï¼Œå…¶ä½™ä½ç½®æ”¾å­—æ¯ï¼Œè¦æ±‚æ¨ªç€æˆ–ç«–ç€çš„ï¼Œä»»æ„æé•¿çš„ééšœç¢ä½ç½®å½¢æˆçš„å­—ç¬¦ä¸²æ˜¯å›æ–‡çš„ã€‚ç°ç»™å®šä¸€äº›ä½ç½®çš„å­—æ¯ï¼Œå…¶ä½™åº”å½“æ”¾å­—æ¯çš„ä½ç½®ç”¨ '.' ä»£æ›¿ï¼Œéšœç¢ç”¨ '#' è¡¨ç¤ºï¼Œé—®æœ€å¤šèƒ½æ¨æ–­å‡ºå¤šå°‘ä¸ªä½ç½®çš„å­—æ¯ã€‚ é¢„å¤„ç†ä¸€ä¸‹å“ªäº›ä½ç½®åº”å½“æ˜¯åŒä¸€ä¸ªå­—æ¯ï¼Œç„¶åå¯¹äºæ¯ä¸€ä¸ªä½ç½®é›†åˆï¼ˆ å¹¶æŸ¥é›† / BFS ï¼‰ï¼Œåˆ¤æ–­æ˜¯å¦å¯ä»¥èµ‹å€¼ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;#define M 1007#define N 1000007using namespace std;typedef long long ll; inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;char s[M][M], rep[N];int testcase, f[N], id[M][M];int find(int x) &#123; return x == f[x] ? x : f[x] = find(f[x]);&#125;inline void merge(int a, int b) &#123; a = find(a); b = find(b); f[a] = b;&#125;inline void work() &#123; int n = rd(); int m = rd(); int idcnt = 0; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) &#123; id[i][j] = ++idcnt; f[idcnt] = idcnt; char c = getchar(); while (c != &#x27;.&#x27; &amp;&amp; c != &#x27;#&#x27; &amp;&amp; !isalpha(c)) c = getchar(); rep[idcnt] = s[i][j] = c; &#125; for (int i = 1; i &lt;= n; ++i) s[i][m + 1] = &#x27;#&#x27;; for (int i = 1; i &lt;= m; ++i) s[n + 1][i] = &#x27;#&#x27;; for (int i = 1; i &lt;= n; ++i) &#123; int l = 0; for (int j = 1; j &lt;= m; ++j) &#123; if (s[i][j] == &#x27;#&#x27;) &#123;l = 0; continue;&#125; if (!l) l = j; if (s[i][j + 1] == &#x27;#&#x27;) &#123; int len = j - l + 1; for (int k = 1; k &lt;= len / 2; ++k) merge(id[i][l + k - 1], id[i][l + len - k]); &#125; &#125; &#125; for (int i = 1; i &lt;= m; ++i) &#123; int l = 0; for (int j = 1; j &lt;= n; ++j) &#123; if (s[j][i] == &#x27;#&#x27;) &#123;l = 0; continue;&#125; if (!l) l = j; if (s[j + 1][i] == &#x27;#&#x27;) &#123; int len = j - l + 1; for (int k = 1; k &lt;= len / 2; ++k) merge(id[l + k - 1][i], id[l + len - k][i]); &#125; &#125; &#125; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) if (s[i][j] != &#x27;.&#x27;) rep[find(id[i][j])] = s[i][j]; int ans = 0; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) &#123; ans += (s[i][j] != rep[find(id[i][j])]); s[i][j] = rep[find(id[i][j])]; &#125; printf(&quot;Case #%d: %d\\n&quot;, ++testcase, ans); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) putchar(s[i][j]); puts(&quot;&quot;); &#125;&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; D. Increasing Sequence Card Game ä» \\(n!\\) ä¸ª \\(n\\)çš„å…¨æ’åˆ—ä¸­ç­‰æ¦‚ç‡éšæœºä¸€ä¸ªï¼Œé—®æœŸæœ›æœ‰å¤šå°‘ä¸ªä½ç½® \\(i\\) ï¼Œæ»¡è¶³ \\(P_i\\) æ˜¯ \\(P_1,\\cdots,P_i\\) ä¸­çš„æœ€å¤§å€¼ã€‚ è€ƒè™‘å¯¹æ¯ä¸ªæ•°åˆ†åˆ«ç®—è´¡çŒ®ï¼Œåˆ™æ•°å­— \\(x\\) çš„è´¡çŒ®å°±æ˜¯ \\(1\\times (\\ x\\) æ˜¯æ‰€åœ¨æ’åˆ—çš„å‰ç¼€ \\(\\max\\) çš„æ¦‚ç‡ \\()\\) è‹¥æ•°å­— \\(x\\) æœ‰è´¡çŒ®ï¼Œåˆ™ \\(x\\) å‰é¢åªèƒ½æœ‰å°äº \\(x\\) çš„æ•°å­—ï¼Œè€ƒè™‘æšä¸¾ \\(x\\) å‰é¢æœ‰ \\(i\\) ä¸ªæ•°å­—ï¼š \\[ p(x) = \\frac{\\sum_{i=0}^{x-1} {x-1\\choose i}i!(n- i - 1)!}{n!} = \\sum_{i=0}^{x-1}\\frac{(x-1)!(n-i-1)!}{(x-1-i)!n!} =\\frac{1}{x}\\sum_{i=1}^{x}\\frac{x!\\times (n-i)!}{ (x-i)!\\times n!} \\] çœ‹èµ·æ¥å¯ä»¥é…æˆç»„åˆæ•°ä½œæ¯”ï¼Œäºæ˜¯ï¼š \\[ p(x)=\\frac{1}{x}\\sum_{i=1}^{x}\\frac{x!}{(x-i)!}\\frac{(n-i)!}{ n!}=\\frac{1}{x}\\sum_{i=1}^{x}\\frac{x!}{i!(x-i)!}\\frac{(n-i)!\\times i!}{n!} =\\frac{1}{x}\\sum_{i=1}^{x}\\frac{x\\choose i}{n\\choose i} \\] åé¢çš„å½¢å¼éå¸¸å¥½çœ‹ï¼Œä½†æ˜¯æ²¡ä»€ä¹ˆåŒ–ç®€çš„ä½™åœ° QAQ æˆ‘ä»¬æ¢ä¸€ç§é…å‡‘ï¼š \\[ p(x) =\\frac{1}{x}\\sum_{i=1}^{x}\\frac{x!}{n!}\\frac{(n-i)!}{(x-i)!}=\\frac{1}{x}\\sum_{i=1}^{x}\\frac{x!(n-x)!}{n!}\\frac{(n-i)!}{(x-i)!(n-x)!}=\\frac{1}{x}\\sum_{i=1}^{x}\\frac{n-i\\choose n-x}{n\\choose x} \\] å‘ç°åˆ†æ¯å¯ä»¥æå‡ºæ¥äº†ï¼Œè€Œä¸”åˆ†å­ä¹Ÿå¯ä»¥ç”¨ç»å…¸æ€§è´¨åŒ–ç®€ï¼ˆç»„åˆæ•°ä¸€åˆ—çš„å’Œç­‰äºå³ä¸‹è§’ï¼‰ï¼š \\[ p(x) = \\frac{1}{x\\times {n\\choose x}}\\sum_{i=1}^x{n-i\\choose n-x} = \\frac{n\\choose n - x + 1}{x\\times {n\\choose x}} = \\frac{x}{x(n-x+1)} = \\frac{1}{n-x+1} \\] æ•…ç­”æ¡ˆï¼š \\[ ans = \\sum_{x=1}^n\\frac{1}{n-x+1} = \\sum_{x=1}^n \\frac{1}{x}\\approx \\ln(n) \\] éšç€ \\(n\\) å˜å¤§ï¼ŒçœŸå®ç­”æ¡ˆå’Œ \\(\\ln(n)\\) çš„è¯¯å·®ä¸ä¼šè¶…è¿‡ eps çš„è¦æ±‚ï¼Œè¯æ˜è§å®˜æ–¹é¢˜è§£ ã€‚ å› æ­¤åªéœ€é¢„å¤„ç†è¾ƒå°èŒƒå›´ï¼Œè¾ƒå¤§èŒƒå›´ç›´æ¥ç”¨ log å‡½æ•°å³å¯ã€‚ 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;#define N 10000007using namespace std;typedef long long ll; inline ll rd() &#123; ll x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;int testcase;double ans[N];inline void work() &#123; ll n = rd(); if (n &lt; N) printf(&quot;Case #%d: %.10lf\\n&quot;, ++testcase, ans[n]); else printf(&quot;Case #%d: %.10lf\\n&quot;, ++testcase, ans[N - 1] + log(n) - log(N - 1));&#125;int main() &#123; for (int i = 1; i &lt; N; ++i) ans[i] = ans[i - 1] + 1.0 / i; for (int t = rd(); t; --t) work(); return 0;&#125;","categories":[{"name":"Misc Solutions","slug":"Misc-Solutions","permalink":"http://blog.gyx.me/categories/Misc-Solutions/"}],"tags":[{"name":"Union-Find Set","slug":"Union-Find-Set","permalink":"http://blog.gyx.me/tags/Union-Find-Set/"},{"name":"Constructive Algorithm","slug":"Constructive-Algorithm","permalink":"http://blog.gyx.me/tags/Constructive-Algorithm/"},{"name":"Combinatorics","slug":"Combinatorics","permalink":"http://blog.gyx.me/tags/Combinatorics/"},{"name":"Probabilities","slug":"Probabilities","permalink":"http://blog.gyx.me/tags/Probabilities/"}]},{"title":"Codeforces Round #738 (Div. 2)","slug":"codeforces/1559","date":"2021-08-17T16:00:00.000Z","updated":"2023-03-20T16:25:51.090Z","comments":true,"path":"codeforces/1559/","link":"","permalink":"http://blog.gyx.me/codeforces/1559/","excerpt":"","text":"A - Mocha and Math ç­¾åˆ°ã€‚æ˜¾ç„¶å¯ä»¥æ„é€ å‡ºæ¥æ‰€æœ‰çš„ä¸ã€‚ 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;inline void work() &#123; int n = rd(), ans = rd(); for (int i = 2; i &lt;= n; ++i) ans = (ans &amp; rd()); printf(&quot;%d\\n&quot;, ans);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; B - Mocha and Red and Blue ä¸¤ä¾§çš„é—®å·æ˜¾ç„¶å¯ä»¥å¤„ç†æˆæ— ç›¸é‚»é‡å¤ï¼Œä¸­é—´çš„é—®å·éƒ½ä¾ç…§å·¦ä¾§äº¤æ›¿æ”¾å°±è¡Œã€‚æ˜¾ç„¶æ²¡æœ‰ç›¸é‚»é‡å¤æ›´å°‘çš„æ„é€ ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 1007char s[N];inline void work() &#123; int n = rd(); scanf(&quot;%s&quot;, s + 1); int l = 1, r = n; while (s[l] == &#x27;?&#x27; &amp;&amp; l &lt;= n) ++l; if (l == n + 1) &#123; for (int i = 1; i &lt;= n; ++i) putchar((i &amp; 1) ? &#x27;B&#x27; : &#x27;R&#x27;); puts(&quot;&quot;); return; &#125; for (int i = l - 1; i; --i) s[i] = (s[i + 1] == &#x27;R&#x27; ? &#x27;B&#x27; : &#x27;R&#x27;); while (s[r] == &#x27;?&#x27; &amp;&amp; r) --r; for (int i = r + 1; i &lt;= n; ++i) s[i] = (s[i - 1] == &#x27;R&#x27; ? &#x27;B&#x27; : &#x27;R&#x27;); for (int i = l; i &lt;= r; ++i) if (s[i] == &#x27;?&#x27;) s[i] = (s[i - 1] == &#x27;R&#x27; ? &#x27;B&#x27; : &#x27;R&#x27;); puts(s + 1);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; C - Mocha and Hiking å¦‚æœ \\(a[1]=1\\) æœ‰ \\(n+1\\to 1\\to 2\\to \\cdots\\to n\\) ã€‚ å¦‚æœ \\(a[n]=0\\) æœ‰ \\(1\\to 2\\to \\cdots\\to n\\to n+1\\) ã€‚ å¦åˆ™ \\(a[1] = 0,a[n] = 1\\) ï¼Œä¸€å®šæœ‰ä¸€ä¸ªä½ç½® \\(a[i] = 0, a[i + 1] = 1\\) ï¼Œæœ‰ \\(1\\to \\cdots \\to i\\to n+1\\to i+1\\to \\cdots\\to n\\) ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 10007int a[N];inline void work() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) a[i] = rd(); if (a[1] == 1) &#123; printf(&quot;%d &quot;, n + 1); for (int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, i); puts(&quot;&quot;); return; &#125; if (a[n] == 0) &#123; for (int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, i); printf(&quot;%d\\n&quot;, n + 1); return; &#125; for (int i = 1; i &lt;= n; ++i) if (a[i] == 0 &amp;&amp; a[i + 1] == 1) &#123; for (int j = 1; j &lt;= i; ++j) printf(&quot;%d &quot;, j); printf(&quot;%d &quot;, n + 1); for (int j = i + 1; j &lt;= n; ++j) printf(&quot;%d &quot;, j); puts(&quot;&quot;); return; &#125;&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; D - Mocha and Diana ç»™å®šä¸¤ä¸ªæ£®æ— \\(A,B\\) ï¼ŒèŠ‚ç‚¹æ ‡å·éƒ½æ˜¯ \\(1\\sim n\\) ã€‚ ä¸€æ¬¡æ“ä½œé€‰æ‹©ä¸€ä¸ª \\((u,v)\\) ï¼Œä½¿å¾—è¾¹ \\((u,v)\\) åŠ å…¥ä¸¤å¹…å›¾åï¼Œä¸¤å¹…å›¾ä¾æ—§éƒ½æ˜¯æ£®æ—ã€‚ é—®æœ€å¤šèƒ½æ“ä½œå¤šå°‘æ¬¡ï¼Œå¹¶è¾“å‡ºæ–¹æ¡ˆã€‚ å®¹æ˜“å‘ç°æ¯æ¬¡æˆåŠŸçš„æ“ä½œä¹‹åï¼Œ\\(A,B\\) çš„è¿é€šå—æ•°éƒ½ \\(-1\\) ã€‚ å¦‚æœä¸èƒ½æ“ä½œäº†ï¼Œä¸” \\(A\\)è¿é€šå—æ•°ä¸å”¯ä¸€ï¼Œé‚£ä¹ˆè€ƒè™‘ï¼š\\(\\forall 1\\le i,j\\le n\\) ï¼Œ \\(i\\) å’Œ \\(j\\) åœ¨ \\(A\\) ä¸­ä¸è¿é€šï¼Œåˆ™ \\(i\\) å’Œ \\(j\\) åœ¨ \\(B\\) ä¸­è¿é€šã€‚\\(\\forall 1\\le i,j\\le n\\) ï¼Œ \\(i\\) å’Œ \\(j\\) åœ¨ \\(A\\) ä¸­è¿é€šï¼Œåˆ™ \\(\\exists 1\\le k\\le n\\) ï¼Œ\\(k\\) åœ¨ \\(A\\) ä¸­ä¸ \\(i\\) å’Œ \\(j\\) å‡ä¸è¿é€šã€‚ç»“åˆä¸¤æ¡å¯ä»¥å¾—åˆ°æ‰€æœ‰ç‚¹åœ¨ \\(B\\)ä¸­å‡è¿é€šï¼Œå³ \\(B\\) æ˜¯ä¸€æ£µæ ‘ã€‚ æ‰€ä»¥æœ€å¤šæ“ä½œæ¬¡æ•°æ˜¯ \\(\\min (n-1-|E_A|,n-1-|E_B|)\\) ï¼Œä¸”æ¯æ¬¡éšä¾¿æ‰¾ä¸€ä¸ªå¯æ“ä½œçš„æ“ä½œéƒ½æ˜¯å¯¹çš„ã€‚ é‚£ä¹ˆç°åœ¨é—®é¢˜æ˜¯æ€ä¹ˆå¿«é€Ÿæ‰¾å‡ºå¯ä¾›é€‰æ‹©çš„ç‚¹å¯¹ï¼Œæ–¹æ³•å¾ˆå¤šï¼Œè®°å½•ä¸€ä¸ªæ¯”è¾ƒæœ‰æ„æ€çš„æ„é€ æ€§æ–¹æ³•ï¼š å…ˆå°è¯•æ“ä½œ \\(1\\) å·ç‚¹å’Œæ‰€æœ‰ç‚¹çš„ç»„åˆï¼ˆå³èƒ½å’Œ \\(1\\) è¿é€šçš„éƒ½è¿é€šï¼‰ã€‚ ä»¤ \\(A,B\\) ä¸­ä¸ \\(1\\) å·ç‚¹ä¸è¿é€šçš„é›†åˆåˆ†åˆ«ä¸º \\(S_A,S_B\\) ï¼Œç”±å®šä¹‰ \\(S_A\\cap S_B=\\emptyset\\) ï¼ˆå¦åˆ™ä¸€å®šå¯ä»¥æ“ä½œ \\(1\\) å’Œäº¤ä¸­çš„ç‚¹ï¼‰ã€‚ æ¯æ¬¡ä» \\(S_A,S_B\\) ä¸­å„æ‰¾å‡ºä¸€ä¸ªç‚¹ï¼Œæ“ä½œè¿™ä¸¤ä¸ªç‚¹ï¼ˆç”±ä¸Šç»“è®ºä¸¤ä¸ªå›¾ä¸­ä¸¤ç‚¹ä¸€å®šä¸è¿é€šï¼‰ï¼ŒæŒ‰å®šä¹‰æ›´æ–° \\(S_A,S_B\\) ã€‚ é¦–å…ˆ \\(S_A, S_B\\) æ˜¾ç„¶æ˜¯å¯æ“ä½œçš„æœ€å¤§èŒƒå›´äº†ï¼Œæ‰€ä»¥æ­£ç¡®æ€§æ²¡é—®é¢˜ã€‚ è€ƒè™‘å®ç°æ–¹æ³•ï¼Œå…¶å®æ‡’æƒ°åˆ é™¤æ³•å°±å¥½äº†ï¼Œæ¯æ¬¡å–ç‚¹çš„æ—¶å€™åˆ¤æ–­ä¸‹æ˜¯å¦åˆæ³•å³å¯ã€‚å¹¶æŸ¥é›†å®ç°å¤æ‚åº¦ \\(O(n\\alpha(n))\\) ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 100007struct DSU &#123; int f[N]; inline void reset(int n) &#123;for (int i = 1; i &lt;= n; ++i) f[i] = i;&#125; int find(int x) &#123;return x == f[x] ? x : f[x] = find(f[x]);&#125; inline bool merge(int x, int y) &#123; x = find(x); y = find(y); return x == y ? false : (f[x] = y, true); &#125;&#125; A, B;vector&lt;int&gt; sA, sB;vector&lt;pii&gt; res;int main() &#123; int n = rd(), m1 = rd(), m2 = rd(); A.reset(n); B.reset(n); while (m1--) A.merge(rd(), rd()); while (m2--) B.merge(rd(), rd()); for (int j = 1; j &lt;= n; ++j) if (A.find(1) != A.find(j) &amp;&amp; B.find(1) != B.find(j)) &#123; res.push_back(make_pair(1, j)); A.merge(1, j); B.merge(1, j); &#125; for (int i = 1; i &lt;= n; ++i) &#123; if (A.find(1) != A.find(i)) sA.push_back(i); if (B.find(1) != B.find(i)) sB.push_back(i); &#125; while (!sA.empty() &amp;&amp; !sB.empty()) &#123; int u = sA.back(), v = sB.back(); sA.pop_back(); sB.pop_back(); res.push_back(make_pair(u, v)); A.merge(u, v); B.merge(u, v); while (!sA.empty() &amp;&amp; A.find(1) == A.find(sA.back())) sA.pop_back(); while (!sB.empty() &amp;&amp; B.find(1) == B.find(sB.back())) sB.pop_back(); &#125; printf(&quot;%d\\n&quot;, (int)res.size()); for (auto [u, v] : res) printf(&quot;%d %d\\n&quot;, u, v); return 0;&#125; E - Mocha and Stars ç»™å®š \\(n\\le 50,m\\le 10^5\\) ï¼Œè®¡æ•° \\((a_1,a_2,\\cdots,a_n)\\) çš„ä¸ªæ•°ï¼Œæ»¡è¶³ï¼š \\(\\forall 1\\le i\\le n, a_i\\in \\left[l_i, r_i\\right]\\cap \\mathbb{Z}\\) \\(\\sum_{i=1}^n a_i \\leq m\\) \\(\\operatorname{gcd}\\left(a_1, a_2, \\ldots, a_n\\right)=1\\) æ³•ä¸€ï¼šå¯¹ \\(\\text{gcd}\\) å®¹æ–¥ï¼Œè®¾ \\(f(d)\\) è¡¨ç¤º \\(d|\\operatorname{gcd}\\left(a_1, a_2, \\ldots, a_n\\right)\\) çš„æ–¹æ¡ˆæ•°ï¼Œ\\(g(d)\\) è¡¨ç¤º \\(d=\\operatorname{gcd}\\left(a_1, a_2, \\ldots, a_n\\right)\\) çš„æ–¹æ¡ˆæ•°ã€‚ æ˜¾ç„¶æœ‰ \\(g(d)=f(d)-\\sum_{k=2}^\\infty g(kd)\\) ï¼Œåˆç”±äº \\(\\operatorname{gcd}\\left(a_1, a_2, \\ldots, a_n\\right)\\) æœ€å¤§å–åˆ° \\(\\lfloor\\frac{m}{n}\\rfloor\\) ï¼Œå¯ä»¥å€’æ¨ã€‚ æ±‚ \\(f(d)\\) è€ƒè™‘è¦æ±‚æ¯ä¸ªæ•°å­—éƒ½è¦æ˜¯ \\(d\\) çš„å€æ•°ï¼Œä¸å¦¨è®¾ \\(a_i=b_id\\) ï¼Œæœ‰ï¼š \\(l_i\\le a_i=b_id\\le r_i\\) ï¼Œæœ‰ \\(\\lceil\\frac{l_i}{d}\\rceil\\le b_i\\le \\lfloor\\frac{r_i}{d}\\rfloor\\) \\(\\sum a_i = \\sum b_id\\le m\\) ï¼Œæœ‰ \\(\\sum b_i\\le \\lfloor\\frac{m}{d}\\rfloor\\) è¿™æ ·è½¬åŒ–æˆäº† \\((n,\\lfloor\\frac{m}{d}\\rfloor)\\) è§„æ¨¡çš„é—®é¢˜ã€‚ è®¾ \\(cnt[i][j]\\) è¡¨ç¤ºå‰ \\(i\\) ä¸ªæ•°å­—å’Œæ˜¯ \\(j\\) çš„æ–¹æ¡ˆæ•°ï¼Œå‰ç¼€å’Œä¼˜åŒ– dp å¤æ‚åº¦ \\(O(n\\lfloor\\frac{m}{d}\\rfloor)\\) ï¼Œ \\(f(d)=\\sum_{k=0}^{\\lfloor\\frac{m}{d}\\rfloor} cnt[n][k]\\) ã€‚ æ€»å¤æ‚åº¦ä¸º \\(O(\\sum_{d=1}^{\\lfloor\\frac{m}{n}\\rfloor} n\\big\\lfloor\\frac{m}{d}\\rfloor)=O(nm\\ln m)\\)ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 51#define M 100007#define mod 998244353int l[N], r[N], f[N][M], sum[N][M], ans[M];int main() &#123; int n = rd(), m = rd(); for (int i = 1; i &lt;= n; ++i) &#123;l[i] = rd(); r[i] = rd();&#125; for (int j = 0; j &lt;= m; ++j) sum[0][j] = 1; auto mo = [&amp;](int x) &#123;return x &gt;= mod ? x - mod : x;&#125;; auto dp = [&amp;](int t, int d) &#123; for (int i = 1; i &lt;= n; ++i) &#123; int L = (l[i] + d - 1) / d, R = r[i] / d; for (int j = 1; j &lt;= t; ++j) f[i][j] = 0; for (int j = L; j &lt;= t; ++j) f[i][j] = mo(mod + sum[i - 1][j - L] - (j - R - 1 &gt;= 0 ? sum[i - 1][j - R - 1] : 0)); for (int j = 1; j &lt;= t; ++j) sum[i][j] = mo(sum[i][j - 1] + f[i][j]); &#125; return sum[n][t]; &#125;; int lim = m / n; for (int d = lim; d; --d) &#123; ans[d] = dp(m / d, d); for (int i = d * 2; i &lt;= lim; i += d) ans[d] = mo(ans[d] + mod - ans[i]); &#125; printf(&quot;%d\\n&quot;, ans[1]); return 0;&#125; æ³•äºŒï¼šç›´æ¥è«æ¯”ä¹Œæ–¯åæ¼”æ±‚å®¹æ–¥çš„ç³»æ•°ï¼Œå®šä¹‰ \\(\\operatorname{valid}(a_1,a_2,\\dots,a_n)\\) è¡¨ç¤ºè¿™ä¸ªæ–¹æ¡ˆæ˜¯å¦ç¬¦åˆå‰ä¸¤ä¸ªè¦æ±‚ã€‚ \\[ \\begin{aligned} &amp;\\ \\ \\ \\ \\ \\sum_{a_1=l_1}^{r_1} \\sum_{a_2=l_2}^{r_2} \\ldots \\sum_{a_n=l_n}^{r_n}\\operatorname{valid}\\left(a_1, a_2, \\ldots, a_n\\right)\\left[\\operatorname{gcd}\\left(a_1, a_2, \\ldots, a_n\\right)=1\\right] \\\\ &amp;=\\sum_{a_1=l_1}^{r_1} \\sum_{a_2=l_2}^{r_2} \\ldots \\sum_{a_n=l_n}^{r_n} \\operatorname{valid}\\left(a_1, a_2, \\ldots, a_n\\right) \\sum_{d \\mid \\operatorname{gcd}\\left(a_1, a_2, \\ldots, a_n\\right)} \\mu(d) \\\\ &amp;=\\sum_{a 1}^{r_1} \\sum_{a_2=l_2}^{r_2} \\cdots \\sum_{a_n=l_n}^{r_n} \\operatorname{valid}\\left(a_1, a_2, \\ldots, a_n\\right) \\sum_{d\\left|a_1, d\\right| a_2, \\ldots, d \\mid a_n} \\mu(d) \\\\ &amp;=\\sum_{d=1}^m \\mu(d) \\sum_{a_1=\\left\\lceil\\frac{l_1}{d}\\right\\rceil}^{\\left\\lfloor\\frac{r_1}{d}\\right\\rfloor} \\sum_{a_2=\\left\\lceil\\frac{l_2}{d}\\right\\rceil}^{\\left\\lfloor\\frac{r_2}{d}\\right\\rfloor} \\cdots \\sum_{a_n=\\left\\lceil\\frac{l_n}{d}\\right\\rceil}^{\\left\\lfloor\\frac{r_n}{d}\\right\\rfloor} \\operatorname{valid}\\left(a_1 d, a_2 d, \\ldots, a_n d\\right) \\\\ \\end{aligned} \\] è€ƒè™‘æœ€åä¸€è¡Œ \\(\\mu(d)\\) åé¢çš„éƒ¨åˆ†ï¼Œå¯ä»¥ç”¨æ³•ä¸€åŒæ ·çš„ \\(dp\\) è®¡æ•°ï¼Œå› æ­¤å¤æ‚åº¦ \\(O(m+\\sum_{d=1}^m n\\big\\lfloor\\frac{m}{d}\\rfloor)=O(nm\\ln m)\\)ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 51#define M 100007#define mod 998244353int l[N], r[N], f[N][M], sum[N][M];int prm[M], mnd[M], mu[M] = &#123;0, 1&#125;;int main() &#123; int n = rd(), m = rd(); for (int i = 1; i &lt;= n; ++i) &#123;l[i] = rd(); r[i] = rd();&#125; for (int i = 2; i &lt;= m; ++i) &#123; if (!mnd[i]) &#123;prm[++prm[0]] = mnd[i] = i; mu[i] = mod - 1;&#125; for (int j = 1, p = prm[1], prod; j &lt;= prm[0]; p = prm[++j]) &#123; if ((prod = i * p) &gt; m) break; mnd[prod] = p; if (p == mnd[i]) &#123;mu[prod] = 0; break;&#125; mu[prod] = 1ll * mu[i] * mu[p] % mod; &#125; &#125; for (int j = 0; j &lt;= m; ++j) sum[0][j] = 1; auto mo = [&amp;](int x) &#123;return x &gt;= mod ? x - mod : x;&#125;; auto dp = [&amp;](int t, int d) &#123; for (int i = 1; i &lt;= n; ++i) &#123; int L = (l[i] + d - 1) / d, R = r[i] / d; for (int j = 1; j &lt;= t; ++j) f[i][j] = 0; for (int j = L; j &lt;= t; ++j) f[i][j] = mo(mod + sum[i - 1][j - L] - (j - R - 1 &gt;= 0 ? sum[i - 1][j - R - 1] : 0)); for (int j = 1; j &lt;= t; ++j) sum[i][j] = mo(sum[i][j - 1] + f[i][j]); &#125; return sum[n][t]; &#125;; int ans = 0; for (int d = 1; d &lt;= m / n; ++d) ans = (ans + 1ll * mu[d] * dp(m / d, d)) % mod; printf(&quot;%d\\n&quot;, ans); return 0;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://blog.gyx.me/categories/Codeforces/"},{"name":"Codeforces Round","slug":"Codeforces/Codeforces-Round","permalink":"http://blog.gyx.me/categories/Codeforces/Codeforces-Round/"}],"tags":[{"name":"Constructive Algorithm","slug":"Constructive-Algorithm","permalink":"http://blog.gyx.me/tags/Constructive-Algorithm/"},{"name":"Number Theory","slug":"Number-Theory","permalink":"http://blog.gyx.me/tags/Number-Theory/"},{"name":"Counting","slug":"Counting","permalink":"http://blog.gyx.me/tags/Counting/"}]},{"title":"AtCoder Beginner Contest 214","slug":"atcoder/abc214","date":"2021-08-14T13:58:14.000Z","updated":"2023-03-20T16:27:49.505Z","comments":true,"path":"atcoder/abc214/","link":"","permalink":"http://blog.gyx.me/atcoder/abc214/","excerpt":"","text":"D. Sum of Maximum Weights ç»™å®šä¸€æ£µæ ‘ï¼Œè¾¹æœ‰è¾¹æƒã€‚è®¡ç®—æ‰€æœ‰ç‚¹å¯¹è·¯å¾„ä¸Šæœ€å¤§è¾¹æƒçš„æƒå€¼å’Œï¼ŒèŒƒå›´ \\(n\\le 10^5\\) è€ƒè™‘ç±»ä¼¼ Kruskal çš„è¿‡ç¨‹æ·»åŠ æ ‘è¾¹ï¼Œåˆ™æ¯ä¸€æ¡è¾¹åŠ å…¥æ—¶ï¼Œå¯¹äºè¿é€šçš„ä¸¤ä¸ªé›†åˆé—´çš„ç‚¹å¯¹ï¼Œæœ€å¤§è¾¹å³ä¸ºå½“å‰è¾¹ã€‚ å› æ­¤åœ¨ç»´æŠ¤å¹¶æŸ¥é›†çš„åŒæ—¶ç»´æŠ¤é›†åˆå¤§å°å³å¯ï¼Œè´¡çŒ®ä¸º w \\(\\times\\) Size(u) \\(\\times\\) Size(v) ï¼Œå¤æ‚åº¦ \\(O(n\\log n)\\) E. Packing Under Range Regulations æœ‰ \\(10^9\\) ä¸ªç›’å­ï¼Œæ¯ä¸ªç›’å­åªèƒ½æ”¾ä¸€ä¸ªçƒã€‚æœ‰ \\(n\\) ä¸ªçƒï¼Œç¬¬ \\(i\\) ä¸ªè¦æ”¾åœ¨ \\([l_i,r_i]\\) çš„æŸä¸€ä¸ªç›’å­ä¸­ï¼Œé—®æ˜¯å¦æœ‰è§£ï¼ŒèŒƒå›´ \\(n\\le 2\\times 10^5\\) æ¯”è¾ƒç»å…¸çš„è´ªå¿ƒï¼Œè€ƒè™‘ä»å·¦å¾€å³æ”¾ï¼Œæœ€ç´§æ€¥çš„éœ€æ±‚è‚¯å®šæ˜¯å³ç«¯ç‚¹æœ€å°çš„ã€‚ æŒ‰ç…§å³ç«¯ç‚¹æ’åºï¼Œä¾æ¬¡è€ƒè™‘æ¯ä¸ªéœ€æ±‚ï¼Œå°½é‡å¾€å·¦æ”¾ï¼Œç›¸å½“äºåŒºé—´æŸ¥è¯¢æœ€é å·¦çš„æœªè¦†ç›–ä½ç½®ï¼Œç„¶åä¿®æ”¹è¿™ä¸ªä½ç½®çš„è¦†ç›–çŠ¶æ€ã€‚ å®ç°å¯ä»¥é€‰æ‹©åŠ¨æ€å¼€ç‚¹çº¿æ®µæ ‘+çº¿æ®µæ ‘ä¸ŠåŒºé—´å†…äºŒåˆ†ï¼Œæˆ‘æ˜¯ç”¨çš„æ˜¯å¹¶æŸ¥é›†ç»´æŠ¤ä¸‹ä¸€ä¸ªæœªè¦†ç›–çš„ä½ç½®ï¼ˆç–¯ç‹‚çš„é¦’å¤´ï¼‰ã€‚ å› ä¸ºåºåˆ—æœ‰ \\(10^9\\) é•¿ï¼Œä½¿ç”¨ unordered_map ç»´æŠ¤å¹¶æŸ¥é›†æ•°ç»„ï¼Œå…·ä½“å®ç°è§ä»£ç ï¼Œå¤æ‚åº¦ \\(O(n\\log n)\\) ã€‚ 1234567891011121314151617181920212223242526struct node &#123;int l, r;&#125; c[N];inline bool operator &lt; (const node &amp;a, const node &amp;b) &#123; return a.r == b.r ? a.l &lt; b.l : a.r &lt; b.r;&#125;unordered_map&lt;int, int&gt; nxt;int find(int x) &#123; return nxt[x] ? nxt[x] = find(nxt[x]) : x;&#125;void work() &#123; int n = rd(); for (int i = 1; i &lt;= n; ++i) &#123;c[i].l = rd(); c[i].r = rd();&#125; sort(c + 1, c + 1 + n); for (int i = 1, pos; i &lt;= n; ++i) &#123; if (!nxt[c[i].l]) &#123; nxt[c[i].l] = c[i].l + 1; continue; &#125; pos = find(c[i].l); if (pos &gt; c[i].r) &#123;puts(&quot;No&quot;); return;&#125; nxt[pos] = pos + 1; &#125; puts(&quot;Yes&quot;);&#125;","categories":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://blog.gyx.me/categories/AtCoder/"},{"name":"AtCoder Beginner Contest","slug":"AtCoder/AtCoder-Beginner-Contest","permalink":"http://blog.gyx.me/categories/AtCoder/AtCoder-Beginner-Contest/"}],"tags":[{"name":"Union-Find Set","slug":"Union-Find-Set","permalink":"http://blog.gyx.me/tags/Union-Find-Set/"}]},{"title":"AtCoder Regular Contest 124","slug":"atcoder/arc124","date":"2021-07-26T14:53:11.000Z","updated":"2023-03-20T16:28:52.911Z","comments":true,"path":"atcoder/arc124/","link":"","permalink":"http://blog.gyx.me/atcoder/arc124/","excerpt":"","text":"A. LR Constraints ç»™ä¸€ä¸ªæ•°åˆ—èµ‹å€¼ï¼Œå€¼åŸŸ \\([1,k]\\)ï¼Œå¯¹äºæ¯ä¸ª \\(k\\)ï¼Œçº¦æŸç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®æˆ–æœ€åä¸€æ¬¡å‡ºç°çš„ä½ç½®ï¼Œæ±‚æ–¹æ¡ˆæ•° ç»´æŠ¤ä¸€ä¸‹å¯¹äºæ¯ä¸ªä½ç½®ï¼Œå½“å‰æœ‰å¤šå°‘ç§æ–¹æ¡ˆï¼Œå¤æ‚åº¦ \\(O(n)\\) B. XOR Matching 2 ç»™å®šä¸¤ä¸ªé•¿åº¦ç›¸åŒçš„æ•°åˆ— \\(A,B\\)ï¼Œæ±‚æœ‰å“ªäº› \\(x\\) ï¼Œä½¿å¾—å°† \\(B\\) é‡æ’åï¼Œä»»æ„ä½ç½® \\(A_i\\ \\text{xor}\\ B_i = x\\) é‡æ’åæœ‰ \\(\\forall 1\\le i,j\\le n,\\ A_i\\ \\text{xor}\\ B_i=A_j\\ \\text{xor}\\ B_j\\Rightarrow A_i\\ \\text{xor}\\ A_j=B_i\\ \\text{xor}\\ B_j\\)â€‹â€‹â€‹â€‹ ä¹Ÿå°±æ˜¯è¯´ï¼Œè¦æ»¡è¶³é‡æ’å, ï¼ˆ\\(A_i\\)â€‹â€‹ ä¸æ‰€æœ‰å…¶ä»– \\(A\\)â€‹â€‹ çš„å¼‚æˆ–å€¼ï¼‰ä¸ï¼ˆ\\(B_i\\)â€‹â€‹ ä¸æ‰€æœ‰å…¶ä»– \\(B\\)â€‹â€‹â€‹â€‹ çš„å¼‚æˆ–å€¼ï¼‰ä¸€ä¸€å¯¹åº” çº¦æŸæ¡ä»¶å¾ˆå¼ºï¼Œæˆ‘ä»¬åªéœ€è¦å¤„ç† \\(A_1\\)â€‹ ä¸å…¶ä»– \\(A\\) çš„å¼‚æˆ–å€¼ï¼Œç„¶åæ‰¾å¯èƒ½å¯¹åº”çš„ \\(B\\) å³å¯ï¼Œå¤æ‚åº¦ \\(O(n^2\\log n)\\)â€‹â€‹ C. LCM of GCDs ç»™å®š \\(n\\) ä¸ª pairï¼Œæ¯ä¸ª pairä¸­çš„æ•°ä¸€ä¸ªæ”¾å…¥ \\(A\\) é›†ï¼Œå¦ä¸€ä¸ªæ”¾å…¥\\(B\\)â€‹ é›†ï¼Œæœ€å¤§åŒ– \\(lcm[\\ gcd(A),\\ gcd(B)\\ ]\\) é›†åˆçš„æœ€å¤§å…¬çº¦æ•°ä¸€å®šæ˜¯æ¯ä¸ªæ•°çš„å› å­ï¼Œå°†ç¬¬ä¸€ä¸ª pair é‡Œçš„ä¸¤ä¸ªæ•°æ±‚å‡ºæ‰€æœ‰çš„çº¦æ•°ï¼Œæšä¸¾ç­”æ¡ˆã€‚ å¦‚æœå­˜åœ¨ä¸€ç§æ–¹æ¡ˆä½¿å¾—ç­”æ¡ˆä¸º \\([x,y]\\)â€‹â€‹ çš„å€æ•°ï¼Œé‚£ä¹ˆå¯¹äºæ¯ä¸ª pair \\((a,b)\\)â€‹â€‹ ï¼Œæœ‰ \\(x|a,\\ y|b\\)â€‹ æˆ–è€… \\(x|b,\\ y|a\\)â€‹ â€‹â€‹ æš´åŠ›æ£€éªŒå³å¯ï¼Œå¤æ‚åº¦ \\(O\\big(div(A_{1a})div(A_{1b})n\\big)\\)â€‹ D. Yet Another Sorting Problem ä¸€ä¸ª \\(n+m\\)â€‹ çš„æ’åˆ—ï¼Œæ¯æ¬¡é€‰æ‹©å‰\\(n\\)â€‹ ä¸ªä¸­ä¸€ä¸ªå’Œå \\(m\\)â€‹ä¸ªä¸­ä¸€ä¸ªäº¤æ¢ï¼Œé—®äº¤æ¢æˆå•ä½ç½®æ¢æ‰€éœ€æœ€å°‘æ¬¡æ•° å¦‚æœæ²¡æœ‰ä½ç½®é€‰æ‹©çš„é™åˆ¶ï¼Œè¿˜åŸä¸€ä¸ª \\(n\\)â€‹â€‹ çš„æ’åˆ—æ‰€éœ€æœ€å°‘äº¤æ¢æ¬¡æ•°ä¸º \\(n\\ -\\) æ’åˆ—æ‰€å¯¹åº”çš„ç¯æ•°ã€‚ å°†æ’åˆ— \\(p\\)â€‹â€‹è§†ä½œç½®æ¢ï¼Œå°†ä½ç½®è§†ä¸ºç‚¹ï¼Œæ¯ä¸ªæ•°ç”±å½“å‰ä½ç½®æŒ‡å‘ç›®æ ‡ä½ç½®ï¼Œå³å»ºè¾¹ \\(i\\to p_i\\)â€‹â€‹ å¾—åˆ°è‹¥å¹²ä¸ªç¯ã€‚æˆ‘ä»¬çš„ç›®æ ‡æ˜¯è®©æ‰€æœ‰çš„ \\(i\\)â€‹ æ»¡è¶³\\(i \\to i\\)â€‹ ï¼Œå³ \\(\\forall i, p_i = i\\)â€‹ â€‹å˜ä¸ºå•ä½ç½®æ¢ã€‚å› æ­¤å¯¹äºæŸæ¬¡äº¤æ¢ï¼Œæ“ä½œéƒ½ä¼šå½¢å¦‚å°† \\(p_i\\)â€‹ å’Œ \\(p_{p_i}\\)â€‹â€‹ è¿›è¡Œäº¤æ¢ï¼Œä¹Ÿå°±æ˜¯å°†ç¬¬ \\(i\\) ä½çš„æ•°å’Œç¬¬ \\(p_i\\) ä½çš„æ•°äº¤æ¢ã€‚é‚£ä¹ˆå¯¹äºåŸæ¥æ‰€åœ¨ç¯ä¸­çš„ç»“æ„ \\(i\\to p_i, p_i\\to p_{p_i}\\)â€‹ ï¼Œå˜æ¢åç¬¬ \\(i\\)â€‹ä¸ªä½ç½®ä¸Šå˜ä¸º \\(p_{p_i}\\)â€‹ ï¼Œè€Œç¬¬ \\(p_i\\) ä½ä¸Šçš„æ•°å˜ä¸º \\(p_i\\)â€‹â€‹â€‹ä¹Ÿå°±æ˜¯è¯´ï¼Œå¯¹äºæ¯ä¸ªç¯ï¼Œæ¯æ¬¡äº¤æ¢ç›¸å½“äºå°†ç¯ä¸Šçš„ä¸€ä¸ª \\(a\\to b\\to c\\) ç»“æ„å˜ä¸º \\(a\\to cï¼Œb\\to b\\)â€‹â€‹â€‹â€‹â€‹ç›®æ ‡æ˜¯å½¢æˆ \\(n\\)â€‹ä¸ªè‡ªç¯ï¼Œå› æ­¤æ¯ä¸ªç¯éœ€è¦ç¯é•¿ \\(-\\ 1\\)â€‹æ¬¡ç§»åŠ¨æ‰èƒ½å°†ç¯å†…å½’ä½ï¼Œè€Œä¸åŒçš„ç¯ä¹‹é—´è¿˜åŸè¿‡ç¨‹æ— å…³ã€‚ è€ƒè™‘ä½ç½®é€‰æ‹©çš„é™åˆ¶æ¡ä»¶ï¼Œæˆ‘ä»¬å°†å‰ \\(n\\) ä¸ªç‚¹æŸ“æˆé»‘è‰²ï¼Œå \\(m\\) ä¸ªç‚¹æŸ“æˆç™½è‰²ã€‚ å¯ä»¥å‘ç°ï¼Œæ¯æ¬¡å¯ä»¥æ“ä½œçš„çº¦æŸæ¡ä»¶ç­‰ä»·äºæ¯æ¬¡åˆ æ‰çš„è¾¹è¦æ»¡è¶³è¿æ¥çš„ä¸¤ä¸ªç‚¹é¢œè‰²ä¸åŒã€‚ å¯¹äºä¸€ä¸ªç”±è‹¥å¹²æ®µç™½é»‘äº¤æ›¿è¿æ¥çš„ç¯ï¼Œæˆ‘ä»¬ä¸€å®šå¯ä»¥é€šè¿‡ç™½ç‚¹åƒæŒ‡å‘çš„é»‘è‰²çš„ç‚¹ï¼Œå°†æ•´ä¸ªç¯å˜æˆåªå‰©ä¸‹ä¸€ä¸ªé»‘è‰²ï¼Œç„¶åç”¨è¿™ä¸ªé»‘è‰²åˆ æ‰æ‰€æœ‰å…¶ä»–ç™½è‰²ï¼Œæ€»æ¬¡æ•°ä¸ºç¯é•¿ \\(-1\\)â€‹ å¯¹äºä¸€ä¸ªåªæœ‰æŸä¸€ç§é¢œè‰²çš„ç¯ï¼Œæˆ‘ä»¬éœ€è¦è€ƒè™‘â€œå¼•å…¥â€å¦ä¸€ç§é¢œè‰²ï¼Œéœ€è¦èŠ±è´¹ä¸€æ­¥çš„ä»£ä»·è¿›è¡Œä¸€æ¬¡äº¤æ¢å¼•å…¥ï¼Œç„¶ååˆ†æå¦‚ä¸Šï¼Œæ­¤æ—¶ç¯é•¿å› ä¸ºå¼•å…¥ \\(+1\\)â€‹â€‹ ï¼Œå› æ­¤æ€»æ¬¡æ•°ä¸ºåŸæ¥ç¯é•¿ \\(+1\\)â€‹â€‹ è€ƒè™‘éƒ½æœ‰â€œå¼•å…¥â€éœ€æ±‚ï¼Œä½†é¢œè‰²ä¸åŒçš„ä¸¤ä¸ªå•è‰²ç¯ï¼Œæ­¤æ—¶æŸä¸€ä¸ªç¯å¼•å…¥å¯¹æ–¹çš„æŸä¸ªå…ƒç´ ï¼Œç›¸å½“äºå¸®åŠ©äº†å¯¹æ–¹å¼•å…¥ï¼Œå› æ­¤ä¸¤ä¸ªç¯ä¹‹éœ€è¦ä¸€æ¬¡â€œå¼•å…¥â€ ï¼Œå¹¶ä¸”ä¸¤ä¸ªç¯å…±äº«çš„å¼•å…¥çš„é•¿åº¦ ï¼Œæ€»æ¬¡æ•°ä¸ºç¬¬ä¸€ä¸ªç¯é•¿+ç¬¬äºŒä¸ªç¯é•¿ ç»¼ä¸Šï¼Œå¯¹äºåŒè‰²ç¯ï¼Œæˆ‘ä»¬æ‰€éœ€æ¬¡æ•°ä¸ºç¯é•¿ \\(-1\\) ï¼Œå•è‰²ç¯å…ˆé»˜è®¤ä»£ä»·ä¸ºç¯é•¿ \\(+1\\) ï¼Œæ¯åŒ¹é…ä¸Šä¸€å¯¹æ€»ä»£ä»· \\(-2\\) ã€‚ æ­¤å¤–æœ¬é¢˜æ— éœ€è€ƒè™‘å¤ªè¿‡å¤æ‚ï¼Œé¦–å…ˆåŒè‰²å•è‰²ç¯ä¹‹é—´èåˆæ²¡æœ‰æ„ä¹‰ï¼ˆå¯æ¯”è¾ƒå‰åä»£ä»·ï¼‰ï¼Œå…¶æ¬¡ä¸éœ€è¦è€ƒè™‘å•è‰²ç¯å’ŒåŒè‰²ç¯çš„èåˆï¼Œè¿™ç§æƒ…å†µå¯ä»¥çœ‹ä½œå…ˆå°†åŒè‰²ç¯å½’ä½ï¼Œå†å–æŸä¸€ä¸ªé•¿åº¦ä¸º \\(1\\)â€‹â€‹â€‹â€‹â€‹â€‹ çš„è‡ªç¯ä¸å•è‰²ç¯è¿›è¡Œèåˆã€‚ å¤„ç†è¿‡ç¨‹ä¸­åªæ¶‰åŠ dfs æ‰¾ç¯ï¼Œæ€»å¤æ‚åº¦ \\(O(n)\\) 123456789int cntl = 0, cntr = 0;for (int i = 1; i &lt;= n + m; ++i) if (!bl[i] &amp;&amp; i != p[i]) &#123; ++tot; dfs(i); ans += len[tot]; if (l[tot] &amp;&amp; r[tot]) --ans; else &#123;l[tot] ? ++cntl : ++cntr; ++ans;&#125; &#125;printf(&quot;%d\\n&quot;, ans - min(cntl, cntr) * 2);","categories":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://blog.gyx.me/categories/AtCoder/"},{"name":"AtCoder Regular Contest","slug":"AtCoder/AtCoder-Regular-Contest","permalink":"http://blog.gyx.me/categories/AtCoder/AtCoder-Regular-Contest/"}],"tags":[{"name":"Constructive Algorithm","slug":"Constructive-Algorithm","permalink":"http://blog.gyx.me/tags/Constructive-Algorithm/"},{"name":"Number Theory","slug":"Number-Theory","permalink":"http://blog.gyx.me/tags/Number-Theory/"}]},{"title":"Freshman Year","slug":"life/freshman","date":"2021-07-08T02:27:14.000Z","updated":"2021-07-15T02:27:14.000Z","comments":true,"path":"life/freshman/","link":"","permalink":"http://blog.gyx.me/life/freshman/","excerpt":"","text":"ä»Šå¤©æ˜¯ 2021 å¹´ 7 æœˆ 8 æ—¥ï¼Œæ˜ŸæœŸå››ã€‚ ä¸€å¹´å‰çš„ä»Šå¤©ï¼Œé«˜è€ƒæœ€åä¸€é—¨åˆšåˆšè€ƒå®Œã€‚èµ°å‡ºè€ƒåœºï¼Œå›åˆ°è‡ªå·±çš„æ•™å®¤ï¼Œæ‹¿æ‰‹æœºï¼Œæ¬è¡Œæï¼Œå‘Šåˆ«ã€‚ ç¦»å¼€å­¦æ ¡çš„æ—¶å€™ï¼Œç¢°åˆ°äº†è¿˜åœ¨æ¢³ç†äº¤é€šçš„ç«èµ›æ•™ç»ƒï¼Œé—®æˆ‘è€ƒçš„æ€ä¹ˆæ ·ï¼Œç„¶åçº¦äº†åå¤©è¦ç»™é«˜ä¸€çš„å­¦å¼Ÿä»¬ä¸Šè¯¾ã€‚ ç›´åˆ°æ˜¨æ™šï¼Œæš‘å‡å›æœ¬éƒ¨ç»™åˆä¸€å±Šçš„å­¦å¼Ÿä»¬ä¸Šå®Œæœ€åä¸€å¤©è¯¾ã€‚ä»äºŒä¸­æœ¬éƒ¨çš„æ ¡é—¨é‡Œèµ°å‡ºæ¥ï¼Œå›å¤´çœ‹çœ‹ã€‚ æ¥æ­ç”µä¹‹å‰ é«˜è€ƒå®Œå°±è·Ÿçˆ¸çˆ¸å¦ˆå¦ˆè¯´æˆ‘ä¸å¤è¯»ï¼Œå½“æ™šå°±å¯¹ç­”æ¡ˆï¼Œå¤§æ¦‚ 645ã€‚æŠ¥äº†å—ç§‘å¤§ç»¼è¯„ï¼Œæ‹¿åˆ°äº†è¿˜ç®—ä¸é”™çš„æ ¡è€ƒåˆ†ã€‚ ç„¶ååœ¨å—æ ¡åŒºç»™é«˜ä¸€çš„åŒå­¦è®²äº†æ¯”è¾ƒå…¥é—¨çš„æ¦‚ç‡ï¼Œä¹Ÿæ˜¯é‚£äº›åœ¨ä¸€å¹´å‰çš„æš‘å‡è®¤è¯†çš„ï¼Œåˆšè¸å…¥äºŒä¸­å¤§é—¨å­¦å¼Ÿã€‚ ç»“æŸçš„æ—¶å€™åœ¨ç©ºç©ºçš„å­¦æ ¡é‡Œæºœè¾¾ï¼Œæƒ³æƒ³ä»–ä»¬ä¸Šè¯¾æ—¶å€™é‚£ç§çº¯ç²¹çš„çƒ­æƒ…ï¼Œä¸€ä»£åˆä¸€ä»£ï¼Œå¤šå°‘æœ‰ä¸€ç‚¹æ„Ÿæ…¨ã€‚ èµ°ä¹‹å‰æ‹äº†å¼ ç…§ç‰‡ï¼Œæƒ³èµ·æ¥ä¸€å¥è‡ªè®¤ä¸ºå¾ˆåº”æ™¯çš„è¯ï¼šâ€œé›¨è¿‡å¤©é’äº‘ç ´å¤„ï¼Œè€…èˆ¬é¢œè‰²åšå°†æ¥â€ è¿ç€ä¸‹äº†ä¸¤ä¸‰å¤©çš„å°é›¨ï¼Œåªå‰©ä¸‹ç«èµ›ç”Ÿçš„äºŒä¸­ å‡ºåˆ†çš„æ™šä¸Šæ¯”è¾ƒå¦ç„¶ï¼Œæå‰å‡ åˆ†é’ŸæŸ¥åˆ°äº†åˆ†æ•°ï¼Œæ¯”ä¼°è®¡çš„ä½ 9 åˆ†ï¼Œéƒ½æ‰£åœ¨è¯­æ–‡ä¸Šï¼Œ115 / 134 / 136 / 251ã€‚ ä¹‹åçš„å‡ å¤©æ¯”è¾ƒè¿·èŒ«ï¼Œå¬äº†å‡ ä¸ªå­¦æ ¡çš„æ‹›ç”Ÿå®£è®²éƒ½ä¸å°½å¦‚äººæ„ã€‚å—ç§‘å¤§é‚£è¾¹å‡ åº¦æœ‰å¸Œæœ›ï¼Œåæ¥ç»ˆç©¶æ˜¯è½ç©ºã€‚ åœ¨æˆ‘æƒ³èµ·æ¥æ­ç”µè¿™æ‰€å­¦æ ¡çš„æ—¶å€™ï¼Œçªç„¶æ„Ÿè§‰å°±æ˜¯è¦å»è¿™é‡Œäº†ã€‚ å¯èƒ½æ˜¯é«˜äºŒå»å­¦å†›åŸ¹è®­å–œæ¬¢ä¸Šäº†æ­å·è¿™ä¸ªåŸå¸‚ï¼Œä¹Ÿå¯èƒ½æ˜¯å¯¹ç«èµ›ç”Ÿæ¶¯ç»“æŸçš„ä¸ç”˜å§ã€‚ å…ˆè‡ªå·±å·å·æ‰¾ Claris è¦åˆ°äº†æ•™ç»ƒçš„è”ç³»æ–¹å¼ï¼Œé—®äº†è¯»ç ”å’Œä¸“ä¸šçš„äº‹æƒ…ï¼Œåˆ˜è€å¸ˆçš„çƒ­æƒ…çš„æ­å·è¯è®©äººå¾ˆèˆ’æœã€‚ ç„¶åå°±æ˜¯å°å¿ƒç¿¼ç¿¼åœ°å’Œçˆ¶æ¯äº¤æµï¼Œè¯´æˆ‘è‡ªå·±çš„æƒ³æ³•å’Œè€ƒè™‘ï¼Œç›´åˆ°æœ€åå¿ƒé‡Œååˆ†è¸å®åœ°å¡«ä¸Šäº†ç¬¬ä¸€å¿—æ„¿ã€‚ å½•å–çš„ç»“æœæ˜¯æ•°å­¦ç³»ï¼Œé«˜è€ƒåˆ†æ•°è¾¾åˆ°äº†å“è¶Šå­¦é™¢äºŒæ¬¡é€‰æ‹”çš„æŠ¥ååˆ†æ•°çº¿ï¼ŒæŠ¥äº†å“è¶Šå­¦é™¢çš„æ‹›ç”Ÿè€ƒè¯•ã€‚ ä¹‹åçš„å‡æœŸå†™äº†å‡ ä¸ªæ¿å­ï¼Œæ‰“äº†å‡ åœº CF æ¢å¤ä¸€ç‚¹æ°´å¹³ï¼Œå‚åŠ äº† HDU çš„å‡ åœºå†…éƒ¨è®­ç»ƒï¼Œæ¬äº†ä¸€å¥—é¢˜æ°çƒ‚é’±ã€‚ å¼€å­¦ä¹‹å‰å’Œå²³è€å¸ˆåƒäº†ä¸ªé¥­ï¼ˆç«Ÿç„¶è¿˜èµ¶ä¸Šäº†ä»–ç”Ÿæ—¥ï¼‰ï¼Œ è®©æˆ‘é‡å¿ƒä¸è¦å…¨éƒ¨æ”¾åˆ°ç«èµ›ä¸Šï¼Œè¦ç»™è‡ªå·±ç•™ä¸ªåè·¯ã€‚ åˆåˆ°æ­ç”µ æœ‰ä¸€è¯´ä¸€å‡æœŸè¿˜æ˜¯è¿‡çš„æ¯”è¾ƒéšæ„ï¼Œè™½ç„¶æŠ¥åäº†å“è¶Šå­¦é™¢ï¼Œä½†æ˜¯ä¸€ç‚¹æ²¡å‡†å¤‡ï¼Œ9 æœˆä»½å¿å¿‘åœ°å°±æ¥åˆ°æ­ç”µå•¦ã€‚ è€ƒè¯•ä¹‹å‰è‡ªå·±å¾ˆæ²¡æœ‰åº•æ°”ï¼Œå½“æ—¶è§‰å¾—èƒ½è¿›è®¡ç§‘ç­å°±ä¸é”™äº†ã€‚è€ƒå®Œè§‰å¾—è€ƒçš„è¿˜è¡Œï¼Œå› ä¸ºç«èµ›é‡Œæ¥è§¦è¿‡ä¸€ç‚¹é«˜æ•°çº¿ä»£çš„çŸ¥è¯†ï¼Œè§‰å¾—è‡ªå·±è‹±è¯­é˜…è¯»ä¹Ÿæ¯”è¾ƒä¼šè’™ã€‚ç„¶åæ™šä¸Šå¤§æ¦‚ä¹ç‚¹çš„æ—¶å€™å‡ºæˆç»©äº†ï¼Œéœ‡æƒŠè‡ªå·±ç«Ÿç„¶è¿‡äº†è‹±æ‰ç­çš„çº¿ã€‚ æ™šä¸Šç»™çˆ¸çˆ¸å¦ˆå¦ˆå¾ˆæ¿€åŠ¨åœ°æ‰“äº†ä¸ªç”µè¯ï¼Œæœ‰ç‚¹æ‹…å¿ƒ 11 è¿› 9 è¢«åˆ·æ‰ï¼Œä¸€ç›´åˆ°åäºŒç‚¹å¤šæ‰ç¡ç€ã€‚ ç¬¬äºŒå¤©é¢è¯•çš„æ—¶å€™å…¶å®è‡ªå·±æ¯”è¾ƒè½»æ¾ï¼Œæ„Ÿè§‰é¢è¯•å‘æ¥éƒ½æ¯”è¾ƒç¨³ æ¯”è¾ƒä¼šå¹ ï¼Œé¢è¯•å•ç‹¬é¢ï¼Œäº”ä¸ªè€å¸ˆã€‚ é¢è¯•æ¯”è¾ƒè‡ªç„¶ï¼Œè€å¸ˆä»¬çš„é—®é¢˜åŸºæœ¬æ˜¯è·Ÿç€æˆ‘çš„è‡ªæˆ‘ä»‹ç»æ€è·¯èµ°ï¼Œä¸è¿‡è¿˜æ˜¯æœ‰å‡ ä¸ªé—®é¢˜è¡€å‹æ‹‰æ»¡ã€‚ æˆ‘åŠªåŠ›åœ°å¼ºè°ƒè‡ªå·±çš„ç«èµ›æ°´å¹³ï¼Œç„¶åå†¯è€å¸ˆé—®ï¼šâ€œç°åœ¨è®©ä½ å»æ‰“åŒºåŸŸèµ›èƒ½æ‹¿åˆ°ä»€ä¹ˆå¥–é¡¹ï¼Ÿâ€ æˆ‘ä»‹ç»äº†ä¸€ä¸‹é«˜ä¸­å­¦æ ¡å’Œç­çº§çš„æƒ…å†µï¼Œç„¶åå¦ä¸€ä¸ªè€å¸ˆé—®ï¼šâ€œä½ è§‰å¾—äºŒä¸­å’Œè¡¡ä¸€å“ªä¸ªæ›´å¥½ï¼Ÿâ€ å‘¨è€å¸ˆï¼ˆä¹Ÿæ˜¯ç°åœ¨çš„å¯¼å¸ˆï¼‰é—®ï¼šâ€œä½ ä¹Ÿä¸èƒ½æ‰“ä¸€è¾ˆå­ç«èµ›å•Šã€‚ä»¥åæœ‰ä»€ä¹ˆè¿›ä¸€æ­¥çš„æ‰“ç®—ï¼Ÿâ€ æˆ‘è¯´ä¼šè¯»ç ”ï¼Œä»¥åå¯èƒ½ä¼šå»å½“å¤§å­¦è€å¸ˆã€‚å¯¼å¸ˆç¬‘ç¬‘è¯´è¦æƒ³å½“æ•™æˆï¼Œåé¢å¾—å»å¥½ç‚¹çš„å¤§å­¦è¯»ä¹¦ã€‚ é¢è¯•å®Œå‡ºæ¥è§‰å¾—è‡ªå·±è¿˜æŒºç¨³çš„ï¼Œä½†æ˜¯ä¹Ÿä¸æ•¢ç¡®å®šï¼Œå¿å¿‘åˆ°äº†æ™šä¸Šåç‚¹å¤šå‡ºäº†ç»“æœã€‚ç»ˆäºè¿˜æ˜¯å»å­¦è®¡ç®—æœºäº†ã€‚ ä¹‹åçš„ç”Ÿæ´»å¾ˆé¡ºåˆ©ï¼Œè§é¢ä¼šï¼Œæ­£å¸¸ä¸Šè¯¾ï¼Œç­å§”é€‰ä¸¾ï¼ˆå½“äº†å­¦å§”ï¼‰ã€‚ ä¸Šè¯¾çš„æ—¶å€™å¼ºè¿«è‡ªå·±å»æé—®ï¼Œå›ç­”é—®é¢˜ï¼Œæ„è¯†åˆ°è‡ªå·±å¯ä»¥åšä¸€äº› ç”±è‡ªå·±å†³å®šçš„ æƒ³åšä»€ä¹ˆå°±åšä»€ä¹ˆ çš„äº‹ã€‚ é‡åˆ°äº†è‡ªå·±å–œæ¬¢çš„è€å¸ˆï¼Œæœ‰èƒ½å¤Ÿèˆ’é€‚ç›¸å¤„ï¼ŒçœŸå¿ƒç›¸å¾…çš„ä¸€å¸®åŒå­¦ï¼Œæ…¢æ…¢åœ°ä»é«˜ä¸‰ç—›è‹¦è‡ªé—­çš„çŠ¶æ€èµ°å‡ºæ¥äº†ã€‚ ç«èµ› è¿™æ®µè¯ä¹Ÿæƒ³å†™ç»™æ¯ä¸ªå­¦ç«èµ›è¿‡ç¨‹ä¸­æ„Ÿåˆ°æ— åŠ›çš„åŒè¡Œè€…ã€‚ ç®—æ³•ç«èµ›çš„é­…åŠ›åœ¨äºï¼Œé€šè¿‡åŠªåŠ›ç§¯ç´¯æˆ–çµæœºä¸€åŠ¨ï¼Œä½ èƒ½å¤Ÿåšå‡ºè¶Šæ¥è¶Šéš¾çš„é¢˜ç›®ï¼Œæ˜¯ä¸€ç§å¯¹è‡ªæˆ‘èƒ½åŠ›çš„è®¤å¯ã€‚ ç®—æ³•ç«èµ›çš„å±é™©äº¦åœ¨äºï¼Œä½ å­¦ä¼šçš„ä¸œè¥¿è¶Šå¤šï¼Œè®¤è¯†çš„å‰å®³çš„äººè¶Šå¤šï¼Œé¢å¯¹ä¸å¯è®¡æ•°çš„å¼ºè€…ï¼Œå¾ˆå®¹æ˜“é™·å…¥è‡ªæˆ‘å¦å®šã€‚ æƒ³åˆ°æ­ç”µä¹‹å‰ï¼Œå¾ˆé•¿ä¸€æ®µæ—¶é—´éƒ½è§‰å¾—ï¼Œå¤§å­¦ä¸ä¼šå†æ‰“ç«èµ›äº†ã€‚ å­¦ç«èµ›çš„è¿‡ç¨‹ä¸­ç»å†çš„æ‰“å‡»ï¼Œä¸ä»…æ˜¯æ¯”èµ›å’Œä¸Šè¯¾ä¸­å—åˆ°ä¸€ä¼—ç¥ä»™å±…é«˜ä¸´ä¸‹çš„å‹è¿«æ„Ÿï¼Œæ›´å¤šçš„å…¶å®æ˜¯å‘¨å›´äººä¸ç»æ„çš„å¦å®šå’Œå®‰æ…°ã€‚å¯¹æˆ‘æ¥è¯´ï¼Œè¿™æ˜¯ä¸€ç§å¯¹ä¿¡å¿ƒå¾ˆå¤§çš„æ‰“å‡»ï¼Œä¼šæƒ³è¦è¯æ˜è‡ªå·±ï¼Œäº¦æˆ–æ˜¯å¿ƒé‡Œæ„Ÿåˆ°æ— åŠ›è€Œæ•…ä½œè½»æ¾ã€‚ åœ¨é¢ä¸´æ˜¯å¦ä¹° D çš„æŠ‰æ‹©æ—¶ï¼Œæˆ‘æ”¾å¼ƒäº†ã€‚ä¸æ˜¯æ‹…å¿ƒå–å¾—ä¸äº†ä»€ä¹ˆç»“æœï¼Œè€Œæ˜¯è§‰å¾—å‹åŠ›å¤ªå¤§äº†ã€‚ åœ¨é€‰å­¦æ ¡çš„æ—¶å€™ï¼Œçªç„¶æƒ³åˆ°æ­ç”µçš„é‚£ä¸€åˆ»ï¼Œæœ‰ç§æ­»ç°å¤ç‡ƒçš„æ„Ÿè§‰ã€‚ è®°èµ·æ¥ NOIP 2018 ç»“æŸçš„æ—¶å€™ï¼Œåœ¨å­˜çœŸæ¥¼ä¸‹ï¼Œå­™æ ¡é•¿å’Œæˆ‘ä»¬å‡ ä¸ªåˆšä»ç§¦çš‡å²›å›æ¥çš„å­¦ç”Ÿè¯´çš„å‡ å¥è¯ï¼š â€œå­¦åˆ«çš„ç«èµ›çš„ï¼Œæœ€ç»ˆçš„å‘å±•å’Œç«èµ›ä¸ä¸€å®šæœ‰å…³ç³»ï¼Œä½†æ˜¯ç®—æ³•ç«èµ›çš„å­¦ç”Ÿï¼Œæœ€ç»ˆå¾€å¾€éƒ½ä¼šé€‰æ‹©è®¡ç®—æœºè¡Œä¸šã€‚â€ ç®—æ³•ç«èµ›ä¼šåœ¨å¿ƒé‡ŒåŸ‹ä¸‹ä¸€é¢—ç§å­ã€‚ æˆ‘ä¸æ˜¯é‚£ç§ä¸€å¸†é£é¡ºçš„å¤©æ‰ï¼Œåœ¨å—åˆ°æ‰“å‡»çš„æ—¶å€™ï¼Œæˆ‘ä¼šæ„Ÿåˆ°æ— åŠ›ã€‚ ä½†å½“æˆ‘æŠ›å¼€ååˆ©ã€å’Œä»–äººæ¯”è¾ƒã€è¯æ˜è‡ªå·±è¿™äº›åŠŸåˆ©çš„æ„ä¹‰ä¹‹åï¼Œæˆ‘å‘ç°è‡ªå·±è¿˜å‰©ä¸‹äº›ä¸œè¥¿ï¼Œè¿˜èƒ½çœ‹åˆ°åˆå¿ƒã€‚ æ˜¯å¯¹ç®—æ³•çš„æ¬£èµå’Œçƒ­çˆ±ï¼Œæ˜¯ç†è§£æ¯ä¸€ä¸ªç®—æ³•ã€åšå‡ºæ¯ä¸€ä¸ªé¢˜ç›®çš„ç¬é—´ï¼Œç²¾ç¥ä¸Šçš„äº«å—ï¼Œè¿™å°±å¤Ÿäº†ã€‚ è‡³å°‘åœ¨æˆ‘çœ‹æ¥ï¼Œä»æˆ‘å¼€å§‹æ¥è§¦ç«èµ›ï¼Œåˆ°åšå‡ºå¾ˆå¤šé‡è¦çš„é€‰æ‹©ï¼Œæˆ‘å†³ç­–çš„åˆå¿ƒä»æ¥éƒ½ä¸æ˜¯ååˆ©ï¼Œå› ä¸ºå¯¹ç®—æ³•è¿˜çˆ±ç€ã€‚å†³å®šæœ€ç»ˆæ²¡æœ‰ä¹° D ç±»ï¼Œæœ€å¤§çš„åŸå› è¿˜æ˜¯åœ¨é‚£ä¸ªæ—¶åˆ»ï¼Œç«èµ›å¸¦æ¥çš„ç—›è‹¦è¶…è¿‡äº†å­¦ä¹ çš„äº«å—ï¼Œè¢«ä¸€æ¬¡æ¬¡çš„æ’åè£¹æŒŸï¼Œè¢«å„ç§æœºä¼šæ‰€å¸å¼•ï¼Œæˆ‘è¶Šæ¥è¶Šåƒä¸€ä¸ªæ²¡æœ‰è‡ªæˆ‘çš„æœºå™¨ï¼Œè¶Šæ¥è¶Šè¢«æˆåŠŸå­¦ç‰¢ç‰¢é”æ­»ã€‚è€Œåœ¨æˆ‘é€‰æ‹©å¤§å­¦çš„æ—¶å€™ï¼Œç«èµ›å¯¹æˆ‘çš„æ„ä¹‰ä¸å†æ˜¯æœªæ¥çš„å…¨éƒ¨äº†ã€‚æˆ‘èƒ½å¤Ÿé™ä¸‹æ¥ï¼Œé—®é—®è‡ªå·±å¯¹ç®—æ³•è¿˜æœ‰æ²¡æœ‰é‚£ç§è¿‘ä¹ç—´è¿·çš„å–œçˆ±ï¼Œèƒ½å¤Ÿå°†å®ƒä½œä¸ºä¸€ç§å…´è¶£å»å‘å±•ï¼Œä¸éœ€è¦è€ƒè™‘ä»˜å‡ºå’Œå›æŠ¥ï¼Œè‡³å°‘åœ¨å¤§å­¦ï¼Œæˆ‘è¿˜æ˜¯æœ‰è‡ªç”±æ”¯é…è‡ªå·±çš„æƒåˆ©ã€‚ æˆ‘è¿˜æ˜¯é‚£ä¸ªæ·±æ·±çˆ±ç€ç®—æ³•çš„å°å­©ï¼Œå¯¹å‡ åè¡Œä»£ç èƒŒåçš„æ™ºæ…§å¦‚ç—´å¦‚é†‰ã€‚ Gold Medal (30th Place) : The 45th ICPC Asia Jinan Regional Contest, 2020 Gold Medal ( 15th Place) : The 18th Zhejiang Provincial Collegiate Programming Contest, 2021 Silver Medal (28th Place) : The 45th ICPC Asia Shenyang Regional Contest, 2021 è¯¾å†…å­¦ä¹  ç¬¬ä¸€ä¸ªå­¦æœŸä¸ä¼šé€‰è¯¾ï¼Œä¿®äº†ç³»ç»Ÿé»˜è®¤çš„ 25.25 ä¸ªå­¦åˆ†ï¼Œ ç¬¬äºŒä¸ªå­¦æœŸä¿®äº† 32.25 ä¸ªå­¦åˆ†ã€‚ é€šè¯†é€‰ä¿®åªå®Œæˆäº†ç§‘æŠ€å‘å±•ä¸ç§‘å­¦ç²¾ç¥ï¼Œå¤§äºŒä¸Šåº”è¯¥ä¼šæŠŠå‰©ä¸‹çš„æŒ‡æ ‡ä¿®å®Œã€‚ æ•°ç†åŸºç¡€ æ•°åˆ† ï¼ˆ6 * 3.5 + 5 * 4.2ï¼‰ã€é«˜ä»£ï¼ˆ3 * 5 + 2 * 5ï¼‰ã€ç¦»æ•£ï¼ˆ4 * 5ï¼‰ã€å¤§ç‰©1ï¼ˆ3 * 5ï¼‰ CSä¸“ä¸šè¯¾ è®¡å¯¼ï¼ˆ2 * 5ï¼‰ã€ç¨‹è®¾åŸºç¡€ï¼ˆ5 * 5ï¼‰ã€æ•°æ®ç»“æ„ï¼ˆ4 * 4.5ï¼‰ã€C++ é¢å‘å¯¹è±¡ï¼ˆ3 * 5ï¼‰ é€šè¯†æ•™è‚² æ€ä¿®æ³•åŸºï¼ˆ3 * 5ï¼‰ã€å¿ƒç†å¥åº·ï¼ˆ1 * 4.3ï¼‰ã€å¤§å†›ï¼ˆ2 * 4.8ï¼‰ã€ACMï¼ˆ2 * 5ï¼‰ å¤–è¯­ç±» è‹±è¯­ç²¾è¯» Aï¼ˆ2 * 4.4 + 2 * 4.6ï¼‰ã€è‹±è¯­å¬è¯´ Aï¼ˆ1 * 4.3 + 1 * 4.7ï¼‰ã€å®ç”¨ç¿»è¯‘ï¼ˆ2 * 4.6ï¼‰ å…¶ä»– å¤§å­¦å¯ç¤ºå½•ï¼ˆ1 * 4ï¼‰ã€å½¢å¼ä¸æ”¿ç­–ï¼ˆ0.5 * 5ï¼‰ã€ç§‘ç ”å®è·µï¼ˆ1 * 5ï¼‰ã€ä½“è‚²ï¼ˆ1 * 2.1 + 1 * 1.8ï¼‰ å¾ˆå¹¸è¿çš„æ˜¯é‡åˆ°çš„è€å¸ˆéƒ½å¾ˆè®¤çœŸè´Ÿè´£ï¼Œè€å¸ˆä»¬å¯¹è¯¾ç¨‹å†…å®¹éå¸¸äº†è§£ï¼Œè‡ªå·±é‡åˆ°é—®é¢˜ä¹Ÿéƒ½èƒ½å¾ˆå¥½æ²Ÿé€šã€‚ å¾ˆå¤šè¯¾ç¨‹éƒ½è§‰å¾—è‡ªå·±åšçš„æ²¡é‚£ä¹ˆå¥½ï¼Œå¯¹ç»™å‡ºçš„æˆç»©ä¹Ÿå¸¸å¸¸å—ä¹‹æœ‰æ„§ã€‚ æ•°å­¦åˆ†æå’Œé«˜ç­‰ä»£æ•°ä¸¤é—¨æ•°å­¦åŸºç¡€è¯¾çš„è¡¨ç°æˆªç„¶ç›¸åï¼Œè®©æˆ‘æ›´æ¸…æ¥šåœ°æ„è¯†åˆ°å¾ˆå¤§ç¨‹åº¦ä¸Šæˆ‘æ˜¯ä¸ªå…´è¶£é©±åŠ¨çš„äººã€‚ å¯¹æ•°åˆ†çš„çŸ¥è¯†ä½“ç³»è‡ªå·±æœ¬èº«å¯èƒ½å°±ä¸å¤ªæ„Ÿå…´è¶£ï¼ŒåŠ ä¸Šæ•°åˆ†è¯¾æ˜¯çœŸçš„æä¸èµ·æ¥ç²¾ç¥ï¼Œä¸¤ä¸ªå­¦æœŸçš„æ•°å­¦åˆ†ææˆç»©éƒ½ä¸å¤ªçœ‹çš„è¿‡å»ï¼Œæ•°åˆ†ä¸Šå¯èƒ½è¦åœ¨å¤§ä¸‰é‡ä¿®äº†ã€‚è€å¸ˆç¡®å®æƒ³è¦è®¤çœŸæ•™ä¼šæˆ‘ï¼Œå¯æ˜¯è‡ªå·±ç¡®å®æä¸èµ·å…´è¶£å»å­¦ã€‚ç»å†äº†æ•°åˆ†ä¸Šçš„æ´—ç¤¼ï¼Œæ•°åˆ†ä¸‹è¿˜æ˜¯é€¼ç€è‡ªå·±å­¦äº†å­¦ï¼Œæœ€åçš„ç»“æœç®—æ˜¯é©¬é©¬è™è™å§ï¼Œç¡®å®å¯¹ä¸èµ·è€å¸ˆå¯¹ä¸èµ·è‡ªå·±ã€‚ å¾ˆå–œæ¬¢é«˜ä»£è€å¸ˆçš„è¯¾ï¼Œå¾ˆå¤§ç¨‹åº¦é©±åŠ¨æˆ‘å»èŠ±ç›¸å¯¹æ¯”è¾ƒå¤šçš„æ—¶é—´åœ¨è¿™é—¨è¯¾ä¸Šã€‚ä¸¤ä¸ªå­¦æœŸæœ€åçš„ç»“æœéƒ½æ¯”è¾ƒå¥½ï¼Œåœ¨è‡ªå·±å–œæ¬¢çš„ç§‘ç›®ä¸Šèƒ½å¤Ÿçœ‹åˆ°è‡ªå·±åšäº†äº›äº‹æƒ…ï¼Œä¹Ÿæ˜¯è®©è‡ªå·±å¾ˆå¼€å¿ƒçš„ä¸€ä»¶äº‹ã€‚å”¯ä¸€é—æ†¾çš„æ˜¯æœŸæœ«é”™åœ¨äº†æœ€åä¸€èŠ‚è¯¾è€å¸ˆå¼ºè°ƒè¿‡çš„ä¸€ä¸ªå°ç‚¹ä¸Šï¼ˆè¯æ˜æ­£å®šé˜µéœ€å…ˆè¯´æ˜å¯¹ç§°ï¼‰ã€‚å¤§äºŒä¸‹é¢„å®šäº†è€å¸ˆçš„è¿‘ä¸–ä»£æ•°ã€‚ ä¹Ÿå¾ˆå–œæ¬¢ Cathy ä¸Šçš„è‹±è¯­ç²¾è¯»ï¼Œä¹Ÿç®—æ˜¯ç¬¬ä¸€æ¬¡èƒ½è®©æˆ‘ä¸»åŠ¨æèµ·æ¥å­¦è‹±è¯­çš„å…´è¶£ã€‚ Cathy çš„è¯¾æœ‰ä¸€ç§å¾ˆè½»æ¾çš„æ°”æ°›ï¼Œä¸ä¼šæŒ‰ç…§è¯¾æœ¬ä¸€æ¿ä¸€çœ¼çš„å»ä¸Šï¼Œè®²çš„å¾ˆå¤šä¸œè¥¿å¾ˆå—ç”¨ã€‚ æ„Ÿè°¢ç¨‹è®¾å’ŒOOPï¼ˆC++ï¼‰çš„è€å¸ˆå¯¹æˆ‘çš„åŒ…å®¹ï¼Œè‡ªå·±åœ¨è¿™ä¸¤é—¨è¯¾ä¸Šç¡®å®æœ‰è¿‡å¾ˆå¹¼ç¨šçš„è¡Œä¸ºã€‚å¾ˆä½©æœå°†è¿‘é€€ä¼‘çš„è€å¸ˆèƒ½ç²¾ç¡®æŠŠæ§å¾ˆå¤šç»†èŠ‚ï¼Œéšæ‰‹å†™çš„ä»£ç èƒ½ä¸€éè¿‡ç¼–è¯‘ä»€ä¹ˆé”™éƒ½æ²¡æœ‰ã€‚ ç¦»æ•£æ•°å­¦å’Œæ•°æ®ç»“æ„ ç»™äº†æˆ‘å¾ˆæ·±åˆ»çš„æ•™è®­ã€‚ä¸¤é—¨éƒ½æ˜¯è‡ªè®¤ä¸ºäº†è§£æ¯”è¾ƒå¤šçš„ï¼Œæ•°æ®ç»“æ„ç”šè‡³ç”³è¯·äº†å…å¬ã€‚è€ƒå‰å¤ä¹ çš„éƒ½ä¸æ˜¯å¾ˆå……åˆ†ï¼Œç­‰ä¸Šäº†è€ƒåœºå‘ç°è¦å¼€å§‹è„‘è¡¥ä¸€å †ä¸€å †çš„æ¦‚å¿µã€‚æœŸæœ«ç¦»æ•£å·å­ç®€å•ï¼Œæ²¡æš´éœ²å‡ºæ¥ä»€ä¹ˆé—®é¢˜ã€‚æ•°æ®ç»“æ„è§‰å¾—è‡ªå·±çœ‹çœ‹ä¹¦å°±å¤Ÿäº†ï¼Œæœ€åçš„æˆç»©å´ä¸å°½å¦‚äººæ„ï¼ŒåŸå› åªæ˜¯ä¸çŸ¥é“æ’åºé‡Œçš„ä¸€ä¸ªæ—¢å®šç»†èŠ‚ï¼Œåªèƒ½æ‚”ä¸å½“åˆã€‚ å¤§å­¦ç‰©ç†å’Œæ€æƒ³é“å¾·ä¿®å…»ä¸æ³•å¾‹åŸºç¡€ ä¸¤é—¨è¯¾ç»“æœæ„å¤–çš„å¥½ï¼Œå…¶å®è‡ªå·±è®¤çœŸå»å­¦ä¸€å­¦è¿˜æ˜¯å¯ä»¥æœ‰æ•ˆæœçš„ã€‚ä¸­å­¦é˜¶æ®µä¸€ç›´å¤´ç–¼çš„æ”¿æ²»åœ¨é—­å·çš„æœŸæœ«è€ƒè¯•ä¹Ÿå†™äº†ä¸ªå·®ä¸å¤šã€‚å­¦ä¸ä¼šç”µç£åœ¨è€ƒåœºä¸Šä¹Ÿåšå‡ºæ¥äº†ç»å¤§å¤šæ•°é¢˜ã€‚è€ƒè¯•é‡åˆ°ä¸ä¼šçš„é¢˜ä¹Ÿä¸èƒ½å¤ªç€æ€¥ï¼Œå¤šæƒ³ä¸€ä¼šæ²¡å‡†å°±é€šäº†ã€‚ ä½“è‚² ä»ä¸­è€ƒçš„ \\(18\\) åˆ†ä¿åº•ï¼Œåˆ°å¤§ä¸€ä¸Šçš„ä½“æµ‹ \\(36\\) åˆ†ï¼Œç—›å¤±ä¸¤ä¸ªå­¦æœŸçš„å¥–å­¦é‡‘ï¼Œç»ˆç©¶è¿˜æ˜¯æ²¡é€ƒè¿‡èº«ä½“ç´ è´¨ä¸è¡Œè¿™ä¸ªé—®é¢˜ã€‚è¿˜æ˜¯æ„Ÿè°¢ç¯å¢ƒé€¼ç€æˆ‘å»ç›´é¢ä½“è‚²ï¼ŒæŒ‰ç€ä½“èƒ½ç­çš„è¦æ±‚å¤§ä¸€ä¸‹ç»“ç»“å®å®æŠŠ 40 æ¬¡é˜³å…‰é•¿è·‘è·‘å®Œäº†ï¼Œä¹Ÿç¡®å®è®©æˆ‘çœ‹åˆ°è€åŠ›å¯ä»¥æœ‰æå‡ï¼Œä»æ“åœºè·‘ä¸€åœˆå°±å–˜ä¸ä¸Šæ°”ï¼Œåˆ°ä½“æµ‹çš„æ—¶å€™äººç”Ÿç¬¬ä¸€æ¬¡æŠŠ 1000 ç±³å…¨è·‘ä¸‹æ¥ï¼Œç¡®å®æ˜¯å¾ˆæ¿€åŠ¨çš„ã€‚ä¹Ÿç»ˆäºåœ¨é”»ç‚¼èº«ä½“ä¸Šæœ‰äº†åŠ¨åŠ›ï¼Œé¦–å…ˆæ˜¯å¤§äºŒä¸‹æƒ³è¦å’Œ qyy åŒå­¦ä¸€èµ·å­¦ä½“è‚²èˆï¼Œå…¶æ¬¡æ˜¯æƒ³è¦æ°å¥–å­¦é‡‘ã€‚ æˆ‘çš„å¥¹ åªæƒ³è¯´çˆ±æƒ…çš„ä½“éªŒæ˜¯ä¸€ç§å¾ˆçº¯ç²¹çš„å¹¸ç¦ã€‚ æ„¿æ„ä¸ºå¥¹ç‰ºç‰²è‡ªå·±çš„ä¸€åˆ‡ï¼Œæ— æ—¶æ— åˆ»éƒ½ä¼šæƒ³èµ·å¥¹çš„äº‹æƒ…ï¼Œæ‰¾ä¸åˆ°å¥¹ä¼šåå¦‚é’ˆæ¯¡ï¼Œä»€ä¹ˆéƒ½åšä¸ä¸‹å»ã€‚ å¥¹æ‰€é«˜å…´çš„äº‹æƒ…æ¯”å¥¹è¿˜é«˜å…´ï¼Œå¥¹éš¾å—çš„æ—¶å€™ä¼šè·Ÿç€ä¸€èµ·å“­å‡ºæ¥ï¼Œåœ¨çˆ±æƒ…ä¸­ä¸¤ä¸ªäººéƒ½å­¦ä¼šäº†å¦‚ä½•ç…§é¡¾å¯¹æ–¹ã€‚ ä¸¤ä¸ªäººåœ¨ä¸€èµ·å‘†ç€å¸¸å¸¸å¿ƒæœ‰çµçŠ€ï¼Œåšäº‹æƒ…ååº”å¦‚å‡ºä¸€è¾™ï¼Œå¾ˆå¤šäº‹æƒ…ä¸ç”¨è¨€è¯­ã€‚ ä¸¤ä¸ªäººåœ¨ä¸€èµ·å‘†ç€å°±æ˜¯æœ€å¿«ä¹çš„äº‹æƒ…ï¼Œèƒ½å¤Ÿä¸€èµ·å­¦ä¹ ï¼Œæ•£æ­¥ï¼Œå¥¹åœ¨æˆ‘çš„èº«è¾¹å°±èƒ½æ„Ÿå—åˆ°æ— æ¯”çš„è¸å®ã€‚ ä¼šèµ°åˆ°ä¸€èµ·çš„äººç»ˆç©¶ä¸ä¼šåˆ†å¼€ã€‚å¿ƒé‡Œå¯¹æœªæ¥æœ‰ç€æœŸç›¼ï¼Œé™ä¸‹å¿ƒæ¥è¸è¸å®å®åšäº‹ï¼Œç»§ç»­åŠ æ²¹ã€‚","categories":[{"name":"Life & Blog","slug":"Life-Blog","permalink":"http://blog.gyx.me/categories/Life-Blog/"}],"tags":[]},{"title":"Codeforces Round #723 (Div. 2)","slug":"codeforces/1526","date":"2021-03-28T16:00:00.000Z","updated":"2023-03-20T16:25:45.387Z","comments":true,"path":"codeforces/1526/","link":"","permalink":"http://blog.gyx.me/codeforces/1526/","excerpt":"","text":"A. Mean Inequality å°† \\(2n\\) ä¸ªä¸åŒçš„æ•°å­—æ’æˆä¸€ä¸ªå¾ªç¯ï¼Œä½¿å¾—ä»»æ„ä½ç½®çš„æ•°ä¸æ˜¯ç›¸é‚»ä¸¤ä¸ªæ•°çš„å¹³å‡å€¼ã€‚ ä»å°åˆ°å¤§æ’åºä¹‹åï¼Œå‰ \\(n\\) ä¸ªå’Œå \\(n\\) ä¸ªäº¤æ›¿æ”¾ã€‚ å› ä¸ºæ•°å­—ä¸¤ä¸¤ä¸åŒï¼Œå¤§çš„æ•°å­—ä¸å¯èƒ½æ˜¯ä¸¤ä¸ªå°çš„æ•°å­—çš„å¹³å‡æ•°ï¼Œå°çš„åŒç†ã€‚ 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125; int a[51];inline void work() &#123; int n = rd(); int m = 2 * n; for (int i = 1; i &lt;= m; ++i) a[i] = rd(); sort(a + 1, a + 1 + m); for (int i = 1; i &lt;= n; ++i) printf(&quot;%d %d &quot;, a[i], a[i + n]); puts(&quot;&quot;);&#125;int main() &#123; for (int t = rd(); t; --t) work(); return 0;&#125; B. I Hate 1111 è¯¢é—®ä¸€ä¸ªæ­£æ•´æ•° \\(x\\) æ˜¯å¦å¯ä»¥æ‹†åˆ†æˆè‹¥å¹²ä¸ª \\(11,111,1111,\\dots\\) çš„å’Œ æ ¹æ® éº¦ä¹é¸¡å®šç† ï¼Œ\\(11\\) å’Œ \\(111\\) å¯ä»¥ç»„æˆå¤§äº \\(11*111-111-11=1099\\) çš„ä»»ä½•æ•°ã€‚ æ‰€ä»¥åé¢çš„æ•°å­—éƒ½æ²¡ç”¨äº†ï¼Œ \\(x\\le 1099\\) çš„éƒ¨åˆ†åšä¸€ä¸‹ \\(11\\) å’Œ \\(111\\) çš„å®Œå…¨èƒŒåŒ…ï¼Œå…¶ä»–æƒ…å†µéƒ½æ˜¯ YES ã€‚ 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125; #define N 1100bool f[N];inline void work() &#123; int x = rd(); puts(x &gt;= N ? &quot;YES&quot; : (f[x] ? &quot;YES&quot; : &quot;NO&quot;));&#125;int main() &#123; f[0] = 1; for (int i = 11; i &lt; N; ++i) f[i] |= f[i - 11]; for (int i = 111; i &lt; N; ++i) f[i] |= f[i - 111]; for (int t = rd(); t; --t) work(); return 0;&#125; C. Potions ç»™ä¸€ä¸ªæ•°åˆ—ï¼Œæ±‚ä¸€ä¸ªæœ€é•¿çš„å­åºåˆ—ï¼Œä½¿å¾—å­åºåˆ—ä»»æ„å‰ç¼€å’Œéƒ½ \\(\\ge 0\\) ç»å…¸çš„å¸¦åæ‚”è´ªå¿ƒï¼Œç”¨ä¸€ä¸ªå°æ ¹å †ç»´æŠ¤æ‹¿äº†çš„æ•°å­—ã€‚ æ¯æ¬¡å…ˆæŠŠå½“å‰çš„æ‹¿äº†ï¼Œå¦‚æœå½“å‰çš„å’Œæ˜¯è´Ÿçš„ï¼Œå°±ä¸€ç›´å»æ‰å †é¡¶ç›´åˆ°åˆæ³•å³å¯ã€‚ è¿™æ ·å­åœ¨æ¯æ¬¡ç»“æŸçš„æ—¶å€™éƒ½æ˜¯æ­£çš„ï¼Œå¹¶ä¸”å»æ‰äº†æœ€å°‘çš„æ•°ã€‚ ç­‰æ•ˆçš„è´ªå¿ƒæ˜¯æ¯æ¬¡æ”¾è¿›æ¥å¦‚æœå˜æˆè´Ÿæ•°å°±çœ‹ä¸€ä¸‹èƒ½ä¸èƒ½æ›¿æ¢å †é¡¶ã€‚ 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125; priority_queue&lt;int&gt; q;int main() &#123; int n = rd(); int ans = 0; ll nw = 0; for (int i = 1, a; i &lt;= n; ++i) &#123; a = rd(); ++ans; nw += a; q.push(-a); while (nw &lt; 0) &#123; nw += q.top(); q.pop(); --ans; &#125; &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125; D. Kill Anton ç»™å®šä¸€ä¸ªå­—ç¬¦é›†åªæœ‰ 'A','D','O','T' çš„ä¸²ï¼Œå°†å…¶é‡æ’ä½¿å¾—æ¢å¤æˆåŸæ¥çš„æ‰€éœ€æ“ä½œæ¬¡æ•°æœ€å¤§ã€‚ æ“ä½œä¸€æ¬¡å¯ä»¥äº¤æ¢ä¸¤ä¸ªå­—ç¬¦çš„ä½ç½®ã€‚ çŒœä¸€ä¸‹æ“ä½œæ¬¡æ•°åªå’Œé€†åºæ•°ç›¸å…³ï¼ˆæˆ‘ä¸€ç›´ä¸å¤ªä¼šè¿™ç§çš„è¯æ˜ï¼‰ï¼Œæ‰€ä»¥ä¸€å®šå¯ä»¥æŠŠåŒä¸€ç±»å­—ç¬¦æ”¾åˆ°ä¸€èµ·ã€‚ è®° inv[i][j] è¡¨ç¤ºå­—ç¬¦ i å‰å­—ç¬¦j çš„é¡ºåºå¯¹æ•°ï¼Œå³å¦‚æœç»“æœä¸²ä¸­å­—ç¬¦ i åœ¨å­—ç¬¦ j å‰ï¼Œå¢åŠ çš„é€†åºæ•°ã€‚ å› æ­¤æšä¸¾ \\(4!\\) ç§æ’åˆ—ï¼Œè®¡ç®—ä¸€ä¸‹å“ªä¸€ç§é€†åºæ•°æœ€å¤§å³å¯ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const char tc[4] = &#123;&#x27;A&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;T&#x27;&#125;;ll cnt[4], inv[4][4];inline int tr(char c) &#123; if (c == &#x27;A&#x27;) return 0; if (c == &#x27;N&#x27;) return 1; return (c == &#x27;O&#x27; ? 2 : 3);&#125;string s;inline void work() &#123; cin &gt;&gt; s; for (int i = 0; i &lt; 4; ++i) &#123; cnt[i] = 0; for (int j = 0; j &lt; 4; ++j) inv[i][j] = 0; &#125; for (auto c : s) &#123; int i = tr(c); for (int j = 0; j &lt; 4; ++j) if (j != i) inv[i][j] += cnt[j]; ++cnt[i]; &#125; ll ans = -1; int p[4] = &#123;0, 1, 2, 3&#125;, res[4]; do &#123; ll tmpans = 0; for (int i = 0; i &lt; 4; ++i) for (int j = i + 1; j &lt; 4; ++j) tmpans += inv[p[i]][p[j]]; if (tmpans &gt; ans) &#123; ans = tmpans; for (int i = 0; i &lt; 4; ++i) res[i] = p[i]; &#125; &#125; while(next_permutation(p, p + 4)); for (int i = 0; i &lt; 4; ++i) for (int j = 1; j &lt;= cnt[res[i]]; ++j) putchar(tc[res[i]]); puts(&quot;&quot;);&#125;int main() &#123; int t; for (cin &gt;&gt; t; t; --t) work(); return 0;&#125; E. Oolimry and Suffix Array ç»™å®šåç¼€æ•°ç»„ï¼Œæ±‚æœ‰å¤šå°‘ä¸ªä¸²é•¿ä¸º \\(n\\) ï¼Œå­—ç¬¦é›†å¤§å°ä¸º \\(k\\) çš„å­—ç¬¦ä¸² \\(S\\) ç¬¦åˆè¿™ä¸ªåç¼€æ•°ç»„ åç¼€æ•°ç»„ \\(sa_i\\) è®°å½•çš„æ˜¯æ’åç¬¬ \\(i\\) ä½çš„åç¼€çš„å¼€å§‹ä¸‹æ ‡ã€‚ æ ¹æ®å­—å…¸åºè¦æ±‚ï¼Œ\\(S_{sa_i}\\) å’Œ \\(S_{sa_{i+1}}\\) åªæœ‰ä¸¤ç§å…³ç³»ï¼š\\(S_{sa_i}&lt;S_{sa_{i+1}}\\) æˆ– \\(S_{sa_i}=S_{sa_{i+1}}\\) å°äºä¸€å®šæ˜¯å¯ä»¥çš„ï¼Œç­‰äºçš„å……è¦æ¡ä»¶æ˜¯ \\(rank_{sa_i+1}&lt;rank_{sa_{i+1}+1}\\) ï¼Œå³å»æ‰ç¬¬ä¸€ä¸ªå­—ç¬¦å­—å…¸åºä¸å˜ã€‚ å› æ­¤æˆ‘ä»¬å¾—åˆ°äº†å«æœ‰ \\(n-1\\) ä¸ªä¸ç­‰å·çš„ä¸ç­‰å¼é“¾ï¼Œå‡è®¾å…¶ä¸­æœ‰ \\(a\\) ä¸ªæ˜¯ \\(\\le\\) ã€‚ æˆ‘ä»¬æšä¸¾æœ‰ \\(i\\) ä¸ª \\(\\le\\) å®é™…ä¸Šæ˜¯ \\(&lt;\\) ï¼Œé‚£ä¹ˆå®é™…å­—ç¬¦é›†å¤§å°æ˜¯ \\(n-i\\) ï¼Œæ–¹æ¡ˆæ•°å°±æ˜¯ \\[ \\sum_{i=0}^a{a\\choose i}{k\\choose n-i}={a+k\\choose n} \\] ç­‰å¼ä»ç»„åˆå«ä¹‰ç†è§£ï¼Œä» \\(a+k\\) ä¸ªé‡Œé€‰ \\(n\\) ä¸ªï¼Œå®šä»·äºæšä¸¾ä»å‰ \\(a\\) ä¸ªé‡Œé€‰ \\(i\\) ä¸ªï¼Œå‰©ä½™çš„ä»å \\(k\\) ä¸ªé‡Œé€‰ã€‚ 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int rd() &#123; int x = 0; bool f = 0; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == &#x27;-&#x27;); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;&#125;#define N 200007#define mod 998244353inline int fpow(int x, int t = mod - 2) &#123; int res = 1; for (; t; t &gt;&gt;= 1, x = 1ll * x * x % mod) if (t &amp; 1) res = 1ll * res * x % mod; return res;&#125;int rk[N], pos[N], fac[N &lt;&lt; 1] = &#123;1&#125;;int main() &#123; int n = rd(), k = rd(); for (int i = 1; i &lt;= n; ++i) rk[pos[i] = rd()] = i; for (int i = 1; i &lt; n; ++i) k += (rk[pos[i] + 1] &lt; rk[pos[i + 1] + 1]); if (k &lt; n) &#123;puts(&quot;0&quot;); return 0;&#125; for (int i = 1; i &lt;= k; ++i) fac[i] = 1ll * fac[i - 1] * i % mod; printf(&quot;%lld\\n&quot;, 1ll * fac[k] * fpow(fac[n]) % mod * fpow(fac[k - n]) % mod); return 0;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://blog.gyx.me/categories/Codeforces/"},{"name":"Codeforces Round","slug":"Codeforces/Codeforces-Round","permalink":"http://blog.gyx.me/categories/Codeforces/Codeforces-Round/"}],"tags":[{"name":"Greedy","slug":"Greedy","permalink":"http://blog.gyx.me/tags/Greedy/"},{"name":"Constructive Algorithm","slug":"Constructive-Algorithm","permalink":"http://blog.gyx.me/tags/Constructive-Algorithm/"},{"name":"Number Theory","slug":"Number-Theory","permalink":"http://blog.gyx.me/tags/Number-Theory/"},{"name":"Counting","slug":"Counting","permalink":"http://blog.gyx.me/tags/Counting/"}]},{"title":"Render Math Equations in Hexo","slug":"life/mathjax","date":"2019-05-31T16:00:00.000Z","updated":"2021-05-31T16:00:00.000Z","comments":true,"path":"life/mathjax/","link":"","permalink":"http://blog.gyx.me/life/mathjax/","excerpt":"","text":"\\[ f(a) = \\frac{1}{2\\pi i}\\oint_{\\gamma}\\frac{f(z)}{z-a}dz \\] Beautiful and accessible math in all browsers - MathJax This post is used to check out whether the mathjax plugin (hexo-math) still works. Inline Formula Consider the sequence of \\(n\\) distinct positive integers: \\(c_1, c_2, \\cdots, c_n\\). The child calls a vertex-weighted rooted binary tree good if and only if for every vertex \\(v\\), the weight of \\(v\\) is in the set \\(\\{c_1, c_2, \\cdots, c_n\\}\\) . Also our child thinks that the weight of a vertex-weighted tree is the sum of all vertices' weights. Given an integer \\(m\\), can you for all $s (1 s â‰¤ m) $ calculate the number of good vertex-weighted rooted binary trees with weight \\(s\\) ? Please, check the samples for better understanding what trees are considered different. We only want to know the answer modulo \\(998244353\\) ( \\(7 Ã— 17 Ã— 2^{23} + 1\\) , a prime number). Block Formula \\[ \\int \\frac{dx}{cos^2x}=\\int sec^2xdx=tan x+C\\ \\] \\[ \\int \\frac{dx}{sin^2x}=\\int csc^2xdx=-cot x+C\\ \\] \\[ \\sum\\limits_{i = 0}^{E} w[i]{M \\choose i} {N \\choose iS} \\frac{(iS)!}{(S!)^{i}} \\sum\\limits_{j = 0}^{E - i} (-1)^{j} {M - i \\choose j} {N - iS \\choose jS} \\frac{(jS)!}{(S!)^{j}} (M - i - j)^{N - iS - jS} \\] \\[ = \\sum\\limits_{i = 0}^{E} w[i]{M \\choose i} {N \\choose iS} \\frac{(iS)!}{(S!)^{i}} \\sum\\limits_{j = i}^{E} (-1)^{j - i} {M - i \\choose j - i} {N - iS \\choose jS - iS} \\frac{(jS - iS)!}{(S!)^{j - i}} (M - j)^{N - jS} \\] Matrix \\[ \\begin{bmatrix} (\\omega_n^0)^0 &amp; (\\omega_n^0)^1 &amp; \\cdots &amp; (\\omega_n^0)^{n-1}\\\\\\\\ (\\omega_n^1)^0 &amp; (\\omega_n^1)^1 &amp; \\cdots &amp; (\\omega_n^1)^{n-1}\\\\\\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\\\\\ (\\omega_n^{n-1})^0 &amp; (\\omega_n^{n-1})^1 &amp; \\cdots &amp; (\\omega_n^{n-1})^{n-1} \\end{bmatrix} \\begin{bmatrix} a_0 \\\\\\\\ a_1 \\\\\\\\ \\vdots \\\\\\\\ a_{n-1} \\end{bmatrix} = \\begin{bmatrix} A(\\omega_n^0) \\\\\\\\ A(\\omega_n^1) \\\\\\\\ \\vdots \\\\\\\\ A(\\omega_n^{n-1}) \\end{bmatrix} \\] \\[ \\begin{bmatrix} a_0 \\\\\\\\ a_1 \\\\\\\\ \\vdots \\\\\\\\ a_{n-1} \\end{bmatrix} = \\frac{1}{n} \\begin{bmatrix} (\\omega_n^{-0})^0 &amp; (\\omega_n^{-0})^1 &amp; \\cdots &amp; (\\omega_n^{-0})^{n-1} \\\\\\\\ (\\omega_n^{-1})^0 &amp; (\\omega_n^{-1})^1 &amp; \\cdots &amp; (\\omega_n^{-1})^{n-1} \\\\\\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\\\\\ (\\omega_n^{-(n-1)})^0 &amp; (\\omega_n^{-(n-1)})^1 &amp; \\cdots &amp; (\\omega_n^{-(n-1)})^{n-1} \\end{bmatrix} \\begin{bmatrix} A(\\omega_n^0) \\\\\\\\ A(\\omega_n^1) \\\\\\\\ \\vdots \\\\\\\\ A(\\omega_n^{n-1}) \\end{bmatrix} \\] To prevent escaping, you need to use \\\\\\\\ to make a new line rather than \\\\ . For more about the Mathjax symbols, refer to ï¼šThe Comprehensive LaTeX Symbol List .","categories":[{"name":"Life & Blog","slug":"Life-Blog","permalink":"http://blog.gyx.me/categories/Life-Blog/"}],"tags":[]},{"title":"Hello World","slug":"life/hello-world","date":"2018-11-28T16:00:00.000Z","updated":"2018-11-28T16:00:00.000Z","comments":true,"path":"life/hello-world/","link":"","permalink":"http://blog.gyx.me/life/hello-world/","excerpt":"","text":"ã€Œ Hello, the lovely world. ã€ ã€Œ Stay hungry, Stay foolish. ã€ 12345678910111213141516171819202122&gt;&gt;&gt; import thisThe Zen of Python, by Tim PetersBeautiful is better than ugly.Explicit is better than implicit.Simple is better than complex.Complex is better than complicated.Flat is better than nested.Sparse is better than dense.Readability counts.Special cases aren&#x27;t special enough to break the rules.Although practicality beats purity.Errors should never pass silently.Unless explicitly silenced.In the face of ambiguity, refuse the temptation to guess.There should be one-- and preferably only one --obvious way to do it.Although that way may not be obvious at first unless you&#x27;re Dutch.Now is better than never.Although never is often better than *right* now.If the implementation is hard to explain, it&#x27;s a bad idea.If the implementation is easy to explain, it may be a good idea.Namespaces are one honking great idea -- let&#x27;s do more of those!","categories":[{"name":"Life & Blog","slug":"Life-Blog","permalink":"http://blog.gyx.me/categories/Life-Blog/"}],"tags":[]}],"categories":[{"name":"Life & Blog","slug":"Life-Blog","permalink":"http://blog.gyx.me/categories/Life-Blog/"},{"name":"Summary","slug":"Summary","permalink":"http://blog.gyx.me/categories/Summary/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://blog.gyx.me/categories/Codeforces/"},{"name":"Codeforces Round","slug":"Codeforces/Codeforces-Round","permalink":"http://blog.gyx.me/categories/Codeforces/Codeforces-Round/"},{"name":"AtCoder","slug":"AtCoder","permalink":"http://blog.gyx.me/categories/AtCoder/"},{"name":"AtCoder Beginner Contest","slug":"AtCoder/AtCoder-Beginner-Contest","permalink":"http://blog.gyx.me/categories/AtCoder/AtCoder-Beginner-Contest/"},{"name":"Official Contests","slug":"Official-Contests","permalink":"http://blog.gyx.me/categories/Official-Contests/"},{"name":"Educational Codeforces Round","slug":"Codeforces/Educational-Codeforces-Round","permalink":"http://blog.gyx.me/categories/Codeforces/Educational-Codeforces-Round/"},{"name":"AtCoder Regular Contest","slug":"AtCoder/AtCoder-Regular-Contest","permalink":"http://blog.gyx.me/categories/AtCoder/AtCoder-Regular-Contest/"},{"name":"Algorithms","slug":"Algorithms","permalink":"http://blog.gyx.me/categories/Algorithms/"},{"name":"Misc Solutions","slug":"Misc-Solutions","permalink":"http://blog.gyx.me/categories/Misc-Solutions/"},{"name":"AtCoder Grand Contest","slug":"AtCoder/AtCoder-Grand-Contest","permalink":"http://blog.gyx.me/categories/AtCoder/AtCoder-Grand-Contest/"}],"tags":[{"name":"Algebra","slug":"Algebra","permalink":"http://blog.gyx.me/tags/Algebra/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.gyx.me/tags/Dynamic-Programming/"},{"name":"DFS and Similar","slug":"DFS-and-Similar","permalink":"http://blog.gyx.me/tags/DFS-and-Similar/"},{"name":"Markov Chains","slug":"Markov-Chains","permalink":"http://blog.gyx.me/tags/Markov-Chains/"},{"name":"Linear Basis","slug":"Linear-Basis","permalink":"http://blog.gyx.me/tags/Linear-Basis/"},{"name":"STL","slug":"STL","permalink":"http://blog.gyx.me/tags/STL/"},{"name":"Shortest Path","slug":"Shortest-Path","permalink":"http://blog.gyx.me/tags/Shortest-Path/"},{"name":"Counting","slug":"Counting","permalink":"http://blog.gyx.me/tags/Counting/"},{"name":"Segment Tree","slug":"Segment-Tree","permalink":"http://blog.gyx.me/tags/Segment-Tree/"},{"name":"Graphs","slug":"Graphs","permalink":"http://blog.gyx.me/tags/Graphs/"},{"name":"Geometry","slug":"Geometry","permalink":"http://blog.gyx.me/tags/Geometry/"},{"name":"Number Theory","slug":"Number-Theory","permalink":"http://blog.gyx.me/tags/Number-Theory/"},{"name":"Constructive Algorithm","slug":"Constructive-Algorithm","permalink":"http://blog.gyx.me/tags/Constructive-Algorithm/"},{"name":"Knapsack Problem","slug":"Knapsack-Problem","permalink":"http://blog.gyx.me/tags/Knapsack-Problem/"},{"name":"String Suffix Structures","slug":"String-Suffix-Structures","permalink":"http://blog.gyx.me/tags/String-Suffix-Structures/"},{"name":"Greedy","slug":"Greedy","permalink":"http://blog.gyx.me/tags/Greedy/"},{"name":"Flows","slug":"Flows","permalink":"http://blog.gyx.me/tags/Flows/"},{"name":"Tricks","slug":"Tricks","permalink":"http://blog.gyx.me/tags/Tricks/"},{"name":"Probabilities","slug":"Probabilities","permalink":"http://blog.gyx.me/tags/Probabilities/"},{"name":"Minkowski Sum","slug":"Minkowski-Sum","permalink":"http://blog.gyx.me/tags/Minkowski-Sum/"},{"name":"Trie","slug":"Trie","permalink":"http://blog.gyx.me/tags/Trie/"},{"name":"String","slug":"String","permalink":"http://blog.gyx.me/tags/String/"},{"name":"Divide and Conquer","slug":"Divide-and-Conquer","permalink":"http://blog.gyx.me/tags/Divide-and-Conquer/"},{"name":"Difference and Prefix Sum","slug":"Difference-and-Prefix-Sum","permalink":"http://blog.gyx.me/tags/Difference-and-Prefix-Sum/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"http://blog.gyx.me/tags/Binary-Search/"},{"name":"Binary Lifting","slug":"Binary-Lifting","permalink":"http://blog.gyx.me/tags/Binary-Lifting/"},{"name":"Sparse Table","slug":"Sparse-Table","permalink":"http://blog.gyx.me/tags/Sparse-Table/"},{"name":"Stack","slug":"Stack","permalink":"http://blog.gyx.me/tags/Stack/"},{"name":"Matrix Theory","slug":"Matrix-Theory","permalink":"http://blog.gyx.me/tags/Matrix-Theory/"},{"name":"Fenwick Tree","slug":"Fenwick-Tree","permalink":"http://blog.gyx.me/tags/Fenwick-Tree/"},{"name":"System of Difference Constraints","slug":"System-of-Difference-Constraints","permalink":"http://blog.gyx.me/tags/System-of-Difference-Constraints/"},{"name":"Game Theory","slug":"Game-Theory","permalink":"http://blog.gyx.me/tags/Game-Theory/"},{"name":"01-BFS","slug":"01-BFS","permalink":"http://blog.gyx.me/tags/01-BFS/"},{"name":"Connectivity","slug":"Connectivity","permalink":"http://blog.gyx.me/tags/Connectivity/"},{"name":"Threshold Optimization","slug":"Threshold-Optimization","permalink":"http://blog.gyx.me/tags/Threshold-Optimization/"},{"name":"Combinatorics","slug":"Combinatorics","permalink":"http://blog.gyx.me/tags/Combinatorics/"},{"name":"Persistent Data Structure","slug":"Persistent-Data-Structure","permalink":"http://blog.gyx.me/tags/Persistent-Data-Structure/"},{"name":"Scheduling","slug":"Scheduling","permalink":"http://blog.gyx.me/tags/Scheduling/"},{"name":"Bitmask","slug":"Bitmask","permalink":"http://blog.gyx.me/tags/Bitmask/"},{"name":"Union-Find Set","slug":"Union-Find-Set","permalink":"http://blog.gyx.me/tags/Union-Find-Set/"}]}