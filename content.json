{"pages":[{"title":"About","text":"Hello, I’m Colin from HDU. Welcome to my blog &amp; Have a nice day ! Friends ID &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ID ZH_comld ZZH - EZS / HDU ZigZagK ZZK - HDU ACM wjh15101051 WJH - EZS / BUAA Dinosaurcj CJ - HDU CTF - PWN Kingsann CZY - SJZEZ / THU wenzhuan WZ - HDU ACM / CTF ErkkiErkko GSH - SDFZ / THU","link":"/about/index.html"},{"title":"Comments","text":"","link":"/comments/index.html"},{"title":"To Do","text":"Contests Start Time Name Remark July 14th 22:35 Educational Codeforces Round 111 Upsolved 4 / 6 July 17th 22:35 Codeforces Round #733 Wating July 22th 22:35 Harbour.Space Scholarship Contest 2021-2022 Wating July 24th 20:00 AtCoder Beginner Contest 211 Wating July 25th 20:00 AtCoder Regular Contest 124 Wating July 25th 22:35 Codeforces Global Round 15 Wating July 26th 12:00 Best Coder - Test Round Wating July 29th 22:35 Codeforces Round #735 Wating July 31th 14:00 Best Coder Round 1A Wating Contests (Team Training) Date Name Remark July 17th Nowcoder Multi-University Training Contest 1 Upsolved 8 / 11 July 19th Nowcoder Multi-University Training Contest 2 Wating July 20th HDU Multi-University Training Contest 1 Upsolved 7 / 11 July 22th HDU Multi-University Training Contest 2 Wating July 24th Nowcoder Multi-University Training Contest 3 Wating July 26th Nowcoder Multi-University Training Contest 4 Wating July 27th HDU Multi-University Training Contest 3 Wating July 29th HDU Multi-University Training Contest 4 Wating July 31th Nowcoder Multi-University Training Contest 5 Wating","link":"/todo/index.html"},{"title":"Training Records","text":"ICPC Contests Name ( Posts Link ) Rank Solved Upsolved 2020 ICPC Asia Shenyang Regional Contest * 28 6/13 8/13 2020 ICPC Asia Macau Regional Contest 16 4/12 5/12 2020 ICPC Asia Kunming Regional Contest 28 7/13 7/13 2020 ICPC Asia Jinan Regional Contest * 30 6/13 7/13 2020 ICPC Asia Nanjing Regional Contest 39 6/13 6/13 2020 ICPC Asia Shanghai Regional Contest 123 5/13 5/13 CCPC ContestsOpen CupCodeforcesAtCoder","link":"/training/index.html"},{"title":"Codeforces Round 699 (Div. 2)","text":"A. Space Navigation统计四个方向的移动分别有多少，只保留走向目标向量对应方向的移动，判断是否可达。 B. New Colony观察数据范围 $n,h_i\\le 100$ 最多扔 $10^4$ 个石头就结束了，模拟 $\\text O(n^2h)$ 即可。 C. Fence Painting首先如果最后一次涂色不在 $b_i$ 里，肯定无解。 然后如果所有涂色不能满足将所有 $a_i$ 和 $b_i$ 不一样的位置覆盖为 $b_i$ ，则无解。 剩下的情况必定有解，一种构造方法： 对每种颜色 $c$ 预处理出来所有 $a_i$ 和 $b_i$ 不同且 $b_i=c$ 的位置集合 $S_c$ 。 首先确定最后一次涂色的位置 $pos_m$ ： 若 $S_{c_m}$ 为空，则令 $pos_m$ 为任意一个 $b_i=c_m$ 的位置。 若 $S_{c_m}$ 不为空，则让 $pos_m$ 为 $S_{c_m}$ 中的任意一个，并将该位置移出 $S_{c_m}$ 。 然后时间倒序考虑，对于当前颜色 $c_j$ ： 若 $S_{c_j}$ 为空，那么让 $pos_j=pos_m$ ，因为第 $m$ 次操作是最后一次，所以肯定会覆盖。 若 $S_{c_j}$ 不为空，则让 $pos_j$ 为 $S_{c_j}$ 中任意一个位置，然后将该位置移除 $S_{c_j}$ 即可。 D. AB Graph首先奇数长度一定有解，在两个点之间来回跑就可以了。 考虑偶数长度，如果存在连接两个点的一组边类型相同，那么就一直在这两个点之间来回跑就可以了。 剩余的情况就是每一组边都是一条 $A$ 一条 $B$ ，那么对于 $n\\ge 3$ 时很容易证明： 存在一个点 $x$ ，满足存在另两个点 $y,z$ ，边 $x\\to y$ 和 $x\\to z$ 的类型不同。 反证法：假设对于任意的点，所有的出边类型相同，入边类型相同，且两种边类型不同。 不妨设点 $x$ 的所有出边类型均为 $A$ ，也就是说对于其他任意的点的入边类型均为 $A$ （由假设性质） 那么对于任意另外两个点 $y,z$ 之间的边的类型，存在矛盾： $z$ 的入边由上知类型为 $A$ ，则 $y\\to z$ 是 $z$ 的入边，类型必须为 $A$。 $y$ 的出边与入边类型相反，则 $y\\to z$ 是 $y$ 的出边，类型必须为 $B$ 。 因此只需要 $\\text O(n)$ 枚举 $x$ ，$\\text O(n)$ 扫描其他点，判断是否存在 $y,z$ 即可。 对于 $m = 4k$ 的情况，构造解形如 $x\\ y\\ x\\ y\\cdots x\\ y\\ x\\ z\\ x\\ \\cdots z\\ x\\ z\\ x$ 即可。 对于 $m = 4k+2$ 的情况，构造解形如 $y\\ x\\ y\\ x\\ y\\cdots x\\ y\\ x\\ z\\ x\\ \\cdots z\\ x\\ z\\ x\\ z$ 即可。 E. Sorting Books","link":"/solution/codeforces/r699.html"},{"title":"Codeforces Round 701 (Div. 2)","text":"A. Add and Divide首先最优解一定是 ++b 若干次（可能为 $0$ ），然后再一直做 a=a/b 直到符合条件。 考虑最差的情况：$a=10^9,b=1$ ，至多只需 $1+\\lceil \\log_2{10^9}\\rceil = 31$ 次，所以所有答案都 $\\le 31$。 因此枚举++b 的操作次数 $k\\ (0\\le k\\le 31)$ ，然后暴力计算答案即可，复杂度 $\\text O(t\\log^2 a)$ 。 B. Replace and Keep Sorted考虑 $b_i\\not =a_i$ ，那么考虑 $b_i$ 的取值范围： 对于 $i=l$ 的情况， $1\\le b_i&lt;a_{i+1}$ ，与 $a_i$ 不同的方案有 $a_{i + 1} - 2$ 个。 对于 $i=r$ 的情况， $a_{i-1}&lt;b_i\\le k$ ，与 $a_i$ 不同的方案有 $k - a_{i-1} - 1$ 个。 对于 $l&lt;i&lt;r$ 的情况， $a_{i-1}&lt;b_i&lt;a_{i+1}$ ，与 $a_i$ 不同的方案有 $a_{i+1}-a_{i-1}-2$ 个。 $i$ 不同的贡献是独立的，所以用前缀和优化一下第三部分的计算，各个位置的方案数求和即可。 C. Floor and Mod设 $\\lfloor a/b\\rfloor=a\\ \\text{mod}\\ b=k$ ，根据整除理论，有 $a=k *b+k$ ，且 $k &lt; b$ 。 考虑枚举 $k$ ，去数可行的 $b$ ，那么限制条件有：$1\\le b \\le y\\ ,\\ 1\\le k*b+b=a\\le x$ 移项，得 $1\\le b\\le \\min(y,\\ x / k - 1)$ ，即 $k$ 的贡献为 $\\min(y,\\ x/k - 1)$ 。 又由 $k\\le b$ 得 $k ^2 &lt; k * b+k = a\\le x$ ，得 $k\\le \\sqrt x$ ，因此 $O(t\\sqrt x)$ 枚举 $k$ 直接计算即可。 比赛时用的另一种做法，复杂度也是 $\\text O(t\\sqrt x)$ ： 考虑枚举 $b$ ，由上知可行的 $a = k *(b+1)$ 且 $1\\le k\\le b-1$ 。 考虑枚举 $b$ ，则贡献为 $\\min(b-1,\\lfloor x/(b + 1)\\rfloor)$ ，具体的： 当 $(b+1)(b-1)\\le x$ 时，即 $b \\le \\sqrt{x + 1}$ 时，贡献为 $b-1$ ，可以等差数列求和。 否则贡献取 $\\lfloor x /(b + 1)\\rfloor$ ，整除分块计算即可。 D. Multiples and Power Differences数据范围 $1\\le a_{i,j}\\le 16$ ，观察： $\\text{lcm}(1,2,\\cdots,16)=720720\\le 10^6 - 10^5$ $16^4 = 65536\\le 10^5$ 将矩阵黑白染色，黑色变为 $720720$ ， 白色变为 $720720+x^4$ 即可 （ $x$ 为原矩阵对应位置的数） E. Move and Swap设 $f[u]$ 表示红点在 $u$ 时，$u$ 及其子树的最大得分。 若红蓝不交换，假设红色在 $u$ ，则最优解本质上是 $u$ 儿子最大得分 + 同深度点与 $u$ 点权最大差值。 若红蓝交换，则本质是任选同深度节点 $v$ 的最优儿子，及 $v$ 与 $u$ 点权差值。 那么转移方程具体的（设 $d[u]$ 表示节点 $u$ 的深度）：$$f[u] = \\max \\bigg \\{ \\max_{s\\in son[u]} f[s] + \\max_{d[v] = d[u]} | a_u - a_v |\\ ,\\ \\max_{d[v]=d[u]}\\bigg(|a_u-a_v| + \\max_{s\\in son[v]} f[s]\\bigg)\\bigg \\}$$可以发现转移是从深到浅转移的。第一部分直接枚举儿子转移即可，第二部分维护： $$mxp[d] = \\max_{d[v]=d}\\bigg(a_v + \\max_{s\\in son[v]} f[s]\\bigg)\\ ,\\ mxm[d] = \\max_{d[v]=d}\\bigg(-a_v + \\max_{s\\in son[v]} f[s]\\bigg)$$ 则第二部分的转移就可以表示为 $f[u] = \\max\\{mxp[d[u]] - a[u],mxm[d[u]]+a[u]\\}$ 。 F. Copy or Prefix Sum假设当前处理到第 $i$ 位，前 $i-1$ 位的和为 $S$ ，那么 $a_i=b_i$ 或者 $a_i=b_i-S$ 都是可以的。 那么答案为什么不是 $2^n$ 呢？因为 $S=0$ 时会重复计数。 设 $f_{i,S}$ 表示前 $i$ 位填完，前缀和为 $S$ 的方案数，那么转移为： $a_i=b_i$ ： $\\forall S\\ ,\\ f_{i+1,S+b_i} += f_{i,S}$ $a_i = b_i -S$ ： $\\forall S\\ ,\\ f_{i+1,b_i}+=f_{i,S}$ ，即 $f_{i+1,b_i}=\\sum_{\\forall S} f_{i,S}$ $S=0$ 去重：$f_{i+1,b_i} -= f_{i,0}$ 综上，$i\\to i+1$ 转移的过程即为：所有的 $f$ 整体向右偏移 $b_i$ ，然后对 $f_{b_i}$ 单独赋值。 因此省略第一维，使用 map 维护第二维，用记录整体偏移量的方法优化。 记录 $tot=\\sum_{k=1}^ib_k\\ ,\\ ans=\\sum_{\\forall S} f_S$ ，递推即可，实现见 代码 。","link":"/solution/codeforces/r701.html"}],"posts":[{"title":"Nowcoder Summer 2021. Contest 1","text":"Problems: https://ac.nowcoder.com/acm/contest/11166 Official Editorial: https://www.nowcoder.com/study/live/633 Problems to be solved : C（点分治） / I（期望DP） / J（线段树） A. Alice and Bob两堆石子，数量分别为 $a,b$ ，两个人博弈，每次选一堆拿走 $k\\ (k&gt;0)$ 个，另一堆拿走 $s\\times k\\ (s \\ge 0)$​​​​ 个。 无法操作者输，问谁赢，数据范围 $T\\le 10^4, 1\\le n, m\\le 5\\times 10^3$​​​ 。 设 $f[i][j]=0/1$​​​ 表示初始状态为 $i,j$​ 先手是否必胜，转移复杂度为调和级数 $O(n\\log n)$ ，总复杂度 $O(n^3\\log n)$ 。 打表后发现先手必败局面非常少，打表可过。有依据性质的解法，待更。 E. Escape along Water Pipe一个 $n*m$​ 的网格图，每个格子里是一个水管（共 $(_2^4)= 6$​​ 种类型，一条边入另一条边出）。 从左上角的上方走到右下角的下方，中间任意时刻可以旋转任意位置，但不能旋转当前所在位置。 问是否有解，若有解输出方案（旋转+移动），数据范围 $\\sum n\\times m\\le 10^6$​ 。 把每个位置拆点，加上离开的方向，大力 BFS 判连通性就好了。 输出方案需要记录 BFS 过程中的上一个状态，反推回去，维护一下需要旋转的角度。 由于一个点可能由多个方向进入，因此可能会被旋转多次，每次的角度是基于上一次旋转的。 Code - Problem E. Escape along Water Pipe 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;bits/stdc++.h&gt;#define N 1005using namespace std;inline int rd() { int x = 0; bool f = 0 ; char c = getchar(); for (; !isdigit(c); c = getchar()) f |= (c == '-'); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return f ? -x : x;}bool f[N][N][4], ty[N][N];int n, m, a[N][N];struct state { int x, y, dr; inline bool operator == (const state &amp;b) { return x == b.x &amp;&amp; y == b.y &amp;&amp; dr == b.dr; }}lst[N][N][4];queue&lt;state&gt; q;// 1// 0 [+] 2// 3 const int dy[4] = {-1, 0, 1, 0};const int dx[4] = {0, -1, 0, 1};inline void bfs() { f[1][1][2 + ty[1][1]] = 1; lst[1][1][2 + ty[1][1]] = (state){0, 0, 3}; q.push((state){1, 1, 2 + ty[1][1]}); while (!q.empty()) { state nw = q.front(); q.pop(); int x = nw.x + dx[nw.dr]; int y = nw.y + dy[nw.dr]; //printf(\"(%d,%d,%d)\\n\", nw.x, nw.y, nw.dr); if (x &lt;= 0 || x &gt; n || y &lt;= 0 || y &gt; m) continue; if (ty[x][y]) { int dr = nw.dr; if (f[x][y][dr]) continue; f[x][y][dr] = 1; lst[x][y][dr] = nw; q.push((state){x, y, dr}); } else { int dr = (nw.dr + 1) % 4; if (!f[x][y][dr]) { f[x][y][dr] = 1; lst[x][y][dr] = nw; q.push((state){x, y, dr}); } dr = (nw.dr + 3) % 4; if (!f[x][y][dr]) { f[x][y][dr] = 1; lst[x][y][dr] = nw; q.push((state){x, y, dr}); } } }}const int tube[4][4] = {{-1, 0, 4, 3},{0, -1, 1, 5},{4, 1, -1, 2},{3, 5, 2, -1}};const int tr[6][6] = {{0, 90, 180, 270, -1, -1},{270, 0, 90, 180, -1, -1},{180, 270, 0, 90, -1, -1},{90, 180, 270, 0, -1, -1},{0, 0, 0, 0, 0, 90},{0, 0, 0, 0, 90, 0}};deque&lt;state&gt; route;inline state getsta(state nw) { int lstdr = (lst[nw.x][nw.y][nw.dr].dr + 2) % 4; return (state){nw.x, nw.y, tube[nw.dr][lstdr]};}int tmp[N][N];inline int getr(int x) { if (x &lt; 0) x += 360; return x;}inline void getroute() { route.clear(); state nw{n, m, 3}; while (nw.x != 0 || nw.y != 0) { state pre = lst[nw.x][nw.y][nw.dr]; nw = getsta(nw); route.push_front((state){nw.x, nw.y, -1}); //printf(\"nw = (%d,%d,%d)\\n\", nw.x, nw.y, nw.dr); //printf(\"push_front : %d %d %d\\n\", nw.x, nw.y, 0); route.push_front((state){nw.x, nw.y, tr[a[nw.x][nw.y]][nw.dr]}); //printf(\"push_front : %d %d %d\\n\", nw.x, nw.y, tr[a[nw.x][nw.y]][nw.dr]); nw = pre; } printf(\"%lu\\n\", route.size()); for (auto i : route) { if (i.dr != -1) { printf(\"1 %d %d %d\\n\", getr(i.dr - tmp[i.x][i.y]), i.x, i.y); tmp[i.x][i.y] = i.dr; } else printf(\"0 %d %d\\n\", i.x, i.y); }}inline void work() { n = rd(); m = rd(); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) { a[i][j] = rd(); ty[i][j] = (a[i][j] &gt; 3); tmp[i][j] = 0; f[i][j][0] = f[i][j][1] = f[i][j][2] = f[i][j][3] = 0; } bfs(); if (!f[n][m][3]) {puts(\"NO\"); return;} puts(\"YES\"); getroute();}int main() { int t = rd(); while (t--) work(); return 0;} H. Hash Function给定 $n$​ 个数 $a_1, \\cdots, a_n$​ ，使用取模的方法进行哈希，即取定模数 $x$​ 有 $Hash(a_i) = a_i\\ \\text{mod}\\ x$​ 。 确定最小非负整数 $x$​ ，使得不会出现哈希冲突。数据范围 $1\\le n, a_i\\le 10^5$​​​​ 。 $a_i$ 和 $a_j$ 发生冲突的条件为 $x\\ |\\ (a_i-a_j)$ ，因此只需要考虑差有哪些，然后将他们的倍数划掉即可。 由于值域只有 $10^5$ ，因此只需要确定 $1\\cdots 10^5$​ 中有哪些数是某两个数的差值。 假设 $v_i=0/1$ 表示是否存在一个 $a_i=i$ ，$w_i$ 表示是否存在一对 $j,k$ 满足 $i=a_j-a_k$​ ，有： $$w_i=\\bigg[\\ \\sum_{i=j-k}v_j*v_k &gt;0 \\ \\bigg]$$ 这里的卷积处理技巧就比较常见了，设值域为 $[0,m]$​​​ ，令 $u_i=v_{m-i}$​​​ ，有 $$\\sum_{i=j-k}v_j\\ast v_k = \\sum_{i+m=j+m-k} v_j\\ast v_k = \\sum_{i+m=j+k} v_j\\ast u_k$$因此将 $u$​ 和 $v$​​ 做卷积，将结果数组的后一半平移 $m$​ 即可得到 $w_i$ 。 NTT 之后，枚举答案 $x$ 调和级数判断是否存在倍数 $ki$ 满足 $w_{ki}=1$，复杂度 $O(n\\log n)$ 。 Code - Problem H. Hash Function 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;bits/stdc++.h&gt;#define N 2100001#define M 500000#define mod 998244353using namespace std;inline int rd() { int x = 0; char c = getchar(); for (; !isdigit(c); c = getchar()); for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48); return x;}inline int fpow(int x, int t = mod - 2) { int res = 1; while (t) { if (t &amp; 1) res = 1ll * res * x % mod; x = 1ll * x * x % mod; t &gt;&gt;= 1; } return res;}int n, m, a[N], b[N], rev[N], w[2][N], mxlen;inline int mo(int x) {return x &gt;= mod ? x - mod : x;}inline void init(int len) { mxlen = len; w[0][0] = w[1][0] = 1; int per = fpow(3, (mod - 1) / mxlen); int invper = fpow(per); for (int i = 1; i &lt; mxlen; ++i) { w[0][i] = 1ll * w[0][i - 1] * per % mod; w[1][i] = 1ll * w[1][i - 1] * invper % mod; }}inline int Rev(int n) { int len = 1, bit = 0; while (len &lt;= n) ++bit, len &lt;&lt;= 1; for (int i = 0; i &lt; len; ++i) rev[i] = ((rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (bit - 1))); return len;}inline void NTT(int *f, int len, int o) { for (int i = 0; i &lt; len; ++i) if (i &gt; rev[i]) swap(f[i], f[rev[i]]); for (int i = 1; i &lt; len; i &lt;&lt;= 1) { int wn = mxlen / (i &lt;&lt; 1); for (int j = 0; j &lt; len; j += (i &lt;&lt; 1)) { int nw = 0, x, y; for (int k = 0; k &lt; i; ++k, nw += wn) { x = f[j + k]; y = 1ll * w[o][nw] * f[i + j + k] % mod; f[j + k] = mo(x + y); f[i + j + k] = mo(x - y + mod); } } } if (o == 1) { int invl = fpow(len); for (int i = 0; i &lt; len; ++i) f[i] = 1ll * f[i] * invl % mod; }}bool vis[N];int main() { n = rd(); for (int i = 1; i &lt;= n; ++i) a[rd()] = 1; for (int i = 0; i &lt;= M; ++i) b[i] = a[M - i]; int len = Rev(2 * M + 2); init(len); NTT(a, len, 0); NTT(b, len, 0); for (int i = 0; i &lt; len; ++i) a[i] = 1ll * a[i] * b[i] % mod; NTT(a, len, 1); for (int i = 0; i &lt;= M; ++i) if (a[i + M] &gt; 0) vis[i] = 1; bool f = 0; for (int i = 1; i &lt;= M; ++i) { f = 0; for (int j = i; j &lt;= M; j += i) if (vis[j]) {f = 1; break;} if (!f) {printf(\"%d\\n\", i); return 0;} } printf(\"%d\\n\", M + 1); return 0;}","link":"/2021/07/21/Nowcoder_Summer_2021_1/"},{"title":"Atcode Beginner Contest 203","text":"Contest Link: AtCoder Beginner Contest 203 Official Editorial: Editorial - AtCoder Beginner Contest 203 Overview: 比平时的 ABC 难一些， F 题比较有意思。 D. Pond给定一个 $n\\times n$ 的矩阵，找到所有 $k\\times k$ 的子矩阵中，子矩阵内中位数的最小值。 考虑对于某个 $x$ ，将矩阵中小于等于 $x$ 的数标 $1$ ，其余标 $0$ 。 若某个 $k\\times k$ 的子矩阵内和为 $\\lfloor\\frac{k^2}{2} + 1\\rfloor$ ，则此时 $x$ 可以成为答案之一（ $x$ 为该子矩阵的中位数） 赛时的做法比较窒息，将所有数字排序后逐个插入，需要支持单点加，询问是否存在对应的子矩阵。 由于询问的矩阵大小相同，将子矩阵内的权值记录在左上角，转化成了子矩阵加加，维护矩阵内单点 $\\max$ 。 写了二维线段树复杂度 $O(n^2\\log^2n)$ ，TLE * 8，耻辱下播。 实际上二分答案+二维前缀和就好了，每次二分，把原矩阵中小于的标 $1$ 。 然后用二维容斥逐个检查是否存在 $k\\times k$ 的子矩阵内和 $&gt;\\lfloor\\frac{k^2}{2} + 1\\rfloor$ 即可，复杂度 $O(n^2\\log n)$ 。 E. White Pawn题意不再叙述，注意直着移动目标位置不能有黑点，斜着移动目标位置必须有黑点。 考虑维护起点到每一行末尾的连通性，那么一个黑点能影响的连通性，其实只有它所在的行。 具体的，如果某个黑点坐标在 $(x_0,y_0)$ ，起点可以到的 $x=x_0-1$ 的行的集合为 $S$ ，那么： ￼ 如果 $y_0+1\\in S$ 或 $y_0-1\\in S$ ，则 $x=x_0$ 时 $y_0$ 可达，将 $y_0$ 加入。 ￼ 否则 $x=x_0$ 时 $y_0$ 不可达，将 $y_0$ 删去。 因此只需要维护可达行的集合 $S$ ，按黑点 $x$ 从小到大修改 $S$ 即可，显然集合的大小与黑点的个数是线性关系。 维护的时候需要注意同一列上不同点可能会互相影响，可以把修改存下来，每一列处理完后统一做。 1234567891011121314151617181920set&lt;int&gt; S;map&lt;int, vector&lt;int&gt; &gt; a;vector&lt;int&gt; add, del;int main() { int n = rd(), m = rd(); for (int i = 1; i &lt;= m; ++i) a[rd()].push_back(rd()); S.insert(n); for (auto v : a) { add.clear(); del.clear(); for (auto y : v.second) if (S.count(y - 1) || S.count(y + 1)) add.push_back(y); else del.push_back(y); for (auto y : add) S.insert(y); for (auto y : del) S.erase(y); } printf(\"%d\\n\", S.size()); return 0;} F. Weed题意不再叙述，注意是双关键字最优。 赛时以为第一关键字最优的情况一定是推掉最大/最小的共 k 个，反例很好找（一段一段的分布） 性质：每次 2 操作集合里的最大值都会至少减半，最多删 $\\log\\{\\max a_i\\}$ 次一定会结束了，第一关键字最大为 $30$ 。 这个状态设计比较有意思（答案放到状态中）：首先将 $a[i]$ 从小到大排序，$f[i][j]$ 表示，只考虑 $a[1],\\cdots, a[i]$ ，即只考虑 $\\le a[i]$ 的元素时， 最少提前使用 2 操作删掉几个，使得剩余的只需要 $j$ 次 1 操作即可删干净。 转移分讨当前元素删/不删即可: $f[i][j] = \\min(f[i-1][j] + 1,f[pos - 1][j - 1])$ 其中 $pos$ 的含义为，最小的 $x\\ge 1$ ，满足 $a[x] &gt; \\frac{a[i]}2$ ，即使用一次操作 $a[i]$ 能带走的最靠前的位置。 123456789sort(a + 1, a + 1 + n);for (int i = 1, p = 1; i &lt;= n; i++) { for (; a[p] * 2 &lt;= a[i]; p++); f[i][0] = i; for (int j = 1; j &lt; K; j++) f[i][j] = min(f[i - 1][j] + 1, f[p - 1][j - 1]);}for (p = 0; f[n][p] &gt; k; p++);printf(\"%d %d\\n\", p, f[n][p]);","link":"/2021/05/31/abc203/"},{"title":"热爱生活","text":"今天是 2021 年 7 月 8 日，星期四。 一年前的今天，高考最后一门刚刚考完。走出考场，回到自己的教室，拿手机，搬行李，告别。 离开学校的时候，碰到了还在梳理交通的竞赛教练，问我考的怎么样，然后约了后天要给高一的学弟们上课。 直到昨晚，暑假回本部给又一届的学弟们上完最后一天课。从二中本部的校门里走出来，回头看看。 来杭电之前高考完就跟爸爸妈妈说我不复读，当晚就对答案，大概 645。报了南科大综评，拿到了还算不错的校考分。 然后在南校区给高一的同学讲了比较入门的概率，也是那些在一年前的暑假认识的，刚踏入二中大门学弟。 结束的时候在空空的学校里溜达，想想他们上课时候那种纯粹的热情，一代又一代，多少有一点感慨。 走之前拍了张照片，想起来一句自认为很应景的话：“雨过天青云破处，者般颜色做将来” 出分的晚上比较坦然，提前几分钟查到了分数，比估计的低 9 分，都扣在语文上，115 / 134 / 136 / 251。 之后的几天比较迷茫，听了几个学校的招生宣讲都不尽如人意。南科大那边几度有希望，后来终究是落空。 在我想起来杭电这所学校的时候，突然感觉就是要去这里了。 可能是高二去学军培训喜欢上了杭州这个城市，也可能是对竞赛生涯结束的不甘吧。 先自己偷偷找 Claris 要到了教练的联系方式，问了读研和专业的事情，刘老师的热情的杭州话让人很舒服。 然后就是小心翼翼地和父母交流，说我自己的想法和考虑，直到最后心里十分踏实地填上了第一志愿。 录取的结果是数学系，高考分数达到了卓越学院二次选拔的报名分数线，报了卓越学院的招生考试。 之后的假期写了几个板子，打了几场 CF 恢复一点水平，参加了 HDU 的几场内部训练，搬了一套题恰烂钱。 开学之前和岳老师吃了个饭（竟然还赶上了他生日）， 让我重心不要全部放到竞赛上，要给自己留个后路。 初到杭电有一说一假期还是过的比较随意，虽然报名了卓越学院，但是一点没准备，9 月份忐忑地就来到杭电啦。 考试之前自己很没有底气，当时觉得能进计科班就不错了。考完觉得考的还行，因为竞赛里接触过一点高数线代的知识，觉得自己英语阅读也比较会蒙。然后晚上大概九点的时候出成绩了，震惊自己竟然过了英才班的线。 晚上给爸爸妈妈很激动地打了个电话，有点担心 11 进 9 被刷掉，一直到十二点多才睡着。 第二天面试的时候其实自己比较轻松，感觉面试向来都比较稳 比较会吹 ，面试单独面，五个老师。 面试跟想象里的一样顺利，老师们的问题基本是跟着我的自我介绍思路走，不过还是有几个问题血压拉满。 我努力地强调自己的竞赛水平，然后冯老师问：“现在让你去打区域赛能拿到什么奖项？” 我介绍了一下高中学校和班级的情况，然后另一个老师问：“你觉得二中和衡一哪个更好？” 周老师（也是现在的导师）问：“你也不能打一辈子竞赛啊。以后有什么进一步的打算？” 我说会读研，以后可能会去当大学老师。导师笑笑说要想当教授，后面得去好点的大学读书。 面试完出来觉得自己还挺稳的，但是也不敢确定，忐忑到了晚上十点多出了结果。终于还是去学计算机了。 之后的生活比较顺利，见面会，正常上课，班委选举（当了学委）。 上课的时候强迫自己去提问，回答问题，意识到自己可以做一些 由自己决定的 想做什么就做什么 的事。 遇到了自己喜欢的老师，有能够舒适相处，真心相待的一帮同学，慢慢地从高三痛苦自闭的状态走出来了。 竞赛这段话也想写给每个学竞赛过程中感到无力的同行者。 算法竞赛的魅力在于，通过努力积累或灵机一动，你能够做出越来越难的题目，是一种对自我能力的认可。 算法竞赛的危险亦在于，你学会的东西越多，认识的厉害的人越多，面对不可计数的强者，很容易陷入自我否定。 想到杭电之前，很长一段时间都觉得，大学不会再打竞赛了。 学竞赛的过程中经历的打击，不仅是比赛和上课中受到一众神仙居高临下的压迫感，更多的其实是周围人不经意的否定和安慰。对我来说，这是一种对信心很大的打击，会想要证明自己，亦或是心里感到无力而故作轻松。 在面临是否买 D 的抉择时，我放弃了。不是担心取得不了什么结果，而是觉得压力太大了。 在选学校的时候，突然想到杭电的那一刻，有种死灰复燃的感觉。 记起来 NOIP 2018 结束的时候，在存真楼下，孙校长和我们几个刚从秦皇岛回来的学生说的几句话： “学别的竞赛的，最终的发展和竞赛不一定有关系，但是算法竞赛的学生，最终往往都会选择计算机行业。” 算法竞赛会在心里埋下一颗种子。 我不是那种一帆风顺的天才，在受到打击的时候，我会感到无力。 但当我抛开名利、和他人比较、证明自己这些功利的意义之后，我发现自己还剩下些东西，还能看到初心。 是对算法的欣赏和热爱，是理解每一个算法、做出每一个题目的瞬间，精神上的的享受，这就够了。 至少在我看来，从我开始接触竞赛，到做出很多重要的选择，我决策的初心从来都不是名利，因为对算法还爱着。决定最终没有买 D 类，最大的原因还是在那个时刻，竞赛带来的痛苦超过了学习的享受，被一次次的排名裹挟，被各种机会所吸引，我越来越像一个没有自我的机器，越来越被成功学牢牢锁死。而在我选择大学的时候，竞赛对我的意义不再是未来的全部了。我能够静下来，问问自己对算法还有没有那种近乎痴迷的喜爱，能够将它作为一种兴趣去发展，不需要考虑付出和回报，至少在大学，我还是有自由支配自己的权利。 我还是那个深深爱着算法的小孩，对几十行代码背后的智慧如痴如醉。 一年来取得的结果超过预期，也让自己慢慢恢复了信心，继续努力。 Gold Medal (30th Place) : The 45th ICPC Asia Jinan Regional Contest, 2020 Gold Medal ( 15th Place) : The 18th Zhejiang Provincial Collegiate Programming Contest, 2021 Silver Medal (28th Place) : The 45th ICPC Asia Shenyang Regional Contest, 2021 课内学习第一个学期不会选课，修了系统默认的 25.25 个学分， 第二个学期修了 32.25​ 个学分。 通识选修的任务完成的不太行，只完成了科技发展与科学精神（2/2），大二上应该会把通识剩下的指标修完。 数理基础（23） 数分 （6 * 3.5 + 5 * 4.2）、高代（3 * 5 + 2 * 5）、离散（4 * 5）、大学物理1（3 * 5） CS专业课（14） 计导（2 * 5）、程设基础（5 * 5）、数据结构（4 * 4.5）、C++ 面向对象（3 * 5） 通识教育（8） 思修法基（3 * 5）、心理健康（1 * 4.3）、大军（2 * 4.8）、ACM（2 * 5） 外语类（8） 英语精读 A（2 * 4.4 + 2 * 4.6）、英语听说 A（1 * 4.3 + 1 * 4.7）、实用翻译（2 * 4.6） 其他（3.5） 大学启示录（1 * 4）、形式与政策（0.5 * 5）、科研实践（1 * 5）、体育（1 * 2.1 + 1 * 1.8） 很幸运的是遇到的老师都很认真负责，老师们对课程内容非常了解，自己遇到问题也都能很好沟通。 很多课程都觉得自己做的没那么好，对给出的成绩也常常受之有愧。 数学分析和高等代数两门数学基础课的表现截然相反，让我更清楚地意识到很大程度上我是个兴趣驱动的人。 对数分的知识体系自己本身可能就不太感兴趣，加上数分课是真的提不起来精神，两个学期的数学分析成绩都不太看的过去，数分上可能要在大三重修了。老师确实想要认真教会我，可是自己确实提不起兴趣去学。经历了数分上的洗礼，数分下还是逼着自己学了学，最后的结果算是马马虎虎吧，确实对不起老师对不起自己。 很喜欢高代老师的课，很大程度驱动我去花相对比较多的时间在这门课上。两个学期最后的结果都比较好，在自己喜欢的科目上能够看到自己做了些事情，也是让自己很开心的一件事。唯一遗憾的是期末错在了最后一节课老师强调过的一个小点上（证明正定阵需先说明对称）。大二下预定了老师的近世代数。 也很喜欢 Cathy 上的英语精读，也算是第一次能让我主动提起来学英语的兴趣。 Cathy 的课有一种很轻松的气氛，不会按照课本一板一眼的去上，讲的很多东西很受用。 感谢程设和OOP（C++）的老师对我的包容，自己在这两门课上确实有过很幼稚的行为。很佩服将近退休的老师能精确把控很多细节，随手写的代码能一遍过编译什么错都没有。 离散数学和数据结构 给了我很深刻的教训。两门都是自认为了解比较多的，数据结构甚至申请了免听。考前复习的都不是很充分，等上了考场发现要开始脑补一堆一堆的概念。期末离散卷子简单，没暴露出来什么问题。数据结构觉得自己看看书就够了，最后的成绩却不尽如人意，原因只是不知道排序里的一个既定细节，只能悔不当初。 大学物理和思想道德修养与法律基础 两门课结果意外的好，其实自己认真去学一学还是可以有效果的。中学阶段一直头疼的政治在闭卷的期末考试也写了个差不多。学不会电磁在考场上也做出来了绝大多数题。考试遇到不会的题也不能太着急，多想一会没准就通了。 体育 从中考的 $18$ 分保底，到大一上的体测 $36$ 分，痛失两个学期的奖学金，终究还是没逃过身体素质不行这个问题。还是感谢环境逼着我去直面体育，按着体能班的要求大一下结结实实把 40 次阳光长跑跑完了，也确实让我看到耐力可以有提升，从操场跑一圈就喘不上气，到体测的时候人生第一次把 1000 米全跑下来，确实是很激动的。也终于在锻炼身体上有了动力，首先是大二下想要和 qyy 同学一起学体育舞，其次是想要恰奖学金。 情窦初开我知道你们想看这个，但是没有什么要多说的，只想说爱情的体验是一种很纯粹的幸福。 愿意为她牺牲自己的一切，无时无刻都会想起她的事情，找不到她会坐如针毡，什么都做不下去。 她所高兴的事情比她还高兴，她难受的时候会跟着一起哭出来，在爱情中两个人都学会了如何照顾对方。 两个人在一起呆着常常心有灵犀，做事情反应如出一辙，很多事情不用言语。 两个人在一起呆着就是最快乐的事情，能够一起学习，散步，她在我的身边就能感受到无比的踏实。 会走到一起的人终究不会分开。心里对未来有着期盼，静下心来踏踏实实做事，继续加油。","link":"/2021/07/08/freshman/"},{"title":"Hello World","text":"「 Hello, the lovely world. 」 「 Stay hungry, Stay foolish. 」 12345678910111213141516171819202122&gt;&gt;&gt; import thisThe Zen of Python, by Tim PetersBeautiful is better than ugly.Explicit is better than implicit.Simple is better than complex.Complex is better than complicated.Flat is better than nested.Sparse is better than dense.Readability counts.Special cases aren't special enough to break the rules.Although practicality beats purity.Errors should never pass silently.Unless explicitly silenced.In the face of ambiguity, refuse the temptation to guess.There should be one-- and preferably only one --obvious way to do it.Although that way may not be obvious at first unless you're Dutch.Now is better than never.Although never is often better than *right* now.If the implementation is hard to explain, it's a bad idea.If the implementation is easy to explain, it may be a good idea.Namespaces are one honking great idea -- let's do more of those!","link":"/2018/11/29/hello-world/"},{"title":"Render Math Equations in Hexo","text":"$$f(a) = \\frac{1}{2\\pi i}\\oint_{\\gamma}\\frac{f(z)}{z-a}dz$$ Beautiful and accessible math in all browsers - MathJax This post is used to check out whether the mathjax plugin (hexo-math) still works. Inline FormulaConsider the sequence of $n$ distinct positive integers: $c_1, c_2, \\cdots, c_n$. The child calls a vertex-weighted rooted binary tree good if and only if for every vertex $v$, the weight of $v$ is in the set ${c_1, c_2, \\cdots, c_n}$ . Also our child thinks that the weight of a vertex-weighted tree is the sum of all vertices’ weights. Given an integer $m$, can you for all $s (1 \\le s ≤ m) $ calculate the number of good vertex-weighted rooted binary trees with weight $s$ ? Please, check the samples for better understanding what trees are considered different. We only want to know the answer modulo $998244353$ ( $7 × 17 × 2^{23} + 1$ , a prime number). Block Formula$$\\int \\frac{dx}{cos^2x}=\\int sec^2xdx=tan x+C\\$$ $$\\int \\frac{dx}{sin^2x}=\\int csc^2xdx=-cot x+C\\$$ $$\\sum\\limits_{i = 0}^{E} w[i]{M \\choose i} {N \\choose iS} \\frac{(iS)!}{(S!)^{i}} \\sum\\limits_{j = 0}^{E - i} (-1)^{j} {M - i \\choose j} {N - iS \\choose jS} \\frac{(jS)!}{(S!)^{j}} (M - i - j)^{N - iS - jS}$$ $$= \\sum\\limits_{i = 0}^{E} w[i]{M \\choose i} {N \\choose iS} \\frac{(iS)!}{(S!)^{i}} \\sum\\limits_{j = i}^{E} (-1)^{j - i} {M - i \\choose j - i} {N - iS \\choose jS - iS} \\frac{(jS - iS)!}{(S!)^{j - i}} (M - j)^{N - jS}$$ Matrix$$\\begin{bmatrix}(\\omega_n^0)^0 &amp; (\\omega_n^0)^1 &amp; \\cdots &amp; (\\omega_n^0)^{n-1}\\\\ (\\omega_n^1)^0 &amp; (\\omega_n^1)^1 &amp; \\cdots &amp; (\\omega_n^1)^{n-1}\\\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\(\\omega_n^{n-1})^0 &amp; (\\omega_n^{n-1})^1 &amp; \\cdots &amp; (\\omega_n^{n-1})^{n-1}\\end{bmatrix}\\begin{bmatrix}a_0 \\\\a_1 \\\\\\vdots \\\\a_{n-1}\\end{bmatrix}=\\begin{bmatrix}A(\\omega_n^0) \\\\A(\\omega_n^1) \\\\\\vdots \\\\A(\\omega_n^{n-1})\\end{bmatrix}$$ $$\\begin{bmatrix}a_0 \\\\a_1 \\\\\\vdots \\\\a_{n-1}\\end{bmatrix}=\\frac{1}{n}\\begin{bmatrix}(\\omega_n^{-0})^0 &amp; (\\omega_n^{-0})^1 &amp; \\cdots &amp; (\\omega_n^{-0})^{n-1} \\\\(\\omega_n^{-1})^0 &amp; (\\omega_n^{-1})^1 &amp; \\cdots &amp; (\\omega_n^{-1})^{n-1} \\\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\(\\omega_n^{-(n-1)})^0 &amp; (\\omega_n^{-(n-1)})^1 &amp; \\cdots &amp; (\\omega_n^{-(n-1)})^{n-1}\\end{bmatrix}\\begin{bmatrix}A(\\omega_n^0) \\\\A(\\omega_n^1) \\\\\\vdots \\\\A(\\omega_n^{n-1})\\end{bmatrix}$$ To prevent escaping, you need to use \\\\\\\\ to make a new line rather than \\\\ . For more about the Mathjax symbols, refer to The Comprehensive LaTeX Symbol List .","link":"/2019/06/01/mathjax/"}],"tags":[{"name":"Atcoder","slug":"Atcoder","link":"/tags/Atcoder/"},{"name":"Binary Search","slug":"Binary-Search","link":"/tags/Binary-Search/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"Blog","slug":"Blog","link":"/tags/Blog/"}],"categories":[{"name":"solution","slug":"solution","link":"/categories/solution/"},{"name":"life","slug":"life","link":"/categories/life/"},{"name":"Blog","slug":"Blog","link":"/categories/Blog/"}]}