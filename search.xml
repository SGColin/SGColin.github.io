<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>热爱生活</title>
      <link href="2021/07/08/freshman/"/>
      <url>2021/07/08/freshman/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><p>今天是 2021 年 7 月 8 日，星期四。</p><p>一年前的今天，高考最后一门刚刚考完。走出考场，回到自己的教室，拿手机，搬行李，告别。</p><p>离开学校的时候，碰到了还在梳理交通的竞赛教练，问我考的怎么样，然后约了后天要给高一的学弟们上课。</p><p>直到昨晚，暑假回本部给又一届的学弟们上完最后一天课。从二中本部的校门里走出来，回头看看。</p><a id="more"></a><h2 id="来杭电之前"><a href="#来杭电之前" class="headerlink" title="来杭电之前"></a>来杭电之前</h2><p>高考完就跟爸爸妈妈说我<strong>不复读</strong>，当晚就对答案，大概 645。报了南科大综评，拿到了还算不错的校考分。</p><p>然后在南校区给高一的同学讲了比较入门的概率，也是那些在一年前的暑假认识的，刚踏入二中大门学弟。</p><p>结束的时候在空空的学校里溜达，想想他们上课时候那种纯粹的热情，一代又一代，多少有一点感慨。</p><p>走之前拍了张照片，想起来一句自认为很应景的话：“<strong>雨过天青云破处，者般颜色做将来</strong>”</p><img src="/material/EZS.png" alt="连着下了两三天的小雨，只剩下竞赛生的二中" style="zoom:70%;"><p>出分的晚上比较坦然，提前几分钟查到了分数，比估计的低 9 分，都扣在语文上，115 / 134 / 136 / 251。</p><p>之后的几天比较迷茫，听了几个学校的招生宣讲都不尽如人意。南科大那边几度有希望，后来终究是落空。</p><hr><p>在我想起来杭电这所学校的时候，突然感觉就是要去这里了。</p><p>可能是高二去学军培训喜欢上了杭州这个城市，也可能是对竞赛生涯结束的不甘吧。</p><p>先自己偷偷找 Claris 要到了教练的联系方式，问了读研和专业的事情，刘老师的热情的杭州话让人很舒服。</p><p>然后就是小心翼翼地和父母交流，说我自己的想法和考虑，直到最后心里十分踏实地填上了第一志愿。</p><p>录取的结果是数学系，高考分数达到了卓越学院二次选拔的报名分数线，报了卓越学院的招生考试。</p><p>之后的假期写了几个板子，打了几场 CF 恢复一点水平，参加了 HDU 的几场内部训练，搬了一套题恰烂钱。</p><p>开学之前和岳老师吃了个饭（竟然还赶上了他生日）， 让我重心不要全部放到竞赛上，要给自己留个后路。</p><h2 id="初到杭电"><a href="#初到杭电" class="headerlink" title="初到杭电"></a>初到杭电</h2><p>有一说一假期还是过的比较随意，虽然报名了卓越学院，但是一点没准备，9 月份忐忑地就来到杭电啦。</p><p>考试之前自己很没有底气，当时觉得能进计科班就不错了。考完觉得考的还行，因为竞赛里接触过一点高数线代的知识，觉得自己英语阅读也比较会蒙。然后晚上大概九点的时候出成绩了，震惊自己竟然过了英才班的线。</p><p>晚上给爸爸妈妈很激动地打了个电话，有点担心 11 进 9 被刷掉，一直到十二点多才睡着。</p><p>第二天面试的时候其实自己比较轻松，感觉面试向来都比较稳 <del>比较会吹</del> ，面试单独面，五个老师。</p><p>面试比较自然，老师们的问题基本是跟着我的自我介绍思路走，不过还是有几个问题血压拉满。</p><ol><li><p>我努力地强调自己的竞赛水平，然后冯老师问：“现在让你去打区域赛能拿到什么奖项？”</p></li><li><p>我介绍了一下高中学校和班级的情况，然后另一个老师问：“你觉得二中和衡一哪个更好？”</p></li><li><p>周老师（也是现在的导师）问：“你也不能打一辈子竞赛啊。以后有什么进一步的打算？”<br> 我说会读研，以后可能会去当大学老师。导师笑笑说要想当教授，后面得去好点的大学读书。</p></li></ol><p>面试完出来觉得自己还挺稳的，但是也不敢确定，忐忑到了晚上十点多出了结果。终于还是去学计算机了。</p><p>之后的生活很顺利，见面会，正常上课，班委选举（当了学委）。</p><p>上课的时候强迫自己去提问，回答问题，意识到自己可以做一些 <strong>由自己决定的</strong> <strong>想做什么就做什么</strong> 的事。</p><p>遇到了自己喜欢的老师，有能够舒适相处，真心相待的一帮同学，慢慢地从高三痛苦自闭的状态走出来了。</p><h2 id="竞赛"><a href="#竞赛" class="headerlink" title="竞赛"></a>竞赛</h2><p>这段话也想写给每个学竞赛过程中感到无力的同行者。</p><p><strong>算法竞赛的魅力在于，通过努力积累或灵机一动，你能够做出越来越难的题目，是一种对自我能力的认可。</strong></p><p><strong>算法竞赛的危险亦在于，你学会的东西越多，认识的厉害的人越多，面对不可计数的强者，很容易陷入自我否定。</strong></p><p>想到杭电之前，很长一段时间都觉得，大学不会再打竞赛了。</p><p>学竞赛的过程中经历的打击，不仅是比赛和上课中受到一众神仙居高临下的压迫感，更多的其实是周围人不经意的否定和安慰。对我来说，这是一种对信心很大的打击，会想要证明自己，亦或是心里感到无力而故作轻松。 </p><p>在面临是否买 D 的抉择时，我放弃了。不是担心取得不了什么结果，而是觉得压力太大了。</p><p>在选学校的时候，突然想到杭电的那一刻，有种死灰复燃的感觉。</p><p>记起来 NOIP 2018 结束的时候，在存真楼下，孙校长和我们几个刚从秦皇岛回来的学生说的几句话：</p><p>“学别的竞赛的，最终的发展和竞赛不一定有关系，但是算法竞赛的学生，最终往往都会选择计算机行业。”</p><p><strong>算法竞赛会在心里埋下一颗种子。</strong></p><p><strong>我不是那种一帆风顺的天才，在受到打击的时候，我会感到无力。</strong></p><p><strong>但当我抛开名利、和他人比较、证明自己这些功利的意义之后，我发现自己还剩下些东西，还能看到初心。</strong></p><p><strong>是对算法的欣赏和热爱，是理解每一个算法、做出每一个题目的瞬间，精神上的享受，这就够了。</strong></p><p>至少在我看来，从我开始接触竞赛，到做出很多重要的选择，我决策的初心从来都不是名利，因为对算法还爱着。决定最终没有买 D 类，最大的原因还是在那个时刻，竞赛带来的痛苦超过了学习的享受，被一次次的排名裹挟，被各种机会所吸引，我越来越像一个没有自我的机器，越来越被成功学牢牢锁死。而在我选择大学的时候，竞赛对我的意义不再是未来的全部了。我能够静下来，问问自己对算法还有没有那种近乎痴迷的喜爱，能够将它作为一种兴趣去发展，不需要考虑付出和回报，至少在大学，我还是有自由支配自己的权利。</p><p><strong>我还是那个深深爱着算法的小孩，对几十行代码背后的智慧如痴如醉。</strong></p><hr><ul><li>Gold Medal (30th Place) : The 45th ICPC Asia Jinan Regional Contest, 2020</li><li>Gold Medal ( 15th Place) : The 18th Zhejiang Provincial Collegiate Programming Contest, 2021</li><li>Silver Medal (28th Place) : The 45th ICPC Asia Shenyang Regional Contest, 2021</li></ul><h2 id="课内学习"><a href="#课内学习" class="headerlink" title="课内学习"></a>课内学习</h2><p>第一个学期不会选课，修了系统默认的 25.25 个学分， 第二个学期修了 32.25​ 个学分。</p><p>通识选修只完成了科技发展与科学精神（2/2），大二上应该会把剩下的指标修完。</p><table><thead><tr><th align="center">数理基础（23）</th><th>数分 （6 * 3.5 + 5 * 4.2）、高代（3 * 5 + 2 * 5）、离散（4 * 5）、大学物理1（3 * 5）</th></tr></thead><tbody><tr><td align="center">CS专业课（14）</td><td>计导（2 * 5）、程设基础（5 * 5）、数据结构（4 * 4.5）、C++ 面向对象（3 * 5）</td></tr><tr><td align="center">通识教育（8）</td><td>思修法基（3 * 5）、心理健康（1 * 4.3）、大军（2 * 4.8）、ACM（2 * 5）</td></tr><tr><td align="center">外语类（8）</td><td>英语精读 A（2 * 4.4 + 2 * 4.6）、英语听说 A（1 * 4.3 + 1 * 4.7）、实用翻译（2 * 4.6）</td></tr><tr><td align="center">其他（3.5）</td><td>大学启示录（1 * 4）、形式与政策（0.5 * 5）、科研实践（1 * 5）、体育（1 * 2.1 + 1 * 1.8）</td></tr></tbody></table><p>很幸运的是遇到的老师都很认真负责，老师们对课程内容非常了解，自己遇到问题也都能很好沟通。</p><p>很多课程都觉得自己做的没那么好，对给出的成绩也常常受之有愧。</p><p><strong>数学分析</strong>和<strong>高等代数</strong>两门数学基础课的表现截然相反，让我更清楚地意识到很大程度上我是个兴趣驱动的人。</p><p>对数分的知识体系自己本身可能就不太感兴趣，<del>加上数分课是真的提不起来精神</del>，两个学期的数学分析成绩都不太看的过去，数分上可能要在大三重修了。老师确实想要认真教会我，可是自己确实提不起兴趣去学。经历了数分上的洗礼，数分下还是逼着自己学了学，最后的结果算是马马虎虎吧，确实对不起老师对不起自己。</p><p>很喜欢高代老师的课，很大程度驱动我去花相对比较多的时间在这门课上。两个学期最后的结果都比较好，在自己喜欢的科目上能够看到自己做了些事情，也是让自己很开心的一件事。唯一遗憾的是期末错在了最后一节课老师强调过的一个小点上（证明正定阵需先说明对称）。大二下预定了老师的近世代数。</p><p>也很喜欢 Cathy 上的<strong>英语精读</strong>，也算是第一次能让我主动提起来学英语的兴趣。 Cathy 的课有一种很轻松的气氛，不会按照课本一板一眼的去上，讲的很多东西很受用。</p><p>感谢<strong>程设和OOP（C++）</strong>的老师对我的包容，自己在这两门课上确实有过很幼稚的行为。很佩服将近退休的老师能精确把控很多细节，随手写的代码能一遍过编译什么错都没有。</p><p><strong>离散数学和数据结构</strong> 给了我很深刻的教训。两门都是自认为了解比较多的，<strong>数据结构</strong>甚至申请了免听。考前复习的都不是很充分，等上了考场发现要开始脑补一堆一堆的概念。期末离散卷子简单，没暴露出来什么问题。数据结构觉得自己看看书就够了，最后的成绩却不尽如人意，原因只是不知道排序里的一个既定细节，只能悔不当初。</p><p><strong>大学物理和思想道德修养与法律基础</strong> 两门课结果意外的好，其实自己认真去学一学还是可以有效果的。中学阶段一直头疼的政治在闭卷的期末考试也写了个差不多。学不会电磁在考场上也做出来了绝大多数题。考试遇到不会的题也不能太着急，多想一会没准就通了。</p><p><strong>体育</strong> 从中考的 $18$ 分保底，到大一上的体测 $36$ 分，痛失两个学期的奖学金，终究还是没逃过身体素质不行这个问题。还是感谢环境逼着我去直面体育，按着体能班的要求大一下结结实实把 40 次阳光长跑跑完了，也确实让我看到耐力可以有提升，从操场跑一圈就喘不上气，到体测的时候人生第一次把 1000 米全跑下来，确实是很激动的。也终于在锻炼身体上有了动力，首先是大二下想要和 qyy 同学一起学体育舞，其次是想要恰奖学金。</p><h2 id="我的她"><a href="#我的她" class="headerlink" title="我的她"></a>我的她</h2><p>只想说爱情的体验是一种很纯粹的幸福。</p><p>愿意为她牺牲自己的一切，无时无刻都会想起她的事情，找不到她会坐如针毡，什么都做不下去。</p><p>她所高兴的事情比她还高兴，她难受的时候会跟着一起哭出来，在爱情中两个人都学会了如何照顾对方。</p><p>两个人在一起呆着常常心有灵犀，做事情反应如出一辙，很多事情不用言语。</p><p>两个人在一起呆着就是最快乐的事情，能够一起学习，散步，她在我的身边就能感受到无比的踏实。</p><p>会走到一起的人终究不会分开。心里对未来有着期盼，静下心来踏踏实实做事，继续加油。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线性筛与积性函数</title>
      <link href="2020/07/23/linear-sieve/"/>
      <url>2020/07/23/linear-sieve/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><p>线性筛是一种数论筛法，可以筛出一定范围内的质数或<strong>任意积性函数</strong>的值。</p><p>其中”线性“的含义为 <strong>每个数字只被其最小的质因数筛出</strong> ，并非时间复杂度。</p><p>假设求积性函数 $f(x)$ 的质数幂 $f(p^k)$ 复杂度为 $t$，则最终复杂度为 $ \mathcal O(n+\frac{n}{\ln n}\times  t)$ 。</p><a id="more"></a><h2 id="数论函数"><a href="#数论函数" class="headerlink" title="数论函数"></a>数论函数</h2><p>定义域为正整数集 $\mathbb N^+$，陪域为复数集 $\mathbb C$ 的函数。</p><p>常见的数论函数可视为，定义域为正整数，值域为整数的函数。</p><h3 id="积性函数"><a href="#积性函数" class="headerlink" title="积性函数"></a>积性函数</h3><p>对于一个数论函数 $f$ ， $\forall\ a\ \bot\ b,\ f(ab) = f(a)\times f(b)$，则称 $f$ 为<strong>积性函数</strong>。</p><p>若 $n$ 的标准分解为 $n = p_1^{k_1}\times p_2^{k_2}\times …\times p_m^{k_m}\ (p_1&lt;p_2&lt;…&lt;p_m)$ ，则<br>$$<br>f(n)=\prod_{i=1}^m f(p_i^{k_i})<br>$$<br>这也是线性筛的基础，即积性函数的基本性质之一就是可被线性筛。</p><h3 id="完全积性函数"><a href="#完全积性函数" class="headerlink" title="完全积性函数"></a>完全积性函数</h3><p>对于一个数论函数 $f$ ， $\forall\ a,b\in \mathbb N^+ ,\ f(ab) = f(a)\times f(b)$，则称 $f$ 为<strong>完全积性函数</strong>。</p><hr><h2 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h2><p>求 $f(n)$ 的值时，考虑其标准分解 </p><p>$$<br>n = p_1^{k_1}\times p_2^{k_2}\times …\times p_m^{k_m}\ (p_1&lt;p_2&lt;…&lt;p_m)<br>$$</p><p>对标准分解的最小质因数的指数 $k_1$ 的情况讨论。</p><ul><li><p>$n$ 是素数 $p_1$，即 $k_1=m=1$</p></li><li><p>$n=p_1\times i$，其中 $i$ 是任意正整数，且 $k_1=1$，即 $p_1\nmid i$ </p></li><li><p>$n=p_1\times i$，其中 $i$ 是任意正整数，且 $k_1&gt;1$，即 $p_1\mid i$ </p></li></ul><p>下面对三类情况分别进行处理：</p><ul><li><p>$n$ 是素数 $p_1$，即 $k_1=m=1$</p><p>往往可以利用数论函数的定义快速求出。</p></li><li><p>$n=p_1\times i$，其中 $i$ 是任意正整数，且 $k_1=1$，即 $p_1\nmid i$ </p><p>利用积性函数的定义，由于 $p_1\bot i$，有 $f(n) = f(p_1) \times f(i)$</p><p>由于 $p_1&lt;n,\ i&lt;n$，$f(p_1)$ 和 $f(i)$ 在此前都已求出。</p></li><li><p>$n=p_1\times i$，其中 $i$ 是任意正整数，且 $k_1&gt;1$，即 $p_1\mid i$ </p><p>将 $n$ 重新表示为 $n=p_1^{k_1}\times j$ 的形式，此时 $p_1^{k_1}\bot j$，有$f(n)=f(p_1^{k_1})\times f(j)$</p><p>由于 $p_1^{k_1}&lt;n, j&lt;n$，$f(p_1^{k_1})$ 和 $f(j)$ 在此前都已求出。</p></li></ul><p>现在只需要解决如何快速求出 $n$ 对应的 $p_1^{k_1}$ 和 $k_1$ 的值。</p><p>不妨设 $g(n)=p_1^{k_1},\ k(n)=k_1$，这两个函数虽然不是积性的，但依然可以按照上述思路讨论。</p><table><thead><tr><th align="center">$n$ 与 $p_1$ 关系</th><th align="center">$g(n)$</th><th align="center">$k(n)$</th></tr></thead><tbody><tr><td align="center">$n$ 是素数 $p_1$</td><td align="center">$p_1$</td><td align="center">$1$</td></tr><tr><td align="center">$n=p_1\times i$，且 $p_1\nmid i$</td><td align="center">$p$</td><td align="center">$1$</td></tr><tr><td align="center">$n=p_1\times i$，且 $p_1\mid i$</td><td align="center">$g(i)\times p_1$</td><td align="center">$k(i)+1$</td></tr></tbody></table><p>因此我们可以在线性筛的同时求出 $g(n)$ 和 $k(n)$，复杂度不变。</p><hr><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>下面展示一些积性函数的线性筛法。</p><p>对应函数的积性证明参考 <a href="">这里</a> ，本篇不再证明。</p><p>下面提到的 $n,m,i,j,p,k$ 的定义与上述内容相同。</p><h3 id="线性筛质数"><a href="#线性筛质数" class="headerlink" title="线性筛质数"></a>线性筛质数</h3><p>本质上是筛 <strong>最小质因数</strong> $d_{min}(n)=p_1$，若 $d_{min}(n)=n$ 则这个数为质数。</p><p>这个函数也不是积性函数，但是对于由当前质数 $p_i$ 筛掉的任意合数 $n$，都有 $d_{min}(n)=p_i$</p><div><div class="fold_hider"><div class="close hider_title">Sample-Code</div></div><div class="fold"><figure class="highlight c++ hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) {</span><br><span class="line">    <span class="hljs-keyword">if</span> (!mindiv[i]) prime[++tot] = mindiv[i] = i;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= tot; ++j) {</span><br><span class="line">        <span class="hljs-keyword">if</span> (prime[j] &gt; mindiv[i] || prime[j] * i &gt; n) <span class="hljs-keyword">break</span>;</span><br><span class="line">    mindiv[prime[j] * i] = prime[j];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></div><h3 id="线性筛-mu"><a href="#线性筛-mu" class="headerlink" title="线性筛 $\mu$"></a>线性筛 $\mu$</h3><p>莫比乌斯函数 $\mu$ 是积性函数，定义为<br>$$<br>\mu(n)= \begin{cases} 1 \qquad &amp; n=1 \ (-1)^k \qquad &amp; n=\Pi_{i=1}^{k} p_i \ 0 \qquad &amp; \text{otherwise} \end{cases}<br>$$<br>易得 $\mu(p_i^k)=0(k&gt;1)$，直接按条件分讨就可以。</p><table><thead><tr><th align="center">$n$ 与 $p_1$ 关系</th><th align="center">$\mu(n)$</th></tr></thead><tbody><tr><td align="center">$n$ 是素数 $p_1$</td><td align="center">$-1$</td></tr><tr><td align="center">$n=p_1\times i$，且 $p_1\nmid i$</td><td align="center">$\mu(p_1)\times \mu(i)=-\mu(i)$</td></tr><tr><td align="center">$n=p_1\times i$，且 $p_1\mid i$</td><td align="center">$\mu(p_1^{k_1})\times\mu(j)=0$</td></tr></tbody></table><div><div class="fold_hider"><div class="close hider_title">Sample-Code</div></div><div class="fold"><figure class="highlight c++ hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mu[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) {</span><br><span class="line">    <span class="hljs-keyword">if</span> (!mindiv[i]) prime[++tot] = mindiv[i] = i, mu[i] = <span class="hljs-number">-1</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= tot; ++j) {</span><br><span class="line">        <span class="hljs-keyword">if</span> (prime[j] &gt; mindiv[i] || prime[j] * i &gt; n) <span class="hljs-keyword">break</span>;</span><br><span class="line">    mindiv[prime[j] * i] = prime[j];</span><br><span class="line">        mu[prime[j] * i] = (i % prime[j]) ? -mu[i] : <span class="hljs-number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></div><h3 id="线性筛-varphi"><a href="#线性筛-varphi" class="headerlink" title="线性筛 $\varphi$"></a>线性筛 $\varphi$</h3><p>欧拉函数 $\varphi$ 是积性函数，定义为 </p><p>$$<br>\varphi(n)=\sum_{i=1}^n[i\bot n]<br>$$</p><p>同时有 $\varphi$ 计算公式（证明见<a href="">这里</a>) </p><p>$$<br>\varphi(n)=n\prod_{i=1}^m \frac{p_i-1}{p_i}<br>$$</p><p>由计算公式知，第三类情况 </p><p>$$<br>\varphi(n)=\varphi(p_1^k)\times\varphi(j)=(p_1-1)\times p_1^{k-1}\times \varphi(j)\<br>\varphi(i)=\varphi(p_1^{k_1-1})\times \varphi(j)=(p_1-1)\times p_1^{k_1-2}\times \varphi(j)<br>$$</p><p>因此有 </p><p>$$<br>\varphi(n)=\varphi(i)\times p_1<br>$$</p><table><thead><tr><th align="center">$n$ 与 $p_1$ 关系</th><th align="center">$\varphi(n)$</th></tr></thead><tbody><tr><td align="center">$n$ 是素数 $p_1$</td><td align="center">$n-1$</td></tr><tr><td align="center">$n=p_1\times i$，且 $p_1\nmid i$</td><td align="center">$\varphi(p_1)\times \varphi(i)=(p_1-1)\times \varphi(i)$</td></tr><tr><td align="center">$n=p_1\times i$，且 $p_1\mid i$</td><td align="center">$\varphi(p_1^k)\times\varphi(j)=p_1\times \varphi(i)$</td></tr></tbody></table><div><div class="fold_hider"><div class="close hider_title">Sample-Code</div></div><div class="fold"><figure class="highlight c++ hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">phi[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) {</span><br><span class="line">    <span class="hljs-keyword">if</span> (!phi[i]) prime[++tot] = i, phi[i] = i - <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= tot; ++j) {</span><br><span class="line">        <span class="hljs-keyword">if</span> (prime[j] &gt; mindiv[i] || prime[j] * i &gt; n) <span class="hljs-keyword">break</span>;</span><br><span class="line">    phi[prime[j] * i] = phi[i] * ((i % prime[j]) ? prime[j] - <span class="hljs-number">1</span> : prime[j]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></div><h3 id="关于-sigma-k"><a href="#关于-sigma-k" class="headerlink" title="关于 $\sigma_k$"></a>关于 $\sigma_k$</h3><p>约束幂和函数 $\sigma_k$ 是积性函数，定义为<br>$$<br>\sigma_k(n)=\sum_{d|n}d^k<br>$$<br>也就是说，$\sigma_k$ 是一个函数族，代表 $n$ 的约数的 $k$ 次幂和。</p><p>下面我们从简到难介绍 $\sigma_k$ 的求法。</p><h3 id="线性筛-tau"><a href="#线性筛-tau" class="headerlink" title="线性筛 $\tau$"></a>线性筛 $\tau$</h3><p>约数个数函数 $\tau=\sigma_0$ 是积性函数，即约束的 $0$ 次幂和，定义为<br>$$<br>\tau(n)=\sigma_0(n)=\sum [d | n]<br>$$<br>利用多集合的计数思路，对于 $n$ 的标准分解，有<br>$$<br>\tau(n)=\sigma_0(n)=\prod_{i=1}^m (k_i+1)<br>$$</p><p>同样直接分类讨论即可，但注意维护 $g(n)$ 和计算 $\tau(p^k)$ 的位置。</p><table><thead><tr><th align="center">$n$ 与 $p_1$ 关系</th><th align="center">$\tau(n)$</th></tr></thead><tbody><tr><td align="center">$n$ 是素数 $p_1$</td><td align="center">$2$</td></tr><tr><td align="center">$n=p_1\times i$，且 $p_1\nmid i$</td><td align="center">$\tau(p_1)\times \tau(i)=2\tau(i)$</td></tr><tr><td align="center">$n=p_1\times i$，且 $p_1\mid i$</td><td align="center">$\tau(p_1^k)\times\tau(j)$</td></tr></tbody></table><div><div class="fold_hider"><div class="close hider_title">Sample-Code</div></div><div class="fold"><figure class="highlight c++ hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">g[<span class="hljs-number">1</span>] = tau[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) {</span><br><span class="line">    <span class="hljs-keyword">if</span> (!mindiv[i]) {</span><br><span class="line">       g[i] = i;</span><br><span class="line">        tau[i] = <span class="hljs-number">2</span>;</span><br><span class="line">        prime[++tot] = mindiv[i] = i;</span><br><span class="line">    }</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>, temp; j &lt;= tot; ++j) {</span><br><span class="line">        temp = prime[j] * i;</span><br><span class="line">        <span class="hljs-keyword">if</span> (prime[j] &gt; mindiv[i] || temp &gt; n) <span class="hljs-keyword">break</span>;</span><br><span class="line">    <span class="hljs-keyword">if</span> (prime[j] == mindiv[i]) {</span><br><span class="line">            g[temp] = g[i] * prime[j];</span><br><span class="line">            <span class="hljs-keyword">if</span> (g[temp] == temp) tau[temp] = tau[g[i]] + <span class="hljs-number">1</span>;</span><br><span class="line">            <span class="hljs-keyword">else</span> tau[temp] = tau[g[temp]] * tau[i / g[i]];</span><br><span class="line">            <span class="hljs-keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        g[temp] = prime[j];</span><br><span class="line">        mindiv[temp] = prime[j];</span><br><span class="line">        tau[temp] = <span class="hljs-number">2</span> * tau[i];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></div><h3 id="线性筛-sigma"><a href="#线性筛-sigma" class="headerlink" title="线性筛 $\sigma$"></a>线性筛 $\sigma$</h3><p>约数和函数 $\sigma=\sigma_1$ 是积性函数，即约束的 $1$ 次幂和，定义为<br>$$<br>\sigma(n)=\sigma_1(n)=\sum_{d|n} d<br>$$<br>利用多集合的计数思路，对于 $n$ 的标准分解，有<br>$$<br>\sigma(n)=\sigma_1(n)=\prod_{i=1}^m \sum_{j=0}^{k_i} p_i^j<br>$$</p><p>同样直接分类讨论即可，注意维护 $g(n),k(n)$ 和计算 $\sigma(p^k)$ 的位置 。</p><p>由于计算 $\sigma(p^k)$ 单次复杂度为 $O(\log k)$，总复杂度依然保持线性。</p><table><thead><tr><th align="center">$n$ 与 $p_1$ 关系</th><th align="center">$\sigma(n)$</th></tr></thead><tbody><tr><td align="center">$n$ 是素数 $p_1$</td><td align="center">$p_1+1$</td></tr><tr><td align="center">$n=p_1\times i$，且 $p_1\nmid i$</td><td align="center">$\sigma(p_1)\times \sigma(i)=(p_1+1)\times \sigma(i)$</td></tr><tr><td align="center">$n=p_1\times i$，且 $p_1\mid i$</td><td align="center">$\sigma(p_1^k)\times\sigma(j)$</td></tr></tbody></table><div><div class="fold_hider"><div class="close hider_title">Sample-Code</div></div><div class="fold"><figure class="highlight c++ hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">g[<span class="hljs-number">1</span>] = k[<span class="hljs-number">1</span>] = sigma[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) {</span><br><span class="line">    <span class="hljs-keyword">if</span> (!mindiv[i]) {</span><br><span class="line">       g[i] = i;</span><br><span class="line">        k[i] = <span class="hljs-number">1</span>;</span><br><span class="line">        sigma[i] = i + <span class="hljs-number">1</span>;</span><br><span class="line">        prime[++tot] = mindiv[i] = i;</span><br><span class="line">    }</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>, temp; j &lt;= tot; ++j) {</span><br><span class="line">        temp = prime[j] * i;</span><br><span class="line">        <span class="hljs-keyword">if</span> (prime[j] &gt; mindiv[i] || temp &gt; n) <span class="hljs-keyword">break</span>;</span><br><span class="line">    <span class="hljs-keyword">if</span> (prime[j] == mindiv[i]) {</span><br><span class="line">            k[temp] = k[i] + <span class="hljs-number">1</span>;</span><br><span class="line">            g[temp] = g[i] * prime[j];</span><br><span class="line">            <span class="hljs-keyword">if</span> (g[temp] == temp) sigma[temp] = sigma[g[i]] + fpow(prime[j], k[i]);</span><br><span class="line">            <span class="hljs-keyword">else</span> sigma[temp] = sigma[g[temp]] * sigma[i / g[i]];</span><br><span class="line">            <span class="hljs-keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        g[temp] = prime[j];</span><br><span class="line">        k[temp] = <span class="hljs-number">1</span>;</span><br><span class="line">        mindiv[temp] = prime[j];</span><br><span class="line">        sigma[temp] = (prime[j] + <span class="hljs-number">1</span>) * sigma[i];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></div><h3 id="线性筛-sigma-k"><a href="#线性筛-sigma-k" class="headerlink" title="线性筛 $\sigma_k$"></a>线性筛 $\sigma_k$</h3><p>约数幂和函数 $\sigma_k$ 是积性函数，即约束的 $k$ 次幂和，定义为<br>$$<br>\sigma_k(n)=\sum_{d|n} d^k<br>$$<br>为避免重复，用大写 $K$ 表示所求幂次。</p><p>同样直接分类讨论即可，注意维护 $g(n),k(n)$ 和计算 $\sigma_k(p^k)$ 的位置 。</p><p>此时计算 $\sigma_k(p^k)$ 单次复杂度为 $\mathcal O(\log (k\times K))$，总复杂度<strong>不再保持线性</strong>。</p><table><thead><tr><th align="center">$n$ 与 $p_1$ 关系</th><th align="center">$\sigma_k(n)$</th></tr></thead><tbody><tr><td align="center">$n$ 是素数 $p_1$</td><td align="center">$p_1^{K}+1$</td></tr><tr><td align="center">$n=p_1\times i$，且 $p_1\nmid i$</td><td align="center">$\sigma(p_1)\times \sigma(i)$</td></tr><tr><td align="center">$n=p_1\times i$，且 $p_1\mid i$</td><td align="center">$\sigma(p_1^k)\times\sigma(j)$</td></tr></tbody></table><div><div class="fold_hider"><div class="close hider_title">Sample-Code</div></div><div class="fold"><figure class="highlight c++ hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">g[<span class="hljs-number">1</span>] = k[<span class="hljs-number">1</span>] = sigma[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) {</span><br><span class="line">    <span class="hljs-keyword">if</span> (!mindiv[i]) {</span><br><span class="line">       g[i] = i;</span><br><span class="line">        k[i] = <span class="hljs-number">1</span>;</span><br><span class="line">        sigma[i] = fpow(i, K) + <span class="hljs-number">1</span>;</span><br><span class="line">        prime[++tot] = mindiv[i] = i;</span><br><span class="line">    }</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>, temp; j &lt;= tot; ++j) {</span><br><span class="line">        temp = prime[j] * i;</span><br><span class="line">        <span class="hljs-keyword">if</span> (prime[j] &gt; mindiv[i] || temp &gt; n) <span class="hljs-keyword">break</span>;</span><br><span class="line">    <span class="hljs-keyword">if</span> (prime[j] == mindiv[i]) {</span><br><span class="line">            k[temp] = k[i] + <span class="hljs-number">1</span>;</span><br><span class="line">            g[temp] = g[i] * prime[j];</span><br><span class="line">            <span class="hljs-keyword">if</span> (g[temp] == temp) sigma[temp] = sigma[g[i]] + fpow(prime[j], k[i] * K);</span><br><span class="line">            <span class="hljs-keyword">else</span> sigma[temp] = sigma[g[temp]] * sigma[i / g[i]];</span><br><span class="line">            <span class="hljs-keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        g[temp] = prime[j];</span><br><span class="line">        k[temp] = <span class="hljs-number">1</span>;</span><br><span class="line">        mindiv[temp] = prime[j];</span><br><span class="line">        sigma[temp] = sigma[prime[j]] * sigma[i];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></div><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>当 $K$ 很大的时候显然会超时，例如计算 $n=K=10^7$ 时，可以考虑打表。</p><p>找到 $p_i,k_i$ 可能的最大值，得到 $p\le 4\times 10^3,k_i\le 25$，直接记忆化省掉快速幂。</p><div><div class="fold_hider"><div class="close hider_title">Sample-Code</div></div><div class="fold"><figure class="highlight c++ hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;</span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e7</span> + <span class="hljs-number">10</span>, p = <span class="hljs-number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// c[N] 即文中 k[N]</span></span><br><span class="line"><span class="hljs-keyword">int</span> n, k, pri[N], tot, c[N], mn[N], g[N];</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line">ll f[N], ans;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fpow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, ll b)</span> </span>{</span><br><span class="line"><span class="hljs-keyword">int</span> r = <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">for</span>( ; b ; b &gt;&gt;= <span class="hljs-number">1</span>, a = (ll) a * a % p) <span class="hljs-keyword">if</span>(b &amp; <span class="hljs-number">1</span>) r = (ll) r * a % p;</span><br><span class="line"><span class="hljs-keyword">return</span> r;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> val[<span class="hljs-number">4000</span>][<span class="hljs-number">25</span>];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">F</span><span class="hljs-params">(<span class="hljs-keyword">int</span> mn, <span class="hljs-keyword">int</span> c)</span> </span>{</span><br><span class="line"><span class="hljs-keyword">if</span>(val[mn][c] != <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> val[mn][c];</span><br><span class="line"><span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span> ; j &lt;= c ; ++ j) r = ((ll) r + fpow(mn, (ll) j * k)) % p;</span><br><span class="line"><span class="hljs-keyword">return</span> val[mn][c] = r;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{</span><br><span class="line"><span class="hljs-built_in">memset</span>(val, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> val);</span><br><span class="line"><span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">ans = f[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; ++ i) {</span><br><span class="line"><span class="hljs-keyword">if</span>(!vis[i]) pri[++ tot] = i, f[i] = <span class="hljs-number">1</span> + fpow(i, k), g[i] = i, c[i] = <span class="hljs-number">1</span>, mn[i] = i;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span> ; j &lt;= tot &amp;&amp; (ll) i * pri[j] &lt;= n ; ++ j) {</span><br><span class="line"><span class="hljs-keyword">int</span> x = i * pri[j];</span><br><span class="line">vis[x] = <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">if</span>(i % pri[j] == <span class="hljs-number">0</span>) {</span><br><span class="line">f[x] = f[i / g[i]] * F(mn[i], c[i] + <span class="hljs-number">1</span>) % p;</span><br><span class="line">g[x] = g[i] * pri[j];</span><br><span class="line">c[x] = c[i] + <span class="hljs-number">1</span>;</span><br><span class="line">mn[x] = pri[j];</span><br><span class="line"><span class="hljs-keyword">break</span>;</span><br><span class="line">} <span class="hljs-keyword">else</span> f[x] = f[i] * f[pri[j]] % p, g[x] = pri[j], c[x] = <span class="hljs-number">1</span>, mn[x] = pri[j];</span><br><span class="line">}</span><br><span class="line">ans = (ans + f[i]) % p;</span><br><span class="line">}</span><br><span class="line"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>, ans);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></div><hr><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>对于一些未定义积性函数，线性筛的应用。</p><h3 id="2018-南京网络预赛-Sum"><a href="#2018-南京网络预赛-Sum" class="headerlink" title="[2018 南京网络预赛] Sum"></a><a href="https://nanti.jisuanke.com/t/A1956">[2018 南京网络预赛] Sum</a></h3><p>定义 $f(x)$ 为满足以下条件的<strong>有序</strong>二元组 $(a,b)$ 的方案数</p><ul><li>$x = a\times b$</li><li>$a$ 和 $b$ 均无平方因子 ( $\mu(a)\neq 0,\mu(b)\neq 0$ )</li></ul><p>求 $\sum_{i=1}^n f(i)$，数据范围 $n\le 2\times 10^7$ </p><p><strong>Solution</strong></p><p>显然 $f(x)=\sum_{d|x} abs(\mu(d)\mu(\frac nd))$，是积性函数（相当于是重定义让 $\mu\ge 0$， $\mu*\mu$ ）。</p><table><thead><tr><th align="center">$n$ 与 $p_1$ 关系</th><th align="center">$f(n)$</th></tr></thead><tbody><tr><td align="center">$n$ 是素数 $p_1$</td><td align="center">$2$</td></tr><tr><td align="center">$n=p_1\times i$，且 $p_1\nmid i$</td><td align="center">$f(p_1)\times f(i)=2f(i)$</td></tr></tbody></table><p>对于 $n=p_1\times i$，且 $p_1\mid i$ 的情况，讨论：</p><ul><li><p>若 $p_1 | \frac i{p_1}$ 即 $p_1 | \frac{n}{p_1^2}$ 时， $n$ 中 $p_1$ 的指数至少为 $3$ ，无论如何划分 $(a,b)$，都有一个 $\mu = 0$ ， $f(n) = 0$ </p></li><li><p>否则 $p_1$ 的指数为 $2$ ， 产生贡献必须把 $p_1$ 分给 $a$ 和 $b$ 各一个，即方案数 $f(n) = f(\frac{n}{p_1^2})$</p></li></ul><figure class="highlight c++ hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 20000007ll</span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rd</span><span class="hljs-params">()</span> </span>{</span><br><span class="line">  <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;</span><br><span class="line">  <span class="hljs-keyword">char</span> c = getchar();</span><br><span class="line">  <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isdigit</span>(c)) c = getchar();</span><br><span class="line">  <span class="hljs-keyword">while</span> (<span class="hljs-built_in">isdigit</span>(c)) {</span><br><span class="line">    x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>);</span><br><span class="line">    c = getchar();</span><br><span class="line">  }</span><br><span class="line">  <span class="hljs-keyword">return</span> x;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> tot, f[N], prm[N];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>{</span><br><span class="line">  f[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;</span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; N; ++i) {</span><br><span class="line">    <span class="hljs-keyword">if</span> (!vis[i]) prm[++tot] = i, f[i] = <span class="hljs-number">2</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= tot; ++j) {</span><br><span class="line">       <span class="hljs-keyword">if</span> (<span class="hljs-number">1l</span>l * i * prm[j] &gt;= N) <span class="hljs-keyword">break</span>;</span><br><span class="line">       vis[i * prm[j]] = <span class="hljs-number">1</span>;</span><br><span class="line">       <span class="hljs-keyword">if</span> (i % prm[j] == <span class="hljs-number">0</span>) {</span><br><span class="line">         f[i * prm[j]] = ((i / prm[j]) % prm[j]) ? f[i / prm[j]] : <span class="hljs-number">0</span>;</span><br><span class="line">         <span class="hljs-keyword">break</span>;</span><br><span class="line">       }</span><br><span class="line">       f[i * prm[j]] = f[i] &lt;&lt; <span class="hljs-number">1</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; N; ++i) f[i] += f[i - <span class="hljs-number">1</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{</span><br><span class="line">  init();</span><br><span class="line">  <span class="hljs-keyword">int</span> t = rd();</span><br><span class="line">  <span class="hljs-keyword">while</span> (t--) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, f[rd()]);</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>(还有一种做法即 $f=\mu^2 *\mu^2$ ，反演即可，查询单次 $\mathcal O(\sqrt n)$ ，参考<a href="https://www.cnblogs.com/lfri/p/11382166.html">这里</a>)</p></body></html>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性筛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Render Math Equations in Hexo</title>
      <link href="2019/06/01/mathjax/"/>
      <url>2019/06/01/mathjax/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><p>$$<br>f(a) = \frac{1}{2\pi i}\oint_{\gamma}\frac{f(z)}{z-a}dz<br>$$</p><p><a href="https://www.mathjax.org/">Beautiful and accessible math in all browsers - MathJax</a> </p><p>This post is used to check out whether the mathjax plugin (<a href="https://github.com/hexojs/hexo-math">hexo-math</a>) still works.</p><a id="more"></a><h2 id="Inline-Formula"><a href="#Inline-Formula" class="headerlink" title="Inline Formula"></a>Inline Formula</h2><p>Consider the sequence of $n$ distinct positive integers: $c_1, c_2, \cdots, c_n$. The child calls a vertex-weighted rooted binary tree <strong>good</strong> if and only if for every vertex $v$, the weight of $v$ is in the set ${c_1, c_2, \cdots, c_n}$ . Also our child thinks that the <strong>weight</strong> of a vertex-weighted tree is the sum of all vertices’ weights.</p><p>Given an integer $m$, can you for all $s (1 \le  s ≤ m) $ calculate the number of good vertex-weighted rooted binary trees with weight $s$ ? Please, check the samples for better understanding what trees are considered different.</p><p>We only want to know the answer modulo $998244353$ ( $7 × 17 × 2^{23} + 1$ , a prime number).</p><h2 id="Block-Formula"><a href="#Block-Formula" class="headerlink" title="Block Formula"></a>Block Formula</h2><p>$$<br>\int \frac{dx}{cos^2x}=\int sec^2xdx=tan x+C\<br>$$</p><p>$$<br>\int \frac{dx}{sin^2x}=\int csc^2xdx=-cot x+C\<br>$$</p><p>$$<br>\sum\limits_{i = 0}^{E} w[i]{M \choose i} {N \choose iS} \frac{(iS)!}{(S!)^{i}} \sum\limits_{j = 0}^{E - i} (-1)^{j} {M - i \choose j} {N - iS \choose jS} \frac{(jS)!}{(S!)^{j}} (M - i - j)^{N - iS - jS}<br>$$</p><p>$$<br>= \sum\limits_{i = 0}^{E} w[i]{M \choose i} {N \choose iS} \frac{(iS)!}{(S!)^{i}} \sum\limits_{j = i}^{E} (-1)^{j - i} {M - i \choose j - i} {N - iS \choose jS - iS} \frac{(jS - iS)!}{(S!)^{j - i}} (M - j)^{N - jS}<br>$$</p><h2 id="Matrix"><a href="#Matrix" class="headerlink" title="Matrix"></a>Matrix</h2><p>$$<br>\begin{bmatrix}<br>(\omega_n^0)^0 &amp; (\omega_n^0)^1 &amp; \cdots &amp; (\omega_n^0)^{n-1}\\ (\omega_n^1)^0 &amp; (\omega_n^1)^1 &amp; \cdots &amp; (\omega_n^1)^{n-1}\\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>(\omega_n^{n-1})^0 &amp; (\omega_n^{n-1})^1 &amp; \cdots &amp; (\omega_n^{n-1})^{n-1}<br>\end{bmatrix}<br>\begin{bmatrix}<br>a_0 \\<br>a_1 \\<br>\vdots \\<br>a_{n-1}<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>A(\omega_n^0) \\<br>A(\omega_n^1) \\<br>\vdots \\<br>A(\omega_n^{n-1})<br>\end{bmatrix}<br>$$</p><p>$$<br>\begin{bmatrix}<br>a_0 \\<br>a_1 \\<br>\vdots \\<br>a_{n-1}<br>\end{bmatrix}<br>=<br>\frac{1}{n}<br>\begin{bmatrix}<br>(\omega_n^{-0})^0 &amp; (\omega_n^{-0})^1 &amp; \cdots &amp; (\omega_n^{-0})^{n-1} \\<br>(\omega_n^{-1})^0 &amp; (\omega_n^{-1})^1 &amp; \cdots &amp; (\omega_n^{-1})^{n-1} \\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>(\omega_n^{-(n-1)})^0 &amp; (\omega_n^{-(n-1)})^1 &amp; \cdots &amp; (\omega_n^{-(n-1)})^{n-1}<br>\end{bmatrix}<br>\begin{bmatrix}<br>A(\omega_n^0) \\<br>A(\omega_n^1) \\<br>\vdots \\<br>A(\omega_n^{n-1})<br>\end{bmatrix}<br>$$</p><blockquote class="colorquote warning"><p>To prevent escaping, you need to use <code>\\\\</code> to make a new line rather than <code>\\</code> .</p></blockquote><blockquote class="colorquote success"><p>For more about the Mathjax symbols, refer to <a href="/material/mathjax-symbol-list.pdf">The Comprehensive LaTeX Symbol List</a> .</p></blockquote></body></html>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2018/11/29/hello-world/"/>
      <url>2018/11/29/hello-world/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><p>「 Hello, the lovely world. 」</p><p>「 Stay hungry, Stay foolish. 」</p><figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> this</span><br><span class="line">The Zen of Python, by Tim Peters</span><br><span class="line"></span><br><span class="line">Beautiful <span class="hljs-keyword">is</span> better than ugly.</span><br><span class="line">Explicit <span class="hljs-keyword">is</span> better than implicit.</span><br><span class="line">Simple <span class="hljs-keyword">is</span> better than complex.</span><br><span class="line">Complex <span class="hljs-keyword">is</span> better than complicated.</span><br><span class="line">Flat <span class="hljs-keyword">is</span> better than nested.</span><br><span class="line">Sparse <span class="hljs-keyword">is</span> better than dense.</span><br><span class="line">Readability counts.</span><br><span class="line">Special cases aren<span class="hljs-string">'t special enough to break the rules.</span></span><br><span class="line"><span class="hljs-string">Although practicality beats purity.</span></span><br><span class="line"><span class="hljs-string">Errors should never pass silently.</span></span><br><span class="line"><span class="hljs-string">Unless explicitly silenced.</span></span><br><span class="line"><span class="hljs-string">In the face of ambiguity, refuse the temptation to guess.</span></span><br><span class="line"><span class="hljs-string">There should be one-- and preferably only one --obvious way to do it.</span></span><br><span class="line"><span class="hljs-string">Although that way may not be obvious at first unless you'</span>re Dutch.</span><br><span class="line">Now <span class="hljs-keyword">is</span> better than never.</span><br><span class="line">Although never <span class="hljs-keyword">is</span> often better than *right* now.</span><br><span class="line">If the implementation <span class="hljs-keyword">is</span> hard to explain, it<span class="hljs-string">'s a bad idea.</span></span><br><span class="line"><span class="hljs-string">If the implementation is easy to explain, it may be a good idea.</span></span><br><span class="line"><span class="hljs-string">Namespaces are one honking great idea -- let'</span>s do more of those!</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
