<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Classmate Alumni</title>
      <link href="/2020/07/09/classmate-alumni/"/>
      <url>/2020/07/09/classmate-alumni/</url>
      
        <content type="html"><![CDATA[<p>人生天地间，忽如远行客。</p><p>如果你在我高中三年的生活中遇见我，希望在这里留下你的消息。</p><a id="more"></a><script charset="UTF-8" defer>(function(h){function n(a){return null===a?null:a.scrollHeight>a.clientHeight?a:n(a.parentNode)}function t(b){if(b.data){var f=JSON.parse(b.data);!f.height||p||q||(d.style.height=+f.height+"px");if(f.getter){b={};var f=[].concat(f.getter),k,h=f.length,m,c,g,e;for(k=0;k<h;k++){m=k;c=f[k]||{};c.n&&(m=c.n);g=null;try{switch(c.t){case "window":e=window;break;case "scrollParent":e=n(a)||window;break;default:e=a}if(c.e)if("rect"===c.v){g={};var l=e.getBoundingClientRect();g={top:l.top,left:l.left,width:l.width,height:l.height}}else g=e[c.v].apply(e,[].concat(c.e))||!0;else c.s?(e[c.v]=c.s,g=!0):g=e[c.v]||!1}catch(u){}b[m]=g}b.innerState=!p&&!q;a.contentWindow.postMessage(JSON.stringify({queryRes:b}),"*")}}}for(var r=h.document,b=r.documentElement;b.childNodes.length&&1==b.lastChild.nodeType;)b=b.lastChild;var d=b.parentNode,a=r.createElement("iframe");d.style.overflowY="auto";d.style.overflowX="hidden";var p=d.style.height&&"auto"!==d.style.height,q="absolute"===d.style.position||window.getComputedStyle&&"absolute"===window.getComputedStyle(d,null).getPropertyValue("position")||d.currentStyle&&"absolute"===d.currentStyle.position;h.addEventListener&&h.addEventListener("message",t,!1);a.src="http://sg-colin.mikecrm.com/IPh2KJB";a.id="mkinIPh2KJB";a.onload=function(){a.contentWindow.postMessage(JSON.stringify({cif:1}),"*")};a.frameBorder=0;a.scrolling="no";a.style.display="block";a.style.minWidth="100%";a.style.width="100px";a.style.height="100%";a.style.border="none";a.style.overflow="auto";d.insertBefore(a,b)})(window);</script>]]></content>
      
      
      <categories>
          
          <category> Summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Counting Tricks</title>
      <link href="/2020/01/03/count-in-gk/"/>
      <url>/2020/01/03/count-in-gk/</url>
      
        <content type="html"><![CDATA[<p>做高考计数题的时候发现 OI 里的一些东西挺好用。</p><p>简单整理一下，可能对于高考略超纲，但是不难上手。</p><a id="more"></a><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>内容很基础，但是我想说的是，计数题的计算公式还是从实际意义去理解比较好。</p><ul><li><p><strong>排列 (Permutation)</strong></p><script type="math/tex; mode=display">P_{n}^m=\frac{n!}{(n-m)!}</script><p>从 $n$ 个不同的元素里，选出 $m$ 个进行全排列的方案数。</p><p>分子 $n!$ 的含义是 $n$ 个元素的全排列，其中有 $n-m$ 个是不需要的，因此他们的顺序没有意义，去掉不同顺序带来的计数，除掉 $n-m$ 的全排列数 $(n-m)!$ </p></li><li><p><strong>组合 (Combination)</strong></p><script type="math/tex; mode=display">C_n^m=\frac{n!}{m!(n-m)!}</script><p>从 $n$ 个不同的元素里，选出 $m$ 个组成一个集合的方案数。</p><p>相当于排列数中的 $m$ 个元素去掉顺序，即 $P_n^m$ 再除掉 $m$ 的全排列数 $m!$</p></li><li><p><strong>顺序化与去顺序</strong></p><p>从排列数和组合数的定义可以看出，排列的顺序带来了更多的方案数；</p><p>而组合的选取集合无序性，使得方案数去掉了 $m$ 个元素内部顺序。</p><p>我们可以笼统的归纳出：$m$ 个元素有顺序的方案数 $=$ 无顺序的方案数 $\times \ m!$</p><p>这样就可以很好地解释一个恒等式：$P_n^m=C_n^m\times m!$</p><p>有序与无序的转换可以通过乘或除全排列来实现，这个思想后面我们还会用到。</p></li><li><p><strong>一个组合恒等式</strong></p><script type="math/tex; mode=display">C_n^m=C_{n-1}^{m-1}+C_{n-1}^m</script><p>含义是，从 $n$ 个不同的元素里，选出 $m$ 个组成一个集合的方案，可以由两种情况发展而来：</p><ol><li>选上第 $n$ 个元素，前 $n-1$ 个元素中选取 $m-1$ 个。</li><li>不选第 $n-1$ 个元素，前 $m-1$ 个元素中选取 $m$ 个。</li></ol><p>这种<strong>增量的思维，即单独考虑第 $n$ 个元素的选取策略</strong>的思考方式很重要，在后面也还会用到。</p></li></ul><h2 id="全错位排列"><a href="#全错位排列" class="headerlink" title="全错位排列"></a>全错位排列</h2><p>指 $n$ 个不同元素的全排列，使得对于任何 $i(i\in[1,n])$ ，满足第 $i$ 个位置上的数不是 $i$ 的排列数。</p><p>  其通项公式确实不太好记忆，但是递推公式非常好记忆：</p><script type="math/tex; mode=display">  D_1 = 0\ ,\ D_2 = 1  \\D_n=(n-1)(D_{n-1}+D_{n-2})\ (n\ge 3)</script><p>  公式的含义是，当 $n\ge 3$ 时，用增量的思维，单独考虑数字 $n$ 在排列中的位置。</p><p>  不妨设 $n$ 排在了第 $k$ 位，其中 $k\not = n$，也就是 $k\in [1,n-1]$，这是考虑第 $n$ 位的情况：</p><ol><li>当数字 $k$ 排在第 $n$ 位时，除了 $n$ 和 $k$ 以外还有 $n-2$ 个数，其错排数为 $D_{n-2}$。</li><li>当 $k$ 不排在第 $n$ 位时，那么将第 $n$ 位重新考虑成一个新的“第 $k$ 位”，这时的包括 $k$ 在内的剩下 $n-1$ 个数的每一种错排，都等价于只有 $n-1$个数时的错排（只是其中的第 $k$ 位会换成第 $n$ 位），其错排数为 $D_{n-1}$。</li></ol><p>这两种情况是独立的，而 $k$ 的选取又有 $n-1$ 种，所以 $D_n=(n-1)(D_{n-1}+D_{n-2})$</p><h2 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h2><p>  <del>会了这个在 2016 年的高考题里选择压轴 12 题你就可以一秒算出。</del></p><p>  这个数列的含义有很多，这里先给出公式再解释：</p><script type="math/tex; mode=display">  \begin{align}  H_n=\frac{C_{2n}^{n}}{n+1}=\frac{\prod_{i=n+2}^{2n}i}{n!}\end{align}</script><p>  比较常见的一种定义是：从原点 $(0,0)$ 到点 $B(n,n)$ ，只能向右或向上进行长度为一个单位的移动，<strong>路线一直处于 $y=x$ 之下</strong>的方案数；</p><p>  <img src="https://i.loli.net/2019/12/13/S9WAc7rw3qEuVKz.png" style="zoom:67%;"></p><ol><li><p>总共需要走的步数为 $2n$ 步，而向右一共要走 $n$ 步，故总的方案数为 $C_{2n}^{n}$ 。</p></li><li><p>不合法的方案即为越过 $y=x$ 的路径数，考虑将每一个不合法的方案中从 $(0,0)$ 到<strong>第一个</strong>越过 $y=x$ 的点这一部分的路径关于 $y=x+1$对称，其余部分不变。我们发现，每一个不合法的路径都一一映射到了一个从 $(-1,1)$ 到 $(n,n)$ 的路径，那么不合法的方案数即为从 $(-1,1)$ 走到 $(n,n)$ 的方案数，因为一共向上要走$n-1$步，向右一共要走$n+1$步，所以不合法的方案数为 $C_{2n}^{n-1}$或 $C_{2n}^{n+1}$。</p></li><li>做一个减法，整理一下就得到了公式：</li></ol><script type="math/tex; mode=display">H_n=C_{2n}^n-C_{2n}^{n-1}=C_{2n}^n - C_{2n}^{n}\times \frac{n}{n+1}=\frac{C_{2n}^{n}}{n+1}</script><p>Catalan 数还有以下几中比较常见的解释：</p><ul><li><p>$n$ 个 $0$ 与 $n$ 个 $1$ 构成的序列，使得任何一个前缀 $0$ 的个数不少于 $1$ 的方案数。</p><p>也就是  16 年高考题的题面啦，把 $0$ 当作向右走一步，把 $1$ 当作向上走一步，就可以解释了。</p></li><li><p>给定 $n$ 对括号，求所有括号正确配对的括号序列数。</p><p>把左括号当作向右走一步，把右括号当作向上走一步，就可以解释了。</p></li><li><p>将一个 $n+2$ 条边的凸多边形，通过若干条互不相交的对角线，划分成 $n$ 个三角形的方案数。</p><p>这个用组合数学不太好解释，想听的同学找我吧…</p></li></ul><h2 id="第二类斯特林数"><a href="#第二类斯特林数" class="headerlink" title="第二类斯特林数"></a>第二类斯特林数</h2><p>第一类 Stirling 数貌似用处不太大就先不讲了…</p><p>第二类 Stirling 数是一个二维数表，$S_n^m$ 表示将 $n$ 个不同的元素，划分成 $m$ 个不同的非空集合的方案数。</p><script type="math/tex; mode=display">S_n^m=S_{n-1}^{m-1}+m\times S_{n-1}^m</script><p>同样以增量的角度思考递推式的形式。</p><ul><li>如果第 $n$ 个元素单独作为一个集合，则方案唯一，剩下的部分组成 $m-1$ 个集合，贡献为 $S_{n−1}^{m−1}$ 。 </li><li>如果第 $n$ 个元素加入之前的集合，那么有 $m$ 个集合可以选择，贡献是 $m\times S_{n-1}^m$ 。</li></ul><p>对于一些边界的情况很容易得到结论：</p><script type="math/tex; mode=display">S_n^0=0,S_n^1=1,S_n^n=1,S_n^m=0(m>n)</script><p>所以简单的二维数表也就不难推出：</p><div class="table-container"><table><thead><tr><th style="text-align:center">n\m</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">3</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">7</td><td style="text-align:center">6</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">15</td><td style="text-align:center">25</td><td style="text-align:center">10</td><td style="text-align:center">1</td></tr></tbody></table></div><p>用法在后面我们会提到。</p><h2 id="隔板法"><a href="#隔板法" class="headerlink" title="隔板法"></a>隔板法</h2><p>核心的思想是两句话：</p><ol><li>每两个相邻的板构成一个盒子。</li><li>板是相同的，盒子是不同的。板之间形成的空隙的顺序完成了的对盒子不同的要求，把盒子变成板实质为“去顺序”</li></ol><p>操作的方法有两种，分别是插空法和排列法，我们在下面的小球装箱中，利用前两种情况的问题进行说明。</p><h2 id="小球装箱"><a href="#小球装箱" class="headerlink" title="小球装箱"></a>小球装箱</h2><p>由球、盒子是否相同，盒子是否可空组合成的八种问题。</p><p>鉴于是面向高考题目的一份总结，这里只说六种比较好操作的情况。</p><p>问题格式为，有 $n$ 个（同/不同）的球，放到 $m$ 个（同/不同）的盒子中，要求盒子（可以/不可以）空。</p><p>这里先给出问题的答案，再逐一说明。</p><div class="table-container"><table><thead><tr><th style="text-align:center">球</th><th style="text-align:center">盒</th><th style="text-align:center">是否可空</th><th style="text-align:center">Answer</th></tr></thead><tbody><tr><td style="text-align:center">同</td><td style="text-align:center">不同</td><td style="text-align:center">不可空</td><td style="text-align:center">$C_{n-1}^{m-1}$</td></tr><tr><td style="text-align:center">同</td><td style="text-align:center">不同</td><td style="text-align:center">可空</td><td style="text-align:center">$C_{n+m-1}^n$</td></tr><tr><td style="text-align:center">不同</td><td style="text-align:center">同</td><td style="text-align:center">不可空</td><td style="text-align:center">$S_n^i$</td></tr><tr><td style="text-align:center">不同</td><td style="text-align:center">同</td><td style="text-align:center">可空</td><td style="text-align:center">$\sum_{i=1}^mS_n^i$</td></tr><tr><td style="text-align:center">不同</td><td style="text-align:center">不同</td><td style="text-align:center">不可空</td><td style="text-align:center">$S_n^m\times P_m^m$</td></tr><tr><td style="text-align:center">不同</td><td style="text-align:center">不同</td><td style="text-align:center">可空</td><td style="text-align:center">$m^n$</td></tr></tbody></table></div><ul><li><p>球同，盒子不同，盒子不可以空。</p><p>思路是隔板法的第一种，<strong>插空法</strong>。</p><p>有 $m$ 个盒子，每两个相邻的板构成一个盒子，所以需要放 $m+1$ 个板。</p><p>首先我们在 $n$ 个球的两侧放上两个板，代表左右边缘两个盒子的一侧。</p><p>那么剩下就要再插入 $m-1$ 个板，板和板之间不能相邻，也就是每两个球的空隙之间只能放一个板。</p><p>有 $n-1$ 个空隙，选出来 $m-1$ 个即可，方案数为 $C_{n-1}^{m-1}$。</p></li><li><p>球同，盒子不同，盒子可以空。</p><p>思路是隔板法的第二种，<strong>排列法</strong>。</p><p>同样有 $m$ 个盒子，每两个相邻的板构成一个盒子，所以需要放 $m+1$ 个板。</p><p>同样首先需要在 $n$ 个球的两侧放上两个板，代表左右边缘两个盒子的一侧。</p><p>那么剩下就要再插入 $m-1$ 个板，但这次板和板之间可以相邻，中间不隔着球的两个板代表一个空盒子，每个球球间空隙可以放任意多个板。</p><p>这是我们相当于要得到一个包含 $n$ 个球和 $m-1$ 个板的排列，由于球之间相同，板之间相同，所以只需要从 $n+m-1$ 个位置里选出 $n$ 个位置放球即可，方案数为 $C_{n+m-1}^n$，当然也可以从板的角度，写成 $C_{n+m-1}^{m-1}$。</p></li><li><p>球不同，盒子相同，盒子不可以空。</p><p>这个问题就是第二类 Stirling 数的定义，将 $n$ 个不同的元素，划分成 $m$ 个不同的非空集合的方案数，所以答案是 $S_n^m$。</p></li><li><p>球不同，盒子相同，盒子可以空。</p><p>我们假设有 $i(i\in [1,m])$ 个盒子非空的，由于盒子相同，此时的答案为 $S_n^i$。</p><p>由于非空的盒子数不同的情况之间独立，所以答案是 $\sum_{i=1}^mS_n^i$。</p></li><li><p>球不同，盒子不同，盒子不可以空。</p><p>此问题相当于是第三个问题的<strong>顺序化</strong>，也就是原本相同的盒子变成不同的了，需要乘上一个不同顺序带来的情况数，所以按照顺序化的操作得到答案为 $S_n^m\times P_m^m$。</p></li><li><p>球不同，盒子不同，盒子可以空。</p><p>球之间的决策是独立的，每个球有 $m$ 个不同的盒子选，不需要考虑是否导致盒子空，方案数为 $m^n$。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Number Theory</title>
      <link href="/2019/07/27/number-theory-in-noip/"/>
      <url>/2019/07/27/number-theory-in-noip/</url>
      
        <content type="html"><![CDATA[<p>一份简单的 NOIP 范围内数论知识初步的总结。</p><p>校内交流使用，代码和知识讲解仅供参考。</p><a id="more"></a><h2 id="Slide"><a href="#Slide" class="headerlink" title="Slide"></a>Slide</h2><p><a href="https://blog.gyx.me/slide/basic-number-theory.pdf">Slide : Number Theory</a></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p>这里是上课可能会用到的代码。</p><h3 id="统计约数"><a href="#统计约数" class="headerlink" title="统计约数"></a>统计约数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">sqrt</span>(n); i++)</span><br><span class="line">  <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">    <span class="keyword">if</span> (n / i != i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n / i);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="标准分解"><a href="#标准分解" class="headerlink" title="标准分解"></a>标准分解</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> lim = <span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= lim; i++)</span><br><span class="line">  <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, i);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">        n /= i; ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cnt);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">if</span> (n != <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%d 1\n"</span>, n);</span><br></pre></td></tr></table></figure><h3 id="约数个数"><a href="#约数个数" class="headerlink" title="约数个数"></a>约数个数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ans *= (a[i] + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="约数和"><a href="#约数和" class="headerlink" title="约数和"></a>约数和</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span>, tmp, nw;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">  <span class="keyword">int</span> nw = <span class="number">1</span>, sum = p[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= a[i]; ++j) &#123;</span><br><span class="line">    nw *= p[i]; sum += nw;</span><br><span class="line">  &#125;</span><br><span class="line">  ans *= sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更相减损术"><a href="#更相减损术" class="headerlink" title="更相减损术"></a>更相减损术</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stein</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) a ^= b, b ^= a,a ^= b; </span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a;             </span><br><span class="line">    <span class="keyword">if</span>((!(a &amp; <span class="number">1</span>)) &amp;&amp; (!(b &amp; <span class="number">1</span>))) <span class="keyword">return</span> stein(a &gt;&gt; <span class="number">1</span>, b &gt;&gt; <span class="number">1</span>) &lt;&lt; <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((a &amp; <span class="number">1</span>) &amp;&amp; (!(b &amp; <span class="number">1</span>))) <span class="keyword">return</span> stein(a, b &gt;&gt; <span class="number">1</span>);       </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((!(a &amp; <span class="number">1</span>)) &amp;&amp; (b &amp; <span class="number">1</span>)) <span class="keyword">return</span> stein(a &gt;&gt; <span class="number">1</span>, b);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> stein(a - b, b);                                     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="辗转相除法"><a href="#辗转相除法" class="headerlink" title="辗转相除法"></a>辗转相除法</h3><p>递归形式（建议写法）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> b ? gcd(b, a % b) : a; &#125;</span><br></pre></td></tr></table></figure><p>迭代形式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;  </span><br><span class="line">  <span class="keyword">for</span>(;;) &#123;  </span><br><span class="line"><span class="keyword">if</span> ( b == <span class="number">0</span> ) <span class="keyword">return</span> a;  </span><br><span class="line">    <span class="keyword">int</span> temp = a % b;  </span><br><span class="line">    a = b; b = temp;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展欧几里得"><a href="#扩展欧几里得" class="headerlink" title="扩展欧几里得"></a>扩展欧几里得</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y, <span class="keyword">int</span> &amp;g)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!b)&#123;g = a; x = <span class="number">1</span>; y = <span class="number">0</span>;&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123; exgcd(b, a % b, y, x, g); y -= a / b * x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="除法分块"><a href="#除法分块" class="headerlink" title="除法分块"></a>除法分块</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>, r, t; l &lt;= n; l = r + <span class="number">1</span>)&#123;</span><br><span class="line">    t = n / l;</span><br><span class="line">    r = (t == <span class="number">0</span> ? n : n / t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Eratosthenes-筛法"><a href="#Eratosthenes-筛法" class="headerlink" title="Eratosthenes 筛法"></a>Eratosthenes 筛法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Eratosthenes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">  is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) is_prime[i] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="keyword">if</span> (is_prime[i]) &#123;</span><br><span class="line">      prime[p++] = i;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt;= n; j += i) is_prime[j] = <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Euler-筛法-筛素数"><a href="#Euler-筛法-筛素数" class="headerlink" title="Euler 筛法(筛素数)"></a>Euler 筛法(筛素数)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mindiv[i]) prime[++tot] = mindiv[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; prime[j] &lt;= mindiv[i] &amp;&amp; (k = prime[j] * i) &lt;= n; j++)</span><br><span class="line">    mindiv[k] = prime[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fastpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = res * a % p;</span><br><span class="line">    a = a * a % p; b &gt;&gt;= <span class="number">1</span>;  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线性逆元"><a href="#线性逆元" class="headerlink" title="线性逆元"></a>线性逆元</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inv[a] = -(p / a) * inv[p % a];</span><br></pre></td></tr></table></figure><h3 id="线性筛欧拉函数"><a href="#线性筛欧拉函数" class="headerlink" title="线性筛欧拉函数"></a>线性筛欧拉函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++i)&#123;</span><br><span class="line">  <span class="keyword">if</span>(!phi[i]) prm[++prm[<span class="number">0</span>]] = i,phi[i] = i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>, k; j &lt;= prm[<span class="number">0</span>] &amp;&amp; (k = prm[j] * i) &lt; N; ++j)</span><br><span class="line">      <span class="keyword">if</span>(i % prm[j]) phi[k] = phi[i] * (prm[j] - <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">else</span> &#123;phi[k] = phi[i] * prm[j]; <span class="keyword">break</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTS &amp; APIO 2019</title>
      <link href="/2019/05/14/cts-apio2019/"/>
      <url>/2019/05/14/cts-apio2019/</url>
      
        <content type="html"><![CDATA[<p>因为退役的关系，这篇流水账看起来比较轻松有趣。</p><p>OI 生涯中最后一篇游记了啊，还是要写的详细些好。</p><a id="more"></a><h2 id="言论"><a href="#言论" class="headerlink" title="言论"></a><span id="jump">言论</span></h2><p>以下部分引用摘自 <a href="https://www.zhihu.com/question/315351707" target="_blank" rel="noopener">如何评价CTS2019/APIO2019？ - 知乎</a> 。</p><p>CTS 闭幕式 wh 发言</p><blockquote><p>就在 $5$ 年之前，$2013$ 年的 CTSC…</p><p>有趣的题目背景，简短的题面，概括了计数，计数，计数，计数以及计算几何和乱搞等知识点…</p><p>这次的提交答案题，考察了以贪心，搜索等基本算法，以及策略上的优化，不再是十合一…</p><p>有些非集训队选手发挥突出，来自历城二中的 rqy，是全场唯一获得高于 400 分成绩的选手…</p><p>令人惊喜的是，有来自<strong>江西</strong>，广西，贵州，黑龙江，新疆等<strong>边远省份</strong>的选手…</p></blockquote><p>CTS 闭幕式 dzd 发言</p><blockquote><p>我们今年的选拔赛，少了一个字母 C ， C 就是 competition 。为什么 C 没了呢？好，给你们直说吧，如果是赛，就不让收费，不让收费呢，CCF 是没钱的，没有一分钱的政府的拨款…</p><p>CCF要坚持下去，我也会坚持下去。如果我实在达不到目的，如果被悲催了，被屈辱了，我只能辞职而去，但绝不就范，绝对不为那些失掉真理，失掉正义和骨气…</p></blockquote><h2 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h2><p>七点从学校出发，坐公交，和老师在火车站碰面。</p><p>把开车时间往后记了半小时，刚到站已经检票有一阵了，被教练D了一会。</p><p>路上老 R 问起省选之后有没有碰电脑，并不敢说没有，装作看了板子的样子。</p><p>老 R 毒奶说我还是有希望水一个 Cu 的（然而并不 care 有没有奖了</p><p>剩下火车上的时间用来思考文化课生活。</p><hr><p>到了宾馆大厅办入住，等的时候看见了万总，已然进队风光无限。</p><p>和 mqt 聊了聊退役之后的高考生活，神仙现场测词汇量 8000+ 膜爆。</p><p>下午在宾馆里颓到五点多才去试机，发现自己连语法都快不会了。</p><p>晚上撞见了从 THUPC 赶来的神仙们，听说 THUPC 是 OI 场？</p><h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h2><p>考场 408 ，监考好像是 LCA 和 栋栋（栋栋的衣服上印着雀魂233</p><p>退役了已然推不动计数式子了啊，跳了 T1 T2 。</p><p>手画了一个小时，把 T3 前30分搞到手，然后敲了个随机，后七个点搞了几分。</p><p>十点多的时候开了三四个 Emacs 电脑就死机了，栋栋找来 LCA 给重启了。</p><p>吃了考场餐，和 Emacs 下了一会棋，打不赢就睡到了考试结束。</p><p>估计在 45 左右，肯定没牌子了，就没去查分和听讲题。</p><h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h2><p>考场 GYM，坐在大门口没法颓了慌慌慌。监考好像是高闻远。</p><p>什么神仙计算几何我只会输0啊…</p><p>串串计数爆搜复杂度好像过不了第一个点啊…</p><p>这么长的网友题做不动啊…</p><p>对面老哥一直拿鼻孔对着我…为啥他总在仰望天空啊…</p><p>然后和 Emacs 博弈到发考场餐，没有士力架差评。 </p><p>打不过正自闭的时候，突然想到我可以开两个 Emacs，一个先手一个后手然后模仿他下，我就可以稳赢一局了（我真是个小天才</p><p>然后百无聊赖睡到结束，依旧没有去查分听讲题。</p><h2 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h2><p>像集训队答辩这种喜闻乐见的项目作为退役选手显然要去啊！</p><blockquote><p>我叫 dzd，zq你如果没进队你会怎么想？（明年再来）</p><p>你校自 1996 年以来怎么 23 年没人去过 IOI ？</p><p>你的题为什么有一个 1 分的 subtask (duliu) ？</p></blockquote><p>结束的时候用尽浑身解数，成功抢到了多余的论文集（退役纪念品++</p><hr><p>路上突然想到论文集上收集一些签名好像挺有纪念意义的，所以晚上闭幕式显然也要去啊！</p><p>国队跟我中午猜的一样233，zy 好可惜啊准备省选把国家队整没了…</p><p>闭幕式上的发言还是挺好玩的，参见开头的 <a href="#jump">言论</a></p><p>然后小透明激动的跑过去要国队签名！</p><p>samjia：诶修的名字比我的好写很多啊…那我写个修吧！</p><p>zzq：写修很简单啊…那我也可以啊!</p><p>wxh：那我写个…写个我自己吧…</p><p>（当时yjz好像不在）</p><p>然后在论文集上就留下了修们的签名！作为退役纪念品完美啊。</p><p><img src="https://i.loli.net/2019/06/06/5cf88ae7ac9ae23183.jpg" alt=""></p><h2 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h2><p>在宾馆摸爆，在 czy 的帮助下把博客的锅修了。</p><p>下午试机切了前三个，然后从 UOJ 上找了个 T5 的代码过了。</p><h2 id="Day-5"><a href="#Day-5" class="headerlink" title="Day 5"></a>Day 5</h2><p>并不想去听课，于是在宾馆颓颓颓…</p><h2 id="Day-6"><a href="#Day-6" class="headerlink" title="Day 6"></a>Day 6</h2><p>又在 408，监考是 Samjia ，旁边坐的是 Day 2 一直仰天长啸的哥们。</p><p>T1 敲了 29 分暴力+线段树，感觉不带修的要写重构树弃了。</p><p>T2 敲了 10 分暴力，推不动式子，这么神仙的题为啥毛子要放到 T1 啊搞不懂…</p><p>T3 敲了 60 分暴力+线段树+序列并查集，后面的不会了。</p><p>纠结了好久 T2 ，还是决定去写 T1 的重构树，写了一个多小时调不出来，交 WA 了，准备睡觉。</p><p>吃完考场餐，突然发现 T1 好像可以离线并查集把 subtask 4 水过去，然后十分钟敲完过了…</p><p>然后和 Emacs 下棋，还是下不赢，旁边早早 AK 的小哥于是开了一盘 Emacs 开始表演</p><p>然后他就赢了….就赢了….感觉自己的智商嘲讽了啊…</p><p>出考场发现一堆 113 的，估计 APIO 也没牌了，就没去听讲题。</p><p>（后来听温巨讲了讲发现 T2 是个 sb 题…淦… T2 的 90 就是Au 和 Cu 的差距啊…</p><h2 id="Day-7"><a href="#Day-7" class="headerlink" title="Day 7"></a>Day 7</h2><p>依旧没有去听课，中午收到消息下午回学校。</p><p>于是在北京西站吃的麦记，用的现金被收银员鄙视了一波…</p><p>火车上得知好像擦线水了一个 Cu (感谢老R</p><p>窗外的落日很好看啊….</p><p><img src="https://i.loli.net/2019/06/06/5cf88a0b581a439686.jpg" alt=""></p><blockquote><p>Last night I saw you running<br>In the open fields of grace<br>No longer were you broken or in pain</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Travel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Derivation</title>
      <link href="/2019/04/27/derivation/"/>
      <url>/2019/04/27/derivation/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.youtube.com/playlist?list=PLZHQObOWTQDMsr9K-rj53DwVRMYO3t5Yr" target="_blank" rel="noopener">Essence of Calculus - 3Blue1Brown</a></p><p>最近决定开始看这个系列，简单写一点原理相关的笔记。</p><a id="more"></a><p>内容写的很粗略，有需要请在 Youtube 观看 3Blue1Brown 的视频。</p><h2 id="Chapter-1"><a href="#Chapter-1" class="headerlink" title="Chapter 1"></a>Chapter 1</h2><h3 id="圆面积公式"><a href="#圆面积公式" class="headerlink" title="圆面积公式"></a>圆面积公式</h3><p>将圆剪成若干个宽度均为 $dr$ 的环，圆的面积就是这些环的面积和。</p><p>如果把环拉直成一个长条，在 $dr$ 很小的时候可以看作一个矩形。</p><p>如果内半径为 $r$，则这个矩形的面积约为 $2\pi r\times dr$ （$\pi$ 的定义）。</p><p>考虑把这些矩形按照对应内半径 $r$ 从小到大摆在数轴上，横轴代表半径长度 $r$，纵轴代表对应环长 $y$。</p><p>可以发现如果做一条直线 $y=2\pi r$，所有矩形条顶部恰好触及直线。</p><p>当 $dr$ 取得越来越小的时候，所有矩形的面积和就越来越接近直线与 $r$ 轴围成的图形面积。</p><p>因此对于半径为 $R$ 的圆，有面积公式</p><script type="math/tex; mode=display">S=\frac{2\pi R\times R}{2}=\pi R^2</script><h3 id="微积分基本定理"><a href="#微积分基本定理" class="headerlink" title="微积分基本定理"></a>微积分基本定理</h3><p>如果函数 $f(x)$ 在区间 $[a,b]$ 上连续，并且存在原函数 $F(x)$，则</p><script type="math/tex; mode=display">\int_{a}^bf(x)dx=F(b)-F(a)=F(x)|_{a}^b</script><p>也就表明了某种意义上，积分与求导互为逆运算。</p><h2 id="Chapter-2"><a href="#Chapter-2" class="headerlink" title="Chapter 2"></a>Chapter 2</h2><h3 id="导数的定义"><a href="#导数的定义" class="headerlink" title="导数的定义"></a>导数的定义</h3><p>（此处的 $\Delta x$ 在下文中常写作 $dx$）</p><p>若函数 $f(x)$ 在 $(a,b)$ 内每一处均可导，则可在 $(a,b)$ 上定义 $f(x)$ 的<strong>导函数</strong>为：</p><script type="math/tex; mode=display">f'(x)=\lim_{\Delta x\to 0}\frac{f(x+\Delta x)-f(x)}{\Delta x}</script><p>具体的，我们称 $f(x)$ 在 $x=x_0$ 处的<strong>导数</strong>为：</p><script type="math/tex; mode=display">f'(x_0)=\lim_{\Delta x\to 0}\frac{f(x_0+\Delta x)-f(x_0)}{\Delta x}</script><p>我们称 $f(x)$ 在 $(a,b)$ 上为 $f’(x)$ 的<strong>原函数</strong>。</p><h3 id="导数的含义"><a href="#导数的含义" class="headerlink" title="导数的含义"></a>导数的含义</h3><p>导数并不是具体的很小的 $dx$ 对应的比值，而是 $dx\to 0$ 时这个比值的极限。</p><p>从图像角度理解，当 $dx$ 比较大的时候，所得的比值是函数图像上相距为 $dx$ 的两点所连割线的斜率。</p><p>当 $dx$ 的值，也就是两点距离无限逼近于 $0$ 时，过着两点割线也就无限逼近在某一点时图像切线。</p><p>所以说导数确切的定义，  并不是“瞬时变化率”，而看作是求“某一点附近的变化率”的<strong>最佳近似</strong>。</p><h2 id="Chapter-3"><a href="#Chapter-3" class="headerlink" title="Chapter 3"></a>Chapter 3</h2><h3 id="用几何求导"><a href="#用几何求导" class="headerlink" title="用几何求导"></a>用几何求导</h3><p>考虑从几何的角度理解 $f(x)=x^2$ 的求导过程，可以将函数的值看作一个边长为 $x$ 的正方形。</p><p>那么函数的变化量 $df$ 就相当于，当边长增加 $dx$ 时，正方形面积的增量。</p><p>考虑将增加的面积拆成三部分，即两个矩形和一个小正方形，因此</p><script type="math/tex; mode=display">\frac{df}{dx}=\frac{2\times x\times  dx+dx^2}{dx}=2x+dx</script><p>因为 $dx$ 是一个很小很小的值，因此可以将其忽略，也就得到了 $(x^2)’=2x$ 。</p><p>实际在求导的过程中，任何约分后含有 $dx$ 的项，也就是约分前增量中含有<strong>两项以上与 $dx$ 相关的项</strong>，都可以看做无限小并忽略计算。</p><hr><p>再考虑 $f(x)=x^3$ 的求导，那么相当于一个立方体，边长增加了 $dx$ 。</p><p>此时有三个面，三个棱和一个顶点都各自延伸出一个小方块，增量为 </p><script type="math/tex; mode=display">df=3\times x^2dx+3\times x\times dx^2+dx^3</script><p>后两项约分后依旧含有 $dx$ ，可以直接忽略，因此有 $(x^3)’=3x^2$ 。</p><hr><p>再考虑 $f(x)=x^{-1}$ 在 $x$ 正半轴的求导，$x^{-1}$ 的含义就是：“谁乘 $x$ 结果为 $1$ ”</p><p>那么在第一象限想想一个矩形，左下角为原点，边与坐标轴平行或垂直，强制面积是 $1$。</p><p>那么考虑在 $x$ 轴上的位置增加 $dx$ 时，为了保证面积不超过 $1$ ，$y$ 轴上的位置减小了 $df$。</p><p>此时矩形上方减少的面积与右侧增加的面积是相等的，因此我们很容易求出</p><script type="math/tex; mode=display">S=dx\times x^{-1}=\frac{dx}{x}\Rightarrow df=\frac{S}{x}=\frac{dx}{x^2}</script><p>因此有 $(x^{-1})’=-x^{-2}$ 。</p><hr><p>最后考虑 $f(x)=\sqrt x$ 的在 $x$ 非负半轴的求导，此时 $\sqrt x$ 的含义是，面积为 $x$ 的正方形的边长长度。</p><p>考虑面积增加了 $dx$，那么边长会增加 $df$ ，此时新增的面积为两个矩形和一个正方形，而正方形的面积为 $df^2$，可以忽略。因此 $dx$ 相当于两个细长矩形的面积和。</p><script type="math/tex; mode=display">dx=2\times df\times \sqrt x\Rightarrow df=\frac{dx}{2\sqrt x}</script><p>因此 $(\sqrt x)’=\frac{1}{2}x^{-\frac{1}{2}}$ 。</p><h3 id="幂函数求导"><a href="#幂函数求导" class="headerlink" title="幂函数求导"></a>幂函数求导</h3><p>由上述几个例子可以发现幂函数求导基本的规律：</p><script type="math/tex; mode=display">(x^n)'=nx^{n-1}</script><p>我们尝试去证明这一过程，考虑将 $x$ 增加一个微小的量 $dx$，函数值会变为 $(x+dx)^n$。</p><p>由上一部分的推导可以知道含有两项以上 $dx$ 相关的项是可以忽略不记的，因此每项中至多一个 $dx$。</p><p>那么需要保留的结果是</p><script type="math/tex; mode=display">x^n+{n\choose 1} \times dx\times x^{n-1}=x^n+nx^{n-1}dx</script><p>因此有 $df(x^n)=nx^{n-1}dx$，即 $(x^n)’=nx^{n-1}$ 。</p><h3 id="三角函数求导"><a href="#三角函数求导" class="headerlink" title="三角函数求导"></a>三角函数求导</h3><p>先考虑 $f(\theta)=\sin(\theta)$ 的求导。</p><p>首先要知道三角函数基于单位圆的定义，单位元上弧长与弧度制表示的角度大小相等， $\sin(\theta)$ 的函数值等于对应点 $y$ 坐标的值。</p><p>那么考虑角度增加 $d\theta$，也就是弧长增加 $d\theta$ ，$y$ 坐标的增量 $d(\sin(\theta))$ 是多少。</p><p>我们放大弧长增长的那一小部分，此时弧可以近似看成线段，线段的长度是 $d\theta$，那么对应的即可构造如图所示的直角三角形，其平行于 $y$ 轴的边长即为 $d(\sin(\theta))$ 。</p><p><img src="https://i.loli.net/2019/04/18/5cb7e8fed360c.png" alt=""></p><p>容易发现这个三角形与原来的大三角形是相似的，也就是说，我们所求的导数可以表示成</p><script type="math/tex; mode=display">\frac{d(\sin(\theta))}{d\theta}=\frac{Adj.}{Hyp.}=\cos(\theta)</script><hr><p>类似的去考虑 $f(\theta)=\cos(\theta)$ 的求导，我们依旧可以用上面那个三角形建立相似关系。</p><p>注意这次在第一象限的时候角度增加 $d\theta$，<strong>$x$ 轴的坐标会减小</strong>，有</p><script type="math/tex; mode=display">\frac{|d(\cos(\theta))|}{d\theta}=\frac{Opp.}{Hyp.}=\sin(\theta)</script><p>因此事实上 $f(\theta)=\cos(\theta)$ 的导数为 $-\sin(\theta)$ 。</p><h2 id="Chapter-4"><a href="#Chapter-4" class="headerlink" title="Chapter 4"></a>Chapter 4</h2><h3 id="加法法则"><a href="#加法法则" class="headerlink" title="加法法则"></a>加法法则</h3><p>两函数和的导数，等于两个函数导数的和。</p><script type="math/tex; mode=display">(f(x)+g(x))'=f'(x)+g'(x)</script><p>从图像的角度看， $dx$ 带来的两函数增量是独立的。</p><h3 id="乘法法则"><a href="#乘法法则" class="headerlink" title="乘法法则"></a>乘法法则</h3><p>两函数积的导数，等于左乘右导+右乘左导。</p><script type="math/tex; mode=display">(f(x)g(x))'=f(x)g'(x)+g(x)f'(x)</script><p>从矩形面积的角度看，两边长分别是函数值，增量分为三部分：$f(x)g’(x)$，$g(x)f’(x)$，$f’(x)g’(x)$ ，而第三项可以忽略不计。</p><h3 id="链式法则"><a href="#链式法则" class="headerlink" title="链式法则"></a>链式法则</h3><p>定义函数复合为，一个函数的自变量，是另一个函数的函数值，即 $f(g(x))$ 的形式。</p><p>复合函数的导数，等于以内函数作为自变量的外函数导数，加上内函数的导数。</p><script type="math/tex; mode=display">(f(g(x)))'=f'(g(x))\times g'(x)</script><h3 id="减法法则"><a href="#减法法则" class="headerlink" title="减法法则"></a>减法法则</h3><p>是用加法和乘法法则展开即可。</p><script type="math/tex; mode=display">\begin{align}(f(x)-g(x))'&=(f(x)+(-1)\times g(x))'\\&=f'(x)+((-1)\times g(x))'\\&=f'(x)+(-1)\times g'(x)\\&=f'(x)-g'(x)\end{align}</script><p>因此我们可以统一的写成 $(f(x)\pm g(x))’=f’(x)\pm g’(x)$ 。</p><h3 id="常数乘法"><a href="#常数乘法" class="headerlink" title="常数乘法"></a>常数乘法</h3><p>用乘法法则展开即可，我们设 $c$ 是一个常数。</p><script type="math/tex; mode=display">(c\times f(x))'=f(x)\times c'+c\times f'(x)=c\times f'(x)</script><h3 id="多项式求导"><a href="#多项式求导" class="headerlink" title="多项式求导"></a>多项式求导</h3><p>由幂函数求导公式和加法法则即可得出。</p><script type="math/tex; mode=display">f(x)=\sum_{i=0}^na_ix,\ f'(x)=\sum_{i=1}^{n}ia_ix^{i-1}</script><h3 id="除法法则"><a href="#除法法则" class="headerlink" title="除法法则"></a>除法法则</h3><p>$\frac{1}{f(x)}$ 其实可以看做 $f(x)$ 与 $h(x)=\frac{1}{x}$ 的复合函数，即 $h(f(x))$ 。</p><p>然后用链式法则和乘法法则展开即可。</p><script type="math/tex; mode=display">\begin{align}\bigg(\frac{g(x)}{f(x)}\bigg)'&=\bigg(g(x)\times h(f(x))\bigg)'\\&=g(x)\times (h(f(x)))'+h(f(x))\times g'(x)\\&=g(x)\times (-\frac{1}{[f(x)]^2})\times f'(x) +\frac{g'(x)}{f(x)}\\&=\frac{g'(x)}{f(x)}-\frac{f'(x)g(x)}{[f(x)]^2}\\&=\frac{g'(x)f(x)-f'(x)g(x)}{[f(x)]^2}\end{align}</script><h2 id="Chapter-5"><a href="#Chapter-5" class="headerlink" title="Chapter 5"></a>Chapter 5</h2><h3 id="指数函数求导"><a href="#指数函数求导" class="headerlink" title="指数函数求导"></a>指数函数求导</h3><p>考虑 $f(x)=a^x$ 的求导，此处 $a$ 为一正常数。</p><script type="math/tex; mode=display">\frac{d(a^{x+dx})}{dx}=\frac{a^x\times a^{dx}-a^x}{dx}=a^x\times\bigg(\frac{a^{dx}-1}{dx}\bigg)</script><p>后面的常数项现在不便于确定，因此人们定义自然对数 $e$：满足 $a=e$ 时这个常数为 $1$ ，即</p><script type="math/tex; mode=display">\lim_{dx\to 0}\frac{e^{dx}-1}{dx}=1</script><p>因此有 $(e^x)’=e^x$ 。</p><hr><p>考虑一般情况，我们知道 $a$ 可以写作 $e^{\ln a}$ 的形式，因此有 $a^x=e^{x\ln a}$ 。</p><p>考虑链式法则求解 $e^{c\times x}$ 形式的函数，设 $f(x)=c\times x$，也就是求导 $e^{f(x)}$：</p><script type="math/tex; mode=display">(e^{f(x)})'=e^{f(x)}\times c</script><p>因此我们就可以写出一般形式指数函数的求导法则了：</p><script type="math/tex; mode=display">(a^x)'=(e^{x\ln a})'=\ln a\times e^{x\ln a}= a^x \ln a</script><h3 id="对数函数求导"><a href="#对数函数求导" class="headerlink" title="对数函数求导"></a>对数函数求导</h3><p>根据反函数求导法则，若 $f(x) = \log_{a}x$，则</p><script type="math/tex; mode=display">f(x)' = \frac{1}{x\ln a}</script><p>特殊的，有</p><script type="math/tex; mode=display">(\ln x)' =\frac{1}{x}</script>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HEOI 2019</title>
      <link href="/2019/04/12/heoi2019/"/>
      <url>/2019/04/12/heoi2019/</url>
      
        <content type="html"><![CDATA[<p>OI 生涯就这样恍恍惚惚的在 HEOI 2019 走到了终点。</p><p>简单的写两笔吧，算是让这个博客完整一些，也算作是警醒后人。</p><a id="more"></a><hr><p>考前有些焦虑过头，还是决定让母亲去陪考。</p><p>第一天迷糊了三个小时，然后就结束了，第二天没能翻盘。</p><p>考试的题目除了 Day1 T3 有些不太好接受以外都还挺好的，最后是被两天 T2 送退役的。</p><p>最后的总分是 $85+0+12+20+60+8=185$，可能已经失败到极致了吧。</p><p>说说失分的原因吧：</p><ul><li><p>Day1 T1：可持久化 01 Trie 的 <code>copy</code> 敲太快，复制时候的 size 设置写错，最后数据水拿到了 $85$：</p><p><code>c[rt].sz=c[lst].sz+1</code> 写成 <code>c[rt].sz=1</code> ，考场 1h 没找出来，然后花了 10min 写了暴力。</p></li><li><p>Day1 T2：把后缀树的性质想成了 SAM 本身 DAG 的性质，直接在 SAM 上连边直接爆零。</p></li><li><p>Day1 T3：最后交卷前 5min 才开始当作看玩笑看后面的点，直接看出 p,u 是啥意思但是来不及写。</p></li><li><p>Day2 T1：考场想出来状态设计，想了想转移复杂度以为不对，就放过去了。</p></li><li><p>Day2 T2：想到了正解的贪心，觉得左侧多个子节点合并到右侧一个子节点中会挂掉，于是打暴力。</p></li><li><p>Day2 T3：爆 int。</p></li></ul><p>最后反过来想想自己的水平确实没有达到 Day2 T1, Day2 T3 这种题的要求，但是之前的又模拟赛太过简单，考挂或许在情理之中吧。</p><p>第二天出考场的时候大概也是释然了吧，出考场的时候几位教练都在紧张的看着我下楼。</p><p>我看到了母亲在笑着看着我，我就笑了，老师们也就突然笑了，拍拍肩膀，一切都过去了。</p><hr><p>并没有买 D。</p><p>心里的担子就这么卸下去了，放松自己的感觉真好啊。</p><p>还在机房的伙伴们加油啊！</p>]]></content>
      
      
      <categories>
          
          <category> Travel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MathJax Test</title>
      <link href="/2019/04/03/mathjaxtest/"/>
      <url>/2019/04/03/mathjaxtest/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.mathjax.org/" target="_blank" rel="noopener">Beautiful math in all browsers - MathJax</a></p><p>经过多次重装终于配置好了满意的 MathJax，写一篇测试文档留作纪念。</p><a id="more"></a><h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><p>数学模式重音符</p><script type="math/tex; mode=display">\ \ \hat{a} \ \ \check{a} \ \ \tilde{a} \ \ \acute{a}\ \ \grave{a} \ \ \dot{a} \ \ \ddot{a} \ \ \breve{a}\ \ \bar{a} \ \ \vec{a} \ \ \widehat{A} \ \ \widetilde{A}</script><p>小写希腊字母</p><script type="math/tex; mode=display">\ \ \alpha \ \ \theta  \ \ \upsilon\ \ \beta \ \ \vartheta \ \ \pi \ \ \phi\ \ \gamma \ \ \iota \ \ \varpi \ \ \varphi\ \ \delta \ \ \kappa \ \ \rho \ \ \chi\ \ \epsilon \ \ \lambda \ \ \varrho \ \ \psi\ \ \varepsilon \ \ \mu \ \ \sigma \ \ \omega\ \ \zeta \ \ \nu \ \ \varsigma\ \ \eta \ \ \xi \ \ \tau</script><p>大写希腊字母</p><script type="math/tex; mode=display">\ \ \Gamma \ \ \Lambda \ \ \Sigma \ \ \Psi\ \ \Delta \ \ \Xi \ \ \Upsilon \ \ \Omega\ \ \Theta \ \ \Pi \ \ \Phi</script><p>二元关系表示符</p><script type="math/tex; mode=display">\ \ <\ \  <\ \  >\ \  >\ \  =\ \ \ \ \leq o\ \ \le \ \ \geq o\ \ \ge \ \ \equiv\ \ \ll \ \ \gg \ \ \doteq</script><script type="math/tex; mode=display">\ \ \prec \ \ \succ  \ \ \sim\ \ \preceq \ \ \succeq \ \ \simeq\ \ \subset \ \ \supset \ \ \approx\ \ \subseteq \ \ \supseteq \ \ \cong\ \ \sqsubset a \ \ \sqsupset  \ \ \Join \ \ \sqsubseteq \ \ \sqsupseteq</script><script type="math/tex; mode=display">\ \ \bowtie\ \ \in \ \ \ni \ \ \owns \ \ \propto\ \ \vdash \ \ \dashv |\ \ \models\ \ \mid \ \ \parallel \ \ \perp\ \ \smile \ \ \frown \ \ \asymp\ \ : \ \ \notin \ \ \neq \ \ \ne</script><p>二元运算符</p><script type="math/tex; mode=display">+\ \  −\ \  -\ \ \pm \ \ \mp \ \ \triangleleft\ \ \cdot \ \ \div \ \ \triangleright\ \ \times\ \ \setminus \ \ \star\ \ \cup \ \ \cap \ \ \ast\ \ \sqcup \ \ \sqcap \ \ \circ\ \ \vee \ \ \lor \ \ \wedge</script><script type="math/tex; mode=display">\land \ \ \bullet\ \ \oplus \ \ \ominus \ \ \diamond\ \ \odot \ \ \oslash \ \ \uplus\ \ \otimes \ \ \bigcirc \ \ \amalg\ \ \bigtriangleup \ \ \bigtriangledown \ \ \dagger\ \ \lhd \ \ \rhd\ \ \ddagger\ \ \unlhd \ \ \unrhd\ \ \wr</script><p>大尺寸运算符</p><script type="math/tex; mode=display">\ \ \sum \ \ \bigcup \ \ \bigvee \ \ \bigoplus\ \ \prod \ \ \bigcap \ \ \bigwedge \ \ \bigotimes\ \ \coprod \ \ \bigsqcup \ \ \bigodot\ \ \int \ \ \oint \ \ \biguplus</script><p>箭头</p><script type="math/tex; mode=display">\leftarrow \ \ \gets \ \ \longleftarrow\ \ \uparrow\ \ \rightarrow \ \ \to \ \ \longrightarrow\ \ \downarrow\ \ \leftrightarrow \ \ \longleftrightarrow\ \ \updownarrow</script><script type="math/tex; mode=display">\ \Leftarrow \ \ \Longleftarrow\ \ \Uparrow\ \ \Rightarrow\ \   \Longrightarrow\ \ \Downarrow \Leftrightarrow \ \ \Longleftrightarrow\ \ \Updownarrow\ \ \mapsto \ \ \longmapsto\ \ \nearrow</script><script type="math/tex; mode=display">\ \ \hookleftarrow \ \ \hookrightarrow\ \ \searrow\ \ \leftharpoonup\ \ \rightharpoonup\ \ \swarrow\ \ \leftharpoondown\ \ \rightharpoondown\ \ \nwarrow\ \ \rightleftharpoons \ \ \iff \ \ \leadsto</script><p>定界符</p><script type="math/tex; mode=display">(\ \ ) \ \ \uparrow \ \ \Uparrow\ \ \lbrack \ \ \rbrack \ \ \downarrow \ \ \Downarrow\ \ \{ \ \ \lbrace \ \ \} \ \ \rbrace \ \ \updownarrow \ \ \Updownarrow\ \ \langle \ \ \rangle \ \ \vert \ \ \Vert\ \ \lfloor \ \ \rfloor \ \ \lceil \ \ \rceil\ \ \backslash</script><p>其他符号</p><script type="math/tex; mode=display">\ \ \dots \ \ \cdots\ \ \vdots\ \ \ddots\ \ \hbar \ \ \imath \ \ \jmath \ \ \ell\ \ \Re \ \ \Im \ \ \aleph \ \ \wp\ \ \forall \ \ \exists \ \ \mho  \ \ \partial\ \ \prime \ \ \emptyset</script><script type="math/tex; mode=display">\infty\ \ \nabla \ \ \triangle \ \ \Box \ \ \Diamond\ \ \bot \ \ \top \ \ \angle \ \ \surd\ \ \diamondsuit \ \ \heartsuit \ \ \clubsuit \ \ \spadesuit\ \ \neg \ \ \lnot \ \ \ \ \natural \ \ \sharp</script><h2 id="行内公式"><a href="#行内公式" class="headerlink" title="行内公式"></a>行内公式</h2><blockquote><p>有 $n$ 只鼠，白兔用 $n - 1$ 根蓝色绳子把它们连成了一棵树，每根蓝色绳子连着两只鼠，白云用 $n - 1$ 根红色绳子把它们连成了一棵树，每根红色绳子连接着两只鼠。</p><p>白云要给予每只鼠一个数。这个数可以是 $[1, y]$ 中的任意一个整数。</p><p>白兔给了白云一个要求：对于两只鼠 $p, q$，若存在一条连接这两只鼠的路径同时属于这两棵树，则 $p$ 和 $q$ 必须被给予相同的整数。存在一条路径同时属于这两棵树指的是：存在一个序列 $(a_1 = p, a_2, \cdots , a_m = q)$，使得：对于所有 $i \in [1, m - 1]$，都有 $a_i$ 和 $a_{i+1}$ 既有一根红色绳子直接相连也有一根蓝色绳子直接相连。</p></blockquote><h2 id="块状公式"><a href="#块状公式" class="headerlink" title="块状公式"></a>块状公式</h2><script type="math/tex; mode=display">\int \frac{dx}{cos^2x}=\int sec^2xdx=tan x+C\</script><script type="math/tex; mode=display">\int \frac{dx}{sin^2x}=\int csc^2xdx=-cot x+C\</script><script type="math/tex; mode=display">\sum\limits_{i = 0}^{E} w[i]{M \choose i} {N \choose iS} \frac{(iS)!}{(S!)^{i}} \sum\limits_{j = 0}^{E - i} (-1)^{j} {M - i \choose j} {N - iS \choose jS} \frac{(jS)!}{(S!)^{j}} (M - i - j)^{N - iS - jS}</script><script type="math/tex; mode=display">= \sum\limits_{i = 0}^{E} w[i]{M \choose i} {N \choose iS} \frac{(iS)!}{(S!)^{i}} \sum\limits_{j = i}^{E} (-1)^{j - i} {M - i \choose j - i} {N - iS \choose jS - iS} \frac{(jS - iS)!}{(S!)^{j - i}} (M - j)^{N - jS}</script><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><script type="math/tex; mode=display">\begin{bmatrix}(\omega_n^0)^0 & (\omega_n^0)^1 & \cdots & (\omega_n^0)^{n-1}\\ (\omega_n^1)^0 & (\omega_n^1)^1 & \cdots & (\omega_n^1)^{n-1}\\ \vdots & \vdots & \ddots & \vdots \\ (\omega_n^{n-1})^0 & (\omega_n^{n-1})^1 & \cdots & (\omega_n^{n-1})^{n-1} \end{bmatrix} \times \begin{bmatrix} a_0 \\ a_1 \\ \vdots \\ a_{n-1} \end{bmatrix}=\begin{bmatrix} A(\omega_n^0) \\ A(\omega_n^1) \\ \vdots \\ A(\omega_n^{n-1}) \end{bmatrix}</script><script type="math/tex; mode=display">\begin{bmatrix} a_0 \\ a_1 \\ \vdots \\ a_{n-1} \end{bmatrix} = \frac{1}{n} \begin{bmatrix} (\omega_n^{-0})^0 & (\omega_n^{-0})^1 & \cdots & (\omega_n^{-0})^{n-1} \\ (\omega_n^{-1})^0 & (\omega_n^{-1})^1 & \cdots & (\omega_n^{-1})^{n-1} \\ \vdots & \vdots & \ddots & \vdots \\ (\omega_n^{-(n-1)})^0 & (\omega_n^{-(n-1)})^1 & \cdots & (\omega_n^{-(n-1)})^{n-1} \end{bmatrix} \begin{bmatrix} A(\omega_n^0) \\ A(\omega_n^1) \\ \vdots \\ A(\omega_n^{n-1}) \end{bmatrix}</script>]]></content>
      
      
      <categories>
          
          <category> Summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Polynomial</title>
      <link href="/2019/03/05/polynomial/"/>
      <url>/2019/03/05/polynomial/</url>
      
        <content type="html"><![CDATA[<p>最近在写一些多项式的模板题，代码总是显得十分混乱。</p><p>深感代码通用的重要性，于是记录一下比较通用的模板。</p><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>为了体现简洁，在每一部分只会放关键代码。</p><p>关于完整代码，在每一部分的代码标题处都放了链接。</p><p>可以保证代码之间函数的调用是合法的，会给出参数说明。</p><p>因为放代码可能会比较长，可以点右边的小火箭回到目录。</p><p>如果 MathJax 加载不出来或加载有误，请您多刷新几次。</p><p>模板出了问题请联系我，万分感谢。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Picks 的博客  <a href="http://picks.logdown.com/" target="_blank" rel="noopener">Picks’s Blog</a></p><p>Miskcoo 的博客  <a href="http://blog.miskcoo.com/" target="_blank" rel="noopener">Miskcoo’s Space</a></p><h2 id="多项式乘法"><a href="#多项式乘法" class="headerlink" title="多项式乘法"></a>多项式乘法</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定两个多项式 $A(x) $ 和 $B(x)$ ：</p><script type="math/tex; mode=display">A(x)=\sum_{i=0}^{n}a_ix^i\ ,\ B(x)=\sum_{i=0}^{n} b_i x^i</script><p>求卷积 $C(x) =A(x) * B(x)$ ，满足</p><script type="math/tex; mode=display">C(x)=\sum_{i=0}^{n} c_i x^i\ ,\  c_i=\sum_{k=0}^{i} a_k\times b_{i-k}</script><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>这部分上面提到的神仙们讲解的都十分详细。</p><p>我的小结限于篇幅，只挂一下 pdf 版本的连接了：<a href="https://blog.gyx.me/note/polynomialtech.pdf">快速傅里叶变换初步</a></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>使用 <a href="http://uoj.ac/problem/34" target="_blank" rel="noopener">[ UOJ 34 ] 多项式乘法</a> 作为测试题。</p><ul><li><p><a href="https://blog.gyx.me/code/template/polynomial/fft.cpp">Fast Fourier Transform</a>，使用的是 3 次变换的最基本写法，用时 362 ms</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Complex *f, <span class="keyword">int</span> len, <span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">      <span class="keyword">if</span> (rev[i] &gt; i) swap(f[i], f[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">      Complex wn = Complex(<span class="built_in">cos</span>(PI / i) , o * <span class="built_in">sin</span>(PI / i));</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j += (i &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Complex w = Complex(<span class="number">1</span>, <span class="number">0</span>), x, y;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; ++k, w = w * wn) &#123;</span><br><span class="line">          x = f[j + k]; y = w * f[i + j + k];</span><br><span class="line">          f[i + j + k] = x - y; f[j + k] = x + y;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="number">-1</span>) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) f[i].x /= len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://blog.gyx.me/code/template/polynomial/ntt.cpp">Fast Number-Theoretic Transform</a>，模数为 998244353，用时 403 ms</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> *f, <span class="keyword">int</span> len, <span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i)</span><br><span class="line">    <span class="keyword">if</span> (i &gt; rev[i]) swap(f[i], f[rev[i]]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> wn = qpow(<span class="number">3</span>, (mod - <span class="number">1</span>) / (i &lt;&lt; <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="number">-1</span>) wn = qpow(wn, mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j += (i &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">      <span class="keyword">int</span> w = <span class="number">1</span>, x, y;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; ++k, w = <span class="number">1l</span>l * w * wn % mod) &#123;</span><br><span class="line">        x = f[j + k]; y = <span class="number">1l</span>l * w * f[i + j + k] % mod;</span><br><span class="line">        f[j + k] = mo(x + y); f[i + j + k] = mo(x - y + mod);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (o == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> invl = qpow(len, mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) f[i] = <span class="number">1l</span>l * f[i] * invl % mod;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="多项式求逆"><a href="#多项式求逆" class="headerlink" title="多项式求逆"></a>多项式求逆</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个 $n$ 次多项式 $A(x)$ ，求出一个多项式 $B(x)$， 满足</p><script type="math/tex; mode=display">A(x) * B(x) \equiv 1  \pmod{ x^{n+1}}</script><p>系数对 998244353 取模。</p><h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><p>采用倍增的思想。</p><p>考虑只有常数项的时候，$A(x)\equiv c\pmod{x}$ ，那么 $A^{-1}(x)$ 即为 $c^{-1}$。</p><p>对于 $n&gt;1$ 的时候，设 $B(x)=A^{-1}(x)$ ，有</p><script type="math/tex; mode=display">A(x)B(x)\equiv 1\pmod{x^n}</script><p>因为此时模 $x^n$ 相当于只保留多项式前 $n$ 项，所以该同余式在模 $x^k,0\le k\le n$ 时都成立</p><script type="math/tex; mode=display">A(x)B(x)\equiv 1\pmod{x^{\lceil\frac{n}{2}\rceil}}</script><p>假设在 $\pmod {x^{\lceil \frac n2\rceil}}$ 意义下 $A(x)$ 的逆元是 $B′(x)$ 并且我们已经求出，那么</p><script type="math/tex; mode=display">A(x)B'(x) \equiv 1 \pmod {x^{\lceil \frac{n}{2} \rceil}}</script><p>两式相减，得</p><script type="math/tex; mode=display">B(x)-B'(x) \equiv 0 \pmod {x^{\lceil \frac{n}{2} \rceil}}</script><p>两边平方，得</p><script type="math/tex; mode=display">B^2(x)-2B(x)B'(x)+B'^2(x)\equiv 0\pmod{x^n}</script><p>模数平方的合法性在于，大于 $n$ 的系数卷积中每组乘法必然有一项下标小于 $n$ ，因此乘起来必然为 $0$ 。</p><p>两侧同称 $A(x)$ ，整理得</p><script type="math/tex; mode=display">B(x)\equiv2B'(x)-A(x)B'^2(x)\pmod{x^n}</script><p>因此只需将 $B’(x)$ 和 $A(x)$ 在模 $x^n$ 意义下的插值求出，有</p><script type="math/tex; mode=display">B_i=2B'_i-A_iB'^2_i=B'_i(2-A_iB')</script><p>因此一遍 NTT 就可以由 $B’(x)$ 求出 $B(x)$ 了。</p><p>总的时间复杂度为</p><script type="math/tex; mode=display">T(n) = T(\frac{n}{2}) + \mathcal O(n \log n) = \mathcal O(n \log n)</script><p>由此过程也可以得到一个结论：<strong>一个多项式有没有逆元完全取决于其常数项是否有逆元。</strong></p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>使用 <a href="https://www.luogu.org/problemnew/show/P4238" target="_blank" rel="noopener">[ Luogu P4238 ] 多项式求逆</a> 作为测试题。</p><ul><li><p><a href="https://blog.gyx.me/code/template/polynomial/inv1.cpp">递归版本</a>，使用 O2 优化，用时 562 ms</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inv</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;b[<span class="number">0</span>] = qpow(a[<span class="number">0</span>], mod - <span class="number">2</span>); <span class="keyword">return</span>;&#125;</span><br><span class="line">  Inv(a, b, (n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">int</span> len = Rev(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) tmp[i] = a[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; len; ++i) b[i] = tmp[i] = <span class="number">0</span>;</span><br><span class="line">  NTT(b, len, <span class="number">1</span>); NTT(tmp, len, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    b[i] = (<span class="number">2l</span>l - <span class="number">1l</span>l * tmp[i] * b[i] % mod + mod) * b[i] % mod;</span><br><span class="line">  NTT(b, len, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) tmp[i] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; len; ++i) b[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://blog.gyx.me/code/template/polynomial/inv2.cpp">迭代版本</a>，使用 O2 优化，用时 570 ms</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inv</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  b[<span class="number">0</span>] = qpow(a[<span class="number">0</span>], mod - <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">int</span> len;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt; (n &lt;&lt; <span class="number">1</span>); l &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    len = Rev(l &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; ++i) tmp[i] = a[i];</span><br><span class="line">    NTT(b, len, <span class="number">1</span>); NTT(tmp, len, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">      b[i] = (<span class="number">2l</span>l - <span class="number">1l</span>l * tmp[i] * b[i] % mod + mod) * b[i] % mod;</span><br><span class="line">    NTT(b, len, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; len; ++i) b[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="多项式开根"><a href="#多项式开根" class="headerlink" title="多项式开根"></a>多项式开根</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个 $n$ 次多项式 $A(x)$，求一个在 $\bmod{x^{n+1}}$ 意义下的多项式 $B(x)$，使得 </p><script type="math/tex; mode=display">B^2(x) \equiv A(x) \pmod{x^{n+1}}</script><p>多项式的系数在模 998244353 意义下进行运算，保证常数项 $a_0=1$。</p><h3 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h3><p>同样采用倍增的思想。</p><p>考虑只有常数项的时候，$A(x)\equiv c\pmod x$ ，那么 $\sqrt {A(x)}$ 即为 $\sqrt c \equiv 1\pmod{x}$ （二次剩余）。</p><p>对于 $n&gt;1$ 的时候，同样根据上一题的结论，我们可以把问题范围缩小到 $\bmod {x^{\lceil \frac{n}2\rceil}}$ ，有</p><script type="math/tex; mode=display">B^2(x)\equiv A(x)\pmod{x^n}\ \Rightarrow\ B^2(x)\equiv A(x)\pmod{x^{\lceil \frac{n}2\rceil}}</script><p>不妨设我们已经求出来了 $\bmod{x^{\lceil \frac{n}2\rceil}} $ 意义下的根 $D(x)$，即</p><script type="math/tex; mode=display">D^2(x)\equiv A(x)\pmod{x^{\lceil \frac{n}2\rceil}}</script><p>因此 $B(x)$ 与 $D(x)$ 在模 $x^{\lceil \frac{n}2\rceil}$ 意义下同余，移项得</p><script type="math/tex; mode=display">B(x)-D(x)\equiv 0\pmod{x^{\lceil \frac{n}2\rceil}}</script><p>两侧平方，得</p><script type="math/tex; mode=display">B^2(x)+D^2(x)-2B(x)D(x)\equiv 0\pmod{x^n}</script><p>模数能平方的原因与上一题相同。</p><p>我们知道$\bmod{x^n}$  时 $B^2(x)$ 即为 $A(x)$ ，因此</p><script type="math/tex; mode=display">A(x)+D^2(x)-2B(x)D(x)\equiv 0\pmod{x^n}</script><p>移项，得</p><script type="math/tex; mode=display">B(x)\equiv \frac{D^2(x) + A(x)}{2D(x)}\equiv \bigg(D(x) +\frac{A(x)}{D(x)}\bigg)\times 2^{-1}\pmod{x^n}</script><p>因此倍增时进行多项式求逆即可，总的时间复杂度为</p><script type="math/tex; mode=display">T(n) = T(\frac{n}{2}) + \mathcal O(n \log n) = \mathcal O(n \log n)</script><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><p>使用 <a href="https://www.luogu.org/problemnew/show/P5205" target="_blank" rel="noopener">[ Luogu P5205 ] 多项式开根</a> 作为测试题，多项式求逆部分均采用递归版本。</p><ul><li><p><a href="https://blog.gyx.me/code/template/polynomial/sqrt1.cpp">递归版本</a>，使用 O2 优化，用时 3081 ms</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Sqrt</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;b[<span class="number">0</span>] = <span class="number">1</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">  Sqrt(a, b, (n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  Inv(b, b0, n);</span><br><span class="line">  <span class="keyword">int</span> len = Rev(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) a0[i] = a[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; len; ++i) a0[i] = <span class="number">0</span>;</span><br><span class="line">  NTT(a0, len, <span class="number">1</span>); NTT(b0, len, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) a0[i] = <span class="number">1l</span>l * a0[i] * b0[i] % mod;</span><br><span class="line">  NTT(a0, len, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) b[i] = <span class="number">1l</span>l * (b[i] + a0[i]) % mod * inv2 % mod;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; len; ++i) b[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://blog.gyx.me/code/template/polynomial/sqrt2.cpp">迭代版本</a>，使用 O2 优化，用时 3104 ms</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Sqrt</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  b[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> len;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt; (n &lt;&lt; <span class="number">1</span>); l &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    Inv(b, b0, l);</span><br><span class="line">    len = Rev(l &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; ++i) a0[i] = a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; len; ++i) a0[i] = <span class="number">0</span>;</span><br><span class="line">    NTT(a0, len, <span class="number">1</span>); NTT(b0, len, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) a0[i] = <span class="number">1l</span>l * a0[i] * b0[i] % mod;</span><br><span class="line">    NTT(a0, len, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; ++i) b[i] = <span class="number">1l</span>l * (b[i] + a0[i]) % mod * inv2 % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; len; ++i) b[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="多项式除法和取模"><a href="#多项式除法和取模" class="headerlink" title="多项式除法和取模"></a>多项式除法和取模</h2><h3 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个 $n$ 次多项式 $A(x)$ 和一个 $m$ 次多项式 $B(x)$，求出多项式 $D(x)$, $R(x)$，满足</p><script type="math/tex; mode=display">A(x) = D(x)B(x) + R(x)</script><p>$D(x)$ 次数为 $n-m$，$R(x)$ 次数小于 $m$ ，所有的运算在模 998244353 意义下进行。</p><h3 id="解决方法-3"><a href="#解决方法-3" class="headerlink" title="解决方法"></a>解决方法</h3><p>注意到带着 $R(x)$ 在这里很麻烦，前人们想到了一个神奇的解决办法。</p><p>设 $A^R(x)=x^nA(\frac{1}{x})$ ，我们将右侧展开：</p><script type="math/tex; mode=display">A^R(x)=x^nA(\frac{1}{x})=x^n\sum_{i=0}^na_i\frac{1}{x^i}=\sum_{i=0}^na_ix^{n-i}</script><p>所以 $A^R(x)$ 就是将 $A(x)$ 的<strong>系数反转</strong> 。</p><p>我们将所求的等式中 $x$ 全部换成 $\frac{1}{x}$ ，然后两侧同乘 $x^n$ ：</p><script type="math/tex; mode=display">x^n A(\frac{1}{x}) = x^{n - m}D(\frac{1}{x}) x^mB(\frac{1}{x}) + x^{n - m + 1}x^{m - 1}R(\frac{1}{x})</script><script type="math/tex; mode=display">A^R(x) = D^R(x)B^R(x) + x^{n - m + 1}R^R(x)</script><p>注意到 $D^R(x)$ 最高次反转后不变，依然为 $n-m$。</p><p>而右侧的 $R^R(x)$ 因为前面有 $x^{n-m+1}$ 所以最低次为 $n-m+1$ 。</p><p>所以我们可以把多项式运算在 $\bmod{x^{n-m+1}}$ 意义下进行，这样 $R(x)$ 就消失了：</p><script type="math/tex; mode=display">A^R(x) \equiv D^R(x)B^R(x) \pmod{x^{n-m+1}}</script><p>因此就可以得到 $D^R(x)$ 的解法：</p><script type="math/tex; mode=display">\frac{A^R(x)}{B^R(x)} \equiv D^R(x) \pmod{x^{n-m+1}}</script><p>一个多项式求逆就可以求出 $D^R(x)$了，再将 $D^R(x)$ 进行反转就得到了答案。</p><p>将求出的 $D(x)$ 回代，再进行一次减法即可求出 $R(x)$。</p><p>复杂度与多项式求逆同阶，为 $\mathcal O(n \log n)$ 。</p><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><p>使用 <a href="https://www.luogu.org/problemnew/show/P4512" target="_blank" rel="noopener">[ Luogu P4512 ] 多项式除法</a> 作为测试题，不再区分多项式求逆部分的实现方式。</p><p><a href="https://blog.gyx.me/code/template/polynomial/div.cpp">多项式求逆递部分归版本</a>，使用 O2 优化，用时 710 ms</p><p>注意求 $D(x)$ 部分的那次卷积是在 $\bmod{x^{n-m+1}}$意义下的，所以 $A^R(x)$ 和 $B^R(x)$ 中高于 $n-m+1$ 的项需要清空（因为 FFT 卷积过程中高次系数也会对低次系数造成影响）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Div</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) ar[i] = a[n - i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) br[i] = b[m - i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n - m + <span class="number">2</span>; i &lt;= n; ++i) ar[i] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n - m + <span class="number">2</span>; i &lt;= m; ++i) br[i] = <span class="number">0</span>;</span><br><span class="line">  Inv(br, invb, n - m + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">int</span> len = Rev((n - m + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  NTT(ar, len, <span class="number">1</span>); NTT(invb, len, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) ar[i] = <span class="number">1l</span>l * ar[i] * invb[i] % mod;</span><br><span class="line">  NTT(ar, len, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - m; ++i) tmp[i] = d[i] = ar[n - m - i];</span><br><span class="line">  len = Rev(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n - m + <span class="number">1</span>; i &lt;= len; ++i) tmp[i] = <span class="number">0</span>;</span><br><span class="line">  NTT(b, len, <span class="number">1</span>); NTT(tmp, len, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) b[i] = <span class="number">1l</span>l * b[i] * tmp[i] % mod;</span><br><span class="line">  NTT(b, len, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) r[i] = mo(a[i] - b[i] + mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="分治-FFT"><a href="#分治-FFT" class="headerlink" title="分治 FFT"></a>分治 FFT</h2><h3 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定长度为 $n-1$ 的数组 $g[1],\dots,g[n-1]$，求长度为 $n$ 的数组 $f[0],\dots,f[n-1]$，其中</p><script type="math/tex; mode=display">f[i]=\sum_{j=1}^if[i-j]g[j]</script><p>边界为 $f[0]=1$，运算在模 998244353 下进行。</p><h3 id="解决方法-4"><a href="#解决方法-4" class="headerlink" title="解决方法"></a>解决方法</h3><h4 id="分治求解"><a href="#分治求解" class="headerlink" title="分治求解"></a>分治求解</h4><p>暴力做是 $\mathcal O(n^2)$ 的，考虑将相同的转移一起做以达到优化的目的。</p><p>考虑使用类似 CDQ 分治的思想，每次我们求出 $[L, mid]$ 范围内的 $f$ 数组之后，把这部分 $f$ 对 $[mid+1, R]$ 范围内 $f$ 的贡献一起做。</p><p>考虑对 $x\in[mid + 1, R]$ 的 $f[x]$ 的贡献 $w_x$，有</p><script type="math/tex; mode=display">w_x=\sum_{i=l}^{mid} f[i]g[x-i]</script><p>因此 $w$ 数组可以卷积求了，注意求 $w_x$ 时后半段的 $f$ 需要认为是 $0$，否则就存在右区间内部的贡献了。</p><p>总的时间复杂度为</p><script type="math/tex; mode=display">T(n) = 2T(\frac{n}{2}) + \mathcal O(n \log n) = \mathcal O(n \log^2 n)</script><h4 id="多项式求逆-1"><a href="#多项式求逆-1" class="headerlink" title="多项式求逆"></a>多项式求逆</h4><p>一阶分治 FFT 是可以看作卷积处理的。</p><p>不妨设将数组看成多项式，有</p><script type="math/tex; mode=display">F(x)=\sum_{i=0}^{n-1}f[i]x^i\ ,\ G(x)=\sum_{i=0}^{n-1}g[i]x^i</script><p>将两个多项式卷积，有</p><script type="math/tex; mode=display">F(x)G(x)=\sum_{i=0}^{\infty}x^i\sum_{j}f[i-j]g[j]=F(x)-f[0]</script><p>后一个等式成立的原因是，注意到后一个求和就是 $f[i]$ 的形式，所以只有 $f[0]$ 没有被计数</p><p>求 $f$ 数组可以看作是 $\bmod{x^n}$ 意义下进行的，因此有</p><script type="math/tex; mode=display">F(x)G(x) \equiv F(x)-f[0] \pmod x^n\ \Rightarrow\ F(x) \equiv \frac{f_0}{1-G(x)} \equiv (1-G(x))^{-1} \pmod x^n</script><p>于是一遍多项式求逆就可以求出来了，复杂度为 $\mathcal O(n\log n)$</p><h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><p>使用 <a href="https://www.luogu.org/problemnew/show/P4721" target="_blank" rel="noopener">[ Luogu P4721 ] 分治 FFT</a> 作为测试题，多项式求逆采用递归版本。</p><ul><li><p><a href="https://blog.gyx.me/code/template/polynomial/divfft1.cpp">分治版本</a>，使用 O2 优化，用时 974 ms</p></li><li><p><a href="https://blog.gyx.me/code/template/polynomial/divfft2.cpp">多项式求逆版本</a>，使用 O2 优化，用时 261 ms</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) a[i] = mo(mod - a[i]);</span><br><span class="line">  Inv(a, b, n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) print(b[i], <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="多项式求导和积分"><a href="#多项式求导和积分" class="headerlink" title="多项式求导和积分"></a>多项式求导和积分</h2><h3 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个 $n$ 次多项式 $A(x)$ ，求一个 $n-1$ 次多项式 $B(x)$ ，和一个 $n+1$ 次多项式 $C(x)$，满足</p><script type="math/tex; mode=display">B(x)=A'(x)\ ,\ C(x)=\int A(x)</script><h3 id="解决方法-5"><a href="#解决方法-5" class="headerlink" title="解决方法"></a>解决方法</h3><p>直接按照定义做即可，有</p><script type="math/tex; mode=display">B(x)=\sum_{i=1}^{n}ia_ix^{i-1}\ ,\ C(x)=\sum_{i=1}^{n}\frac{a_ix^{i+1}}{i+1}</script><p>我们一般认为 $C(x)$ 的常数项为 $0$ ，复杂度显然为 $\mathcal O(n)$。</p><h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Der</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) a[i - <span class="number">1</span>] = <span class="number">1l</span>l * i * a[i] % mod;</span><br><span class="line">  a[n - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Int</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i) a[i] = <span class="number">1l</span>l * a[i - <span class="number">1</span>] * qpow(i, mod - <span class="number">2</span>) % mod;</span><br><span class="line">  a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="多项式-ln"><a href="#多项式-ln" class="headerlink" title="多项式 ln"></a>多项式 ln</h2><h3 id="问题描述-6"><a href="#问题描述-6" class="headerlink" title="问题描述"></a>问题描述</h3><p>给出 $n$ 次多项式 $A(x)$，求一个 $\bmod{x^{n+1}}$ 下的多项式 $B(x)$，满足 </p><script type="math/tex; mode=display">B(x) \equiv \ln A(x)\pmod{x^{n+1}}</script><p>所有运算在模 998244353 下进行。</p><h3 id="解决方法-6"><a href="#解决方法-6" class="headerlink" title="解决方法"></a>解决方法</h3><p>设 $F(x)=\ln x$，则 $B(x)=F(A(x))$ 。</p><p>对 $B(x)$ 求导，根据链式法则，有</p><script type="math/tex; mode=display">B'(x)=F'(A(x))A'(x)=\frac{A'(x)}{A(x)}</script><p>因此对 $A(x)$ 分别进行求导和求逆，卷积即可求出 $B’(x)$ ，再对其进行积分即可。</p><p>复杂度与多项式求逆同阶，为 $\mathcal O(n \log n)$ 。</p><h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><p>使用 <a href="https://www.luogu.org/problemnew/show/P4725" target="_blank" rel="noopener">[ Luogu P4725 ] 多项式对数函数</a> 作为测试题，不再区分多项式求逆部分的实现方式。</p><p><a href="https://blog.gyx.me/code/template/polynomial/ln.cpp">多项式求逆递部分归版本</a>，使用 O2 优化，用时 682 ms</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Ln</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  Inv(a, b, n); Der(a, n);</span><br><span class="line">  <span class="keyword">int</span> len = Rev(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  NTT(a, len, <span class="number">1</span>); NTT(b, len, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) a[i] = <span class="number">1l</span>l * a[i] * b[i] % mod;</span><br><span class="line">  NTT(a, len, <span class="number">-1</span>); Int(a, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Goodbye Wuxu</title>
      <link href="/2019/02/05/goodbye-wuxu/"/>
      <url>/2019/02/05/goodbye-wuxu/</url>
      
        <content type="html"><![CDATA[<p>戊戌狗年结束了，这一年的生活还算顺利。</p><p>上下求索的过程中，一次次的走进迷茫，再从迷茫中回到自己。</p><p>尽人事，知天命。新的一年加油。</p><a id="more"></a><h2 id="Memorabilia"><a href="#Memorabilia" class="headerlink" title="Memorabilia"></a>Memorabilia</h2><p>Mar.  写了转入三三的申请。给十六留下了粗糙的值周记录PPT。</p><p>Apr.  转入三三。省选划水，最后是非正式 rank15。</p><p>May.  花了两天时间研究了 Hexo，采用的 Next 主题。</p><p>Jun.  人生第一次过集体生日。</p><p>Jul.  NOI 同步赛 Spfa 被卡。在洛谷出的比赛过审了，正解被爆踩。</p><p>Aug.  把 Dev-C++ 换了 Atom 。</p><p>Nov.  NOIP 2018 差点被送退役。</p><p>Dec.  参加学考。简单学了点 LaTeX 。</p><p>Jan. 参加 CCPC-Wannafly Winter Camp。</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>随便写点还记得的东西，想到哪里就写些什么了。</p><p>嘴上常挂着 “不忘初心 ”，但是做了不少表面文章，做了不少不懂装懂的傻事。</p><p>有的事情总是呆在 Todo List 上，但是一直不去碰，或是看了两下就把它扔回去，等到下决心去搞了，也有几次搞到一半因为奇奇怪怪的原因放弃了。但这些东西还老是堆在心里一直想着，列的 deadline 也总是咕掉。</p><p>花哨的东西却认认真真搞了不少，几度沉沦于形式的简约和规范，甚至是操作界面的美观。</p><p>很多东西浅尝辄止，只学了一个开头，就去做做水题装作很懂的样子，过了一段时间发现学的不透，又会回来重新再看一遍，反反复复。</p><p>OI 在上半年逐渐成了生活的主线。但是好多时候不知道事情从哪里下手，或者希望渺茫。</p><p>这段时间 OI 以外的生活过的还是比较愉快的，经历了值周，换班，听到了想听的课，见识了很强的同学们和新鲜的思路。但是精力渐渐不太放在文化课上了，好多该刷题的东西一直放着，下课就想往机房跑，到期末还是不怎么会做动量和电解池的题。</p><p>OI 上也没有踏实下来吃透些什么，该学的东西不知道为什么也一直在拖，逐渐的变成了回避，躲避，沉默，每遇到了这些知识点的话题。这种感觉就像个瘤，它就长在你的心上，但是你就是不会碰它，越长越大压得喘不过气来。</p><p>过了生日之后，某一个晚上给父母写了点东西。现在看当时略显稚气的信里并没有说出来什么深处的东西，但还是借此给自己打打气，当时的感觉是 “有所成长” ，也算在那个时期拉了自己一把，OI 开始有些起色。</p><p>NOIP 前的三个月或许是到现在为止最拼的一段时间吧。那段时间压力比较大，也收获了很多感动。</p><p>第一次停课单休也是很新鲜。但状况也不容乐观，好多东西还停留在认识的阶段，有段时间甚至接近崩溃。万幸的是有 Luan 能陪我挺过那段时间，互相交流，心情也逐渐变得乐观起来，工作比较高效。感觉自己能挺过那段时间也是挺神奇，一个多月学了之前落下的好多东西，还能挺住比较密集的考试。我要感谢 Luan，我都不敢想象没了他跟我交流现在我会是什么样子。</p><p>那段时间的生活过的比较平淡，但是充实。还不是太冷的时候跑了几次步，N 老师带着队，第一次没停下跑完了二南外圈 2km。</p><p>NOIP 的事情不想说太多了，以前也写过东西。分别是必然的，但很多意料之外的事情让人很痛苦。</p><p>学考之后这段时间过的比较平凡。事情变得开朗一些。</p><p>突击学考算是一种比较奇妙的体验吧。当整天整天的摸不到键盘的时候，就会坐不住，开始知道自己已经离不开了。教学楼里有趣的事情倒是不少，少见的感受到了 C 主任的亲民，趁着自习的时候也可以偷着拜读一下渡边先生的大作了。</p><p>去不了 NOIWC 的事情也是早就准备好的，能去 CCPC-Wannafly Winter Camp 算是一个惊喜吧，以大学生的视角看算法竞赛也是一种体验。搞到了自己的域名也算是了了一桩心事，以后颓废的时候可能会开发一下。</p><p>大家都好厉害啊。逐渐发现自己站位有些低，或许该多想想远一些的事情。</p><p>希望新的一年自己能专注一些，注意自律，做些务实的事情。</p>]]></content>
      
      
      <categories>
          
          <category> Summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOIP 2018</title>
      <link href="/2018/12/08/noip2018/"/>
      <url>/2018/12/08/noip2018/</url>
      
        <content type="html"><![CDATA[<p>按照惯例写一篇游记，纪念我高中 OI 的第一次正式考试。</p><p>飞雪连天射白鹿，笑书神侠倚碧鸳。纪念伟大的金庸先生。</p><a id="more"></a><h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h2><p>离考试越近自己越静不下来。</p><p>中午一点到了石家庄站，今年的比赛还是在燕大。</p><p>等车的时候发现不会在虚拟机里编译，慌张地问了一波。</p><p>上火车之后莫名其妙被换座到了1A。颓的时候发现，旁边两位爷开始离线切题太强了。</p><h2 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h2><p>早上起来被教练通知又要考一场模拟赛。T3 只会 $60$ 暴力，然后事后诸葛…</p><p>下午试机。耍无赖苟在那里将近一个小时，最后只是敲了链剖和倍增互拍，还拍挂了慌慌慌。</p><p>晚上学长说注意事项，感觉讲的东西都没听说过。回去之后和 ZH 一起梳理了知识点，感觉不错。</p><p>睡觉的时候外面有跑步和喊叫的声音，以及午夜凶铃。以为是初中的 <del>后来得知是高一学长</del>。</p><h2 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="Day 1"></a>Day 1</h2><p>今天在燕大 1 机房，座位在前排角落，周围目测是友善的高一学长。</p><p>开题发现<code>i7-8700K</code> 以及 <code>512M</code> ，非常资瓷啊，再也不怕常数大了…</p><p>T1 确认完题意就会做了。 在<code>首尾相接</code> 上纠结了一会，发现样例解释不了环，就放心写了。</p><p>T2 读了两遍题，感觉有点难。玩样例发现选的都是原来就有的数，觉得有些蹊跷。冷静了一下，分情况讨论证明这个结论是对的，然后就得到了排序之后用背包贪心的解法。</p><p>T3 明白了问题模型之后，发现不会找树上一堆链，开始看部分分。发现简单的子任务合起来就有 $55$ 了，于是先写了这些点，解法分别是树的直径，所有边长取最小值，正常的二分答案+验证，以及二分答案+双指针。</p><p>然后上个厕所冷静了一下，回来发现可以用树形 DP 搞。几次 WA 和 死循环 之后，找了好多反例，高度紧张的状态下在 11:40 的时候终于码完了，应该是我人生中第一个考场 $200+$行吧。测了一发大样例没有 TLE ，肉眼比对第一页没锅，打开<code>cmd</code> ，输入<code>fc track.out track3.ans</code>，显示<code>FC: 找不到差异</code>，突然觉得全世界都清静了。</p><p>下午在宾馆里看板子，晚上十点多就睡了。意外的睡得不错。</p><h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h2><p>今天在燕大 4 机房，座位在正中间，前面是 zyz 后面是 czy ，旁边的老哥看起来不是很友好。</p><p>T1 开始以为是最小字典序拓扑序，写完过不了样例，发现读错题了，应该是是 DFS 序。想起来还没有看数据范围，看完发现是基环树。发现 $60$ 很好写，$100$ 只会平方复杂度，因为用的是邻接矩阵，感觉写起来很麻烦就先撂下了。</p><p>T2 题面太长就先做的 T3 。NOIP 前写过一道题，是 [SDOI2006] 保安站岗 。<strong>我就把边覆盖读成了点覆盖</strong>，十分自信地码完了 $44$ 的暴力，<strong>竟然过了样例</strong>，然后就十分自信地去搞 T2 了。</p><p>T2 明确题意后写了状压路径的 $20$ 暴力，开始找规律。发现和前不久 CodeForces 的 一道 D 题可能有一样的思路，每一条斜线上只要只是一段前缀 $1$ 就合法了，因为每一条斜线上的点在字典序列位置相同。然后推了个公式带进去发现算的不对。找了很久没有发现原因，只好把不合法情况打出来，发现两条交错路径就凉了。尝试状压斜线，发现不会转移，只好暴力把表打出来算了。打的时候发现了一些规律，但是对 $n&gt;4$ 并不适用，就只打了前 $65$ ，放弃了剩下的 $35$ 。</p><p>回去赶 T1 ，思路混乱，发现得把邻接矩阵存改回邻接表。写完发现跑不出来，慌了，把 T1 $60$ 的代码和另外两道题先打了包。到最后都没有调出来，最后收卷的时候头脑一片空白。</p><p>下午去看海，照了合影。我和 Luan 在沙滩上留下了手划出来的字。我写了<code>NEXT YEAR GOTO NOI 2019</code> 。</p><p>返程火车上老师把代码发下来了，交到洛谷上 $60+65+0=125$ 恍恍惚惚，比预想的还要糟糕，没有再和教练说什么。晚上机房泡面，聊天时终于发现自己读错题的事实。</p><h2 id="Day-n"><a href="#Day-n" class="headerlink" title="Day n"></a>Day n</h2><p>几个晚上都在想，如果 Day2T1 码出来，或者 Day2T3 没读错题就能加上四十多。</p><p>民间数据在 HE 大概 rank 30+ ，我还是想接着学的啊。</p><p>最后拿到了成绩，跟洛谷上测出来成绩差不多。</p><p>$100+100+95+60+65+0=420$</p><p>也得到了 rank 40+ 的尴尬境地，几经折腾可以留下来准备省选了。</p><h2 id="Summaries-and-Flags"><a href="#Summaries-and-Flags" class="headerlink" title="Summaries and Flags"></a>Summaries and Flags</h2><p>稍微多说两句。</p><p>不要期望超常发挥，正常发挥就是最大的幸运。</p><p>心态要平衡，OI 两天的赛制也考验心态。之所以会出现低级错误，就是考场上想得太多。考场上不要想之前考的怎么样，认真做题就是最大的成功。</p><p>后面的学习已经有赌的成分在里面了，立一些 Flag 激励自己。</p><ul><li>少看游记少颓废</li><li>省选阶段模拟赛能搞懂的题都改完写题解</li><li>做掉尽可能多的近 $5$ 年内各地省选题</li><li>把能打的不是猝死场的 CodeForces 都打了，赛后补题解</li></ul>]]></content>
      
      
      <categories>
          
          <category> Travel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/11/29/hello-world/"/>
      <url>/2018/11/29/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Hello, the lovely world.</p><p>不忘初心，方得始终。初心易得，始终难守。</p><p>希望自己能记住为之坚持的东西，记住不掺杂利益的热爱。</p><p>希望自己能学会果断选择，不再踌躇，有拥抱生活的勇气。</p><a id="more"></a><hr><p>优美胜于丑陋 明了胜于晦涩</p><p>简单胜于复杂 复杂胜于杂乱</p><p>扁平胜于嵌套 间隔胜于紧凑</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> this</span><br><span class="line">The Zen of Python, by Tim Peters</span><br><span class="line"></span><br><span class="line">Beautiful <span class="keyword">is</span> better than ugly.</span><br><span class="line">Explicit <span class="keyword">is</span> better than implicit.</span><br><span class="line">Simple <span class="keyword">is</span> better than complex.</span><br><span class="line">Complex <span class="keyword">is</span> better than complicated.</span><br><span class="line">Flat <span class="keyword">is</span> better than nested.</span><br><span class="line">Sparse <span class="keyword">is</span> better than dense.</span><br><span class="line">Readability counts.</span><br><span class="line">Special cases aren<span class="string">'t special enough to break the rules.</span></span><br><span class="line"><span class="string">Although practicality beats purity.</span></span><br><span class="line"><span class="string">Errors should never pass silently.</span></span><br><span class="line"><span class="string">Unless explicitly silenced.</span></span><br><span class="line"><span class="string">In the face of ambiguity, refuse the temptation to guess.</span></span><br><span class="line"><span class="string">There should be one-- and preferably only one --obvious way to do it.</span></span><br><span class="line"><span class="string">Although that way may not be obvious at first unless you'</span>re Dutch.</span><br><span class="line">Now <span class="keyword">is</span> better than never.</span><br><span class="line">Although never <span class="keyword">is</span> often better than *right* now.</span><br><span class="line">If the implementation <span class="keyword">is</span> hard to explain, it<span class="string">'s a bad idea.</span></span><br><span class="line"><span class="string">If the implementation is easy to explain, it may be a good idea.</span></span><br><span class="line"><span class="string">Namespaces are one honking great idea -- let'</span>s do more of those!</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
