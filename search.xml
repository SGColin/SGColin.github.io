<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Atcode Regular Contest 124</title>
      <link href="2021/07/26/arc124/"/>
      <url>2021/07/26/arc124/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><p>Contest Link: <a href="https://atcoder.jp/contests/arc124">AtCoder Regular Contest 124</a></p><p>Official Editorial: <a href="https://atcoder.jp/contests/arc124/editorial">Editorial - AtCoder Regular Contest 124</a></p><a id="more"></a><p>overview：不太会用很强的约束条件</p><h2 id="A-LR-Constraints"><a href="#A-LR-Constraints" class="headerlink" title="A. LR Constraints"></a>A. LR Constraints</h2><blockquote><p>给一个数列赋值，值域 $[1,k]$​​ ，对于每个 $k$​​​​​ ，约束第一次出现的位置或最后一次出现的位置，求方案数</p></blockquote><p>维护一下对于每个位置，当前有多少种方案，复杂度 $O(n)$​ </p><h2 id="B-XOR-Matching-2"><a href="#B-XOR-Matching-2" class="headerlink" title="B. XOR Matching 2"></a>B. XOR Matching 2</h2><blockquote><p>给定两个长度相同的数列 $A,B$​​ ，求有哪些 $x$​​ ，使得将 $B$​​ 重排后，任意位置 $A_i\ \text{xor}\ B_i = x$​​​ </p></blockquote><p>重排后有 $\forall 1\le i,j\le n,\ A_i\ \text{xor}\ B_i=A_j\ \text{xor}\ B_j\Rightarrow A_i\ \text{xor}\ A_j=B_i\ \text{xor}\ B_j$​​​​ </p><p>也就是说，要满足重排后, （$A_i$​​ 与所有其他 $A$​​ 的异或值）与（$B_i$​​ 与所有其他 $B$​​​​ 的异或值）<strong>一一对应</strong></p><p>约束条件很强，我们只需要处理 $A_1$​ 与其他 $A$ 的异或值，然后找可能对应的 $B$ 即可，复杂度 $O(n^2\log n)$​​ </p><h2 id="C-LCM-of-GCDs"><a href="#C-LCM-of-GCDs" class="headerlink" title="C. LCM of GCDs"></a>C. LCM of GCDs</h2><blockquote><p>给定 $n$ 个 pair，每个 pair 中的数一个放入 $A$ 集，另一个放入 $B$​ 集，最大化 $lcm[\ gcd(A),\ gcd(B)\ ]$​</p></blockquote><p>集合的最大公约数一定是每个数的因子，将第一个 pair 里的两个数求出所有的约数，枚举答案。</p><p>如果存在一种方案使得答案为 $[x,y]$​​ 的倍数，那么对于每个 pair $(a,b)$​​ ，有 $x|a,\ y|b$​ 或者 $x|b,\ y|a$​ ​​</p><p>暴力检验即可，复杂度 $O\big(div(A_{1a})div(A_{1b})n\big)$​</p><h2 id="D-Yet-Another-Sorting-Problem"><a href="#D-Yet-Another-Sorting-Problem" class="headerlink" title="D. Yet Another Sorting Problem"></a>D. Yet Another Sorting Problem</h2><blockquote><p>一个 $n+m$​ 的排列，每次选择前 $n$​ 个中一个和后 $m$​ 个中一个交换，问交换成单位置换所需最少次数</p></blockquote><p>首先，如果没有位置选择的限制，还原一个 $n$​​ 的排列所需最少交换次数为 $n\ -$ 排列所对应的环数。</p><p>将排列 $p$​​ 视作置换，将位置视为点，每个数由当前位置指向目标位置，即建边 $i\to p_i$​​ 得到若干个环。</p><p>我们的目标是让所有的 $i$​ 满足 $i \to i$​ ，即 $\forall i, p_i = i$​ ​变为单位置换。</p><p>因此对于某次交换，操作都会形如将 $p_i$​ 和 $p_{p_i}$​​ 进行交换，也就是将第 $i$ 位的数和第 $p_i$ 位的数交换。</p><p>那么对于原来所在环中的结构 $i\to p_i\to p_{p_i}$​ ，变换后第 $i$​ 个位置上变为 $p_{p_i}$​ ，而第 $p_i$ 位上的数变为 $p_i$​​​ </p><p>也就是说，对于每个环，每次交换相当于将环上的一个 $a\to b\to c$ 结构变为 $a\to c，b\to b$​​​​​ </p><p>目标是形成 $n$​ 个自环，因此每个环需要环长 $-\ 1$​ 次移动才能将环内归位，而不同的环之间还原过程无关。</p><hr><p>考虑位置选择的限制条件，我们将前 $n$ 个点染成黑色，后 $m$ 个点染成白色。</p><p>可以发现，每次可以操作的约束条件等价于<strong>每次删掉的边要满足连接的两个点颜色不同</strong>。</p><ol><li>对于一个由若干段白黑交替连接的环，我们一定可以通过白点吃指向的黑色的点，将整个环变成只剩下一个黑色，然后用这个黑色删掉所有其他白色，总次数为<strong>环长</strong> $-1$​ </li><li>对于一个只有某一种颜色的环，我们需要考虑“引入”另一种颜色，需要花费一步的代价进行一次交换引入，然后分析如上，此时环长因为引入 $+1$​​ ，因此总次数为<strong>原来环长</strong> $+1$​​</li><li>考虑都有“引入”需求，但颜色不同的两个单色环，此时某一个环引入对方的某个元素，相当于帮助了对方引入，因此两个环之需要一次“引入” ，并且两个环共享的引入的长度 ，总次数为<strong>第一个环长+第二个环长</strong></li></ol><p>综上，对于双色环，我们所需次数为环长 $-1$ ，单色环先默认代价为环长 $+1$ ，每匹配上一对总代价 $-2$ 。</p><p>此外本题无需考虑太过复杂，首先同色单色环之间融合没有意义（可比较前后代价），其次不需要考虑单色环和双色环的融合，这种情况可以看作先将双色环归位，再取某一个长度为 $1$​​​​​​ 的自环与单色环进行融合。</p><p>处理过程中只涉及 dfs 找环，总复杂度 $O(n)$</p><figure class="highlight c++ hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">int</span> cntl = <span class="hljs-number">0</span>, cntr = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n + m; ++i)</span><br><span class="line"><span class="hljs-keyword">if</span> (!bl[i] &amp;&amp; i != p[i]) {</span><br><span class="line">++tot; dfs(i);</span><br><span class="line">ans += len[tot];</span><br><span class="line"><span class="hljs-keyword">if</span> (l[tot] &amp;&amp; r[tot]) --ans;</span><br><span class="line"><span class="hljs-keyword">else</span> {l[tot] ? ++cntl : ++cntr; ++ans;}</span><br><span class="line">}</span><br><span class="line"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, ans - min(cntl, cntr) * <span class="hljs-number">2</span>);</span><br></pre></td></tr></tbody></table></figure><h2 id="E-Pass-to-Next"><a href="#E-Pass-to-Next" class="headerlink" title="E. Pass to Next"></a>E. Pass to Next</h2><p>比赛没来得及看的题，回头做。</p><h2 id="F-Chance-Meeting"><a href="#F-Chance-Meeting" class="headerlink" title="F. Chance Meeting"></a>F. Chance Meeting</h2><p>比赛没来得及看的题，回头做。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> solution </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Atcoder </tag>
            
            <tag> Counting </tag>
            
            <tag> Permutation </tag>
            
            <tag> Number Theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>热爱生活</title>
      <link href="2021/07/08/freshman/"/>
      <url>2021/07/08/freshman/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><p>今天是 2021 年 7 月 8 日，星期四。</p><p>一年前的今天，高考最后一门刚刚考完。走出考场，回到自己的教室，拿手机，搬行李，告别。</p><p>离开学校的时候，碰到了还在梳理交通的竞赛教练，问我考的怎么样，然后约了后天要给高一的学弟们上课。</p><p>直到昨晚，暑假回本部给又一届的学弟们上完最后一天课。从二中本部的校门里走出来，回头看看。</p><a id="more"></a><h2 id="来杭电之前"><a href="#来杭电之前" class="headerlink" title="来杭电之前"></a>来杭电之前</h2><p>高考完就跟爸爸妈妈说我<strong>不复读</strong>，当晚就对答案，大概 645。报了南科大综评，拿到了还算不错的校考分。</p><p>然后在南校区给高一的同学讲了比较入门的概率，也是那些在一年前的暑假认识的，刚踏入二中大门学弟。</p><p>结束的时候在空空的学校里溜达，想想他们上课时候那种纯粹的热情，一代又一代，多少有一点感慨。</p><p>走之前拍了张照片，想起来一句自认为很应景的话：“<strong>雨过天青云破处，者般颜色做将来</strong>”</p><img src="/material/a.png" alt="连着下了两三天的小雨，只剩下竞赛生的二中" style="zoom:70%;"><p>出分的晚上比较坦然，提前几分钟查到了分数，比估计的低 9 分，都扣在语文上，115 / 134 / 136 / 251。</p><p>之后的几天比较迷茫，听了几个学校的招生宣讲都不尽如人意。南科大那边几度有希望，后来终究是落空。</p><hr><p>在我想起来杭电这所学校的时候，突然感觉就是要去这里了。</p><p>可能是高二去学军培训喜欢上了杭州这个城市，也可能是<strong>对竞赛生涯结束的不甘</strong>吧。</p><p>先自己偷偷找 Claris 要到了教练的联系方式，问了读研和专业的事情，刘老师的热情的杭州话让人很舒服。</p><p>然后就是小心翼翼地和父母交流，说我自己的想法和考虑，直到最后心里十分踏实地填上了第一志愿。</p><p>录取的结果是数学系，高考分数达到了卓越学院二次选拔的报名分数线，报了卓越学院的招生考试。</p><p>之后的假期写了几个板子，打了几场 CF 恢复一点水平，参加了 HDU 的几场内部训练，搬了一套题恰烂钱。</p><p>开学之前和岳老师吃了个饭（竟然还赶上了他生日）， 让我重心不要全部放到竞赛上，要给自己留个后路。</p><h2 id="初到杭电"><a href="#初到杭电" class="headerlink" title="初到杭电"></a>初到杭电</h2><p>有一说一假期还是过的比较随意，虽然报名了卓越学院，但是一点没准备，9 月份忐忑地就来到杭电啦。</p><p>考试之前自己很没有底气，当时觉得能进计科班就不错了。考完觉得考的还行，因为竞赛里接触过一点高数线代的知识，觉得自己英语阅读也比较会蒙。然后晚上大概九点的时候出成绩了，震惊自己竟然过了英才班的线。</p><p>晚上给爸爸妈妈很激动地打了个电话，有点担心 11 进 9 被刷掉，一直到十二点多才睡着。</p><p>第二天面试的时候其实自己比较轻松，感觉面试向来都比较稳 <del>比较会吹</del> ，面试单独面，五个老师。</p><p>面试跟想象里的一样顺利，老师们的问题基本是跟着我的自我介绍思路走，不过还是有几个问题血压拉满。</p><ol><li><p>我努力地强调自己的竞赛水平，然后冯老师问：“现在让你去打区域赛能拿到什么奖项？”</p></li><li><p>我介绍了一下高中学校和班级的情况，然后另一个老师问：“你觉得二中和衡一哪个更好？”</p></li><li><p>周老师（也是现在的导师）问：“你也不能打一辈子竞赛啊。以后有什么进一步的打算？”<br> 我说会读研，以后可能会去当大学老师。导师笑笑说要想当教授，后面得去好点的大学读书。</p></li></ol><p>面试完出来觉得自己还挺稳的，但是也不敢确定，忐忑到了晚上十点多出了结果。终于还是去学计算机了。</p><p>之后的生活比较顺利，见面会，正常上课，班委选举（当了学委）。</p><p>上课的时候强迫自己去提问，回答问题，意识到自己可以做一些 <strong>由自己决定的</strong> <strong>想做什么就做什么</strong> 的事。</p><p>遇到了自己喜欢的老师，有能够舒适相处，真心相待的一帮同学，慢慢地从高三痛苦自闭的状态走出来了。</p><h2 id="竞赛"><a href="#竞赛" class="headerlink" title="竞赛"></a>竞赛</h2><p>这段话也想写给每个学竞赛过程中感到无力的同行者。</p><p><strong>算法竞赛的魅力在于，通过努力积累或灵机一动，你能够做出越来越难的题目，是一种对自我能力的认可。</strong></p><p><strong>算法竞赛的危险亦在于，你学会的东西越多，认识的厉害的人越多，面对不可计数的强者，很容易陷入自我否定。</strong></p><p>想到杭电之前，很长一段时间都觉得，大学不会再打竞赛了。</p><p>学竞赛的过程中经历的打击，不仅是比赛和上课中受到一众神仙居高临下的压迫感，更多的其实是周围人不经意的否定和安慰。对我来说，这是一种对信心很大的打击，会想要证明自己，亦或是心里感到无力而故作轻松。 </p><p>在面临是否买 D 的抉择时，我放弃了。不是担心取得不了什么结果，而是觉得压力太大了。</p><p>在选学校的时候，突然想到杭电的那一刻，有种死灰复燃的感觉。</p><p>记起来 NOIP 2018 结束的时候，在存真楼下，孙校长和我们几个刚从秦皇岛回来的学生说的几句话：</p><p>“学别的竞赛的，最终的发展和竞赛不一定有关系，但是算法竞赛的学生，最终往往都会选择计算机行业。”</p><p><strong>算法竞赛会在心里埋下一颗种子。</strong></p><p><strong>我不是那种一帆风顺的天才，在受到打击的时候，我会感到无力。</strong></p><p><strong>但当我抛开名利、和他人比较、证明自己这些功利的意义之后，我发现自己还剩下些东西，还能看到初心。</strong></p><p><strong>是对算法的欣赏和热爱，是理解每一个算法、做出每一个题目的瞬间，精神上的享受，这就够了。</strong></p><p>至少在我看来，从我开始接触竞赛，到做出很多重要的选择，我决策的初心从来都不是名利，因为对算法还爱着。决定最终没有买 D 类，最大的原因还是在那个时刻，竞赛带来的痛苦超过了学习的享受，被一次次的排名裹挟，被各种机会所吸引，我越来越像一个没有自我的机器，越来越被成功学牢牢锁死。而在我选择大学的时候，竞赛对我的意义不再是未来的全部了。我能够静下来，问问自己对算法还有没有那种近乎痴迷的喜爱，能够将它作为一种兴趣去发展，不需要考虑付出和回报，至少在大学，我还是有自由支配自己的权利。</p><p><strong>我还是那个深深爱着算法的小孩，对几十行代码背后的智慧如痴如醉。</strong></p><hr><p>一年来取得的结果超过预期，也让自己慢慢恢复了信心，继续努力。</p><ul><li>Gold Medal (30th Place) : The 45th ICPC Asia Jinan Regional Contest, 2020</li><li>Gold Medal ( 15th Place) : The 18th Zhejiang Provincial Collegiate Programming Contest, 2021</li><li>Silver Medal (28th Place) : The 45th ICPC Asia Shenyang Regional Contest, 2021</li></ul><h2 id="课内学习"><a href="#课内学习" class="headerlink" title="课内学习"></a>课内学习</h2><p>第一个学期不会选课，修了系统默认的 25.25 个学分， 第二个学期修了 32.25​ 个学分。</p><p>通识选修的任务完成的不太行，只完成了科技发展与科学精神（2/2），大二上应该会把通识剩下的指标修完。</p><table><thead><tr><th align="center">数理基础（23）</th><th>数分 （6 * 3.5 + 5 * 4.2）、高代（3 * 5 + 2 * 5）、离散（4 * 5）、大学物理1（3 * 5）</th></tr></thead><tbody><tr><td align="center">CS专业课（14）</td><td>计导（2 * 5）、程设基础（5 * 5）、数据结构（4 * 4.5）、C++ 面向对象（3 * 5）</td></tr><tr><td align="center">通识教育（8）</td><td>思修法基（3 * 5）、心理健康（1 * 4.3）、大军（2 * 4.8）、ACM（2 * 5）</td></tr><tr><td align="center">外语类（8）</td><td>英语精读 A（2 * 4.4 + 2 * 4.6）、英语听说 A（1 * 4.3 + 1 * 4.7）、实用翻译（2 * 4.6）</td></tr><tr><td align="center">其他（3.5）</td><td>大学启示录（1 * 4）、形式与政策（0.5 * 5）、科研实践（1 * 5）、体育（1 * 2.1 + 1 * 1.8）</td></tr></tbody></table><p>很幸运的是遇到的老师都很认真负责，老师们对课程内容非常了解，自己遇到问题也都能很好沟通。</p><p>很多课程都觉得自己做的没那么好，对给出的成绩也常常受之有愧。</p><p><strong>数学分析</strong>和<strong>高等代数</strong>两门数学基础课的表现截然相反，让我更清楚地意识到很大程度上我是个兴趣驱动的人。</p><p>对数分的知识体系自己本身可能就不太感兴趣，<del>加上数分课是真的提不起来精神</del>，两个学期的数学分析成绩都不太看的过去，数分上可能要在大三重修了。老师确实想要认真教会我，可是自己确实提不起兴趣去学。经历了数分上的洗礼，数分下还是逼着自己学了学，最后的结果算是马马虎虎吧，确实对不起老师对不起自己。</p><p>很喜欢高代老师的课，很大程度驱动我去花相对比较多的时间在这门课上。两个学期最后的结果都比较好，在自己喜欢的科目上能够看到自己做了些事情，也是让自己很开心的一件事。唯一遗憾的是期末错在了最后一节课老师强调过的一个小点上（证明正定阵需先说明对称）。大二下预定了老师的近世代数。</p><p>也很喜欢 Cathy 上的<strong>英语精读</strong>，也算是第一次能让我主动提起来学英语的兴趣。 Cathy 的课有一种很轻松的气氛，不会按照课本一板一眼的去上，讲的很多东西很受用。</p><p>感谢<strong>程设和OOP（C++）</strong>的老师对我的包容，自己在这两门课上确实有过很幼稚的行为。很佩服将近退休的老师能精确把控很多细节，随手写的代码能一遍过编译什么错都没有。</p><p><strong>离散数学和数据结构</strong> 给了我很深刻的教训。两门都是自认为了解比较多的，<strong>数据结构</strong>甚至申请了免听。考前复习的都不是很充分，等上了考场发现要开始脑补一堆一堆的概念。期末离散卷子简单，没暴露出来什么问题。数据结构觉得自己看看书就够了，最后的成绩却不尽如人意，原因只是不知道排序里的一个既定细节，只能悔不当初。</p><p><strong>大学物理和思想道德修养与法律基础</strong> 两门课结果意外的好，其实自己认真去学一学还是可以有效果的。中学阶段一直头疼的政治在闭卷的期末考试也写了个差不多。学不会电磁在考场上也做出来了绝大多数题。考试遇到不会的题也不能太着急，多想一会没准就通了。</p><p><strong>体育</strong> 从中考的 $18$ 分保底，到大一上的体测 $36$ 分，痛失两个学期的奖学金，终究还是没逃过身体素质不行这个问题。还是感谢环境逼着我去直面体育，按着体能班的要求大一下结结实实把 40 次阳光长跑跑完了，也确实让我看到耐力可以有提升，从操场跑一圈就喘不上气，到体测的时候人生第一次把 1000 米全跑下来，确实是很激动的。也终于在锻炼身体上有了动力，首先是大二下想要和 qyy 同学一起学体育舞，其次是想要恰奖学金。</p><h2 id="我的她"><a href="#我的她" class="headerlink" title="我的她"></a>我的她</h2><p>只想说爱情的体验是一种很纯粹的幸福。</p><p>愿意为她牺牲自己的一切，无时无刻都会想起她的事情，找不到她会坐如针毡，什么都做不下去。</p><p>她所高兴的事情比她还高兴，她难受的时候会跟着一起哭出来，在爱情中两个人都学会了如何照顾对方。</p><p>两个人在一起呆着常常心有灵犀，做事情反应如出一辙，很多事情不用言语。</p><p>两个人在一起呆着就是最快乐的事情，能够一起学习，散步，她在我的身边就能感受到无比的踏实。</p><p>会走到一起的人终究不会分开。心里对未来有着期盼，静下心来踏踏实实做事，继续加油。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Atcode Beginner Contest 203</title>
      <link href="2021/05/31/abc203/"/>
      <url>2021/05/31/abc203/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><p>Contest Link: <a href="https://atcoder.jp/contests/abc203">AtCoder Beginner Contest 203</a></p><p>Official Editorial: <a href="https://atcoder.jp/contests/abc203/editorial">Editorial - AtCoder Beginner Contest 203</a></p><a id="more"></a><p>Overview: 比平时的 ABC 难一些， F 题比较有意思。</p><h2 id="D-Pond"><a href="#D-Pond" class="headerlink" title="D. Pond"></a>D. Pond</h2><p>给定一个 $n\times n$ 的矩阵，找到所有 $k\times k$ 的子矩阵中，子矩阵内中位数的最小值。</p><blockquote class="colorquote info"><p>考虑对于某个 $x$ ，将矩阵中小于等于 $x$ 的数标 $1$ ，其余标 $0$ 。</p><p>若某个 $k\times k$ 的子矩阵内和为 $\lfloor\frac{k^2}{2} + 1\rfloor$ ，则此时 $x$ 可以成为答案之一（ $x$ 为该子矩阵的中位数）</p></blockquote><p>赛时的做法比较窒息，将所有数字排序后逐个插入，需要支持单点加，询问是否存在对应的子矩阵。</p><p>由于询问的矩阵大小相同，将子矩阵内的权值记录在左上角，转化成了子矩阵加加，维护矩阵内单点 $\max$ 。</p><p>写了二维线段树复杂度 $O(n^2\log^2n)$ ，TLE * 8，耻辱下播。</p><hr><p>实际上二分答案+二维前缀和就好了，每次二分，把原矩阵中小于的标 $1$ 。</p><p>然后用二维容斥逐个检查是否存在 $k\times k$ 的子矩阵内和 $&gt;\lfloor\frac{k^2}{2} + 1\rfloor$ 即可，复杂度 $O(n^2\log n)$ 。</p><h2 id="E-White-Pawn"><a href="#E-White-Pawn" class="headerlink" title="E. White Pawn"></a>E. White Pawn</h2><p>题意不再叙述，注意直着移动目标位置不能有黑点，斜着移动目标位置必须有黑点。</p><p>考虑维护起点到每一行末尾的连通性，那么一个黑点能影响的连通性，其实只有它所在的行。</p><p>具体的，如果某个黑点坐标在 $(x_0,y_0)$ ，起点可以到的 $x=x_0-1$ 的行的集合为 $S$ ，那么：</p><ul><li><p>￼ 如果 $y_0+1\in S$ 或 $y_0-1\in S$ ，则 $x=x_0$ 时 $y_0$ 可达，将 $y_0$ 加入。</p></li><li><p>￼ 否则 $x=x_0$ 时 $y_0$ 不可达，将 $y_0$ 删去。</p></li></ul><p>因此只需要维护可达行的集合 $S$ ，按黑点 $x$ 从小到大修改 $S$ 即可，显然集合的大小与黑点的个数是线性关系。</p><p>维护的时候需要注意同一列上不同点可能会互相影响，可以把修改存下来，每一列处理完后统一做。</p><figure class="highlight c++ hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt; S;</span><br><span class="line"><span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &gt; a;</span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; add, del;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{ </span><br><span class="line">    <span class="hljs-keyword">int</span> n = rd(), m = rd();</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) a[rd()].push_back(rd());</span><br><span class="line">    S.insert(n);</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : a) {</span><br><span class="line">        add.clear();</span><br><span class="line">      del.clear();</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : v.second) </span><br><span class="line">            <span class="hljs-keyword">if</span> (S.count(y - <span class="hljs-number">1</span>) || S.count(y + <span class="hljs-number">1</span>)) add.push_back(y);</span><br><span class="line">            <span class="hljs-keyword">else</span> del.push_back(y);</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : add) S.insert(y);</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : del) S.erase(y);</span><br><span class="line">    }</span><br><span class="line">    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, S.size());</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="F-Weed"><a href="#F-Weed" class="headerlink" title="F. Weed"></a>F. Weed</h2><p>题意不再叙述，注意是双关键字最优。</p><p>赛时以为第一关键字最优的情况一定是推掉最大/最小的共 k 个，反例很好找（一段一段的分布）</p><p>性质：每次 2 操作集合里的最大值都会至少减半，最多删 $\log\{\max a_i\}$ 次一定会结束了，第一关键字最大为 $30$ 。</p><p>这个状态设计比较有意思（答案放到状态中）：首先将 $a[i]$ 从小到大排序，$f[i][j]$ 表示，只考虑 $a[1],\cdots, a[i]$ ，即只考虑 $\le a[i]$ 的元素时， 最少提前使用 2 操作删掉几个，使得剩余的只需要 $j$ 次 1 操作即可删干净。</p><p>转移分讨当前元素删/不删即可: $f[i][j] = \min(f[i-1][j] + 1,f[pos - 1][j - 1])$</p><p>其中 $pos$ 的含义为，最小的 $x\ge 1$ ，满足 $a[x] &gt; \frac{a[i]}2$ ，即使用一次操作 $a[i]$ 能带走的最靠前的位置。</p><figure class="highlight c++ hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sort(a + <span class="hljs-number">1</span>, a + <span class="hljs-number">1</span> + n);</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, p = <span class="hljs-number">1</span>; i &lt;= n; i++) {</span><br><span class="line">  <span class="hljs-keyword">for</span> (; a[p] * <span class="hljs-number">2</span> &lt;= a[i]; p++);</span><br><span class="line">    f[i][<span class="hljs-number">0</span>] = i;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; K; j++)</span><br><span class="line">      f[i][j] = min(f[i - <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>, f[p - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]);</span><br><span class="line">}</span><br><span class="line"><span class="hljs-keyword">for</span> (p = <span class="hljs-number">0</span>; f[n][p] &gt; k; p++);</span><br><span class="line"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d\n"</span>, p, f[n][p]);</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
      
      
      <categories>
          
          <category> solution </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Atcoder </tag>
            
            <tag> Binary Search </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Render Math Equations in Hexo</title>
      <link href="2019/06/01/mathjax/"/>
      <url>2019/06/01/mathjax/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><p>$$<br>f(a) = \frac{1}{2\pi i}\oint_{\gamma}\frac{f(z)}{z-a}dz<br>$$</p><p><a href="https://www.mathjax.org/">Beautiful and accessible math in all browsers - MathJax</a> </p><p>This post is used to check out whether the mathjax plugin (<a href="https://github.com/hexojs/hexo-math">hexo-math</a>) still works.</p><a id="more"></a><h2 id="Inline-Formula"><a href="#Inline-Formula" class="headerlink" title="Inline Formula"></a>Inline Formula</h2><p>Consider the sequence of $n$ distinct positive integers: $c_1, c_2, \cdots, c_n$. The child calls a vertex-weighted rooted binary tree <strong>good</strong> if and only if for every vertex $v$, the weight of $v$ is in the set ${c_1, c_2, \cdots, c_n}$ . Also our child thinks that the <strong>weight</strong> of a vertex-weighted tree is the sum of all vertices’ weights.</p><p>Given an integer $m$, can you for all $s (1 \le  s ≤ m) $ calculate the number of good vertex-weighted rooted binary trees with weight $s$ ? Please, check the samples for better understanding what trees are considered different.</p><p>We only want to know the answer modulo $998244353$ ( $7 × 17 × 2^{23} + 1$ , a prime number).</p><h2 id="Block-Formula"><a href="#Block-Formula" class="headerlink" title="Block Formula"></a>Block Formula</h2><p>$$<br>\int \frac{dx}{cos^2x}=\int sec^2xdx=tan x+C\<br>$$</p><p>$$<br>\int \frac{dx}{sin^2x}=\int csc^2xdx=-cot x+C\<br>$$</p><p>$$<br>\sum\limits_{i = 0}^{E} w[i]{M \choose i} {N \choose iS} \frac{(iS)!}{(S!)^{i}} \sum\limits_{j = 0}^{E - i} (-1)^{j} {M - i \choose j} {N - iS \choose jS} \frac{(jS)!}{(S!)^{j}} (M - i - j)^{N - iS - jS}<br>$$</p><p>$$<br>= \sum\limits_{i = 0}^{E} w[i]{M \choose i} {N \choose iS} \frac{(iS)!}{(S!)^{i}} \sum\limits_{j = i}^{E} (-1)^{j - i} {M - i \choose j - i} {N - iS \choose jS - iS} \frac{(jS - iS)!}{(S!)^{j - i}} (M - j)^{N - jS}<br>$$</p><h2 id="Matrix"><a href="#Matrix" class="headerlink" title="Matrix"></a>Matrix</h2><p>$$<br>\begin{bmatrix}<br>(\omega_n^0)^0 &amp; (\omega_n^0)^1 &amp; \cdots &amp; (\omega_n^0)^{n-1}\\ (\omega_n^1)^0 &amp; (\omega_n^1)^1 &amp; \cdots &amp; (\omega_n^1)^{n-1}\\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>(\omega_n^{n-1})^0 &amp; (\omega_n^{n-1})^1 &amp; \cdots &amp; (\omega_n^{n-1})^{n-1}<br>\end{bmatrix}<br>\begin{bmatrix}<br>a_0 \\<br>a_1 \\<br>\vdots \\<br>a_{n-1}<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>A(\omega_n^0) \\<br>A(\omega_n^1) \\<br>\vdots \\<br>A(\omega_n^{n-1})<br>\end{bmatrix}<br>$$</p><p>$$<br>\begin{bmatrix}<br>a_0 \\<br>a_1 \\<br>\vdots \\<br>a_{n-1}<br>\end{bmatrix}<br>=<br>\frac{1}{n}<br>\begin{bmatrix}<br>(\omega_n^{-0})^0 &amp; (\omega_n^{-0})^1 &amp; \cdots &amp; (\omega_n^{-0})^{n-1} \\<br>(\omega_n^{-1})^0 &amp; (\omega_n^{-1})^1 &amp; \cdots &amp; (\omega_n^{-1})^{n-1} \\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>(\omega_n^{-(n-1)})^0 &amp; (\omega_n^{-(n-1)})^1 &amp; \cdots &amp; (\omega_n^{-(n-1)})^{n-1}<br>\end{bmatrix}<br>\begin{bmatrix}<br>A(\omega_n^0) \\<br>A(\omega_n^1) \\<br>\vdots \\<br>A(\omega_n^{n-1})<br>\end{bmatrix}<br>$$</p><blockquote class="colorquote warning"><p>To prevent escaping, you need to use <code>\\\\</code> to make a new line rather than <code>\\</code> .</p></blockquote><blockquote class="colorquote success"><p>For more about the Mathjax symbols, refer to <a href="/material/mathjax-symbol-list.pdf">The Comprehensive LaTeX Symbol List</a> .</p></blockquote></body></html>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2018/11/29/hello-world/"/>
      <url>2018/11/29/hello-world/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><p>「 Hello, the lovely world. 」</p><p>「 Stay hungry, Stay foolish. 」</p><figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> this</span><br><span class="line">The Zen of Python, by Tim Peters</span><br><span class="line"></span><br><span class="line">Beautiful <span class="hljs-keyword">is</span> better than ugly.</span><br><span class="line">Explicit <span class="hljs-keyword">is</span> better than implicit.</span><br><span class="line">Simple <span class="hljs-keyword">is</span> better than complex.</span><br><span class="line">Complex <span class="hljs-keyword">is</span> better than complicated.</span><br><span class="line">Flat <span class="hljs-keyword">is</span> better than nested.</span><br><span class="line">Sparse <span class="hljs-keyword">is</span> better than dense.</span><br><span class="line">Readability counts.</span><br><span class="line">Special cases aren<span class="hljs-string">'t special enough to break the rules.</span></span><br><span class="line"><span class="hljs-string">Although practicality beats purity.</span></span><br><span class="line"><span class="hljs-string">Errors should never pass silently.</span></span><br><span class="line"><span class="hljs-string">Unless explicitly silenced.</span></span><br><span class="line"><span class="hljs-string">In the face of ambiguity, refuse the temptation to guess.</span></span><br><span class="line"><span class="hljs-string">There should be one-- and preferably only one --obvious way to do it.</span></span><br><span class="line"><span class="hljs-string">Although that way may not be obvious at first unless you'</span>re Dutch.</span><br><span class="line">Now <span class="hljs-keyword">is</span> better than never.</span><br><span class="line">Although never <span class="hljs-keyword">is</span> often better than *right* now.</span><br><span class="line">If the implementation <span class="hljs-keyword">is</span> hard to explain, it<span class="hljs-string">'s a bad idea.</span></span><br><span class="line"><span class="hljs-string">If the implementation is easy to explain, it may be a good idea.</span></span><br><span class="line"><span class="hljs-string">Namespaces are one honking great idea -- let'</span>s do more of those!</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
