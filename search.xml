<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>多项式科技初步</title>
      <link href="/2019/02/27/polynomial/"/>
      <url>/2019/02/27/polynomial/</url>
      
        <content type="html"><![CDATA[<p>啃了一周的多项式，终于有点感觉了。</p><p>写一些总结和简要题解留作纪念，顺便测试一下 MathJax 。</p><p>以后再做多项式的题会补充进来，但估计最近应该不怎么做多项式了。</p><a id="more"></a><p>（由于我太菜东西还没有学完，最近还会更新</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>为了体现简洁，在每一部分只会放关键代码。</p><p>代码具有一定的通用性，保证代码之间函数的调用是合法的。</p><p>如果 MathJax 加载不出来或加载有误，请您多刷新几次。</p><p>总结可能会比较长，可以点右边的小火箭回到目录。</p><p>有什么问题请联系我，万分感谢。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Picks 的博客  <a href="http://picks.logdown.com/" target="_blank" rel="noopener">Picks’s Blog</a></p><p>Miskcoo 的博客  <a href="http://blog.miskcoo.com/" target="_blank" rel="noopener">Miskcoo’s Space</a></p><p>毛爷爷的论文 <a href="https://blog.gyx.me/data/ctsc/2016.pdf">《再探快速傅里叶变换》</a></p><h2 id="多项式乘法"><a href="#多项式乘法" class="headerlink" title="多项式乘法"></a>多项式乘法</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定两个多项式 $A(x) $ 和 $B(x)$ ：</p><script type="math/tex; mode=display">A(x)=\sum_{i=0}^{n}a_ix^i\ ,\ B(x)=\sum_{i=0}^{n} b_i x^i</script><p>求卷积 $C(x) =A(x) * B(x)$ ，满足</p><script type="math/tex; mode=display">C(x)=\sum_{i=0}^{n} c_i x^i\ ,\  c_i=\sum_{k=0}^{i} a_k\times b_{i-k}</script><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>这部分上面提到的神仙们讲解的都十分详细。</p><p>我的小结限于篇幅，就直接挂 pdf 版本的连接了：<a href="https://blog.gyx.me/papers/fft.pdf">快速傅里叶变换初步</a></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>使用 <a href="http://uoj.ac/problem/34" target="_blank" rel="noopener">[ UOJ 34 ] 多项式乘法</a> 作为测试题。</p><ul><li><p><a href="https://blog.gyx.me/code/template/polynomial/fft.cpp">Fast Fourier Transform</a>，使用的是 3 次变换的最基本写法，用时 362 ms</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Complex *f, <span class="keyword">int</span> len, <span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">      <span class="keyword">if</span> (rev[i] &gt; i) swap(f[i], f[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">      Complex wn = Complex(<span class="built_in">cos</span>(PI / i) , o * <span class="built_in">sin</span>(PI / i));</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j += (i &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Complex w = Complex(<span class="number">1</span>, <span class="number">0</span>), x, y;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; ++k, w = w * wn) &#123;</span><br><span class="line">          x = f[j + k]; y = w * f[i + j + k];</span><br><span class="line">          f[i + j + k] = x - y; f[j + k] = x + y;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="number">-1</span>) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) f[i].x /= len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://blog.gyx.me/code/template/polynomial/ntt.cpp">Fast Number-Theoretic Transform</a>，模数为 998244353，用时 403 ms</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> *f, <span class="keyword">int</span> len, <span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i)</span><br><span class="line">    <span class="keyword">if</span> (i &gt; rev[i]) swap(f[i], f[rev[i]]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> wn = qpow(<span class="number">3</span>, (mod - <span class="number">1</span>) / (i &lt;&lt; <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="number">-1</span>) wn = qpow(wn, mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j += (i &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">      <span class="keyword">int</span> w = <span class="number">1</span>, x, y;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; ++k, w = <span class="number">1l</span>l * w * wn % mod) &#123;</span><br><span class="line">        x = f[j + k]; y = <span class="number">1l</span>l * w * f[i + j + k] % mod;</span><br><span class="line">        f[j + k] = mo(x + y); f[i + j + k] = mo(x - y + mod);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (o == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> invl = qpow(len, mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) f[i] = <span class="number">1l</span>l * f[i] * invl % mod;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="多项式求逆"><a href="#多项式求逆" class="headerlink" title="多项式求逆"></a>多项式求逆</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个 $n$ 次多项式 $A(x)$ ，求出一个多项式 $B(x)$， 满足</p><script type="math/tex; mode=display">A(x) * B(x) \equiv 1  \pmod{ x^{n+1}}</script><p>系数对 998244353 取模。</p><h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><p>采用倍增的思想。</p><p>考虑只有常数项的时候，$A(x)\equiv c\pmod{x}$ ，那么 $A^{-1}(x)$ 即为 $c^{-1}$。</p><p>对于 $n&gt;1$ 的时候，设 $B(x)=A^{-1}(x)$ ，有</p><script type="math/tex; mode=display">A(x)B(x)\equiv 1\pmod{x^n}</script><p>因为此时模 $x^n$ 相当于只保留多项式前 $n$ 项，所以该同余式在模 $x^k,0\le k\le n$ 时都成立</p><script type="math/tex; mode=display">A(x)B(x)\equiv 1\pmod{x^{\lceil\frac{n}{2}\rceil}}</script><p>假设在 $\pmod {x^{\lceil \frac n2\rceil}}$ 意义下 $A(x)$ 的逆元是 $B′(x)$ 并且我们已经求出，那么</p><script type="math/tex; mode=display">A(x)B'(x) \equiv 1 \pmod {x^{\lceil \frac{n}{2} \rceil}}</script><p>两式相减，得</p><script type="math/tex; mode=display">B(x)-B'(x) \equiv 0 \pmod {x^{\lceil \frac{n}{2} \rceil}}</script><p>两边平方，得</p><script type="math/tex; mode=display">B^2(x)-2B(x)B'(x)+B'^2(x)\equiv 0\pmod{x^n}</script><p>模数平方的合法性在于，大于 $n$ 的系数卷积中每组乘法必然有一项下标小于 $n$ ，因此乘起来必然为 $0$ 。</p><p>两侧同称 $A(x)$ ，整理得</p><script type="math/tex; mode=display">B(x)\equiv2B'(x)-A(x)B'^2(x)\pmod{x^n}</script><p>因此只需将 $B’(x)$ 和 $A(x)$ 在模 $x^n$ 意义下的插值求出，有</p><script type="math/tex; mode=display">B_i=2B'_i-A_iB'^2_i=B'_i(2-A_iB')</script><p>因此一遍 NTT 就可以由 $B’(x)$ 求出 $B(x)$ 了。</p><p>总的时间复杂度为</p><script type="math/tex; mode=display">T(n) = T(\frac{n}{2}) + \mathcal O(n \log n) = \mathcal O(n \log n)</script><p>由此过程也可以得到一个结论：<strong>一个多项式有没有逆元完全取决于其常数项是否有逆元。</strong></p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>使用 <a href="https://www.luogu.org/problemnew/show/P4238" target="_blank" rel="noopener">[ Luogu P4238 ] 多项式求逆</a> 作为测试题。</p><ul><li><p><a href="https://blog.gyx.me/code/template/polynomial/inv1.cpp">递归版本</a>，使用 O2 优化，用时 562 ms</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inv</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;b[<span class="number">0</span>] = qpow(a[<span class="number">0</span>], mod - <span class="number">2</span>); <span class="keyword">return</span>;&#125;</span><br><span class="line">  Inv(a, b, (n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">int</span> len = Rev(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) tmp[i] = a[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; len; ++i) b[i] = tmp[i] = <span class="number">0</span>;</span><br><span class="line">  NTT(b, len, <span class="number">1</span>); NTT(tmp, len, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    b[i] = (<span class="number">2l</span>l - <span class="number">1l</span>l * tmp[i] * b[i] % mod + mod) * b[i] % mod;</span><br><span class="line">  NTT(b, len, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) tmp[i] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; len; ++i) b[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://blog.gyx.me/code/template/polynomial/inv2.cpp">迭代版本</a>，使用 O2 优化，用时 570 ms</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inv</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  b[<span class="number">0</span>] = qpow(a[<span class="number">0</span>], mod - <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">int</span> len;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt; (n &lt;&lt; <span class="number">1</span>); l &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    len = Rev(l &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; ++i) tmp[i] = a[i];</span><br><span class="line">    NTT(b, len, <span class="number">1</span>); NTT(tmp, len, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">      b[i] = (<span class="number">2l</span>l - <span class="number">1l</span>l * tmp[i] * b[i] % mod + mod) * b[i] % mod;</span><br><span class="line">    NTT(b, len, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; len; ++i) b[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="多项式开根"><a href="#多项式开根" class="headerlink" title="多项式开根"></a>多项式开根</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个 $n$ 次多项式 $A(x)$，求一个在 $\bmod{x^{n+1}}$ 意义下的多项式 $B(x)$，使得 </p><script type="math/tex; mode=display">B^2(x) \equiv A(x) \pmod{x^{n+1}}</script><p>多项式的系数在模 998244353 意义下进行运算，保证常数项 $a_0=1$。</p><h3 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h3><p>同样采用倍增的思想。</p><p>考虑只有常数项的时候，$A(x)\equiv c\pmod x$ ，那么 $\sqrt {A(x)}$ 即为 $\sqrt c \equiv 1\pmod{x}$ （二次剩余）。</p><p>对于 $n&gt;1​$ 的时候，同样根据上一题的结论，我们可以把问题范围缩小到 $\bmod {x^{\lceil \frac{n}2\rceil}}​$ ，有</p><script type="math/tex; mode=display">B^2(x)\equiv A(x)\pmod{x^n}\ \Rightarrow\ B^2(x)\equiv A(x)\pmod{x^{\lceil \frac{n}2\rceil}}</script><p>不妨设我们已经求出来了 $\bmod{x^{\lceil \frac{n}2\rceil}} ​$ 意义下的根 $D(x)​$，即</p><script type="math/tex; mode=display">D^2(x)\equiv A(x)\pmod{x^{\lceil \frac{n}2\rceil}}</script><p>因此 $B(x)​$ 与 $D(x)​$ 在模 $x^{\lceil \frac{n}2\rceil}​$ 意义下同余，移项得</p><script type="math/tex; mode=display">B(x)-D(x)\equiv 0\pmod{x^{\lceil \frac{n}2\rceil}}</script><p>两侧平方，得</p><script type="math/tex; mode=display">B^2(x)+D^2(x)-2B(x)D(x)\equiv 0\pmod{x^n}</script><p>模数能平方的原因与上一题相同。</p><p>我们知道$\bmod{x^n}$  时 $B^2(x)$ 即为 $A(x)$ ，因此</p><script type="math/tex; mode=display">A(x)+D^2(x)-2B(x)D(x)\equiv 0\pmod{x^n}</script><p>移项，得</p><script type="math/tex; mode=display">B(x)\equiv \frac{D^2(x) + A(x)}{2D(x)}\equiv \bigg(D(x) +\frac{A(x)}{D(x)}\bigg)\times 2^{-1}\pmod{x^n}</script><p>因此倍增时进行多项式求逆即可，总的时间复杂度为</p><script type="math/tex; mode=display">T(n) = T(\frac{n}{2}) + \mathcal O(n \log n) = \mathcal O(n \log n)</script><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><p>使用 <a href="https://www.luogu.org/problemnew/show/P5205" target="_blank" rel="noopener">[ Luogu P5205 ] 多项式开根</a> 作为测试题，多项式求逆部分均采用递归版本。</p><ul><li><p><a href="https://blog.gyx.me/code/template/polynomial/sqrt1.cpp">递归版本</a>，使用 O2 优化，用时 3081 ms</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Sqrt</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;b[<span class="number">0</span>] = <span class="number">1</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">  Sqrt(a, b, (n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  Inv(b, b0, n);</span><br><span class="line">  <span class="keyword">int</span> len = Rev(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) a0[i] = a[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; len; ++i) a0[i] = <span class="number">0</span>;</span><br><span class="line">  NTT(a0, len, <span class="number">1</span>); NTT(b0, len, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) a0[i] = <span class="number">1l</span>l * a0[i] * b0[i] % mod;</span><br><span class="line">  NTT(a0, len, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) b[i] = <span class="number">1l</span>l * (b[i] + a0[i]) % mod * inv2 % mod;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; len; ++i) b[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://blog.gyx.me/code/template/polynomial/sqrt2.cpp">迭代版本</a>，使用 O2 优化，用时 3104 ms</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Sqrt</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  b[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> len;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt; (n &lt;&lt; <span class="number">1</span>); l &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    Inv(b, b0, l);</span><br><span class="line">    len = Rev(l &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; ++i) a0[i] = a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; len; ++i) a0[i] = <span class="number">0</span>;</span><br><span class="line">    NTT(a0, len, <span class="number">1</span>); NTT(b0, len, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) a0[i] = <span class="number">1l</span>l * a0[i] * b0[i] % mod;</span><br><span class="line">    NTT(a0, len, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; ++i) b[i] = <span class="number">1l</span>l * (b[i] + a0[i]) % mod * inv2 % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; len; ++i) b[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="多项式除法和取模"><a href="#多项式除法和取模" class="headerlink" title="多项式除法和取模"></a>多项式除法和取模</h2><h3 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个 $n$ 次多项式 $A(x)$ 和一个 $m$ 次多项式 $B(x)$，求出多项式 $D(x)$, $R(x)$，满足</p><script type="math/tex; mode=display">A(x) = D(x)B(x) + R(x)</script><p>$D(x)$ 次数为 $n-m$，$R(x)$ 次数小于 $m$ ，所有的运算在模 998244353 意义下进行。</p><h3 id="解决方法-3"><a href="#解决方法-3" class="headerlink" title="解决方法"></a>解决方法</h3><p>注意到带着 $R(x)​$ 在这里很麻烦，前人们想到了一个神奇的解决办法。</p><p>设 $A^R(x)=x^nA(\frac{1}{x})$ ，我们将右侧展开：</p><script type="math/tex; mode=display">A^R(x)=x^nA(\frac{1}{x})=x^n\sum_{i=0}^na_i\frac{1}{x^i}=\sum_{i=0}^na_ix^{n-i}</script><p>所以 $A^R(x)$ 就是将 $A(x)$ 的<strong>系数反转</strong> 。</p><p>我们将所求的等式中 $x$ 全部换成 $\frac{1}{x}$ ，然后两侧同乘 $x^n$ ：</p><script type="math/tex; mode=display">x^n A(\frac{1}{x}) = x^{n - m}D(\frac{1}{x}) x^mB(\frac{1}{x}) + x^{n - m + 1}x^{m - 1}R(\frac{1}{x})</script><script type="math/tex; mode=display">A^R(x) = D^R(x)B^R(x) + x^{n - m + 1}R^R(x)</script><p>注意到 $D^R(x)$ 最高次反转后不变，依然为 $n-m$。</p><p>而右侧的 $R^R(x)$ 因为前面有 $x^{n-m+1}$ 所以最低次为 $n-m+1$ 。</p><p>所以我们可以把多项式运算在 $\bmod{x^{n-m+1}}$ 意义下进行，这样 $R(x)$ 就消失了：</p><script type="math/tex; mode=display">A^R(x) \equiv D^R(x)B^R(x) \pmod{x^{n-m+1}}</script><p>因此就可以得到 $D^R(x)$ 的解法：</p><script type="math/tex; mode=display">\frac{A^R(x)}{B^R(x)} \equiv D^R(x) \pmod{x^{n-m+1}}</script><p>一个多项式求逆就可以求出 $D^R(x)$了，再将 $D^R(x)$ 进行反转就得到了答案。</p><p>将求出的 $D(x)$ 回代，再进行一次减法即可求出 $R(x)$。</p><p>复杂度与多项式求逆同阶，为 $\mathcal O(n \log n)​$ 。</p><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><p>使用 <a href="https://www.luogu.org/problemnew/show/P4512" target="_blank" rel="noopener">[ Luogu P4512 ] 多项式除法</a> 作为测试题，不再区分多项式求逆部分的实现方式。</p><p><a href="https://blog.gyx.me/code/template/polynomial/div.cpp">多项式求逆递部分归版本</a>，使用 O2 优化，用时 710 ms</p><p>注意求 $D(x)$ 部分的那次卷积是在 $\bmod{x^{n-m+1}}$意义下的，所以 $A^R(x)$ 和 $B^R(x)$ 中高于 $n-m+1$ 的项需要清空（因为 FFT 卷积过程中高次系数也会对低次系数造成影响）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Div</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) ar[i] = a[n - i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) br[i] = b[m - i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n - m + <span class="number">2</span>; i &lt;= n; ++i) ar[i] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n - m + <span class="number">2</span>; i &lt;= m; ++i) br[i] = <span class="number">0</span>;</span><br><span class="line">  Inv(br, invb, n - m + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">int</span> len = Rev((n - m + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  NTT(ar, len, <span class="number">1</span>); NTT(invb, len, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) ar[i] = <span class="number">1l</span>l * ar[i] * invb[i] % mod;</span><br><span class="line">  NTT(ar, len, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - m; ++i) tmp[i] = d[i] = ar[n - m - i];</span><br><span class="line">  len = Rev(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n - m + <span class="number">1</span>; i &lt;= len; ++i) tmp[i] = <span class="number">0</span>;</span><br><span class="line">  NTT(b, len, <span class="number">1</span>); NTT(tmp, len, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) b[i] = <span class="number">1l</span>l * b[i] * tmp[i] % mod;</span><br><span class="line">  NTT(b, len, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) r[i] = mo(a[i] - b[i] + mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分治-FFT"><a href="#分治-FFT" class="headerlink" title="分治 FFT"></a>分治 FFT</h2><h3 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定长度为 $n-1$ 的数组 $g[1],\dots,g[n-1]$，求长度为 $n$ 的数组 $f[0],\dots,f[n-1]$，其中</p><script type="math/tex; mode=display">f[i]=\sum_{j=1}^if[i-j]g[j]</script><p>边界为 $f[0]=1$，运算在模 998244353 下进行。</p><h3 id="解决方法-4"><a href="#解决方法-4" class="headerlink" title="解决方法"></a>解决方法</h3><h4 id="分治求解"><a href="#分治求解" class="headerlink" title="分治求解"></a>分治求解</h4><p>暴力做是 $\mathcal O(n^2)$ 的，考虑将相同的转移一起做以达到优化的目的。</p><p>考虑使用类似 CDQ 分治的思想，每次我们求出 $[L, mid]$ 范围内的 $f$ 数组之后，把这部分 $f$ 对 $[mid+1, R]$ 范围内 $f$ 的贡献一起做。</p><p>考虑对 $x\in[mid + 1, R]$ 的 $f[x]$ 的贡献 $w_x$，有</p><script type="math/tex; mode=display">w_x=\sum_{i=l}^{mid} f[i]g[x-i]</script><p>因此 $w$ 数组可以卷积求了，注意求 $w_x$ 时后半段的 $f$ 需要认为是 $0$，否则就存在右区间内部的贡献了。</p><p>总的时间复杂度为</p><script type="math/tex; mode=display">T(n) = 2T(\frac{n}{2}) + \mathcal O(n \log n) = \mathcal O(n \log^2 n)</script><h4 id="多项式求逆-1"><a href="#多项式求逆-1" class="headerlink" title="多项式求逆"></a>多项式求逆</h4><p>一阶分治 FFT 是可以看作卷积处理的。</p><p>不妨设将数组看成多项式，有</p><script type="math/tex; mode=display">F(x)=\sum_{i=0}^{n-1}f[i]x^i\ ,\ G(x)=\sum_{i=0}^{n-1}g[i]x^i</script><p>将两个多项式卷积，有</p><script type="math/tex; mode=display">F(x)G(x)=\sum_{i=0}^{\infty}x^i\sum_{j}f[i-j]g[j]=F(x)-f[0]</script><p>后一个等式成立的原因是，注意到后一个求和就是 $f[i]$ 的形式，所以只有 $f[0]$ 没有被计数</p><p>求 $f$ 数组可以看作是 $\bmod{x^n}$ 意义下进行的，因此有</p><script type="math/tex; mode=display">F(x)G(x) \equiv F(x)-f[0] \pmod x^n\ \Rightarrow\ F(x) \equiv \frac{f_0}{1-G(x)} \equiv (1-G(x))^{-1} \pmod x^n</script><p>于是一遍多项式求逆就可以求出来了，复杂度为 $\mathcal O(n\log n)$</p><h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><p>使用 <a href="https://www.luogu.org/problemnew/show/P4721" target="_blank" rel="noopener">[ Luogu P4721 ] 分治 FFT</a> 作为测试题，多项式求逆采用递归版本。</p><ul><li><p><a href="https://blog.gyx.me/code/template/polynomial/divfft1.cpp">分治版本</a>，使用 O2 优化，用时 974 ms</p></li><li><p><a href="https://blog.gyx.me/code/template/polynomial/divfft2.cpp">多项式求逆版本</a>，使用 O2 优化，用时 261 ms</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) a[i] = mo(mod - a[i]);</span><br><span class="line">  Inv(a, b, n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) print(b[i], <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="多项式求导和积分"><a href="#多项式求导和积分" class="headerlink" title="多项式求导和积分"></a>多项式求导和积分</h2><h3 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个 $n$ 次多项式 $A(x)$ ，求一个 $n-1$ 次多项式 $B(x)$ ，和一个 $n+1$ 次多项式 $C(x)$，满足</p><script type="math/tex; mode=display">B(x)=A'(x)\ ,\ C(x)=\int A(x)</script><h3 id="解决方法-5"><a href="#解决方法-5" class="headerlink" title="解决方法"></a>解决方法</h3><p>直接按照定义做即可，有</p><script type="math/tex; mode=display">B(x)=\sum_{i=1}^{n}ia_ix^{i-1}\ ,\ C(x)=\sum_{i=1}^{n}\frac{a_ix^{i+1}}{i+1}</script><p>我们一般认为 $C(x)$ 的常数项为 $0$ ，复杂度显然为 $\mathcal O(n)$。</p><h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Der</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) a[i - <span class="number">1</span>] = <span class="number">1l</span>l * i * a[i] % mod;</span><br><span class="line">  a[n - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Int</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i) a[i] = <span class="number">1l</span>l * a[i - <span class="number">1</span>] * qpow(i, mod - <span class="number">2</span>) % mod;</span><br><span class="line">  a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多项式-ln"><a href="#多项式-ln" class="headerlink" title="多项式 ln"></a>多项式 ln</h2><h3 id="问题描述-6"><a href="#问题描述-6" class="headerlink" title="问题描述"></a>问题描述</h3><p>给出 $n$ 次多项式 $A(x)$，求一个 $\bmod{x^{n+1}}$ 下的多项式 $B(x)$，满足 </p><script type="math/tex; mode=display">B(x) \equiv \ln A(x)\pmod{x^{n+1}}</script><p>所有运算在模 998244353 下进行。</p><h3 id="解决方法-6"><a href="#解决方法-6" class="headerlink" title="解决方法"></a>解决方法</h3><p>设 $F(x)=\ln x$，则 $B(x)=F(A(x))$ 。</p><p>对 $B(x)$ 求导，根据链式法则，有</p><script type="math/tex; mode=display">B'(x)=F'(A(x))A'(x)=\frac{A'(x)}{A(x)}</script><p>因此对 $A(x)$ 分别进行求导和求逆，卷积即可求出 $B’(x)$ ，再对其进行积分即可。</p><p>复杂度与多项式求逆同阶，为 $\mathcal O(n \log n)$ 。</p><h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><p>使用 <a href="https://www.luogu.org/problemnew/show/P4725" target="_blank" rel="noopener">[ Luogu P4725 ] 多项式对数函数</a> 作为测试题，不再区分多项式求逆部分的实现方式。</p><p><a href="https://blog.gyx.me/code/template/polynomial/ln.cpp">多项式求逆递部分归版本</a>，使用 O2 优化，用时 682 ms</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Ln</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  Inv(a, b, n); Der(a, n);</span><br><span class="line">  <span class="keyword">int</span> len = Rev(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  NTT(a, len, <span class="number">1</span>); NTT(b, len, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) a[i] = <span class="number">1l</span>l * a[i] * b[i] % mod;</span><br><span class="line">  NTT(a, len, <span class="number">-1</span>); Int(a, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mathematics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Summary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MathJax 测试</title>
      <link href="/2019/02/23/mathjaxtest/"/>
      <url>/2019/02/23/mathjaxtest/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.mathjax.org/" target="_blank" rel="noopener">Beautiful math in all browsers - MathJax</a></p><p>经过多次重装终于配置好了满意的 MathJax，写一篇测试文档留作纪念。</p><a id="more"></a><h2 id="字符测试"><a href="#字符测试" class="headerlink" title="字符测试"></a>字符测试</h2><p>数学模式重音符</p><script type="math/tex; mode=display">\ \ \hat{a} \ \ \check{a} \ \ \tilde{a} \ \ \acute{a}\ \ \grave{a} \ \ \dot{a} \ \ \ddot{a} \ \ \breve{a}\ \ \bar{a} \ \ \vec{a} \ \ \widehat{A} \ \ \widetilde{A}</script><p>小写希腊字母</p><script type="math/tex; mode=display">\ \ \alpha \ \ \theta  \ \ \upsilon\ \ \beta \ \ \vartheta \ \ \pi \ \ \phi\ \ \gamma \ \ \iota \ \ \varpi \ \ \varphi\ \ \delta \ \ \kappa \ \ \rho \ \ \chi\ \ \epsilon \ \ \lambda \ \ \varrho \ \ \psi\ \ \varepsilon \ \ \mu \ \ \sigma \ \ \omega\ \ \zeta \ \ \nu \ \ \varsigma\ \ \eta \ \ \xi \ \ \tau</script><p>大写希腊字母</p><script type="math/tex; mode=display">\ \ \Gamma \ \ \Lambda \ \ \Sigma \ \ \Psi\ \ \Delta \ \ \Xi \ \ \Upsilon \ \ \Omega\ \ \Theta \ \ \Pi \ \ \Phi</script><p>二元关系表示符</p><script type="math/tex; mode=display">\ \ <\ \  <\ \  >\ \  >\ \  =\ \ \ \ \leq o\ \ \le \ \ \geq o\ \ \ge \ \ \equiv\ \ \ll \ \ \gg \ \ \doteq</script><script type="math/tex; mode=display">\ \ \prec \ \ \succ  \ \ \sim\ \ \preceq \ \ \succeq \ \ \simeq\ \ \subset \ \ \supset \ \ \approx\ \ \subseteq \ \ \supseteq \ \ \cong\ \ \sqsubset a \ \ \sqsupset  \ \ \Join \ \ \sqsubseteq \ \ \sqsupseteq</script><script type="math/tex; mode=display">\ \ \bowtie\ \ \in \ \ \ni \ \ \owns \ \ \propto\ \ \vdash \ \ \dashv |\ \ \models\ \ \mid \ \ \parallel \ \ \perp\ \ \smile \ \ \frown \ \ \asymp\ \ : \ \ \notin \ \ \neq \ \ \ne</script><p>二元运算符</p><script type="math/tex; mode=display">+\ \  −\ \  -\ \ \pm \ \ \mp \ \ \triangleleft\ \ \cdot \ \ \div \ \ \triangleright\ \ \times\ \ \setminus \ \ \star\ \ \cup \ \ \cap \ \ \ast\ \ \sqcup \ \ \sqcap \ \ \circ\ \ \vee \ \ \lor \ \ \wedge</script><script type="math/tex; mode=display">\land \ \ \bullet\ \ \oplus \ \ \ominus \ \ \diamond\ \ \odot \ \ \oslash \ \ \uplus\ \ \otimes \ \ \bigcirc \ \ \amalg\ \ \bigtriangleup \ \ \bigtriangledown \ \ \dagger\ \ \lhd \ \ \rhd\ \ \ddagger\ \ \unlhd \ \ \unrhd\ \ \wr</script><p>大尺寸运算符</p><script type="math/tex; mode=display">\ \ \sum \ \ \bigcup \ \ \bigvee \ \ \bigoplus\ \ \prod \ \ \bigcap \ \ \bigwedge \ \ \bigotimes\ \ \coprod \ \ \bigsqcup \ \ \bigodot\ \ \int \ \ \oint \ \ \biguplus</script><p>箭头</p><script type="math/tex; mode=display">\leftarrow \ \ \gets \ \ \longleftarrow\ \ \uparrow\ \ \rightarrow \ \ \to \ \ \longrightarrow\ \ \downarrow\ \ \leftrightarrow \ \ \longleftrightarrow\ \ \updownarrow</script><script type="math/tex; mode=display">\ \Leftarrow \ \ \Longleftarrow\ \ \Uparrow\ \ \Rightarrow\ \   \Longrightarrow\ \ \Downarrow \Leftrightarrow \ \ \Longleftrightarrow\ \ \Updownarrow\ \ \mapsto \ \ \longmapsto\ \ \nearrow</script><script type="math/tex; mode=display">\ \ \hookleftarrow \ \ \hookrightarrow\ \ \searrow\ \ \leftharpoonup\ \ \rightharpoonup\ \ \swarrow\ \ \leftharpoondown\ \ \rightharpoondown\ \ \nwarrow\ \ \rightleftharpoons \ \ \iff \ \ \leadsto</script><p>定界符</p><script type="math/tex; mode=display">(\ \ ) \ \ \uparrow \ \ \Uparrow\ \ \lbrack \ \ \rbrack \ \ \downarrow \ \ \Downarrow\ \ \{ \ \ \lbrace \ \ \} \ \ \rbrace \ \ \updownarrow \ \ \Updownarrow\ \ \langle \ \ \rangle \ \ \vert \ \ \Vert\ \ \lfloor \ \ \rfloor \ \ \lceil \ \ \rceil\ \ \backslash</script><p>其他符号</p><script type="math/tex; mode=display">\ \ \dots \ \ \cdots\ \ \vdots\ \ \ddots\ \ \hbar \ \ \imath \ \ \jmath \ \ \ell\ \ \Re \ \ \Im \ \ \aleph \ \ \wp\ \ \forall \ \ \exists \ \ \mho  \ \ \partial\ \ \prime \ \ \emptyset</script><script type="math/tex; mode=display">\infty\ \ \nabla \ \ \triangle \ \ \Box \ \ \Diamond\ \ \bot \ \ \top \ \ \angle \ \ \surd\ \ \diamondsuit \ \ \heartsuit \ \ \clubsuit \ \ \spadesuit\ \ \neg \ \ \lnot \ \ \ \ \natural \ \ \sharp</script><h2 id="公式测试"><a href="#公式测试" class="headerlink" title="公式测试"></a>公式测试</h2><script type="math/tex; mode=display">\int \frac{dx}{cos^2x}=\int sec^2xdx=tan x+C\</script><script type="math/tex; mode=display">\int \frac{dx}{sin^2x}=\int csc^2xdx=-cot x+C\</script><script type="math/tex; mode=display">\sum\limits_{i = 0}^{E} w[i]{M \choose i} {N \choose iS} \frac{(iS)!}{(S!)^{i}} \sum\limits_{j = 0}^{E - i} (-1)^{j} {M - i \choose j} {N - iS \choose jS} \frac{(jS)!}{(S!)^{j}} (M - i - j)^{N - iS - jS}</script><script type="math/tex; mode=display">= \sum\limits_{i = 0}^{E} w[i]{M \choose i} {N \choose iS} \frac{(iS)!}{(S!)^{i}} \sum\limits_{j = i}^{E} (-1)^{j - i} {M - i \choose j - i} {N - iS \choose jS - iS} \frac{(jS - iS)!}{(S!)^{j - i}} (M - j)^{N - jS}</script><h2 id="矩阵测试"><a href="#矩阵测试" class="headerlink" title="矩阵测试"></a>矩阵测试</h2><script type="math/tex; mode=display">\begin{bmatrix}(\omega_n^0)^0 & (\omega_n^0)^1 & \cdots & (\omega_n^0)^{n-1}\\ (\omega_n^1)^0 & (\omega_n^1)^1 & \cdots & (\omega_n^1)^{n-1}\\ \vdots & \vdots & \ddots & \vdots \\ (\omega_n^{n-1})^0 & (\omega_n^{n-1})^1 & \cdots & (\omega_n^{n-1})^{n-1} \end{bmatrix} \times \begin{bmatrix} a_0 \\ a_1 \\ \vdots \\ a_{n-1} \end{bmatrix}=\begin{bmatrix} A(\omega_n^0) \\ A(\omega_n^1) \\ \vdots \\ A(\omega_n^{n-1}) \end{bmatrix}</script><script type="math/tex; mode=display">\begin{bmatrix} a_0 \\ a_1 \\ \vdots \\ a_{n-1} \end{bmatrix} = \frac{1}{n} \begin{bmatrix} (\omega_n^{-0})^0 & (\omega_n^{-0})^1 & \cdots & (\omega_n^{-0})^{n-1} \\ (\omega_n^{-1})^0 & (\omega_n^{-1})^1 & \cdots & (\omega_n^{-1})^{n-1} \\ \vdots & \vdots & \ddots & \vdots \\ (\omega_n^{-(n-1)})^0 & (\omega_n^{-(n-1)})^1 & \cdots & (\omega_n^{-(n-1)})^{n-1} \end{bmatrix} \begin{bmatrix} A(\omega_n^0) \\ A(\omega_n^1) \\ \vdots \\ A(\omega_n^{n-1}) \end{bmatrix}</script>]]></content>
      
      
      <categories>
          
          <category> Mathematics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Goodbye Wuxu</title>
      <link href="/2019/02/04/goodbye-wuxu/"/>
      <url>/2019/02/04/goodbye-wuxu/</url>
      
        <content type="html"><![CDATA[<p>戊戌狗年结束了，这一年的生活还算顺利。</p><p>上下求索的过程中，一次次的走进迷茫，再从迷茫中回到自己。</p><p>尽人事，知天命。新的一年加油。</p><a id="more"></a><h2 id="Memorabilia"><a href="#Memorabilia" class="headerlink" title="Memorabilia"></a>Memorabilia</h2><p>Mar.  写了转入三三的申请。给十六留下了粗糙的值周记录PPT。</p><p>Apr.  转入三三。省选划水，最后是非正式 rank15。</p><p>May.  花了两天时间研究了 Hexo，采用的 Next 主题。</p><p>Jun.  人生第一次过集体生日。</p><p>Jul.  NOI 同步赛 Spfa 被卡。在洛谷出的比赛过审了，正解被爆踩。</p><p>Aug.  把 Dev-C++ 换了 Atom 。</p><p>Nov.  NOIP 2018 差点被送退役。</p><p>Dec.  参加学考。简单学了点 LaTeX 。</p><p>Jan. 参加 CCPC-Wannafly Winter Camp。</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>随便写点还记得的东西，想到哪里就写些什么了。</p><p>嘴上常挂着 “不忘初心 ”，但是做了不少表面文章，做了不少不懂装懂的傻事。</p><p>有的事情总是呆在 Todo List 上，但是一直不去碰，或是看了两下就把它扔回去，等到下决心去搞了，也有几次搞到一半因为奇奇怪怪的原因放弃了。但这些东西还老是堆在心里一直想着，列的 deadline 也总是咕掉。</p><p>花哨的东西却认认真真搞了不少，几度沉沦于形式的简约和规范，甚至是操作界面的美观。</p><p>很多东西浅尝辄止，只学了一个开头，就去做做水题装作很懂的样子，过了一段时间发现学的不透，又会回来重新再看一遍，反反复复。</p><p>OI 在上半年逐渐成了生活的主线。但是好多时候不知道事情从哪里下手，或者希望渺茫。</p><p>这段时间 OI 以外的生活过的还是比较愉快的，经历了值周，换班，听到了想听的课，见识了很强的同学们和新鲜的思路。但是精力渐渐不太放在文化课上了，好多该刷题的东西一直放着，下课就想往机房跑，到期末还是不怎么会做动量和电解池的题。</p><p>OI 上也没有踏实下来吃透些什么，该学的东西不知道为什么也一直在拖，逐渐的变成了回避，躲避，沉默，每遇到了这些知识点的话题。这种感觉就像个瘤，它就长在你的心上，但是你就是不会碰它，越长越大压得喘不过气来。</p><p>过了生日之后，某一个晚上给父母写了点东西。现在看当时略显稚气的信里并没有说出来什么深处的东西，但还是借此给自己打打气，当时的感觉是 “有所成长” ，也算在那个时期拉了自己一把，OI 开始有些起色。</p><p>NOIP 前的三个月或许是到现在为止最拼的一段时间吧。那段时间压力比较大，也收获了很多感动。</p><p>第一次停课单休也是很新鲜。但状况也不容乐观，好多东西还停留在认识的阶段，有段时间甚至接近崩溃。万幸的是有 Luan 能陪我挺过那段时间，互相交流，心情也逐渐变得乐观起来，工作比较高效。感觉自己能挺过那段时间也是挺神奇，一个多月学了之前落下的好多东西，还能挺住比较密集的考试。我要感谢 Luan，我都不敢想象没了他跟我交流现在我会是什么样子。</p><p>那段时间的生活过的比较平淡，但是充实。还不是太冷的时候跑了几次步，N 老师带着队，第一次没停下跑完了二南外圈 2km。</p><p>NOIP 的事情不想说太多了，以前也写过东西。分别是必然的，但很多意料之外的事情让人很痛苦。</p><p>学考之后这段时间过的比较平凡。事情变得开朗一些。</p><p>突击学考算是一种比较奇妙的体验吧。当整天整天的摸不到键盘的时候，就会坐不住，开始知道自己已经离不开了。教学楼里有趣的事情倒是不少，少见的感受到了 C 主任的亲民，趁着自习的时候也可以偷着拜读一下渡边先生的大作了。</p><p>去不了 NOIWC 的事情也是早就准备好的，能去 CCPC-Wannafly Winter Camp 算是一个惊喜吧，以大学生的视角看算法竞赛也是一种体验。搞到了自己的域名也算是了了一桩心事，以后颓废的时候可能会开发一下。</p><p>大家都好厉害啊。逐渐发现自己站位有些低，或许该多想想远一些的事情。</p><p>希望新的一年自己能专注一些，注意自律，做些务实的事情。</p>]]></content>
      
      
      <categories>
          
          <category> Thinking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CodeForces 做题记录</title>
      <link href="/2019/01/14/codeforces/"/>
      <url>/2019/01/14/codeforces/</url>
      
        <content type="html"><![CDATA[<p>简单记录 CodeForces 上打比赛的排名和 Rating 变化。</p><p>题解和一些细节写到解题报告里了，代码详见 “Solutions” 。</p><p>本篇将长期置顶。有问题请联系我，万分感谢。</p><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><p>这里是自己写的一些比赛题解。</p><p>代码可以去 <a href="http://codeforces.com/submissions/SGColin" target="_blank" rel="noopener">My Submissions</a> 找，或者去我的 <a href="https://github.com/SGColin/SGColin.github.io/tree/master/code/codeforces" target="_blank" rel="noopener">代码仓库</a> 看，或者访问：</p><p><code>https://blog.gyx.me/code/codeforces/name.cpp</code> </p><p>在 <code>name</code> 处输入题号就可以了，例如 <code>1100A</code> 的 <a href="https://blog.gyx.me/code/codeforces/1100A.cpp">访问结果</a> 。</p><ul><li><a href="https://blog.gyx.me/papers/codeforces/cf514.pdf">Codeforces Round #514 (Div. 2)</a></li><li><a href="https://blog.gyx.me/papers/codeforces/cf524.pdf">Codeforces Round #524 (Div. 2)</a></li><li><a href="https://blog.gyx.me/papers/codeforces/cf525.pdf">Codeforces Round #525 (Div. 2)</a></li><li><a href="https://blog.gyx.me/papers/codeforces/cf532.pdf">Codeforces Round #532 (Div. 2)</a></li><li><a href="https://blog.gyx.me/papers/codeforces/edu55.pdf">Educational Codeforces Round 55 (Rated for Div. 2)</a></li><li><a href="https://blog.gyx.me/papers/codeforces/edu58.pdf">Educational Codeforces Round 58 (Rated for Div. 2)</a></li></ul><h2 id="Standings-and-Rating-Changes"><a href="#Standings-and-Rating-Changes" class="headerlink" title="Standings and Rating Changes"></a>Standings and Rating Changes</h2><p>只记录赛时参加的比赛结果，Virtual 的比赛不再记录。</p><ul><li>Codeforces Round #514 (Div. 2)<br>Standing : 1150<br>Rating Change : 1500 - 1544 , <font color="#20B2AA">Specialist</font></li><li>Codeforces Round #516 (Div. 2)<br>Standing : 181<br>Rating Change : 1544 - 1675 , <font color="#0000FF">Expert</font></li><li>Codeforces Round #517 (Div. 2)<br>Standing : 676<br>Rating Change : 1675 - 1666 , <font color="#0000FF">Expert</font></li><li>Codeforces Round #524 (Div. 2)<br>Standing : 1443<br>Rating Change : 1666 - 1619 , <font color="#0000FF">Expert</font></li><li>Codeforces Round #528 (Div. 2)<br>Standing ：58<br>Rating Change : 1619 - 1787 , <font color="#0000FF">Expert</font></li><li>Educational Codeforces Round 58 (Rated for Div. 2)<br>Standing ：1328<br>Rating Change : 1787 - 1751 , <font color="#0000FF">Expert</font></li><li>Codeforces Round #532 (Div. 2)<br>Standing ：19<br>Rating Change : 1751 - 1974 , <font color="#800080">Candidate Master</font></li><li>Codeforces Round #541 (Div. 2)<br>Standing ：37 (Skiped)<br>Rating Change : 1974 - 1974 , <font color="#800080">Candidate Master</font></li></ul>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Solution </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOIP 2018 行记</title>
      <link href="/2018/12/08/noip2018/"/>
      <url>/2018/12/08/noip2018/</url>
      
        <content type="html"><![CDATA[<p>按照惯例写一篇游记，以及简要题解。</p><p><strong>谨以此文纪念我高中信息学竞赛的第一次正式考试。</strong></p><p>飞雪连天射白鹿，笑书神侠倚碧鸳。纪念伟大的金庸先生。</p><a id="more"></a><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p><a href="">Solution for NOIP 2018</a></p><p>终于在年前把这套题补完了，心情复杂。</p><h2 id="Diary"><a href="#Diary" class="headerlink" title="Diary"></a>Diary</h2><h3 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h3><p>离考试越近自己越静不下来。</p><p>中午一点到了石家庄站，今年的比赛还是在燕大。</p><p>等车的时候发现不会在虚拟机里编译，慌张地问了一波。</p><p>上火车之后莫名其妙被换座到了1A。颓的时候发现，旁边两位爷开始离线切题太强了。</p><h3 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h3><p>早上起来被教练通知又要考一场模拟赛。T3 只会 60 暴力，然后事后诸葛…</p><p>下午试机。耍无赖苟在那里将近一个小时，最后只是敲了链剖和倍增互拍，还拍挂了慌慌慌。</p><p>晚上学长说注意事项，感觉讲的东西都没听说过。回去之后和 ZH 一起梳理了知识点，感觉不错。</p><p>睡觉的时候外面有跑步和喊叫的声音，以及午夜凶铃。以为是初中的 <del>后来得知是高一学长</del>。</p><h3 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="Day 1"></a>Day 1</h3><p>今天在燕大 1 机房，座位在前排角落，周围目测是友善的高一学长。</p><p>开题发现<code>i7-8700K</code> 以及 <code>512M</code> ，非常资瓷啊，再也不怕常数大了…</p><p>T1 确认完题意就会做了。 在<code>首尾相接</code> 上纠结了一会，发现样例解释不了环，就放心写了。</p><p>T2 读了两遍题，感觉有点难。玩样例发现选的都是原来就有的数，觉得有些蹊跷。冷静了一下，分情况讨论证明这个结论是对的，然后就得到了排序之后用背包贪心的解法。</p><p>T3 明白了问题模型之后，发现不会找树上一堆链，开始看部分分。发现简单的子任务合起来就有 55 了，于是先写了这些点，解法分别是树的直径，所有边长取最小值，正常的二分答案+验证，以及二分答案+双指针。</p><p>然后上个厕所冷静了一下，回来发现可以用树形DP搞。几次 WA 和 死循环 之后，找了好多反例，高度紧张的状态下在11:40 的时候终于码完了，应该是我人生中第一个考场 200+行吧。测了一发大样例没有 TLE ，肉眼比对第一页没锅，打开<code>cmd</code> ，输入<code>fc track.out track3.ans</code>，显示<code>FC: 找不到差异</code>，突然觉得全世界都清静了。</p><p>下午在宾馆里看板子，晚上十点多就睡了。意外的睡得不错。</p><h3 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h3><p>今天在燕大 4 机房，座位在正中间，前面是 zyz 后面是 czy ，旁边的老哥看起来不是很友好。</p><p>T1 开始以为是最小字典序拓扑序，写完过不了样例，发现读错题了，应该是是 DFS 序。想起来还没有看数据范围，看完发现是基环树。发现 60 很好写，100 只会平方复杂度，因为用的是邻接矩阵，感觉写起来很麻烦就先撂下了。</p><p>T2 题面太长就先做的 T3 。NOIP 前写过一道题，是 [SDOI2006] 保安站岗 。<strong>我就把边覆盖读成了点覆盖</strong>，十分自信地码完了 44 的暴力，<strong>竟然过了样例</strong>，然后就十分自信地去搞 T2 了。</p><p>T2 明确题意后写了状压路径的 20 暴力，开始找规律。发现和前不久 CodeForces 的 一道 D 题可能有一样的思路，每一条斜线上只要只是一段前缀 1 就合法了，因为每一条斜线上的点在字典序列位置相同。然后推了个公式带进去，发现 n=3,m=3 得到 144 ，而题面上写着 112。</p><p>找了很久没有发现原因，只好把不合法情况打出来，发现两条交错路径就凉了。尝试状压斜线，发现不会转移，只好暴力把 n,m<9 的表打出来算了。打的时候发现对于="" m="">n 的情况，(n,m) 的方案数等于 (n,m-1) 方案数的三倍。发现规律对 n&gt;4 并不适用，就只打了前 65 ，放弃了剩下的 35 。</9></p><p>回去赶 T1 ，思路混乱，发现得把邻接矩阵存改回邻接表。写完发现跑不出来，慌了，把 T1 60 的代码和另外两道题先打了包。到最后都没有调出来，最后收卷的时候头脑一片空白。</p><p>下午去看海，照了合影。我和 Luan 在沙滩上留下了手划出来的字。我写了<code>NEXT YEAR GOTO NOI 2019</code> 。</p><p>返程火车上老师把代码发下来了，交到洛谷上 60+65+0=125 恍恍惚惚，比预想的还要糟糕，没有再和教练说什么。晚上机房泡面，聊天时终于发现自己读错题的事实。</p><h3 id="Day-n"><a href="#Day-n" class="headerlink" title="Day n"></a>Day n</h3><p>几个晚上都在想，如果 Day2T1 码出来，或者 Day2T3 没读错题就能加上四十多。</p><p>民间数据在 HE 大概 rank30+ ，我还是想接着学的啊。</p><p>最后拿到了成绩单，跟洛谷上测出来成绩差不多。</p><p><img src="https://blog.gyx.me/images/noip2018.png" alt=""></p><p>得到了 rank40+ 的尴尬境地，几经折腾可以留下来准备省选了。</p><h2 id="Summaries-and-Flags"><a href="#Summaries-and-Flags" class="headerlink" title="Summaries and Flags"></a>Summaries and Flags</h2><p>稍微多说两句。</p><p>不要期望超常发挥，正常发挥就是最大的幸运。</p><p>心态要平衡，OI 两天的赛制也考验心态。之所以会出现低级错误，就是考场上想得太多。考场上不要想之前考的怎么样，认真做题就是最大的成功。</p><p>后面的学习已经有赌的成分在里面了，立一些 Flag 激励自己。</p><ul><li>少看游记少颓废</li><li>省选阶段模拟赛能搞懂的题都改完写题解</li><li>做掉尽可能多的近 5 年内各地省选题</li><li>把能打的不是猝死场的 CodeForces 都打了，赛后补题解</li></ul>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Solution </tag>
            
            <tag> Travel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/11/29/hello-world/"/>
      <url>/2018/11/29/hello-world/</url>
      
        <content type="html"><![CDATA[<p>不忘初心，方得始终。初心易得，始终难守。</p><p>希望自己能记住为之坚持的东西，记住不掺杂利益的热爱。</p><p>希望自己能学会果断选择，不再踌躇，有拥抱生活的勇气。</p><p>Hello, the lovely world.</p><a id="more"></a><hr><p>优美胜于丑陋 明了胜于晦涩</p><p>简单胜于复杂 复杂胜于杂乱</p><p>扁平胜于嵌套 间隔胜于紧凑</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> this</span><br><span class="line">The Zen of Python, by Tim Peters</span><br><span class="line"></span><br><span class="line">Beautiful <span class="keyword">is</span> better than ugly.</span><br><span class="line">Explicit <span class="keyword">is</span> better than implicit.</span><br><span class="line">Simple <span class="keyword">is</span> better than complex.</span><br><span class="line">Complex <span class="keyword">is</span> better than complicated.</span><br><span class="line">Flat <span class="keyword">is</span> better than nested.</span><br><span class="line">Sparse <span class="keyword">is</span> better than dense.</span><br><span class="line">Readability counts.</span><br><span class="line">Special cases aren<span class="string">'t special enough to break the rules.</span></span><br><span class="line"><span class="string">Although practicality beats purity.</span></span><br><span class="line"><span class="string">Errors should never pass silently.</span></span><br><span class="line"><span class="string">Unless explicitly silenced.</span></span><br><span class="line"><span class="string">In the face of ambiguity, refuse the temptation to guess.</span></span><br><span class="line"><span class="string">There should be one-- and preferably only one --obvious way to do it.</span></span><br><span class="line"><span class="string">Although that way may not be obvious at first unless you'</span>re Dutch.</span><br><span class="line">Now <span class="keyword">is</span> better than never.</span><br><span class="line">Although never <span class="keyword">is</span> often better than *right* now.</span><br><span class="line">If the implementation <span class="keyword">is</span> hard to explain, it<span class="string">'s a bad idea.</span></span><br><span class="line"><span class="string">If the implementation is easy to explain, it may be a good idea.</span></span><br><span class="line"><span class="string">Namespaces are one honking great idea -- let'</span>s do more of those!</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Thinking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
